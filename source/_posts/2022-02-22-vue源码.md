---
title: vue源码
date: 2022-02-22 11:36:51
tags: [Vue, 面试]
categories: 技术类-Vue
---
## 为什么data是函数，而components是对象？

## data函数如果没有返回值会报错吗？

## 为什么props定义的数据不能和data同名?

> vue源码路径：vue\src\core\instance\state.js

```js

// proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) {
      proxy(vm, `_data`, key)
    }
  }
```

可以看到先获取`data`的`key`，然后再去调用`hasOwn`方法去判断`methods`和`props`里面是否有重复的`key`，有的话就会发出警告。最后都通过了之后就会调用`proxy(vm, '_data', key)`，用封装的`proxy`方法对`vm实例`做了一层代理，使得我们可以直接通过`this`直接调用`key`

## vue2代理的实现

```js
const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
}

export function proxy (target: Object, sourceKey: string, key: string) {
  // 去掉_props，vm._props.xxx => vm.xxx，可以直接访问
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  // 代理，
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

使用的是`Object.defineProperty`来实现的

## Vue的初始化

>Vue源码位置：src\core\instance\index.js

```js
initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
```

最先执行的是`initMixin()`，我们看看里面有啥。

>Vue源码位置：src\core\instance\init.js

```js
//init.js

    // 初始化
    vm._self = vm
    // 生命周期
    initLifecycle(vm)
    // 事件
    initEvents(vm)
    // 渲染
    initRender(vm)
    // 面试题：beforeCreae和created之间做了什么？或者说二者有什么区别？
    // 答：初始化injected，初始化state，初始化provide
    callHook(vm, 'beforeCreate')
    // 初始化inject
    initInjections(vm) // resolve injections before data/props
    // 初始化state，state里面有data，computed，method，props，watch
    initState(vm)
    // 初始化provide
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')
```

`initState()`是从`state.js`文件里面导入的，我们再去看看里面有什么。

>src\core\instance\state.js

```js
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  // 初始化props
  if (opts.props) initProps(vm, opts.props)
  // 初始化方法
  if (opts.methods) initMethods(vm, opts.methods)
  // 初始化data
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  // 初始化computed
  if (opts.computed) initComputed(vm, opts.computed)
  // 初始化watch
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

可见在`beforeCreate`与`created`之间初始化了`inject`,`props`,`methods`,`data`,`computed`,`watch`

---
title: 通读vue3文档记录
date: 2021-09-15 19:03:11
tags: Vue3
categories: 技术类-Vue
---
之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是`Object.defineProperty()`，vue3用的是`Proxy`。vue3还新增了`组合式API`等等。

这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。

持续更新ing

# 应用&组件实例
## 应用实例
每个 Vue 应用都是通过用 createApp 函数创建一个新的**应用实例**开始的：

```js
const app = Vue.createApp({ /* 选项 */ })
```

该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：
```js
const app = Vue.createApp({})
app.component('SearchInput', SearchInputComponent)
app.directive('focus', FocusDirective)
app.use(LocalePlugin)
```
应用实例暴露的大多数方法都会返回该同一实例，允许链式：
```js
Vue.createApp({})
  .component('SearchInput', SearchInputComponent)
  .directive('focus', FocusDirective)
  .use(LocalePlugin)
```

## 根组件实例
传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。

一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 `<div id="app"></div>`，我们应该传递 `#app`：
```js
const RootComponent = { /* 选项 */ }
const app = Vue.createApp(RootComponent)
const vm = app.mount('#app')
```
与大多数应用方法不同的是，`mount` 不返回应用本身。相反，它返回的是**根组件实例**。

虽然没有完全遵循 `MVVM` 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。

# 计算属性&侦听器
## 计算属性缓存 vs 方法
    
你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：
```html
<p>{{ calculateBooksMessage() }}</p>
```
```js
// 在组件中
methods: {
  calculateBooksMessage() {
    return this.author.books.length > 0 ? 'Yes' : 'No'
  }
}
```
我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要`author.books` 还没有发生改变，多次访问 `publishedBookMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。 

这也同样意味着下面的计算属性将不再更新，因为 **Date.now () 不是响应式依赖**：
```js
computed: {
  now() {
    return Date.now()
  }
}
```
相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。

我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 `list`，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 `list`。如果没有缓存，我们将不可避免的多次执行 `list` 的 getter！如果你不希望有缓存，请用 method 来替代

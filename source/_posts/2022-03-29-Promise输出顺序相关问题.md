---
title: Promise输出顺序相关问题
date: 2022-03-29 18:06:06
tags: [ES6, 面试]
categories: 技术类-前端
---

## 题：

```js
Promise.resolve()
  .then(() => {
    console.log(0);
    setTimeout(() => {
      console.log("宏任务");
    }, 0);
    // return 4
    return Promise.resolve(4); // 此处是迷惑点
  })
  .then((res) => {
    console.log(res);
  });

Promise.resolve()
  .then(() => {
    console.log(1);
  })
  .then(() => {
    console.log(2);
  })
  .then(() => {
    console.log(3);
  })
  .then(() => {
    console.log(5);
  })
  .then(() => {
    console.log(6);
  })
  .then(() => {
    console.log(7);
  })
  .then(() => {
    console.log(8);
  });
```

## 答：

```js
// 输出结果
0;
1;
2;
3;
4;
5;
6;
7;
8;
宏任务;
```

## 解析：

| `return Promise.resolve(4)`会产生两个微任务

| 等到当前执行栈为空的时候，才会 resolve 掉这个新的 promise

1. **宏任务队列 1**,执行`Promise.resolve()`
2. 遇到`then()`回调,往微任务队列推入以下代码：

```js
// 微任务队列加入了以下代码
// 微任务队列1
console.log(0);
setTimeout(() => {
  console.log("宏任务");
}, 0);
return Promise.resolve(4);
```

3. 仍然在当前宏任务往下执行，执行第二个`Promise.resolve()`
4. 遇到`then()`回调,往微任务队列推入以下代码:

```js
console.log(1);
```

所以此时微任务队列里有两个代码块待执行。队列就是先进先出的原则

```js
// 第一个
console.log(0);
setTimeout(() => {
  console.log("宏任务");
}, 0);
return Promise.resolve(4);

// 第二个
console.log(1);
```

5. 此时代码模块里的宏任务都已经执行完了，开始捞取微任务到执行栈中执行。队列里第一个出来的也就是代码：

```js
console.log(0);
setTimeout(() => {
  console.log("宏任务");
}, 0);
return Promise.resolve(4);
```

输出 0

6.

---

待续

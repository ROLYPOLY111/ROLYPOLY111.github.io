---
title: JavaScript中的堆栈以及数据类型
date: 2021-06-17 15:08:21
tags: JavaScript
categories: 技术类-前端
---

<meta name="referrer" content="no-referrer"/>

# JavaScript 的堆栈以及数据类型

[本文参考此链接](https://www.jianshu.com/p/5e0e8d183102)

## 堆

- 是堆内存的简称。

- 需要程序员自己申请空间，内存大小不一，也不会自动释放。

- 堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大

- 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片

## 栈

- 是栈内存的简称。

- 是自动分配相对固定大小的内存空间，并由系统自动释放，所以生命周期只在函数的运行过程中。

- 后进先出

- 栈是向低地址扩展的数据结构，是一块连续的内存的区域

![栈](https://upload-images.jianshu.io/upload_images/4037795-707975f1f45a6a0d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1136/format/webp)

## 队列

- 是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。

- 先进先出

### 基本数据类型

`javascript`的**基本类型**就 5 种:`Undefined`、`Null`、`Boolean`、`Number`和`String`，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是**确定**的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。

### 引用数据类型

`javascript`中其他类型的数据被称为**引用类型**的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和 new 出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。

### 传值与传址

```javascript
var arr1 = [1, 2, 5, 8];
var arr2 = arr1;
var str1 = arr1[2];
console.log(arr2); //1,2,5,8
console.log(str1); //5
arr2[4] = 99;
str1 = 6;
console.log(arr1); //1,2,5,8,99
console.log(arr1[2]); //5
```

当我改变 arr2 中的数据时，arr1 中数据也发生了变化，当改变 str1 的数据值时，arr1 却没有发生改变。为什么？这就是**传值与传址**的区别。

因为 arr1 是数组，属于引用类型，所以它赋予给 arr2 的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1 得到的是一个基本类型的赋值，因此，str1 仅仅是从 arr1 堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2 都指向同一块堆内存，arr2 修改的堆内存的时候，也就会影响到 arr1，str1 是直接在栈中修改，并且不能影响到 arr1 堆内存中的数据。

![img](https://images2018.cnblogs.com/blog/1402663/201808/1402663-20180802132101478-2092833591.png)

### 深拷贝和浅拷贝

上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将 arr1 的每个基本类型的数据都遍历一遍，依次的赋值给 arr2 的对应字段。避免产生因为地址引用带来的问题。

```javascript
var arr1 = [1, 2, 5, 8];
var arr2 = [];
for (var i = 0; i < arr1.length; i++) {
  arr2[i] = arr1[i];
}
console.log(arr2); //1,2,5,8
arr2[4] = 99;
console.log(arr2); //1,2,5,8,99
console.log(arr1); //1,2,5,8
```

javascript 面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。

# 完~

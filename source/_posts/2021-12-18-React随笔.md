---
title: React笔记
date: 2021-12-18 19:08:44
tags: [React, 面试]
categories: 技术类-React
---

## React 中的`this`

React 的官方文档里写的自定义的方法都需要用 bind 方法绑定一下才能使用，否则 this 会出现指向问题，那究竟是为什么呢？

### 探讨一

```js
class Person {
    constructor(props){
        this.state = {
            ......
        }
    }
    render(){
        return <div onClick={demo}>你好，DexterHwang</div>
    }
}

function demo(){
    console.log(this.state)   // 会报错，注意此处的this
}

ReactDom.render(<Person />,document.getElementById('app'))
```

`React` 中的 `Babel` 使用了严格模式，所以写的全局的 `this`指向的是`undefined`

而且 `demo` 方法并不写在 `Person` 类中，所以这个 `this` 也不会指向 `Person` 的实例对象

### 探讨二

```js
class Person {
    constructor(props){
        this.state = {
            ......
        }
    }
    render(){
        return <div onClick={demo}>你好，DexterHwang</div> // 会报错，报错信息为：`demo is not defined`。`onClick={demo}`是找不到 `demo` 方法的
        // return <div onClick={this.demo}>你好，DexterHwang</div> // 这样写也会报错，因为并不是通过实例对象去调用demo方法。由于demo是作为onClick的回调，不是通过实例调用的，是直接调用。类中的方法默认开启了局部的严格模式，所以this值是undefined
    }
    // demo方法在Person的原型对象(prototype)上，也就是在Person的实例对象的原型链上(_proto_)
    // 只有通过Person实例对象调用demo方法时，demo里面的this指向的就是Person的实例对象
    demo(){
        console.log(this)
    }
}

ReactDom.render(<Person />,document.getElementById('app'))
```

我们看下面的例子

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  study() {
    console.log(this);
  }
}
const p1 = new Person("DexterHwang", 18);

p1.study(); //{name:'DexterHwang',age:18}
const x = p1.study;
x(); // 输出undefined
```

p1 的原型链上是可以找到 study 方法的，然后把 study 方法赋值给了 x。也就相当于在栈上多了一个指针指向了 study 方法，这下 x 就彻底和 p1 没有关系了

另外，再明确一点：_类中自定义的方法，都会启用局部严格模式_。也就是说 this 的值是 undefined

也就是说 x 执行后 this 值就是 undefined

验证：_类中自定义的方法，都会启用局部严格模式_

```js
function test() {
  console.log(this);
}

function test2() {
  "use strict";
  console.log(this);
}

test(); // window
test2(); // undefined
```

### 分析 `this.demo = this.demo.bind(this)`

为什么用 bind()就可以解决 this 指向问题呢？

```js
 class Person {
    constructor(props){
        this.state = {
            ......
        }
        this.demo = this.demo.bind(this)
    }
    render(){
        return <div onClick={this.demo}>你好，DexterHwang</div>
    }

    demo(){
        console.log(this)
    }
}

ReactDom.render(<Person />,document.getElementById('app'))

// 点击后会输出：Person{...}
```

分析`this.demo = this.demo.bind(this)`

等号右侧的第一个 this 指向的是实例对象，这个实例对象上有 demo 方法吗？有，但是实在原型链上的。

bind 方法做两件事：

1. 将 this 牢牢的绑定到传入的参数上
2. 返回一个新的函数

等号右边第二个 this，也就是传入的参数，这个 this 指的就是实例对象

这样的话返回了一个新的函数，而且这个函数牢牢的绑定到了实例对象上，并不需要去原型链上找了

再看等号左侧，将返回的新函数赋值给了 this，这个 this 也是 Person 实例对象，用相同的方法名接收一下

这样就可以使用了

我们这样再去看`onClick={this.demo}`,这下再点击后执行的就是实例自身上的 demo 方法了。

---

## 2021-12-25 更新—— React17 对比新旧生命周期

新的生命周期和旧的生命周期相比，即将废弃三个钩子：`componentWillMount`、`componentWillUpdate`、`componentWillReceiveProps`

新增了两个新的钩子：`getDerivedStateFromProps`、`getSnapshotBeforeUpdate`

剩下的都和之前的一样的

## 2021-12-16 更新—— React 配置代理

单个代理可以直接在`package.json`文件中配置`proxy`

多个代理则需要新建一个`setupProxy.js`文件，配置如下：

```js
const proxy = require("http-proxy-middleware");

module.exports = function (app) {
  app.use(
    proxy("/api1", {
      //遇见api1前缀的请求，就会触发这个代理配置
      target: "http://localhost:5000", // 请求转发给谁，也就是服务器地址
      changeOrigin: true, // 控制服务器收到的请求头中Host的值，这里是localhost:5000
      pathRewrite: { "^/api1": "" }, // 重写请求路径
    }),
    proxy("/api2", {
      target: "http://localhost:5001",
      changeOrigin: true,
      pathRewrite: { "^/api2": "" },
    })
  );
};
```

`create-react-app`脚手架会自动找到`setupProxy.js`文件，并将配置加入到 webpack 中

## 2021-12-27 更新——React 路由原理

靠的是 H5 推出的 history 上的 API

```js
//路由跳转
function push(path) {
  history.push(path);
  return false;
}

// 路由替换
function replace(path) {
  history.replace(path);
}

// 路由回退
function back() {
  history.goBack();
}

// 路由前进
function forword() {
  history.goForward();
}

// 监听路由变化
history.listen((location) => {
  console.log("监听路由变化");
});
```

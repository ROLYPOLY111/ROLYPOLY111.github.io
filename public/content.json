{"meta":{"title":"走花路的长颈鹿","subtitle":"走花路的长颈鹿","description":"走花路的长颈鹿,博客","author":"走花路的长颈鹿","url":"https://zouhualu.github.io","root":"/"},"pages":[{"title":"","date":"2021-09-09T01:43:34.047Z","updated":"2021-09-09T01:43:34.047Z","comments":false,"path":"baidu_verify_code-TmkkRxX4ps.html","permalink":"https://zouhualu.github.io/baidu_verify_code-TmkkRxX4ps.html","excerpt":"","text":"676194d86471561a70b8026338973ebc"},{"title":"about","date":"2021-09-07T07:20:04.000Z","updated":"2021-09-23T07:58:48.894Z","comments":true,"path":"about/index.html","permalink":"https://zouhualu.github.io/about/index.html","excerpt":"","text":"网速足够快或者翻墙的话会使本网站打开的更快一些，网站有缓存，第一次打开可能会比较慢，后面就好了。谢谢关注，请一键三连！！！"}],"posts":[{"title":"leetcode每日算法（2021-09-27）","slug":"leetcode每日算法（2021-09-27）","date":"2021-09-27T03:06:43.000Z","updated":"2021-09-28T02:24:12.490Z","comments":true,"path":"20210927/leetcode每日算法（2021-09-27）/","link":"","permalink":"https://zouhualu.github.io/20210927/leetcode%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%EF%BC%882021-09-27%EF%BC%89/","excerpt":"","text":"1.两数之和 解题我首先想到的是暴力解法，就是对数组嵌套循环（时间复杂度是 O(n²)）：肯定有更好的办法看到评论区有人说用逆向解法，用target减去数组中的一个数，然后判断得到的结果是否在数组中 12345678910var twoSum = function(nums, target) &#123; map = new Map() for(let i = 0; i &lt; nums.length; i++) &#123; x = target - nums[i] if(map.has(x)) &#123; return [map.get(x),i] &#125; map.set(nums[i],i) &#125;&#125;; 12345678910var twoSum = function (nums, target) &#123; let hash = &#123;&#125;; for (let i = 0; i &lt; nums.length; i++) &#123; if (hash[target - nums[i]] !== undefined) &#123; return [i, hash[target - nums[i]]]; &#125; hash[nums[i]] = i; &#125; return [];&#125;;","categories":[{"name":"算法类","slug":"算法类","permalink":"https://zouhualu.github.io/categories/%E7%AE%97%E6%B3%95%E7%B1%BB/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zouhualu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://zouhualu.github.io/tags/leetcode/"}]},{"title":"浮生一日-最爱的电影","slug":"浮生一日-最爱的电影","date":"2021-09-25T10:07:53.000Z","updated":"2021-09-26T02:16:38.702Z","comments":true,"path":"20210925/浮生一日-最爱的电影/","link":"","permalink":"https://zouhualu.github.io/20210925/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5-%E6%9C%80%E7%88%B1%E7%9A%84%E7%94%B5%E5%BD%B1/","excerpt":"","text":"今天重温了电影《第六感》，一部披着灵异外皮的心灵治愈电影。 有些电影无论第几遍看还是让人感动 起码看过三遍以上的电影：《喜剧之王》《新喜剧之王》《双旗镇刀客》《致命ID》《误杀瞒天记》《禁闭岛》《天若有情》《本杰明巴顿奇事》《志明与春娇》…","categories":[{"name":"浮生一日","slug":"浮生一日","permalink":"https://zouhualu.github.io/categories/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/"}],"tags":[{"name":"浮生一日","slug":"浮生一日","permalink":"https://zouhualu.github.io/tags/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/"},{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"栈与队列的理解以及应用场景","slug":"栈与队列的理解以及应用场景","date":"2021-09-23T06:00:28.000Z","updated":"2021-09-23T06:02:36.773Z","comments":true,"path":"20210923/栈与队列的理解以及应用场景/","link":"","permalink":"https://zouhualu.github.io/20210923/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"1.栈栈（stack）又名堆栈，它是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表。 表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈 所以其按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用 实现一个栈： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Stack &#123; constructor() &#123; this.items = []; &#125; /** * 添加一个（或几个）新元素到栈顶 * @param &#123;*&#125; element 新元素 */ push(element) &#123; this.items.push(element) &#125; /** * 移除栈顶的元素，同时返回被移除的元素 */ pop() &#123; return this.items.pop() &#125; /** * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它） */ peek() &#123; return this.items[this.items.length - 1] &#125; /** * 如果栈里没有任何元素就返回true,否则返回false */ isEmpty() &#123; return this.items.length === 0 &#125; /** * 移除栈里的所有元素 */ clear() &#123; this.items = [] &#125; /** * 返回栈里的元素个数。这个方法和数组的length属性很类似 */ size() &#123; return this.items.length &#125;&#125; 关于栈的操作主要的方法如下： push：入栈操作 pop：出栈操作 二.队列跟栈十分相似，队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。 进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列 在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出 简单实现一个队列，如下： 123456789101112131415class Queue &#123; constructor() &#123; this.list = [] this.frontIndex = 0 this.tailIndex = 0 &#125; enqueue(item) &#123; this.list[this.tailIndex++] = item &#125; unqueue() &#123; const item = this.list[this.frontIndex] this.frontIndex++ return item &#125;&#125; 三.应用场景栈借助栈的先进后出的特性，可以简单实现一个逆序输出的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出 包括编译器的在对输入的语法进行分析的时候，例如”()”、”{}”、”[]”这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错 包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值 生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型 队列当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题 队列的使用广泛应用在广度优先搜索中，例如层次遍历一个二叉树的节点值 生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型 参考文献 https://baike.baidu.com/item/%E6%A0%88/12808149 https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481","categories":[{"name":"技术类","slug":"技术类","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"}]},{"title":"Vue3(一)","slug":"Vue3-一","date":"2021-09-16T09:39:17.000Z","updated":"2021-09-26T02:16:38.702Z","comments":true,"path":"20210916/Vue3-一/","link":"","permalink":"https://zouhualu.github.io/20210916/Vue3-%E4%B8%80/","excerpt":"","text":"今天上课内容是 vue 3,共有两节课，一节讲基础，一节讲原理。 以下是课堂笔记：","categories":[{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://zouhualu.github.io/tags/Vue3/"}]},{"title":"通读vue3文档记录","slug":"vue3文档记录","date":"2021-09-15T11:03:11.000Z","updated":"2021-09-17T10:41:59.128Z","comments":true,"path":"20210915/vue3文档记录/","link":"","permalink":"https://zouhualu.github.io/20210915/vue3%E6%96%87%E6%A1%A3%E8%AE%B0%E5%BD%95/","excerpt":"","text":"之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是Object.defineProperty()，vue3用的是Proxy。vue3还新增了组合式API等等。 这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。 持续更新ing 应用&amp;组件实例应用实例每个 Vue 应用都是通过用 createApp 函数创建一个新的应用实例开始的： 1const app = Vue.createApp(&#123; /* 选项 */ &#125;) 该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子： 1234const app = Vue.createApp(&#123;&#125;)app.component(&#x27;SearchInput&#x27;, SearchInputComponent)app.directive(&#x27;focus&#x27;, FocusDirective)app.use(LocalePlugin) 应用实例暴露的大多数方法都会返回该同一实例，允许链式： 1234Vue.createApp(&#123;&#125;) .component(&#x27;SearchInput&#x27;, SearchInputComponent) .directive(&#x27;focus&#x27;, FocusDirective) .use(LocalePlugin) 根组件实例传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。 一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;，我们应该传递 #app： 123const RootComponent = &#123; /* 选项 */ &#125;const app = Vue.createApp(RootComponent)const vm = app.mount(&#x27;#app&#x27;) 与大多数应用方法不同的是，mount 不返回应用本身。相反，它返回的是根组件实例。 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。 计算属性&amp;侦听器计算属性缓存 vs 方法你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果： 1&lt;p&gt;&#123;&#123; calculateBooksMessage() &#125;&#125;&lt;/p&gt; 123456// 在组件中methods: &#123; calculateBooksMessage() &#123; return this.author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;&#125; 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要author.books 还没有发生改变，多次访问 publishedBookMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 这也同样意味着下面的计算属性将不再更新，因为 Date.now () 不是响应式依赖： 12345computed: &#123; now() &#123; return Date.now() &#125;&#125; 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 list，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 list。如果没有缓存，我们将不可避免的多次执行 list 的 getter！如果你不希望有缓存，请用 method 来替代 以下为2021.09.16更新计算属性的 Setter计算属性默认只有 getter，不过在需要时你也可以提供一个 setter： 12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get() &#123; return this.firstName + &#x27; &#x27; + this.lastName &#125;, // setter set(newValue) &#123; const names = newValue.split(&#x27; &#x27;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... 现在再运行 vm.fullName = &#39;John Doe&#39; 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 Class与Style绑定如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作： 1234567891011&lt;div id=&quot;app&quot;&gt; &lt;my-component class=&quot;baz&quot;&gt;&lt;/my-component&gt;&lt;/div&gt;const app = Vue.createApp(&#123;&#125;)app.component(&#x27;my-component&#x27;, &#123; template: ` &lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt; &lt;span&gt;This is a child component&lt;/span&gt; `&#125;) 条件渲染v-if vs v-showv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好 v-if 与 v-for 一起使用 提示 不推荐同时使用 v-if 和 v-for 当 v-if 与 v-for 一起使用时，v-if 具有比 v-for 更高的优先级。请查阅列表渲染指南以获取详细信息。 当它们处于同一节点，v-if 的优先级比 v-for 更高，这意味着 v-if 将没有权限访问 v-for 里的变量： 12345&lt;!-- This will throw an error because property &quot;todo&quot; is not defined on instance. --&gt;&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; 可以把 v-for 移动到&lt;template&gt; 标签中来修正： 12345&lt;template v-for=&quot;todo in todos&quot;&gt; &lt;li v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/template&gt; 表单绑定输入基础用法v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件： text 和 textarea 元素使用 value property 和 input 事件； checkbox 和 radio 使用 checked property 和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 组件基础基本实例这里有一个 Vue 组件的示例： 123456789101112131415// 创建一个Vue 应用const app = Vue.createApp(&#123;&#125;)// 定义一个名为 button-counter 的新全局组件app.component(&#x27;button-counter&#x27;, &#123; data() &#123; return &#123; count: 0 &#125; &#125;, template: ` &lt;button @click=&quot;count++&quot;&gt; You clicked me &#123;&#123; count &#125;&#125; times. &lt;/button&gt;`&#125;) 组件的复用你可以将组件进行任意次数的复用每个组件都会各自独立维护它的data。因为你每用一次组件，就会有一个它的新组件实例被创建 在组件上使用 v-model自定义事件也可以用于创建支持 v-model 的自定义输入组件。记住： 12345678910&lt;input v-model=&quot;searchText&quot; /&gt;等价于：&lt;input :value=&quot;searchText&quot; @input=&quot;searchText = $event.target.value&quot; /&gt;当用在组件上时，v-model 则会这样：&lt;custom-input :model-value=&quot;searchText&quot; @update:model-value=&quot;searchText = $event&quot;&gt;&lt;/custom-input&gt; 为了让它正常工作，这个组件内的 &lt;input&gt; 必须： 将其 value attribute 绑定到一个名叫 modelValue 的 prop 上在其 input 事件被触发时，将新的值通过自定义的 update:modelValue 事件抛出写成代码之后是这样的： 123456789app.component(&#x27;custom-input&#x27;, &#123; props: [&#x27;modelValue&#x27;], template: ` &lt;input :value=&quot;modelValue&quot; @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot; &gt; `&#125;) 现在 v-model 就应该可以在这个组件上完美地工作起来了： 1&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt; 深入组件非 Prop 的 AttributeAttribute 继承当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 &lt;date-picker&gt; 组件的实例中： 1234567app.component(&#x27;date-picker&#x27;, &#123; template: ` &lt;div class=&quot;date-picker&quot;&gt; &lt;input type=&quot;datetime&quot; /&gt; &lt;/div&gt; `&#125;) 如果我们需要通过 data status property 定义 &lt;date-picker&gt; 组件的状态，它将应用于根节点 (即 div.date-picker)。 1234567&lt;!-- 具有非prop attribute的Date-picker组件--&gt;&lt;date-picker data-status=&quot;activated&quot;&gt;&lt;/date-picker&gt;&lt;!-- 渲染 date-picker 组件 --&gt;&lt;div class=&quot;date-picker&quot; data-status=&quot;activated&quot;&gt; &lt;input type=&quot;datetime&quot; /&gt;&lt;/div&gt; 同样的规则适用于事件监听器： 1&lt;date-picker @change=&quot;submitChange&quot;&gt;&lt;/date-picker&gt; 12345app.component(&#x27;date-picker&#x27;, &#123; created() &#123; console.log(this.$attrs) // &#123; onChange: () =&gt; &#123;&#125; &#125; &#125;&#125;) 当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。 123456789app.component(&#x27;date-picker&#x27;, &#123; template: ` &lt;select&gt; &lt;option value=&quot;1&quot;&gt;Yesterday&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;Today&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;Tomorrow&lt;/option&gt; &lt;/select&gt; `&#125;) 在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件： 123&lt;div id=&quot;date-picker&quot; class=&quot;demo&quot;&gt; &lt;date-picker @change=&quot;showChange&quot;&gt;&lt;/date-picker&gt;&lt;/div&gt; 1234567const app = Vue.createApp(&#123; methods: &#123; showChange(event) &#123; console.log(event.target.value) // 将记录所选选项的值 &#125; &#125;&#125;) 禁用 Attribute 继承如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。例如： 禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。 通过将 inheritAttrs 选项设置为 false，你可以访问组件的 $attrs property，该 property 包括组件 props 和 emits property 中未包含的所有属性 (例如，class、style、v-on 监听器等)。 12345678app.component(&#x27;date-picker&#x27;, &#123; inheritAttrs: false, template: ` &lt;div class=&quot;date-picker&quot;&gt; &lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt; &lt;/div&gt; `&#125;) 有了这个新配置，data status attribute 将应用于 input 元素！ 1234567&lt;!-- Date-picker 组件 使用非 prop attribute --&gt;&lt;date-picker data-status=&quot;activated&quot;&gt;&lt;/date-picker&gt;&lt;!-- 渲染 date-picker 组件 --&gt;&lt;div class=&quot;date-picker&quot;&gt; &lt;input type=&quot;datetime&quot; data-status=&quot;activated&quot; /&gt;&lt;/div&gt; 多个根节点上的 Attribute 继承与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。 1&lt;custom-layout id=&quot;custom-layout&quot; @click=&quot;changeValue&quot;&gt;&lt;/custom-layout&gt; 1234567891011121314151617// 这将发出警告app.component(&#x27;custom-layout&#x27;, &#123; template: ` &lt;header&gt;...&lt;/header&gt; &lt;main&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt; `&#125;)// 没有警告，$attrs被传递到&lt;main&gt;元素app.component(&#x27;custom-layout&#x27;, &#123; template: ` &lt;header&gt;...&lt;/header&gt; &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt; `&#125;) 自定义事件处理 v-model 修饰符在 2.x 中，我们对组件 v-model 上的 .trim 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 v-model 的修饰符将通过 modelModifiers prop 提供给组件： 让我们创建一个示例自定义修饰符 capitalize，它将 v-model 绑定提供的字符串的第一个字母大写。 添加到组件 v-model 的修饰符将通过 modelModifiers prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 modelModifiers prop。 请注意，当组件的 created 生命周期钩子触发时，modelModifiers prop 包含 capitalize，其值为 true——因为它被设置在 v-model 绑定 v-model.capitalize=&quot;bar&quot;。 1&lt;my-component v-model.capitalize=&quot;bar&quot;&gt;&lt;/my-component&gt; 12345678910111213141516app.component(&#x27;my-component&#x27;, &#123; props: &#123; modelValue: String, modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125; &#125;, template: ` &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;&gt; `, created() &#123; console.log(this.modelModifiers) // &#123; capitalize: true &#125; &#125;&#125;) 现在我们已经设置了 prop，我们可以检查 modelModifiers 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 &lt;input/&gt; 元素触发 input 事件时，我们都将字符串大写。 1234&lt;div id=&quot;app&quot;&gt; &lt;my-component v-model.capitalize=&quot;myText&quot;&gt;&lt;/my-component&gt; &#123;&#123; myText &#125;&#125;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031const app = Vue.createApp(&#123; data() &#123; return &#123; myText: &#x27;&#x27; &#125; &#125;&#125;)app.component(&#x27;my-component&#x27;, &#123; props: &#123; modelValue: String, modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125; &#125;, methods: &#123; emitValue(e) &#123; let value = e.target.value if (this.modelModifiers.capitalize) &#123; value = value.charAt(0).toUpperCase() + value.slice(1) &#125; this.$emit(&#x27;update:modelValue&#x27;, value) &#125; &#125;, template: `&lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emitValue&quot;&gt;`&#125;)app.mount(&#x27;#app&#x27;) 对于带参数的 v-model 绑定，生成的 prop 名称将为 arg + &quot;Modifiers&quot;： 1&lt;my-component v-model:foo.capitalize=&quot;bar&quot;&gt;&lt;/my-component&gt; 1234567891011app.component(&#x27;my-component&#x27;, &#123; props: [&#x27;foo&#x27;, &#x27;fooModifiers&#x27;], template: ` &lt;input type=&quot;text&quot; :value=&quot;foo&quot; @input=&quot;$emit(&#x27;update:foo&#x27;, $event.target.value)&quot;&gt; `, created() &#123; console.log(this.fooModifiers) // &#123; capitalize: true &#125; &#125;&#125;) 2021.09.17更新提供/注入通常，当我们需要将数据从父组件传递到子组件时，我们使用props。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。 对于这种情况，我们可以使用 provide 和 inject 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 provide 选项来提供数据，子组件有一个 inject 选项来开始使用这个数据。 可复用&amp;组合渲染函数虚拟DOM树Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码： 1return Vue.h(&#x27;h1&#x27;, &#123;&#125;, this.blogTitle) h() 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 VNode。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。 h()参数h() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数： 1234567891011121314151617181920212223242526272829h( // &#123;String | Object | Function | null&#125; tag // 一个 HTML 标签名、一个组件、一个异步组件，或者 null。 // 使用 null 将会渲染一个注释。 // // 必需的。 &#x27;div&#x27;, // &#123;Object&#125; props // 与 attribute、prop 和事件相对应的对象。 // 我们会在模板中使用。 // // 可选的。 &#123;&#125;, // &#123;String | Array | Object&#125; children // 子 VNodes, 使用 `h()` 构建, // 或使用字符串获取 &quot;文本 Vnode&quot; 或者 // 有 slot 的对象。 // // 可选的。 [ &#x27;Some text comes first.&#x27;, h(&#x27;h1&#x27;, &#x27;A headline&#x27;), h(MyComponent, &#123; someProp: &#x27;foobar&#x27; &#125;) ]) 完整实例有了这些知识，我们现在可以完成我们最开始想实现的组件： 1234567891011121314151617181920212223242526272829303132333435363738394041const app = Vue.createApp(&#123;&#125;)/** Recursively get text from children nodes */function getChildrenTextContent(children) &#123; return children .map(node =&gt; &#123; return typeof node.children === &#x27;string&#x27; ? node.children : Array.isArray(node.children) ? getChildrenTextContent(node.children) : &#x27;&#x27; &#125;) .join(&#x27;&#x27;)&#125;app.component(&#x27;anchored-heading&#x27;, &#123; render() &#123; // create kebab-case id from the text contents of the children const headingId = getChildrenTextContent(this.$slots.default()) .toLowerCase() .replace(/\\W+/g, &#x27;-&#x27;) // replace non-word characters with dash .replace(/(^-|-$)/g, &#x27;&#x27;) // remove leading and trailing dashes return Vue.h(&#x27;h&#x27; + this.level, [ Vue.h( &#x27;a&#x27;, &#123; name: headingId, href: &#x27;#&#x27; + headingId &#125;, this.$slots.default() ) ]) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;)","categories":[{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://zouhualu.github.io/tags/Vue3/"}]},{"title":"叔本华《人生的智慧》第一章节","slug":"叔本华《人生的智慧》第一章节","date":"2021-09-13T14:13:47.000Z","updated":"2021-09-15T11:01:19.022Z","comments":true,"path":"20210913/叔本华《人生的智慧》第一章节/","link":"","permalink":"https://zouhualu.github.io/20210913/%E5%8F%94%E6%9C%AC%E5%8D%8E%E3%80%8A%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82/","excerpt":"","text":"对于阅读人生哲理这一类的书，我一直坚信“尽信书则不如无书”。书名叫做《人生的智慧》，第一眼见到就觉得命题有点过于庞大而且作者有些自大。倘若人生的智慧真能总结在一本书中，那我想我们真的应该每个人都手捧一本，而不是什么《红宝书/圣经》。但是又不是每个人都爱去阅读，阅读从来都是用来克制自己的而不是去监管别人的。许多人把叔本华哲学归为悲观主义，但读完第一章节，他一直在指引我们如何去追求人生的乐趣。文章逻辑性强，有理有据，说服力强，看得出叔本华的哲学深度以及译者的功力。至少第一章我读下来，确实有不少启发。以下是部分抄录 第一章 基本的划分决定凡人命运的根本差别在于三项内容： 人的自身，即在最广泛意义上属于人的个性的东西。因此，它包括人的健康、力量、外貌、气质、道德品格、精神智力及其潜在发展。 人所拥有的身外之物，亦即财产和其他占有物。 人向其他人所显示的样子，人在其他人眼中所呈现的样子，亦即人们对他的看法。他人的看法又可分为名誉、地位和名声。 对于一个人的幸福，甚至对于他的整个生存的方式，最主要的明显就是这个人自身的内在素质，它直接决定了这个人是否能够得到内心的幸福，因为人的内心快乐抑或内心痛苦首先就是人的感情、意欲和思想的产物。而人自身之外的所有事物，对于人的幸福都只是间接地发挥影响。因此，同一样外在的事物和同一样的境遇，对于我们每一个人的影响都不尽相同；处在同一样的环境每一个人，都生活在不同的世界中。因为与一个人直接相关的是这一个人对事物的看法、他的感情以及他的意欲活动。外在事物只有在刺激起他的上述东西时才能发挥作用 “对完全一样的客体时，不同的主体就意味着所构成的现实完全不同，反之亦然”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. 注：不同的人对发生的同一件事会有不同的态度和想法 一个人只能直接活在自己的意识之中。因此，外在世界对他帮助不大 “对于人来说，存在和发生的一切事情总是直接存在和发生在他的意识里面，所以，很明显，人的意识的构成是首要关键”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. 注：你的下意识会对发生的事情产生看法。 “尽管在人的一生中，外在变化不断发生，但人的性格却始终如一，这好比虽然有一连串的变奏，但主旋律却维持不变。无人能够脱离自身个性 ”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “对我们的生活幸福而言，我们的自身个性才是最重要和最关键的，因为我们的个性持久不变，它在任何情况下都在发挥着作用”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “我们唯一能够做到的就是尽可能充分地利用我们既定的个性。因此，我们应该循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。所以，我们必须选择与我们个性相配的地位、职业和生活方式。”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “人的自身比起财产和他人对自己的看法具有压倒性的优势；由此可知，注重保持身体健康和发挥个人自身才能比全力投入获得财富更为明智”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “人生最高的乐趣——精神方面的乐趣——对他们来说，是遥不可及的事情。既然如此，他们就只能忙里偷闲地寻求那些短暂的、感官的乐趣——它们费时很少，却耗钱很多。”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “人的内在拥有对于人的幸福才是最关键的”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “无聊——它源自上述的精神贫乏和空虚”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “人自身内在的贫乏由此导致了外在财富的贫乏。”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “彼德尼斯【3】说过：“一个人所拥有的财产决定了这个人在他人眼中的价值。”如果这句话是正确的话，那么，反过来，他人对自己的良好评价，能以各种形式帮助自己获取财产。”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books.","categories":[{"name":"阅读","slug":"阅读","permalink":"https://zouhualu.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"人生的智慧","slug":"人生的智慧","permalink":"https://zouhualu.github.io/tags/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7/"},{"name":"叔本华","slug":"叔本华","permalink":"https://zouhualu.github.io/tags/%E5%8F%94%E6%9C%AC%E5%8D%8E/"},{"name":"哲学","slug":"哲学","permalink":"https://zouhualu.github.io/tags/%E5%93%B2%E5%AD%A6/"}]},{"title":"web设计模式解析与实战（一）","slug":"web设计模式解析与实战","date":"2021-09-12T05:31:57.000Z","updated":"2021-09-15T11:01:19.021Z","comments":true,"path":"20210912/web设计模式解析与实战/","link":"","permalink":"https://zouhualu.github.io/20210912/web%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/","excerpt":"","text":"今天课程主要是讲前端设计模式，早上一节，晚上一节。 设计模式有利于 组织模块 设计沟通 代码质量 五大设计原则： 开闭原则（OCP：open close principle） 开-对拓展开放，对修改关闭 单一职责原则（SRP） 岗位职责单一，互不重叠 依赖倒置原则（DIP） 上层不应该依赖下层实现 接口隔离原则（ISP） 多个专业的接口比单个胖借口好用 里氏替换原则（LSP：the Lxxxx substitution principle） 子类能够覆盖父类 父类能够出现的地方子类就能出现 今天老师给的课后题： 某个停车场，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开， 车辆进入前，显示每层的空余车辆数量 车辆进入时，摄像头可识别车牌号和时间 车辆出来时，出口显示器显示车牌号和停车时长请设计一套系统。","categories":[{"name":"技术类","slug":"技术类","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[{"name":"课程","slug":"课程","permalink":"https://zouhualu.github.io/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"浮生一日(20210911)","slug":"浮生一日","date":"2021-09-11T10:44:58.000Z","updated":"2021-09-15T11:01:19.021Z","comments":true,"path":"20210911/浮生一日/","link":"","permalink":"https://zouhualu.github.io/20210911/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/","excerpt":"","text":"今天老妈的生日🎂 猝不及防的狗粮 苹果的售后真的好，耳机检测了一下就说直接换新的","categories":[{"name":"浮生一日","slug":"浮生一日","permalink":"https://zouhualu.github.io/categories/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/"}],"tags":[{"name":"浮生一日","slug":"浮生一日","permalink":"https://zouhualu.github.io/tags/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/"},{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"TypeScript中函数的理解","slug":"TypeScript中函数的理解","date":"2021-09-10T08:55:32.000Z","updated":"2021-09-10T09:03:27.141Z","comments":true,"path":"20210910/TypeScript中函数的理解/","link":"","permalink":"https://zouhualu.github.io/20210910/TypeScript%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"使用方式和JavaScript使用方式类似，可以通过funciton关键字、箭头函数等形式去定义，例如下面一个简单的加法函数： 1const add = (a:number,b:number)=&gt; a+b 上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：当鼠标放置在第三行 add 函数名的时候，会出现完整的函数定义类型，通过 : 的形式来定义参数类型，通过 =&gt; 连接参数和返回值类型 我们也可以显式地写上返回类型，如下： 1const add = (a:number,b:number):number=&gt; a+b 当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示： 12345678// 方式一type LongHand = &#123; (a: number): number;&#125;;// 方式二type ShortHand = (a: number) =&gt; number; 当存在函数重载时，只能使用方式一的形式 可选参数当函数的参数可能是不存在的，只需要在参数后面加上 ? 代表参数可能不存在，如下： 1const add = (a: number, b?: number) =&gt; a + (b ? b : 0) 这时候参数b可以是number类型或者undefined类型，即可以传一个number类型或者不传都可以 剩余类型剩余参数与JavaScript的语法类似，需要用 ... 来表示剩余参数 如果剩余参数 rest 是一个由number类型组成的数组，则如下表示： 1const add = (a: number, ...rest: number[]) =&gt; rest.reduce(((a, b) =&gt; a + b), a) 函数重载允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力 关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，用于具体实现 这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并 例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下： 1234567891011121314// 上边是声明function add (arg1: string, arg2: string): stringfunction add (arg1: number, arg2: number): number// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字// 下边是实现function add (arg1: string | number, arg2: string | number) &#123; // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2 if (typeof arg1 === &#x27;string&#x27; &amp;&amp; typeof arg2 === &#x27;string&#x27;) &#123; return arg1 + arg2 &#125; else if (typeof arg1 === &#x27;number&#x27; &amp;&amp; typeof arg2 === &#x27;number&#x27;) &#123; return arg1 + arg2 &#125;&#125; 区别从上面可以看到： 从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型 typescript 在参数中，添加可选参数供使用者选择 typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型参考文章 https://www.tslang.cn/docs/handbook/functions.html https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD","categories":[{"name":"技术类-TypeScript","slug":"技术类-TypeScript","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://zouhualu.github.io/tags/TypeScript/"}]},{"title":"本博客说明书","slug":"about-me","date":"2021-09-07T03:19:02.000Z","updated":"2021-09-26T02:21:21.380Z","comments":true,"path":"20210907/about-me/","link":"","permalink":"https://zouhualu.github.io/20210907/about-me/","excerpt":"","text":"幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔 19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。所以我又重新搭了一个。后续会把写过的文档陆续上传到这边本博客主要记录学习过程，技术文档以及日常。 以下是功能测试：嵌入B站视频 代码块 123456console.log(&#x27;zouHuaLu&#x27;)hexo ghexo g -whexo serverhexo cleanhexo deploy 以后有时间弄一下评论功能 2021-09-23 本博客新增评论功能，支持评论啦！","categories":[{"name":"博客说明","slug":"博客说明","permalink":"https://zouhualu.github.io/categories/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}],"tags":[{"name":"博客说明","slug":"博客说明","permalink":"https://zouhualu.github.io/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]},{"title":"TypeScript中类的理解","slug":"TypeScript中类的理解","date":"2021-09-06T06:48:00.000Z","updated":"2021-09-09T07:35:00.949Z","comments":true,"path":"20210906/TypeScript中类的理解/","link":"","permalink":"https://zouhualu.github.io/20210906/TypeScript%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"一、是什么类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础 ❝类是一种用户定义的引用数据类型，也称类类型❞ 传统的面向对象语言基本都是基于类的，JavaScript 基于原型的方式让开发者多了很多理解成本在 ES6 之后，JavaScript 拥有了 class 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多但是JavaScript 的class依然有一些特性还没有加入，比如修饰符和抽象类TypeScript 的 class 支持面向对象的所有特性，比如 类、接口等 二、使用方式定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块(类的数据成员)： 「字段」：字段是类里面声明的变量。字段表示对象的有关数据。 「构造函数」：类实例化时调用，可以为类的对象分配内存。 「方法」：方法为对象要执行的操作如下例子： 123456789101112131415class Car &#123; // 字段 engine:string; // 构造函数 constructor(engine:string) &#123; this.engine = engine &#125; // 方法 disp():void &#123; console.log(&quot;发动机为 : &quot;+this.engine) &#125; &#125; 继承类的继承使用过extends的关键字 1234567891011121314151617class Animal &#123; move(distanceInMeters: number = 0) &#123; console.log(`Animal moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Dog extends Animal &#123; bark() &#123; console.log(&#x27;Woof! Woof!&#x27;); &#125;&#125;const dog = new Dog();dog.bark();dog.move(10);dog.bark(); Dog是一个 派生类，它派生自 Animal 基类，派生类通常被称作子类，基类通常被称作 超类。 Dog类继承了Animal类，因此实例dog也能够使用Animal类move方法。同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。 通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下： 12345678910111213class PrinterClass &#123; doPrint():void &#123; console.log(&quot;父类的 doPrint() 方法。&quot;) &#125; &#125; class StringPrinter extends PrinterClass &#123; doPrint():void &#123; super.doPrint() // 调用父类的函数 console.log(&quot;子类的 doPrint()方法。&quot;) &#125; &#125; 修饰符可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符： 公共 public：可以自由的访问类程序里定义的成员 私有 private：只能够在该类的内部进行访问 受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问 私有修饰符只能够在该类的内部进行访问，实例对象并不能够访问 12345678class Father&#123; private name:String constructor(name:String)&#123; this.name = name &#125;&#125;const father = new Father(&#x27;zouHuaLu&#x27;)father.name //会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot; 并且继承该类的子类并不能访问，如下图所示： 1234567891011class Father&#123; private name:String constructor(name:String)&#123; this.name = name &#125;&#125;class Son extends Father&#123; say()&#123; console.log(`my name is $&#123;this.name&#125;`) //会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot; &#125;&#125; 受保护修饰符跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下： 12345678class Father&#123; protected name:String constructor(name:String)&#123; this.name = name &#125;&#125;const father = new Father(&#x27;zouHuaLu&#x27;)father.name //会报错，提示 &quot;属性name受保护，只能在类Father及其子类中访问&quot; 有一点不同的是 protected 成员在子类中仍然可以访问 1234567891011class Father&#123; protected name:String constructor(name:String)&#123; this.name = name &#125;&#125;class Son extends Father&#123; say()&#123; console.log(`my name is $&#123;this.name&#125;`) &#125;&#125; 只读修饰符通过readonly关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下： 12345678class Father&#123; readonly name:String constructor(name:String)&#123; this.name = name &#125;&#125;const father = new Father(&#x27;zouHuaLu&#x27;)father.name //会报错,提示&quot;无法分配到name，因为它是只读属性&quot; 静态属性这些属性存在于类本身上面而不是类的实例上，通过static进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示： 12345class Square &#123; static width = &#x27;100px&#x27;&#125;console.log(Square.width) // 100px 抽象类抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示： 123456abstract class Animal &#123; abstract makeSound(): void; move(): void &#123; console.log(&#x27;roaming the earch...&#x27;); &#125;&#125; 这种类并不能被实例化，通常需要我们创建子类去继承，如下： 1234567891011class Cat extends Animal &#123; makeSound() &#123; console.log(&#x27;miao miao&#x27;) &#125;&#125;const cat = new Cat()cat.makeSound() // miao miaocat.move() // roaming the earch... 三、应用场景除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在React 工程中是很常用的，如下： 1export default class Carousel extends React.Component&lt;Props, State&gt; &#123;&#125; 由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。 先声明一个类，这个类包含组件 props 所需的类型和初始值： 12345678910111213// props的类型export default class Props &#123; public children: Array&lt;React.ReactElement&lt;any&gt;&gt; | React.ReactElement&lt;any&gt; | never[] = [] public speed: number = 500 public height: number = 160 public animation: string = &#x27;easeInOutQuad&#x27; public isAuto: boolean = true public autoPlayInterval: number = 4500 public afterChange: () =&gt; &#123;&#125; public beforeChange: () =&gt; &#123;&#125; public selesctedColor: string public showDots: boolean = true&#125; 当我们需要传入 props 类型的时候直接将 Props 作为接口传入，此时 Props 的作用就是接口，而当需要我们设置defaultProps初始值的时候，我们只需要: 1public static defaultProps = new Props() Props 的实例就是 defaultProps 的初始值，这就是 class作为接口的实际应用，我们用一个 class 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量 参考文章 https://www.tslang.cn/docs/handbook/classes.html https://www.runoob.com/typescript/ts-class.html","categories":[{"name":"技术类-TypeScript","slug":"技术类-TypeScript","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://zouhualu.github.io/tags/TypeScript/"}]},{"title":"export与export default的区别","slug":"export与export-default的区别","date":"2021-07-01T06:21:44.000Z","updated":"2021-09-23T06:24:16.009Z","comments":true,"path":"20210701/export与export-default的区别/","link":"","permalink":"https://zouhualu.github.io/20210701/export%E4%B8%8Eexport-default%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"node中导入模块：var 名称 = require(‘模块标识符’) node中向外暴露成员的形式：module.exports = {} 在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块 ES6中导入模块，使用 import 模块名称 from ‘模块标识符’ import ‘表示路径’ import * from * 是ES6中导入模块的方式 在ES6中，使用export default 和 export 向外暴露成员例如： 12345// test.jsexport default &#123; name: &#x27;zs&#x27;, age: 20&#125; 或是 123456// test.jsvar info = &#123; name: &#x27;zs&#x27;, age: 20&#125;export default info 在main.js中接收，test.js使用export default 向外暴露的成员 12import person from &#x27;./test.js&#x27;console.log(person); 注意：1、export default 向外暴露的成员，可以使用任意变量来接收 2、在一个模块中，export default 只允许向外暴露一次 3、在一个模块中，可以同时使用export default 和export 向外暴露成员 4、使用export向外暴露的成员，只能使用{ }的形式来接收，这种形式，叫做【按需导出】 5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义 6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收 7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名 例如： 12345678910// test.jsvar info = &#123; name: &#x27;zs&#x27;, age: 20&#125;export default infoexport var title = &#x27;小星星&#x27;export var content = &#x27;哈哈哈&#x27; 在main.js中接收，test.js使用export default 和 export 向外暴露的成员 123import person, &#123;title, content as content1&#125; from &#x27;./test.js&#x27;console.log(person);console.log(title + &#x27;=======&#x27; + content1);","categories":[{"name":"技术类","slug":"技术类","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://zouhualu.github.io/tags/ES6/"}]},{"title":"new操作符的实现","slug":"new操作符的实现","date":"2021-06-18T21:23:44.000Z","updated":"2021-09-23T03:12:42.715Z","comments":true,"path":"20210619/new操作符的实现/","link":"","permalink":"https://zouhualu.github.io/20210619/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"JavaScript中的new操作符的原理例子123456function Person (name, age) &#123; this.name = name this.age = age&#125;const person1 = new Person(&#x27;走花路的长颈鹿&#x27;, 26)console.log(person1) //Person&#123;name:&#x27;走花路的长颈鹿&#x27;,age:26&#125; 先定义了一个构造函数Person，然后通过new操作符生成Person构造函数的一个实例并将其引用赋值给变量person1。然后控制台打印出person1的内容，可以看到该实例对象具有name和age属性，它们的值就是我们在调用构造函数时传入的值。 new关键字进行的操作 先创建一个空对象obj=&#123;&#125; 将obj的__proto__原型指向构造函数Person的prototype原型对象，即obj.__proto__ = Person.prototype 将构造函数Person内部的this指向obj，然后执行构造函数Person()（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象obj而已，就好像执行obj.Person()一样） 若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象obj（默认会添加return this）。否则，返回引用类型的值。 自己实现一个new操作符1234567891011121314151617function myNew (constr, ...args) &#123; // 1,2 创建一个对象obj，将obj的__proto__属性指向构造函数的原型对象 // 即实现：obj.__proto__ === constructor.prototype var obj = Object.create(constr.prototype) // 3.将constrc内部的this（即执行上下文）指向obj，并执行 var result = constr.apply(obj, args) // 4\\. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象 return result instanceof Object ? result : obj&#125;// 使用的例子：function Person(name, age)&#123; this.name = name; this.age = age;&#125;const person1 = myNew(Person, &#x27;Tom&#x27;, 20)console.log(person1) // Person &#123;name: &quot;Tom&quot;, age: 20&#125; 关键点 将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。 将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。 2021年7月1日补充看一个例子 123456789101112function Player(color) &#123; this.color = color&#125;Player.prototype.start = function() &#123;&#125;const white = new Player(&#x27;white&#x27;)const black = new Player(&#x27;black&#x27;)console.log(black.__proto__) // start()console.log(Object.getPrototypeOf(black)) // start()console.log(Player.prototype) // start()console.log(Player.__proto__) // &#123;&#125; 根据反推可以写一下思路 一个继承自Player.prototype的新对象 p1/p2被创建 p1.__proto__ === Player.prototype，p1.__proto__指向Player.prototype 将this指向新创建的对象p1/p2 返回一个新对象： 如果构造函数没有显示的返回值，那么返回this 如果有显式的返回值，是基本类型，那么还是返回this 如果构造函数有显式的返回值，是对象类型，比如是{a:1}，那么就返回{a:1}现在我们再来实现一个new指令的功能12345678910111213function Player(name)&#123; this.name = name&#125;function objectFactory() &#123; let o = new Object() let FunctionConstructor = [].shift.call(arguments) o.__proto__ = FunctionConstructor.prototype let resultObj = FunctionConstructor.apply(o, arguments) return typeof resultObj === &#x27;object&#x27; ? resultObj : o&#125;const p1 = objectFactory(Player, &#x27;花鹿&#x27;)console.log(p1) // 花鹿 完~","categories":[{"name":"技术类","slug":"技术类","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"}]},{"title":"原型与原型链与constructor","slug":"原型与原型链与constructor","date":"2021-06-18T07:16:53.000Z","updated":"2021-09-23T03:13:14.786Z","comments":true,"path":"20210618/原型与原型链与constructor/","link":"","permalink":"https://zouhualu.github.io/20210618/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8Econstructor/","excerpt":"","text":"原型与原型链与constructor本文参考自：https://blog.csdn.net/cc18868876837/article/details/81211729 先来个总结： 我们需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。 __proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。 prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。 constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 基础知识__proto__翻译为原型，多个__proto__串连起来的叫做原型链。 prototype翻译为原型对象。 Object.getPrototypeOf()Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。 示例123456const prototype1 = &#123;&#125;;const object1 = Object.create(prototype1);console.log(Object.getPrototypeOf(object1) === prototype1);// expected output: trueObject.getPrototypeOf(object1) === object1.__proto__ 正式开始12function Foo() &#123;...&#125;;let f1 = new Foo(); 以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。 __proto__属性首先要记住两点： __proto__和constructor是对象才有的属性，在JavaScript中函数也是一种对象。 prototype是函数才有的属性。 这里我们仅留下 __proto__ 属性，它是对象所独有的，可以看到__proto__属性都是由一个对象指向一个对象，即指向它们构造函数的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。 其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠__proto__继承而来的。 prototype属性 prototype属性是函数独有的。他是从一个函数指向一个对象，他的含义是函数的原型对象 f1.__proto__ === Foo.prototype，它们两个完全一样。那prototype属性的作用又是什么呢？它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。 constructor属性 constructor属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合__proto__属性查看会更清楚点，如下图所示），从上图中可以看出Function这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。 函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身 完~","categories":[{"name":"技术类","slug":"技术类","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"原型","slug":"原型","permalink":"https://zouhualu.github.io/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"原型链","slug":"原型链","permalink":"https://zouhualu.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"Vue自定义全局组件","slug":"Vue自定义全局组件","date":"2021-06-18T07:15:40.000Z","updated":"2021-09-23T02:26:35.030Z","comments":true,"path":"20210618/Vue自定义全局组件/","link":"","permalink":"https://zouhualu.github.io/20210618/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6/","excerpt":"","text":"vue自定义全局弹框组件 在components文件夹下新增一个组件文件夹Dialog，新建一个模板组件Dialog.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;template&gt; &lt;div class=&quot;u_dialog_panel&quot; @touchmove.stop=&quot;noop&quot;&gt; &lt;div class=&quot;mask&quot; v-if=&quot;visible&quot; @click=&quot;handleClose&quot;&gt;&lt;/div&gt; &lt;transition name=&quot;open&quot;&gt; &lt;div v-if=&quot;visible&quot; class=&quot;dialog_body&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;div class=&quot;btns&quot; v-if=&quot;confirmText || cancleText&quot;&gt; &lt;div class=&quot;cancle btn&quot; v-if=&quot;cancleText&quot; @click=&quot;handleCancle&quot;&gt;&#123;&#123;cancleText&#125;&#125;&lt;/div&gt; &lt;div class=&quot;confirm btn&quot; :style=&quot;confirmStyle&quot; v-if=&quot;confirmText&quot; @click=&quot;handleConfirm&quot;&gt;&#123;&#123;confirmText&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;UDialog&#x27;, props: &#123; visible: &#123; type: Boolean, default: false, required: true &#125;, // 确定按钮的文案 confirmText: &#123; type: String, default: &#x27;确定&#x27; &#125;, confirmStyle: &#123; type: String, default: &#x27;&#x27; &#125;, // 取消按钮的文案 cancleText: &#123; type: String, default: &#x27;取消&#x27; &#125;, cancleStyle: &#123; type: String, default: &#x27;&#x27; &#125;, &#125;, created () &#123; this.$nextTick(() =&gt; &#123; document.body.insertBefore(this.$el, document.body.lastChild) &#125;) &#125;, beforeDestroy () &#123; document.body.removeChild(this.$el) &#125;, methods: &#123; // 关闭弹窗 handleClose () &#123; this.$emit(&#x27;close&#x27;) &#125;, // 确定按钮 handleConfirm () &#123; this.$emit(&#x27;confirm&#x27;) &#125;, // 取消按钮 handleCancle () &#123; this.$emit(&#x27;cancle&#x27;) &#125;, noop () &#123;&#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.u_dialog_panel &#123; .mask &#123; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); position: fixed; left: 0; top: 0; z-index: 100; backdrop-filter: blur(5px); &#125; .dialog_body&#123; width: 80vw; background-color: #fff; position: fixed; left: 50vw; top: 50vh; z-index: 100; transform: translate(-50%, -50%); transform-origin: 0 0; border-radius: .875rem; &amp;.open-enter &#123; opacity: 0; transform: scale(0.7) translate(-50%, -50%); transition: all 0.3s; &#125; &amp;.open-enter-to &#123; opacity: 1; transform: scale(1) translate(-50%, -50%); transition: all 0.3s; &#125; .btns &#123; display: flex; justify-content: space-between; align-items: center; .btn &#123; display: flex; justify-content: center; align-items: center; flex-grow: 1; width: 50%; height: 2.875rem; border-top: 1px solid #ddd; box-sizing: border-box; display: flex; justify-content: center; align-items: center; font-size: .875rem; &amp; + .btn &#123; border-left: 1px solid #ddd; &#125; &amp;.cancle &#123; color: #666666; &#125; &amp;.confirm &#123; color: #FF5883; &#125; &#125; &#125; &#125;&#125;&lt;/style&gt; 在此文件夹再新建一个index.js 12345678import Dialog from &#x27;./Dialog&#x27;Dialog.install = function (Vue, options) &#123; Vue.component(`$&#123;Dialog.name&#125;`, Dialog)&#125;export default Dialog 最后再main.js里注册为全局组件 123import Dialog from &#x27;./components/Dialog/index.js&#x27;Vue.use(Dialog) 这样就可以在其他组件里无需声明而使用此组件","categories":[{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://zouhualu.github.io/tags/Vue3/"}]},{"title":"JavaScript中的堆栈以及数据类型","slug":"JavaScript中的堆栈以及数据类型","date":"2021-06-17T07:08:21.000Z","updated":"2021-09-23T06:21:08.053Z","comments":true,"path":"20210617/JavaScript中的堆栈以及数据类型/","link":"","permalink":"https://zouhualu.github.io/20210617/JavaScript%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"JavaScript的堆栈以及数据类型本文参考此链接 堆 是堆内存的简称。堆是动态分配内存，内存大小不一，也不会自动释放。栈 是栈内存的简称。栈是自动分配相对固定大小的内存空间，并由系统自动释放。后进先出 基本数据类型javascript的基本类型就5种:Undefined、Null、Boolean、Number和String，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。 引用数据类型javascript中其他类型的数据被称为引用类型的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和new出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。 传值与传址123456789var arr1 = [1,2,5,8]; var arr2 = arr1 ; var str1 = arr1[2]; console.log(arr2);//1,2,5,8console.log(str1);//5arr2[4] = 99; str1 = 6; console.log(arr1);//1,2,5,8,99console.log(arr1[2]);//5 当我改变arr2中的数据时，arr1中数据也发生了变化，当改变str1的数据值时，arr1却没有发生改变。为什么？这就是传值与传址的区别。 因为arr1是数组，属于引用类型，所以它赋予给arr2的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1得到的是一个基本类型的赋值，因此，str1仅仅是从arr1堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2都指向同一块堆内存，arr2修改的堆内存的时候，也就会影响到arr1，str1是直接在栈中修改，并且不能影响到arr1堆内存中的数据。 深拷贝和浅拷贝上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将arr1的每个基本类型的数据都遍历一遍，依次的赋值给arr2的对应字段。避免产生因为地址引用带来的问题。 123456789var arr1 = [1,2,5,8]; var arr2 = []; for(var i=0;i&lt;arr1.length;i++)&#123; arr2[i]=arr1[i];&#125;;console.log(arr2)//1,2,5,8arr2[4]=99;console.log(arr2)//1,2,5,8,99console.log(arr1)//1,2,5,8 javascript面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。 完~","categories":[{"name":"技术类","slug":"技术类","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"}]}],"categories":[{"name":"算法类","slug":"算法类","permalink":"https://zouhualu.github.io/categories/%E7%AE%97%E6%B3%95%E7%B1%BB/"},{"name":"浮生一日","slug":"浮生一日","permalink":"https://zouhualu.github.io/categories/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/"},{"name":"技术类","slug":"技术类","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB/"},{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"},{"name":"阅读","slug":"阅读","permalink":"https://zouhualu.github.io/categories/%E9%98%85%E8%AF%BB/"},{"name":"技术类-TypeScript","slug":"技术类-TypeScript","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-TypeScript/"},{"name":"博客说明","slug":"博客说明","permalink":"https://zouhualu.github.io/categories/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zouhualu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://zouhualu.github.io/tags/leetcode/"},{"name":"浮生一日","slug":"浮生一日","permalink":"https://zouhualu.github.io/tags/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/"},{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"Vue3","slug":"Vue3","permalink":"https://zouhualu.github.io/tags/Vue3/"},{"name":"人生的智慧","slug":"人生的智慧","permalink":"https://zouhualu.github.io/tags/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7/"},{"name":"叔本华","slug":"叔本华","permalink":"https://zouhualu.github.io/tags/%E5%8F%94%E6%9C%AC%E5%8D%8E/"},{"name":"哲学","slug":"哲学","permalink":"https://zouhualu.github.io/tags/%E5%93%B2%E5%AD%A6/"},{"name":"课程","slug":"课程","permalink":"https://zouhualu.github.io/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://zouhualu.github.io/tags/TypeScript/"},{"name":"博客说明","slug":"博客说明","permalink":"https://zouhualu.github.io/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"},{"name":"ES6","slug":"ES6","permalink":"https://zouhualu.github.io/tags/ES6/"},{"name":"原型","slug":"原型","permalink":"https://zouhualu.github.io/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"原型链","slug":"原型链","permalink":"https://zouhualu.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]}
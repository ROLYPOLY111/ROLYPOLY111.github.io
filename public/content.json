{"meta":{"title":"走花路的长颈鹿","subtitle":"走花路的长颈鹿","description":"走花路的长颈鹿,博客","author":"走花路的长颈鹿","url":"https://zouhualu.github.io","root":"/"},"pages":[{"title":"","date":"2021-09-08T12:42:52.396Z","updated":"2021-09-08T12:42:52.396Z","comments":false,"path":"baidu_verify_code-TmkkRxX4ps.html","permalink":"https://zouhualu.github.io/baidu_verify_code-TmkkRxX4ps.html","excerpt":"","text":"676194d86471561a70b8026338973ebc"},{"title":"about","date":"2021-09-07T07:20:04.000Z","updated":"2021-09-08T12:42:52.396Z","comments":false,"path":"about/index.html","permalink":"https://zouhualu.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"叔本华《人生的智慧》第一章节","slug":"叔本华《人生的智慧》第一章节","date":"2021-09-13T14:13:47.000Z","updated":"2021-09-13T14:18:45.571Z","comments":true,"path":"20210913/叔本华《人生的智慧》第一章节/","link":"","permalink":"https://zouhualu.github.io/20210913/%E5%8F%94%E6%9C%AC%E5%8D%8E%E3%80%8A%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82/","excerpt":"","text":"对于阅读人生哲理这一类的书，我一直坚信“尽信书则不如无书”。书名叫做《人生的智慧》，第一眼见到就觉得命题有点过于庞大而且作者有些自大。倘若人生的智慧真能总结在一本书中，那我想我们真的应该每个人都手捧一本，而不是什么《红宝书/圣经》。但是又不是每个人都爱去阅读，阅读从来都是用来克制自己的而不是去监管别人的。许多人把叔本华哲学归为悲观主义，但读完第一章节，他一直在指引我们如何去追求人生的乐趣。文章逻辑性强，有理有据，说服力强，看得出叔本华的哲学深度以及译者的功力。至少第一章我读下来，确实有不少启发。以下是部分抄录 第一章 基本的划分决定凡人命运的根本差别在于三项内容： 人的自身，即在最广泛意义上属于人的个性的东西。因此，它包括人的健康、力量、外貌、气质、道德品格、精神智力及其潜在发展。 人所拥有的身外之物，亦即财产和其他占有物。 人向其他人所显示的样子，人在其他人眼中所呈现的样子，亦即人们对他的看法。他人的看法又可分为名誉、地位和名声。 对于一个人的幸福，甚至对于他的整个生存的方式，最主要的明显就是这个人自身的内在素质，它直接决定了这个人是否能够得到内心的幸福，因为人的内心快乐抑或内心痛苦首先就是人的感情、意欲和思想的产物。而人自身之外的所有事物，对于人的幸福都只是间接地发挥影响。因此，同一样外在的事物和同一样的境遇，对于我们每一个人的影响都不尽相同；处在同一样的环境每一个人，都生活在不同的世界中。因为与一个人直接相关的是这一个人对事物的看法、他的感情以及他的意欲活动。外在事物只有在刺激起他的上述东西时才能发挥作用 “对完全一样的客体时，不同的主体就意味着所构成的现实完全不同，反之亦然”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. 注：不同的人对发生的同一件事会有不同的态度和想法 一个人只能直接活在自己的意识之中。因此，外在世界对他帮助不大 “对于人来说，存在和发生的一切事情总是直接存在和发生在他的意识里面，所以，很明显，人的意识的构成是首要关键”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. 注：你的下意识会对发生的事情产生看法。 “尽管在人的一生中，外在变化不断发生，但人的性格却始终如一，这好比虽然有一连串的变奏，但主旋律却维持不变。无人能够脱离自身个性 ”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “对我们的生活幸福而言，我们的自身个性才是最重要和最关键的，因为我们的个性持久不变，它在任何情况下都在发挥着作用”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “我们唯一能够做到的就是尽可能充分地利用我们既定的个性。因此，我们应该循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。所以，我们必须选择与我们个性相配的地位、职业和生活方式。”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “人的自身比起财产和他人对自己的看法具有压倒性的优势；由此可知，注重保持身体健康和发挥个人自身才能比全力投入获得财富更为明智”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “人生最高的乐趣——精神方面的乐趣——对他们来说，是遥不可及的事情。既然如此，他们就只能忙里偷闲地寻求那些短暂的、感官的乐趣——它们费时很少，却耗钱很多。”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “人的内在拥有对于人的幸福才是最关键的”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “无聊——它源自上述的精神贫乏和空虚”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “人自身内在的贫乏由此导致了外在财富的贫乏。”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. “彼德尼斯【3】说过：“一个人所拥有的财产决定了这个人在他人眼中的价值。”如果这句话是正确的话，那么，反过来，他人对自己的良好评价，能以各种形式帮助自己获取财产。”摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books.","categories":[{"name":"阅读","slug":"阅读","permalink":"https://zouhualu.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"人生的智慧","slug":"人生的智慧","permalink":"https://zouhualu.github.io/tags/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7/"},{"name":"叔本华","slug":"叔本华","permalink":"https://zouhualu.github.io/tags/%E5%8F%94%E6%9C%AC%E5%8D%8E/"},{"name":"哲学","slug":"哲学","permalink":"https://zouhualu.github.io/tags/%E5%93%B2%E5%AD%A6/"}]},{"title":"web设计模式解析与实战（一）","slug":"web设计模式解析与实战","date":"2021-09-12T05:31:57.000Z","updated":"2021-09-12T08:39:10.433Z","comments":true,"path":"20210912/web设计模式解析与实战/","link":"","permalink":"https://zouhualu.github.io/20210912/web%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/","excerpt":"","text":"今天课程主要是讲前端设计模式，早上一节，晚上一节。 设计模式有利于 组织模块 设计沟通 代码质量 五大设计原则： 开闭原则（OCP：open close principle） 开-对拓展开放，对修改关闭 单一职责原则（SRP） 岗位职责单一，互不重叠 依赖倒置原则（DIP） 上层不应该依赖下层实现 接口隔离原则（ISP） 多个专业的接口比单个胖借口好用 里氏替换原则（LSP：the Lxxxx substitution principle） 子类能够覆盖父类 父类能够出现的地方子类就能出现 今天老师给的课后题： 某个停车场，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开， 车辆进入前，显示每层的空余车辆数量 车辆进入时，摄像头可识别车牌号和时间 车辆出来时，出口显示器显示车牌号和停车时长请设计一套系统。","categories":[{"name":"技术类","slug":"技术类","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[{"name":"课程","slug":"课程","permalink":"https://zouhualu.github.io/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"浮生一日(20210911)","slug":"浮生一日","date":"2021-09-11T10:44:58.000Z","updated":"2021-09-11T11:50:08.137Z","comments":true,"path":"20210911/浮生一日/","link":"","permalink":"https://zouhualu.github.io/20210911/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/","excerpt":"","text":"今天老妈的生日🎂 猝不及防的狗粮 苹果的售后真的好，耳机检测了一下就说直接换新的","categories":[{"name":"浮生一日","slug":"浮生一日","permalink":"https://zouhualu.github.io/categories/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/"}],"tags":[{"name":"浮生一日","slug":"浮生一日","permalink":"https://zouhualu.github.io/tags/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/"},{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"TypeScript中函数的理解","slug":"TypeScript中函数的理解","date":"2021-09-10T08:55:32.000Z","updated":"2021-09-11T10:44:14.225Z","comments":true,"path":"20210910/TypeScript中函数的理解/","link":"","permalink":"https://zouhualu.github.io/20210910/TypeScript%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"使用方式和JavaScript使用方式类似，可以通过funciton关键字、箭头函数等形式去定义，例如下面一个简单的加法函数： 1const add = (a:number,b:number)=&gt; a+b 上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：当鼠标放置在第三行 add 函数名的时候，会出现完整的函数定义类型，通过 : 的形式来定义参数类型，通过 =&gt; 连接参数和返回值类型 我们也可以显式地写上返回类型，如下： 1const add = (a:number,b:number):number=&gt; a+b 当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示： 12345678// 方式一type LongHand = &#123; (a: number): number;&#125;;// 方式二type ShortHand = (a: number) =&gt; number; 当存在函数重载时，只能使用方式一的形式 可选参数当函数的参数可能是不存在的，只需要在参数后面加上 ? 代表参数可能不存在，如下： 1const add = (a: number, b?: number) =&gt; a + (b ? b : 0) 这时候参数b可以是number类型或者undefined类型，即可以传一个number类型或者不传都可以 剩余类型剩余参数与JavaScript的语法类似，需要用 ... 来表示剩余参数 如果剩余参数 rest 是一个由number类型组成的数组，则如下表示： 1const add = (a: number, ...rest: number[]) =&gt; rest.reduce(((a, b) =&gt; a + b), a) 函数重载允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力 关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，用于具体实现 这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并 例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下： 1234567891011121314// 上边是声明function add (arg1: string, arg2: string): stringfunction add (arg1: number, arg2: number): number// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字// 下边是实现function add (arg1: string | number, arg2: string | number) &#123; // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2 if (typeof arg1 === &#x27;string&#x27; &amp;&amp; typeof arg2 === &#x27;string&#x27;) &#123; return arg1 + arg2 &#125; else if (typeof arg1 === &#x27;number&#x27; &amp;&amp; typeof arg2 === &#x27;number&#x27;) &#123; return arg1 + arg2 &#125;&#125; 区别从上面可以看到： 从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型 typescript 在参数中，添加可选参数供使用者选择 typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型参考文章 https://www.tslang.cn/docs/handbook/functions.html https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD","categories":[{"name":"技术类-TypeScript","slug":"技术类-TypeScript","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://zouhualu.github.io/tags/TypeScript/"}]},{"title":"本博客说明书","slug":"about-me","date":"2021-09-07T03:19:02.000Z","updated":"2021-09-07T12:24:42.706Z","comments":true,"path":"20210907/about-me/","link":"","permalink":"https://zouhualu.github.io/20210907/about-me/","excerpt":"","text":"幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔 19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。所以我又重新搭了一个。后续会把写过的文档陆续上传到这边 以下是功能测试： 嵌入YOUTUBE视频 嵌入B站视频 嵌入图片 代码块 123456console.log(&#x27;zouHuaLu&#x27;)hexo ghexo g -whexo serverhexo cleanhexo deploy 如果你看到We were unable to load Disqus. If you are a moderator please see our troubleshooting guide.,说明本博客的评论功能有问题，后续有时间再改吧","categories":[{"name":"博客说明","slug":"博客说明","permalink":"https://zouhualu.github.io/categories/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}],"tags":[{"name":"博客说明","slug":"博客说明","permalink":"https://zouhualu.github.io/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]},{"title":"TypeScript中类的理解","slug":"TypeScript中类的理解","date":"2021-09-06T06:48:00.000Z","updated":"2021-09-11T10:44:14.225Z","comments":true,"path":"20210906/TypeScript中类的理解/","link":"","permalink":"https://zouhualu.github.io/20210906/TypeScript%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"一、是什么类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础 ❝类是一种用户定义的引用数据类型，也称类类型❞ 传统的面向对象语言基本都是基于类的，JavaScript 基于原型的方式让开发者多了很多理解成本在 ES6 之后，JavaScript 拥有了 class 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多但是JavaScript 的class依然有一些特性还没有加入，比如修饰符和抽象类TypeScript 的 class 支持面向对象的所有特性，比如 类、接口等 二、使用方式定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块(类的数据成员)： 「字段」：字段是类里面声明的变量。字段表示对象的有关数据。 「构造函数」：类实例化时调用，可以为类的对象分配内存。 「方法」：方法为对象要执行的操作如下例子： 123456789101112131415class Car &#123; // 字段 engine:string; // 构造函数 constructor(engine:string) &#123; this.engine = engine &#125; // 方法 disp():void &#123; console.log(&quot;发动机为 : &quot;+this.engine) &#125; &#125; 继承类的继承使用过extends的关键字 1234567891011121314151617class Animal &#123; move(distanceInMeters: number = 0) &#123; console.log(`Animal moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Dog extends Animal &#123; bark() &#123; console.log(&#x27;Woof! Woof!&#x27;); &#125;&#125;const dog = new Dog();dog.bark();dog.move(10);dog.bark(); Dog是一个 派生类，它派生自 Animal 基类，派生类通常被称作子类，基类通常被称作 超类。 Dog类继承了Animal类，因此实例dog也能够使用Animal类move方法。同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。 通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下： 12345678910111213class PrinterClass &#123; doPrint():void &#123; console.log(&quot;父类的 doPrint() 方法。&quot;) &#125; &#125; class StringPrinter extends PrinterClass &#123; doPrint():void &#123; super.doPrint() // 调用父类的函数 console.log(&quot;子类的 doPrint()方法。&quot;) &#125; &#125; 修饰符可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符： 公共 public：可以自由的访问类程序里定义的成员 私有 private：只能够在该类的内部进行访问 受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问 私有修饰符只能够在该类的内部进行访问，实例对象并不能够访问 12345678class Father&#123; private name:String constructor(name:String)&#123; this.name = name &#125;&#125;const father = new Father(&#x27;zouHuaLu&#x27;)father.name //会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot; 并且继承该类的子类并不能访问，如下图所示： 1234567891011class Father&#123; private name:String constructor(name:String)&#123; this.name = name &#125;&#125;class Son extends Father&#123; say()&#123; console.log(`my name is $&#123;this.name&#125;`) //会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot; &#125;&#125; 受保护修饰符跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下： 12345678class Father&#123; protected name:String constructor(name:String)&#123; this.name = name &#125;&#125;const father = new Father(&#x27;zouHuaLu&#x27;)father.name //会报错，提示 &quot;属性name受保护，只能在类Father及其子类中访问&quot; 有一点不同的是 protected 成员在子类中仍然可以访问 1234567891011class Father&#123; protected name:String constructor(name:String)&#123; this.name = name &#125;&#125;class Son extends Father&#123; say()&#123; console.log(`my name is $&#123;this.name&#125;`) &#125;&#125; 只读修饰符通过readonly关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下： 12345678class Father&#123; readonly name:String constructor(name:String)&#123; this.name = name &#125;&#125;const father = new Father(&#x27;zouHuaLu&#x27;)father.name //会报错,提示&quot;无法分配到name，因为它是只读属性&quot; 静态属性这些属性存在于类本身上面而不是类的实例上，通过static进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示： 12345class Square &#123; static width = &#x27;100px&#x27;&#125;console.log(Square.width) // 100px 抽象类抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示： 123456abstract class Animal &#123; abstract makeSound(): void; move(): void &#123; console.log(&#x27;roaming the earch...&#x27;); &#125;&#125; 这种类并不能被实例化，通常需要我们创建子类去继承，如下： 1234567891011class Cat extends Animal &#123; makeSound() &#123; console.log(&#x27;miao miao&#x27;) &#125;&#125;const cat = new Cat()cat.makeSound() // miao miaocat.move() // roaming the earch... 三、应用场景除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在React 工程中是很常用的，如下： 1export default class Carousel extends React.Component&lt;Props, State&gt; &#123;&#125; 由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。 先声明一个类，这个类包含组件 props 所需的类型和初始值： 12345678910111213// props的类型export default class Props &#123; public children: Array&lt;React.ReactElement&lt;any&gt;&gt; | React.ReactElement&lt;any&gt; | never[] = [] public speed: number = 500 public height: number = 160 public animation: string = &#x27;easeInOutQuad&#x27; public isAuto: boolean = true public autoPlayInterval: number = 4500 public afterChange: () =&gt; &#123;&#125; public beforeChange: () =&gt; &#123;&#125; public selesctedColor: string public showDots: boolean = true&#125; 当我们需要传入 props 类型的时候直接将 Props 作为接口传入，此时 Props 的作用就是接口，而当需要我们设置defaultProps初始值的时候，我们只需要: 1public static defaultProps = new Props() Props 的实例就是 defaultProps 的初始值，这就是 class作为接口的实际应用，我们用一个 class 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量 参考文章 https://www.tslang.cn/docs/handbook/classes.html https://www.runoob.com/typescript/ts-class.html","categories":[{"name":"技术类-TypeScript","slug":"技术类-TypeScript","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://zouhualu.github.io/tags/TypeScript/"}]}],"categories":[{"name":"阅读","slug":"阅读","permalink":"https://zouhualu.github.io/categories/%E9%98%85%E8%AF%BB/"},{"name":"技术类","slug":"技术类","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB/"},{"name":"浮生一日","slug":"浮生一日","permalink":"https://zouhualu.github.io/categories/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/"},{"name":"技术类-TypeScript","slug":"技术类-TypeScript","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-TypeScript/"},{"name":"博客说明","slug":"博客说明","permalink":"https://zouhualu.github.io/categories/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}],"tags":[{"name":"人生的智慧","slug":"人生的智慧","permalink":"https://zouhualu.github.io/tags/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7/"},{"name":"叔本华","slug":"叔本华","permalink":"https://zouhualu.github.io/tags/%E5%8F%94%E6%9C%AC%E5%8D%8E/"},{"name":"哲学","slug":"哲学","permalink":"https://zouhualu.github.io/tags/%E5%93%B2%E5%AD%A6/"},{"name":"课程","slug":"课程","permalink":"https://zouhualu.github.io/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"浮生一日","slug":"浮生一日","permalink":"https://zouhualu.github.io/tags/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/"},{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://zouhualu.github.io/tags/TypeScript/"},{"name":"博客说明","slug":"博客说明","permalink":"https://zouhualu.github.io/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]}
{"meta":{"title":"走花路的长颈鹿","subtitle":"走花路的长颈鹿","description":"走花路的长颈鹿,博客","author":"走花路的长颈鹿","url":"https://zouhualu.github.io","root":"/"},"pages":[{"title":"about","date":"2021-09-07T07:20:04.000Z","updated":"2021-10-31T06:14:39.296Z","comments":true,"path":"about/index.html","permalink":"https://zouhualu.github.io/about/index.html","excerpt":"","text":"网速足够快或者翻墙的话会使本网站打开的更快一些，网站有缓存，第一次打开可能会比较慢，后面就好了。谢谢关注，请一键三连！！！"},{"title":"","date":"2021-10-31T06:14:39.296Z","updated":"2021-10-31T06:14:39.296Z","comments":false,"path":"baidu_verify_code-TmkkRxX4ps.html","permalink":"https://zouhualu.github.io/baidu_verify_code-TmkkRxX4ps.html","excerpt":"","text":"676194d86471561a70b8026338973ebc"}],"posts":[{"title":"装饰器的使用","slug":"装饰器的使用","date":"2021-12-23T06:37:11.000Z","updated":"2021-12-24T07:15:50.878Z","comments":true,"path":"20211223/装饰器的使用/","link":"","permalink":"https://zouhualu.github.io/20211223/%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"在 create-react-app 搭建的项目中使用装饰器 执行yarn eject命令，暴露出配置项 因为装饰器是新的提案，许多浏览器和 Node 环境并不支持，所以我们需要安装插件：@babel/plugin-proposal-decorators。使用create-react-app创建的项目自带这个插件，不过我们需要配置一下，找到package.json文件加入一下代码： 1234567&#123; &quot;babel&quot;: &#123; &quot;presets&quot;: [&quot;react-app&quot;], &quot;plugins&quot;: [[&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125;]] &#125;&#125; 另外 vscode 可能会提示你需要配置tsconfig或jsconfig文件，我们在项目根目录创建jsconfig.js，并写入： 12345&#123; &quot;compilerOptions&quot;: &#123; &quot;experimentalDecorators&quot;: true &#125;&#125; 这样就能愉快的在项目中使用装饰器了 装饰器的使用使用装饰器修饰类1234567891011121314151617//声明一个装饰器function fn(target) &#123; //这个函数的`target`指的就是装饰器要修饰的类 target.test = false;&#125;@fn //使用装饰器class Person &#123; //声明一个类&#125;@fnclass Dog &#123; //声明另一个类&#125;console.log(Person.test); //falseconsole.log(Dog.test); //false 可以看到Person类和Dog类下面多出了一个test属性，这就体现了装饰器的优点，无需更改类的内部代码也无需去继承就可以给类添加新功能 使用装饰器传参1234567891011121314151617@fn@fn2(5)class Person &#123;&#125;function fn(target) &#123; target.test = false;&#125;function fn2(value) &#123; return function (target) &#123; //这个函数的`target`指的就是装饰器要修饰的类 target.count = value; &#125;;&#125;console.log(Person.test);console.log(Person.count); 声明一个装饰器fn2，它接收一个值，并且返回一个函数，这个函数的target指的就是装饰器要修饰的类 使用装饰器添加实例属性123456789101112131415161718192021@fn@fn2(5)@fn3class Person &#123;&#125;function fn(target) &#123; target.test = false;&#125;function fn2(value) &#123; return function (target) &#123; target.count = value; &#125;;&#125;function fn3(target) &#123; target.prototype.foo = &quot;hhh&quot;; // target指的就是装饰的类，在类的原型对象上添加一个属性foo&#125;const test1 = new Person(); // new一个实例出来console.log(test1.foo); 实现一个混入 mixins 功能1234567891011121314151617181920// 实现一个mixins功能export function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list); &#125;;&#125;import &#123; mixins &#125; from &quot;./mixins&quot;;const Test = &#123; test() &#123; console.log(&quot;这是测试&quot;); &#125;,&#125;;@mixins(Test)class Myclass &#123;&#125;const newMyclass = new Myclass();newMyclass.test(); //这是测试 使用装饰器修饰类的成员12345678910111213141516171819202122232425262728293031323334353637@fn@fn2(5)@fn3class Person &#123; @readonly message = &quot;hello&quot;;&#125;function fn(target) &#123; target.test = false;&#125;function fn2(value) &#123; return function (target) &#123; target.count = value; &#125;;&#125;function fn3(target) &#123; target.prototype.foo = &quot;hhh&quot;;&#125;function readonly(target, name, descriptor) &#123; console.log(target); //目标类的原型对象 xxx.prototype console.log(name); // 被修饰的类的成员名称 console.log(descriptor); /*被修饰的类的成员的描述对象： configurable: 能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true enumerable: 是否被遍历，对象属性是否可通过for-in循环，flase为不可循环，默认值为true initializer: 对象属性的默认值，默认值为undefined writable: 对象属性是否可修改,flase为不可修改，默认值为true */ descriptor.writable = false;&#125;const test1 = new Person();test1.message = &quot;你好&quot;; 它接收三个参数，具体看以上代码注释","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"2021-12-23 TODO计划表","slug":"2021-12-23-每日TODO","date":"2021-12-23T06:00:54.000Z","updated":"2021-12-24T07:15:50.878Z","comments":true,"path":"20211223/2021-12-23-每日TODO/","link":"","permalink":"https://zouhualu.github.io/20211223/2021-12-23-%E6%AF%8F%E6%97%A5TODO/","excerpt":"","text":"2021-12-23 —— 2021-12-26 学习Mobx6 学习websocket 了解一下broadcast的机制","categories":[],"tags":[{"name":"TODO","slug":"TODO","permalink":"https://zouhualu.github.io/tags/TODO/"}]},{"title":"React搭配Mobx开发","slug":"React搭配Mobx开发","date":"2021-12-22T08:06:55.000Z","updated":"2021-12-24T07:15:50.877Z","comments":true,"path":"20211222/React搭配Mobx开发/","link":"","permalink":"https://zouhualu.github.io/20211222/React%E6%90%AD%E9%85%8DMobx%E5%BC%80%E5%8F%91/","excerpt":"","text":"今天试了一下React搭配Mobx开发，确实好用 先挖个坑，有空来填","categories":[{"name":"技术类-React","slug":"技术类-React","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://zouhualu.github.io/tags/React/"}]},{"title":"React笔记","slug":"React随笔","date":"2021-12-18T11:08:44.000Z","updated":"2021-12-27T14:43:14.620Z","comments":true,"path":"20211218/React随笔/","link":"","permalink":"https://zouhualu.github.io/20211218/React%E9%9A%8F%E7%AC%94/","excerpt":"","text":"React 中的thisReact 的官方文档里写的自定义的方法都需要用 bind 方法绑定一下才能使用，否则 this 会出现指向问题，那究竟是为什么呢？ 探讨一12345678910111213141516class Person &#123; constructor(props)&#123; this.state = &#123; ...... &#125; &#125; render()&#123; return &lt;div onClick=&#123;demo&#125;&gt;你好，DexterHwang&lt;/div&gt; &#125;&#125;function demo()&#123; console.log(this.state) // 会报错，注意此处的this&#125;ReactDom.render(&lt;Person /&gt;,document.getElementById(&#x27;app&#x27;)) React 中的 Babel 使用了严格模式，所以写的全局的 this指向的是undefined 而且 demo 方法并不写在 Person 类中，所以这个 this 也不会指向 Person 的实例对象 探讨二123456789101112131415161718class Person &#123; constructor(props)&#123; this.state = &#123; ...... &#125; &#125; render()&#123; return &lt;div onClick=&#123;demo&#125;&gt;你好，DexterHwang&lt;/div&gt; // 会报错，报错信息为：`demo is not defined`。`onClick=&#123;demo&#125;`是找不到 `demo` 方法的 // return &lt;div onClick=&#123;this.demo&#125;&gt;你好，DexterHwang&lt;/div&gt; // 这样写也会报错，因为并不是通过实例对象去调用demo方法。由于demo是作为onClick的回调，不是通过实例调用的，是直接调用。类中的方法默认开启了局部的严格模式，所以this值是undefined &#125; // demo方法在Person的原型对象(prototype)上，也就是在Person的实例对象的原型链上(_proto_) // 只有通过Person实例对象调用demo方法时，demo里面的this指向的就是Person的实例对象 demo()&#123; console.log(this) &#125;&#125;ReactDom.render(&lt;Person /&gt;,document.getElementById(&#x27;app&#x27;)) 我们看下面的例子 1234567891011121314class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; study() &#123; console.log(this); &#125;&#125;const p1 = new Person(&quot;DexterHwang&quot;, 18);p1.study(); //&#123;name:&#x27;DexterHwang&#x27;,age:18&#125;const x = p1.study;x(); // 输出undefined p1 的原型链上是可以找到 study 方法的，然后把 study 方法赋值给了 x。也就相当于在栈上多了一个指针指向了 study 方法，这下 x 就彻底和 p1 没有关系了 另外，再明确一点：_类中自定义的方法，都会启用局部严格模式_。也就是说 this 的值是 undefined 也就是说 x 执行后 this 值就是 undefined 验证：类中自定义的方法，都会启用局部严格模式 1234567891011function test() &#123; console.log(this);&#125;function test2() &#123; &quot;use strict&quot;; console.log(this);&#125;test(); // windowtest2(); // undefined 分析 this.demo = this.demo.bind(this)为什么用 bind()就可以解决 this 指向问题呢？ 12345678910111213141516171819 class Person &#123; constructor(props)&#123; this.state = &#123; ...... &#125; this.demo = this.demo.bind(this) &#125; render()&#123; return &lt;div onClick=&#123;this.demo&#125;&gt;你好，DexterHwang&lt;/div&gt; &#125; demo()&#123; console.log(this) &#125;&#125;ReactDom.render(&lt;Person /&gt;,document.getElementById(&#x27;app&#x27;))// 点击后会输出：Person&#123;...&#125; 分析this.demo = this.demo.bind(this) 等号右侧的第一个 this 指向的是实例对象，这个实例对象上有 demo 方法吗？有，但是实在原型链上的。 bind 方法做两件事： 将 this 牢牢的绑定到传入的参数上 返回一个新的函数 等号右边第二个 this，也就是传入的参数，这个 this 指的就是实例对象 这样的话返回了一个新的函数，而且这个函数牢牢的绑定到了实例对象上，并不需要去原型链上找了 再看等号左侧，将返回的新函数赋值给了 this，这个 this 也是 Person 实例对象，用相同的方法名接收一下 这样就可以使用了 我们这样再去看onClick=&#123;this.demo&#125;,这下再点击后执行的就是实例自身上的 demo 方法了。 2021-12-25 更新—— React17 对比新旧生命周期新的生命周期和旧的生命周期相比，即将废弃三个钩子：componentWillMount、componentWillUpdate、componentWillReceiveProps 新增了两个新的钩子：getDerivedStateFromProps、getSnapshotBeforeUpdate 剩下的都和之前的一样的 2021-12-16 更新—— React 配置代理单个代理可以直接在package.json文件中配置proxy 多个代理则需要新建一个setupProxy.js文件，配置如下： 1234567891011121314151617const proxy = require(&quot;http-proxy-middleware&quot;);module.exports = function (app) &#123; app.use( proxy(&quot;/api1&quot;, &#123; //遇见api1前缀的请求，就会触发这个代理配置 target: &quot;http://localhost:5000&quot;, // 请求转发给谁，也就是服务器地址 changeOrigin: true, // 控制服务器收到的请求头中Host的值，这里是localhost:5000 pathRewrite: &#123; &quot;^/api1&quot;: &quot;&quot; &#125;, // 重写请求路径 &#125;), proxy(&quot;/api2&quot;, &#123; target: &quot;http://localhost:5001&quot;, changeOrigin: true, pathRewrite: &#123; &quot;^/api2&quot;: &quot;&quot; &#125;, &#125;) );&#125;; create-react-app脚手架会自动找到setupProxy.js文件，并将配置加入到 webpack 中 2021-12-27 更新——React 路由原理靠的是 H5 推出的 history 上的 API 12345678910111213141516171819202122232425//路由跳转function push(path) &#123; history.push(path); return false;&#125;// 路由替换function replace(path) &#123; history.replace(path);&#125;// 路由回退function back() &#123; history.goBack();&#125;// 路由前进function forword() &#123; history.goForward();&#125;// 监听路由变化history.listen((location) =&gt; &#123; console.log(&quot;监听路由变化&quot;);&#125;);","categories":[{"name":"技术类-React","slug":"技术类-React","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-React/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"React","slug":"React","permalink":"https://zouhualu.github.io/tags/React/"}]},{"title":"JavaScript的同步与异步","slug":"JavaScript的同步与异步","date":"2021-12-14T07:10:10.000Z","updated":"2021-12-18T11:07:41.867Z","comments":true,"path":"20211214/JavaScript的同步与异步/","link":"","permalink":"https://zouhualu.github.io/20211214/JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/","excerpt":"","text":"更详细的可以点这里 异步JavaScript异步指两个或两个以上的对象或事件不同时存在或发生（或多个相关事物的发生无需等待其前一事物的完成） 同步JavaScript各方都实时（或者尽可能实时）地收取（而且必要的话也处理或者回复）信息的即时沟通方式，即为同步。 电话即为一个日常的例子：人们都倾向于在使用电话时即时地作出回应。 许多程序指令也是实时的：例如当输入一个算式时，除非编程人员有意为止，否则环境都会立即将结果反馈回来。 事件队列像promise这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境。 Promises 对比 callbackspromises与旧式callbacks有一些相似之处。它们本质上是一个返回的对象，您可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。 然而，Promise是专门为异步操作而设计的，与旧式回调相比具有许多优点: 您可以使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作。这种链接方式对回调来说要难得多，会使回调以混乱的“末日金字塔”告终。 (也称为回调地狱)。 Promise总是严格按照它们放置在事件队列中的顺序调用。 错误处理要好得多——所有的错误都由块末尾的一个.catch()块处理，而不是在“金字塔”的每一层单独处理。 异步代码的本质让我们研究一个示例，它进一步说明了异步代码的本质，展示了当我们不完全了解代码执行顺序以及将异步代码视为同步代码时可能发生的问题 12345678910111213141516console.log (&#x27;Starting&#x27;);let image;fetch(&#x27;coffee.jpg&#x27;).then((response) =&gt; &#123; console.log(&#x27;It worked :)&#x27;) return response.blob();&#125;).then((myBlob) =&gt; &#123; let objectURL = URL.createObjectURL(myBlob); image = document.createElement(&#x27;img&#x27;); image.src = objectURL; document.body.appendChild(image);&#125;).catch((error) =&gt; &#123; console.log(&#x27;There has been a problem with your fetch operation: &#x27; + error.message);&#125;);console.log (&#x27;All done!&#x27;); 浏览器将会执行代码，看见第一个console.log() 输出Starting ，然后创建image变量。 然后，它将移动到下一行并开始执行fetch()块，但是，因为fetch()是异步执行的，没有阻塞，所以在promise相关代码之后程序继续执行，从而到达最后的console.log()语句All done!并将其输出到控制台。 只有当fetch() 块完成运行返回结果给.then()，我们才最后看到第二个console.log()消息 It worked ;)。所以 这些消息可能以和你预期不同的顺序出现： Starting All done! It worked :) 如果你感到疑惑，考虑下面这个小例子： 1234567console.log(&quot;registering click handler&quot;);button.addEventListener(&#x27;click&#x27;, () =&gt; &#123; console.log(&quot;get click&quot;);&#125;);console.log(&quot;all done&quot;); 这在行为上非常相似——第一个和第三个console.log()消息将立即显示，但是第二个消息将被阻塞，直到有人单击鼠标按钮。前面的示例以相同的方式工作，只是在这种情况下，第二个消息在promise链上被阻塞，直到获取资源后再显示在屏幕上，而不是单击。 要查看实际情况，并将第三个console.log()调用更改为以下命令： 1console.log (&#x27;All done! &#x27; + image.src + &#x27;displayed.&#x27;); 此时控制台将会报错，而不会显示第三个 console.log 的信息： 1TypeError: image is undefined; can&#x27;t access its &quot;src&quot; property 这是因为：浏览器运行第三个console.log()的时候，fetch() 语句块还没有完成，因此image还没有赋值。 小结JavaScript是一种同步的、阻塞的、单线程的语言，在这种语言中，一次只能执行一个操作。 但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是异步地调用函数(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。 这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。 异步还是同步执行代码，取决于我们要做什么 同步-如果我们希望事情能够立即加载并发生。例如，当将一些用户定义的样式应用到一个页面时，您希望这些样式能够尽快被应用。 异步-如果我们正在运行一个需要时间的操作，比如查询数据库并使用结果填充模板，那么最好将该操作从主线程中移开使用异步完成任务。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"git rebase 用法","slug":"git-rebase-用法","date":"2021-12-02T09:16:28.000Z","updated":"2021-12-18T11:07:41.867Z","comments":true,"path":"20211202/git-rebase-用法/","link":"","permalink":"https://zouhualu.github.io/20211202/git-rebase-%E7%94%A8%E6%B3%95/","excerpt":"","text":"参考自此文章 以前提交代码一直是用命令行提交的 123456// 一把梭git pullgit add .git commit -m &#x27;xxxxxx&#x27;git push 在多人开发项目下，这样提交的话会有如下效果: 当很多人都把自己的分支合到主分支的时候，这样会显得主线很乱而且还会有自动生成的提交信息 所以提倡用git rebase 使用 rebase 和 merge 的基本原则 下游分支更新上游分支内容的时候使用 rebase 上游分支合并下游分支内容的时候使用 merge 更新当前分支的内容时一定要使用 –rebase 参数 例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 git rebase master 等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 git merge dev 实际开发中遇到操作当你和其他人在同一个分支开发时，在你提交的时候发现有人已经提交了一些东西上去了，你可以这样操作： git pull --rebase git push 你也可以使用vscode上下载的git插件来操作： 然后再push上去。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"create-react-app 搭建项目踩坑记录","slug":"create-react-app-搭建项目踩坑记录","date":"2021-11-29T11:44:25.000Z","updated":"2021-12-18T11:07:41.866Z","comments":true,"path":"20211129/create-react-app-搭建项目踩坑记录/","link":"","permalink":"https://zouhualu.github.io/20211129/create-react-app-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"中文说明搭建前端开发环境笔记由npx create-react-app articles_published_system创建的项目 后来漏掉了typescript支持，原本可以由命令npx create-react-app articles_published_system --template typescript可以直接创建支持ts的应用 后续要将ts添加到已有项目中，用以下命令： npm install --save typescript @types/node @types/react @types/react-dom @types/jest 项目中配置sass: 执行yarn add node-sass下载包（按理说执行npm install node-sass --save也应该有用，但是我这边报错了）。 报错如下： 我的vscode和node版本都是最新的 建议大家用yarn来安装项目 发现启动后sass会报错 解决办法：sass指定版本为^1.43.5，postcss-pxtorem为^5.1.1，不要安装node-sass了 前端生态配置仍然复杂 将样式文件后缀改为.scss并在tsx或者js文件中引入，项目会自动编译。 为了实现自适应，给项目配置postcss-pxtorem 执行yarn add lib-flexible postcss-pxtorem 在应用入口引入import &#39;lib-flexible&#39; 执行npm run eject可以打开create-react-app应用的配置文件 在config/webpack.config.js文件中配置postcss，位置及方法如下图： UI库使用antdesign 安装antd，yarn add antd 在App.css 中导入样式@import &#39;~antd/dist/antd.css&#39;，然后在组件中引入相应的ui组件就可以用了。 完~","categories":[{"name":"技术类-React","slug":"技术类-React","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://zouhualu.github.io/tags/React/"}]},{"title":"最近在忙什么","slug":"最近在忙什么","date":"2021-11-18T08:59:09.000Z","updated":"2021-12-18T11:07:41.866Z","comments":true,"path":"20211118/最近在忙什么/","link":"","permalink":"https://zouhualu.github.io/20211118/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%BF%99%E4%BB%80%E4%B9%88/","excerpt":"","text":"最近在做一个个人的全栈项目 前端技术栈是：Vite+Vue3+TypeScript+Scss 后端技术栈是：NodeJs+Express+MySQL 已经上线一部分功能,部署在阿里云上了 目前没啥功能。后续会慢慢完善优化 地址在：www.hjzouhualu.com","categories":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Node.js学习记录","slug":"Node-js学习记录","date":"2021-10-31T06:26:14.000Z","updated":"2021-12-18T11:10:28.717Z","comments":true,"path":"20211031/Node-js学习记录/","link":"","permalink":"https://zouhualu.github.io/20211031/Node-js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"使用 exports 从 Node.js 文件中公开功能两种方式： 第一种方式是将对象赋值给 module.exports（这是模块系统提供的对象），这会使文件只导出该对象: 12345678910const car = &#123; brand: &quot;Ford&quot;, model: &quot;Fiesta&quot;,&#125;;module.exports = car;//在另一个文件中const car = require(&quot;./car&quot;); 第二种方式是将要导出的对象添加为 exports 的属性。这种方式可以导出多个对象、函数或数据： 123456const car = &#123; brand: &quot;Ford&quot;, model: &quot;Fiesta&quot;,&#125;;exports.car = car; 或者直接 1234exports.car = &#123; brand: &quot;Ford&quot;, model: &quot;Fiesta&quot;,&#125;; 在另一个文件中，则通过引用导入的属性来使用它： 12const items = require(&quot;./items&quot;);items.car; 或 1const car = require(&quot;./items&quot;).car; module.exports 和 export 之间有什么区别？ 前者公开了它指向的对象。 后者公开了它指向的对象的属性。 package.json 指南package.json 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 npm 和 yarn 存储所有已安装软件包的名称和版本的地方。 对于应用程序，package.json 文件中的内容没有固定的要求。 唯一的要求是必须遵守 JSON 格式，否则，尝试以编程的方式访问其属性的程序则无法读取它。 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#123; &quot;name&quot;: &quot;test-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;A Vue.js project&quot;, &quot;main&quot;: &quot;src/main.js&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;, &quot;test&quot;: &quot;npm run unit&quot;, &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit&quot;, &quot;build&quot;: &quot;node build/build.js&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.5.2&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;^7.1.2&quot;, &quot;babel-core&quot;: &quot;^6.22.1&quot;, &quot;babel-eslint&quot;: &quot;^8.2.1&quot;, &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;, &quot;babel-jest&quot;: &quot;^21.0.2&quot;, &quot;babel-loader&quot;: &quot;^7.1.1&quot;, &quot;babel-plugin-dynamic-import-node&quot;: &quot;^1.2.0&quot;, &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;, &quot;babel-plugin-transform-es2015-modules-commonjs&quot;: &quot;^6.26.0&quot;, &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;, &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.5.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;, &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;, &quot;chalk&quot;: &quot;^2.0.1&quot;, &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;, &quot;css-loader&quot;: &quot;^0.28.0&quot;, &quot;eslint&quot;: &quot;^4.15.0&quot;, &quot;eslint-config-airbnb-base&quot;: &quot;^11.3.0&quot;, &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;, &quot;eslint-import-resolver-webpack&quot;: &quot;^0.8.3&quot;, &quot;eslint-loader&quot;: &quot;^1.7.1&quot;, &quot;eslint-plugin-import&quot;: &quot;^2.7.0&quot;, &quot;eslint-plugin-vue&quot;: &quot;^4.0.0&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;, &quot;file-loader&quot;: &quot;^1.1.4&quot;, &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;, &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;, &quot;jest&quot;: &quot;^22.0.4&quot;, &quot;jest-serializer-vue&quot;: &quot;^0.3.0&quot;, &quot;node-notifier&quot;: &quot;^5.1.2&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;ora&quot;: &quot;^1.2.0&quot;, &quot;portfinder&quot;: &quot;^1.0.13&quot;, &quot;postcss-import&quot;: &quot;^11.0.0&quot;, &quot;postcss-loader&quot;: &quot;^2.0.8&quot;, &quot;postcss-url&quot;: &quot;^7.2.1&quot;, &quot;rimraf&quot;: &quot;^2.6.0&quot;, &quot;semver&quot;: &quot;^5.3.0&quot;, &quot;shelljs&quot;: &quot;^0.7.6&quot;, &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.1&quot;, &quot;url-loader&quot;: &quot;^0.5.8&quot;, &quot;vue-jest&quot;: &quot;^1.0.2&quot;, &quot;vue-loader&quot;: &quot;^13.3.0&quot;, &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;, &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;, &quot;webpack&quot;: &quot;^3.6.0&quot;, &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;, &quot;webpack-merge&quot;: &quot;^4.1.0&quot; &#125;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;= 6.0.0&quot;, &quot;npm&quot;: &quot;&gt;= 3.0.0&quot; &#125;, &quot;browserslist&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]&#125; 这里有很多东西： version 表明了当前的版本。 name 设置了应用程序/软件包的名称。 description 是应用程序/软件包的简短描述。 main 设置了应用程序的入口点。 private 如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。 scripts 定义了一组可以运行的 node 脚本。 dependencies 设置了作为依赖安装的 npm 软件包的列表。 devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。 engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。 browserslist 用于告知要支持哪些浏览器（及其版本）。以上所有的这些属性都可被 npm 或其他工具使用。 package-lock.json 文件该文件旨在跟踪被安装的每个软件包的确切版本，以便产品可以以相同的方式被 100％ 复制（即使软件包的维护者更新了软件包）。 npm 依赖与开发依赖当使用 npm install &lt;package-name&gt; 安装 npm 软件包时，是将其安装为依赖项。 该软件包会被自动地列出在 package.json 文件中的 dependencies 列表下（在 npm 5 之前：必须手动指定 --save）。 当添加了 -D 或 --save-dev 标志时，则会将其安装为开发依赖项（会被添加到 devDependencies 列表）。 开发依赖是仅用于开发的程序包，在生产环境中并不需要。 例如测试的软件包、webpack 或 Babel。 当投入生产环境时，如果输入 npm install 且该文件夹包含 package.json 文件时，则会安装它们，因为 npm 会假定这是开发部署。 Node.js 包运行器 npxs 轻松地运行本地命令 Node.js 开发者过去通常将大多数可执行命令发布为全局的软件包，以使它们处于路径中且可被立即地执行。 运行 npx commandname 会自动地在项目的 node_modules 文件夹中找到命令的正确引用，而无需知道确切的路径，也不需要在全局和用户路径中安装软件包。 无需安装的命令执行 npx 的另一个重要的特性是，无需先安装命令即可运行命令。 使用不同的 Node.js 版本运行代码 直接从 URL 运行任意代码片段 Node.js 事件循环原文链接：Node.js 事件循环 一个简单的事件循环的阐释12345678910111213141516const bar = () =&gt; console.log(&quot;bar&quot;);const baz = () =&gt; console.log(&quot;baz&quot;);const foo = () =&gt; &#123; console.log(&quot;foo&quot;); bar(); baz();&#125;;foo();// 输出// foo// bar// baz 当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 bar()，然后调用 baz()。 此时，调用堆栈如下所示： 入队函数执行123456789101112131415161718const bar = () =&gt; console.log(&quot;bar&quot;);const baz = () =&gt; console.log(&quot;baz&quot;);const foo = () =&gt; &#123; console.log(&quot;foo&quot;); setTimeout(bar, 0); baz();&#125;;foo();/** * 打印输出： * foo * baz * bar */ 当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 setTimeout，将 bar 作为参数传入，并传入 0 作为定时器指示它尽快运行。 然后调用 baz()。 调用堆栈如图： 执行顺序是： 为什么会这样呢？ 消息队列当调用 setTimeout() 时，浏览器或 Node.js 会启动定时器。 当定时器到期时（在此示例中会立即到期，因为将超时值设为 0），则回调函数会被放入“消息队列”中。 在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 onLoad 这样的 DOM 事件也如此。 事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。 我们不必等待诸如 setTimeout、fetch、或其他的函数来完成它们自身的工作，因为它们是由浏览器提供的，并且位于它们自身的线程中。 例如，如果将 setTimeout 的超时设置为 2 秒，但不必等待 2 秒，等待发生在其他地方。 ES6 作业队列ECMAScript 2015 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。 在当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。 有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。 例子： 123456789101112131415161718192021const bar = () =&gt; console.log(&#x27;bar&#x27;)const baz = () =&gt; console.log(&#x27;baz&#x27;)const foo = () =&gt; &#123; console.log(&#x27;foo&#x27;) setTimeout(bar, 0) new Promise((resolve, reject) =&gt; resolve(&#x27;应该在 baz 之后、bar 之前&#x27;) ).then(resolve =&gt; console.log(resolve)) baz()&#125;foo()/** * 输出： * foo * baz * 应该在 baz 之后、bar 之前 * bar * / 这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。 了解 process.nextTick()当尝试了解 Node.js 事件循环时，其中一个重要的部分就是 process.nextTick()。 每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。 当将一个函数传给 process.nextTick() 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数 事件循环正在忙于处理当前的函数代码。 当该操作结束时，JS 引擎会运行在该操作期间传给 nextTick 调用的所有函数。 这是可以告诉 JS 引擎异步地（在当前函数之后）处理函数的方式，但是尽快执行而不是将其排入队列。 调用 setTimeout(() =&gt; {}, 0) 会在下一个滴答结束时执行该函数，比使用 nextTick()（其会优先执行该调用并在下一个滴答开始之前执行该函数）晚得多。 也就是说在当前调用堆栈的执行完成后就开始执行process.nextTick()里面的函数 了解 setImmediate()作为 setImmediate() 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调。 setImmediate() 与 setTimeout(() =&gt; {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？传给 process.nextTick() 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 setTimeout 和 setImmediate 之前执行。 延迟 0 毫秒的 setTimeout() 回调与 setImmediate() 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。","categories":[{"name":"技术类-Node.js","slug":"技术类-Node-js","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://zouhualu.github.io/tags/Node-js/"}]},{"title":"call,apply和bind","slug":"call-apply和bind","date":"2021-10-21T03:18:44.000Z","updated":"2021-10-31T06:14:39.296Z","comments":true,"path":"20211021/call-apply和bind/","link":"","permalink":"https://zouhualu.github.io/20211021/call-apply%E5%92%8Cbind/","excerpt":"","text":"call，apply和bind都是用来改变this的指向，但是他们在使用和功能上各有区别。 call() 方法call() 方法的作用call() 方法的作用：可以调用一个函数，与此同时，它还可以改变这个函数内部的 this 指向。 call() 方法的另一个应用：可以实现继承。之所以能实现继承，其实是利用了上面的作用。 语法1fn1.call(想要将this指向哪里, 函数实参1, 函数实参2); 备注：第一个参数中，如果不需要改变 this 指向，则传 null。 call() 方法举例举例 1、通过 call() 调用函数： 123456789const obj1 = &#123; nickName: &#x27;走花鹿&#x27;, age: 26,&#125;;function fn1() &#123; console.log(this); console.log(this.nickName);&#125;fn1.call(this); // this的指向并没有被改变，此时相当于 fn1(); 上方代码的打印结果： 12windowundefined 上面的代码，跟普通的函数调用 fn1() 没有区别。 举例 2、通过 call() 改变 this 指向： 123456789101112var obj1 = &#123; nickName: &#x27;走花鹿&#x27;, age: 26,&#125;;function fn1(a, b) &#123; console.log(this); console.log(this.nickName); console.log(a + b);&#125;fn1.call(obj1, 2, 4); // 先将 this 指向 obj1，然后执行 fn1() 函数 上方代码的打印结果： 123obj1走花鹿6 举例 3、通过 call() 实现继承： 1234567891011121314// 给 Father 增加 name 和 age 属性function Father(myName, myAge) &#123; this.name = myName; this.age = myAge;&#125;function Son(myName, myAge) &#123; // 【下面这一行，重要代码】 // 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承 Father.call(this, myName, myAge);&#125;const son1 = new Son(&#x27;走花鹿&#x27;, 26);console.log(JSON.stringify(son1)); 上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。 打印结果： 1&#123;&quot;myName&quot;:&quot;走花鹿&quot;,&quot;myAge&quot;:26&#125; apply() 方法apply() 方法的作用apply() 方法的作用：可以调用一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。 apply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。 语法1fn1.apply(想要将this指向哪里, [函数实参1, 函数实参2]); 备注：第一个参数中，如果不需要改变 this 指向，则传 null。 到这里可以看出， call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。 apply() 方法举例举例、通过 apply() 改变 this 指向： 123456789101112var obj1 = &#123; nickName: &#x27;走花鹿&#x27;, age: 26,&#125;;function fn1(a) &#123; console.log(this); console.log(this.nickName); console.log(a);&#125;fn1.apply(obj1, [&#x27;hello&#x27;]); // 先将 this 指向 obj1，然后执行 fn1() 函数 注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。 打印结果： 123obj1走花鹿hello apply() 方法的巧妙应用：求数组的最大值我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？ 虽然数组里没有获取最大值的方法，但是数值里面有 Math.max(数字1，数字2，数字3) 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。 举例：求数组中多个元素的最大值： 12345678const arr1 = [3, 7, 10, 8];// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。const maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值console.log(maxValue);const minValue = Math.min.apply(Math, arr1); // 求数组 arr1 中元素的最小值console.log(minValue); 打印结果： 12103 bind() 方法bind() 方法的作用bind() 方法不会调用函数，但是可以改变函数内部的 this 指向。 把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。 语法 1新函数 = fn1.bind(想要将this指向哪里, 函数实参1, 函数实参2); 参数： 第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。 其他参数：fn1 函数的实参。 解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Array数组的一些发现","slug":"Array数组的一些发现","date":"2021-10-20T05:49:22.000Z","updated":"2021-10-31T06:14:39.296Z","comments":true,"path":"20211020/Array数组的一些发现/","link":"","permalink":"https://zouhualu.github.io/20211020/Array%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%91%E7%8E%B0/","excerpt":"","text":"今天对一些元素都是纯数字的数组做forEach遍历操作，发现无法改变原数组，查找了一些资料发现，forEach只能处理数组中的引用类型，元素为基础类型的需要另外的写法。如下： 123456789101112131415161718192021let arr = [1, 2, 3, 4, 5]let arr1 = [1, 2, 3, 4, 5]let arr2 = [&#123;a:1,b:2&#125;]// 元素为基础类型number，原数组不变arr.forEach(item =&gt; &#123; item += 1&#125;)// 这种写法可行arr1.forEach((item, index) =&gt; &#123; arr1[index] += 1&#125;)// 元素为引用类型的，原数组会改变arr2.forEach(item=&gt;&#123; item.a = 66&#125;)console.log(arr);console.log(arr1);console.log(arr2); 这主要是和计算机的堆栈有关。基础类型是存储在栈中，forEach中得到item也是存储于栈中，所以它就和数组中的元素毫无关系了；而对象是存储于堆中，遍历的时候item虽然在栈中但是它的指针会指向堆中的位置，所以可以直接修改原数组。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"}]},{"title":"JavaScript事件循环","slug":"JavaScript事件循环","date":"2021-10-14T03:17:45.000Z","updated":"2021-10-31T06:14:39.295Z","comments":true,"path":"20211014/JavaScript事件循环/","link":"","permalink":"https://zouhualu.github.io/20211014/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"这一篇讲的也特别清楚，建议看看：这一次，彻底弄懂 JavaScript 执行机制 一、是什么JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事 为什么要这么设计，跟JavaScript的应用场景有关 JavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除 DOM ，另一个添加 DOM，此时浏览器该如何处理？ 为了解决单线程运行阻塞问题，JavaScript用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop） 事件循环（Event Loop）在JavaScript中，所有的任务都可以分为 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行 异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等 同步任务与异步任务的运行流程图如下： 从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环 二、宏任务与微任务如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子： 1234567891011121314console.log(1)setTimeout(()=&gt;&#123; console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123; console.log(&#x27;new Promise&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then&#x27;)&#125;)console.log(3) 如果按照上面流程图来分析代码，我们会得到下面的执行步骤： console.log(1)，同步任务，主线程中执行 setTimeout() ，异步任务，放到 Event Table，0 毫秒后console.log(2)回调推入 Event Queue 中 new Promise ，同步任务，主线程直接执行 .then ，异步任务，放到 Event Table console.log(3)，同步任务，主线程执行 所以按照分析，它的结果应该是 1 =&gt; &#39;new Promise&#39; =&gt; 3 =&gt; 2 =&gt; &#39;then&#39; 但是实际结果是：1=&gt;&#39;new Promise&#39;=&gt; 3 =&gt; &#39;then&#39; =&gt; 2 出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取 例子中 setTimeout回调事件是先进入队列中的，按理说应该先于 .then 中的执行，但是结果却偏偏相反 原因在于异步任务还可以细分为微任务与宏任务 微任务一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前 常见的微任务有： Promise.then MutaionObserver Object.observe（已废弃；Proxy 对象替代） process.nextTick（Node.js） 宏任务宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合 常见的宏任务有： script (可以理解为外层同步代码) setTimeout/setInterval UI rendering/UI事件 postMessage、MessageChannel setImmediate、I/O（Node.js） 这时候，事件循环，宏任务，微任务的关系如图所示 按照这个流程，它的执行机制是： 执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中 当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完 回到上面的题目 1234567891011console.log(1)setTimeout(()=&gt;&#123; console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123; console.log(&#x27;new Promise&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then&#x27;)&#125;)console.log(3) 流程如下 1234567// 遇到 console.log(1) ，直接打印 1// 遇到定时器，属于新的宏任务，留着后面执行// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;// .then 属于微任务，放入微任务队列，后面再执行// 遇到 console.log(3) 直接打印 3// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2 三、async与awaitasync 是异步的意思，await则可以理解为等待 放到一起可以理解async就是用来声明一个异步方法，而 await是用来等待异步方法执行 asyncasync函数返回一个promise对象，下面两种方法是等效的 12345678function f() &#123; return Promise.resolve(&#x27;TEST&#x27;);&#125;// asyncF is equivalent to f!async function asyncF() &#123; return &#x27;TEST&#x27;;&#125; await正常情况下，await命令后面是一个 Promise对象，返回该对象的结果。如果不是 Promise对象，就直接返回对应的值 123456async function f()&#123; // 等同于 // return 123 return await 123&#125;f().then(v =&gt; console.log(v)) // 123 不管await后面跟着的是什么，await都会阻塞后面的代码 123456789101112async function fn1 ()&#123; console.log(1) await fn2() console.log(2) // 阻塞&#125;async function fn2 ()&#123; console.log(&#x27;fn2&#x27;)&#125;fn1()console.log(3) 上面的例子中，await 会阻塞下面的代码（即加入微任务队列），先执行 async外面的同步代码，同步代码执行完，再回到 async 函数中，再执行之前阻塞的代码 所以上述输出结果为：1，fn2，3，2 四、流程分析通过对上面的了解，我们对JavaScript对各种场景的执行顺序有了大致的了解 这里直接上代码： 1234567891011121314151617181920async function async1() &#123; console.log(&#x27;async1 start&#x27;) await async2() console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123; console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;)setTimeout(function () &#123; console.log(&#x27;settimeout&#x27;)&#125;)async1()new Promise(function (resolve) &#123; console.log(&#x27;promise1&#x27;) resolve()&#125;).then(function () &#123; console.log(&#x27;promise2&#x27;)&#125;)console.log(&#x27;script end&#x27;) 分析过程： 执行整段代码，遇到 console.log(&#39;script start&#39;) 直接打印结果，输出 script start 遇到定时器了，它是宏任务，先放着不执行 遇到 async1()，执行 async1 函数，先打印 async1 start，下面遇到await怎么办？先执行 async2，打印 async2，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码 跳到 new Promise 这里，直接执行，打印 promise1，下面遇到 .then()，它是微任务，放到微任务列表等待执行 最后一行直接打印 script end，现在同步代码执行完了，开始执行微任务，即 await下面的代码，打印 async1 end 继续执行下一个微任务，即执行 then 的回调，打印 promise2 上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 settimeout 所以最后的结果是：script start、async1 start、async2、promise1、script end、async1 end、promise2、settimeout","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"深入理解javascript之typeof和instanceof","slug":"深入理解javascript之typeof和instanceof","date":"2021-10-13T08:41:28.000Z","updated":"2021-10-31T06:14:39.295Z","comments":true,"path":"20211013/深入理解javascript之typeof和instanceof/","link":"","permalink":"https://zouhualu.github.io/20211013/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E4%B9%8Btypeof%E5%92%8Cinstanceof/","excerpt":"","text":"typeoftypeof方法返回一个字符串，来表示数据的类型。 各个数据类型对应typeof的值： 数据类型 Type Undefined “undefined” Null “object” Boolean “boolean” Number “number” String “string” Symbol “symbol” 宿主对象(JS环境提供的，比如浏览器) Implementation-dependent 函数对象Function “function” 任何其他对象Object “object” 下面是代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Numberstypeof 37 === &#x27;number&#x27;;typeof 3.14 === &#x27;number&#x27;;typeof Math.LN2 === &#x27;number&#x27;;typeof Infinity === &#x27;number&#x27;;typeof NaN === &#x27;number&#x27;; // 尽管NaN是&quot;Not-A-Number&quot;的缩写,意思是&quot;不是一个数字&quot;typeof Number(1) === &#x27;number&#x27;; // 不要这样使用!// Stringstypeof &quot;&quot; === &#x27;string&#x27;;typeof &quot;bla&quot; === &#x27;string&#x27;;typeof (typeof 1) === &#x27;string&#x27;; // typeof返回的肯定是一个字符串typeof String(&quot;abc&quot;) === &#x27;string&#x27;; // 不要这样使用!// Booleanstypeof true === &#x27;boolean&#x27;;typeof false === &#x27;boolean&#x27;;typeof Boolean(true) === &#x27;boolean&#x27;; // 不要这样使用!// Symbolstypeof Symbol() === &#x27;symbol&#x27;;typeof Symbol(&#x27;foo&#x27;) === &#x27;symbol&#x27;;typeof Symbol.iterator === &#x27;symbol&#x27;;// Undefinedtypeof undefined === &#x27;undefined&#x27;;typeof blabla === &#x27;undefined&#x27;; // 一个未定义的变量,或者一个定义了却未赋初值的变量// Objectstypeof &#123;a:1&#125; === &#x27;object&#x27;;// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型typeof [1, 2, 4] === &#x27;object&#x27;;typeof new Date() === &#x27;object&#x27;;// 下面的容易令人迷惑，不要这样使用！typeof new Boolean(true) === &#x27;object&#x27;;typeof new Number(1) ==== &#x27;object&#x27;;typeof new String(&quot;abc&quot;) === &#x27;object&#x27;;// 函数typeof function()&#123;&#125; === &#x27;function&#x27;;typeof Math.sin === &#x27;function&#x27;; 发现typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象hj的typeof返回值都是object instanceofinstanceof运算符可以用来判断某个构造函数的prototype属性是否存在于另外一个要检测对象的原型链上。 1234567891011121314151617181920212223242526// 定义构造函数function C()&#123;&#125; function D()&#123;&#125; var o = new C();// true，因为 Object.getPrototypeOf(o) === C.prototypeo instanceof C; // false，因为 D.prototype不在o的原型链上o instanceof D; o instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回trueC.prototype instanceof Object // true,同上C.prototype = &#123;&#125;;var o2 = new C();o2 instanceof C; // trueo instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.D.prototype = new C(); // 继承var o3 = new D();o3 instanceof D; // trueo3 instanceof C; // true","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"互联网是如何运作的","slug":"互联网是如何运作的","date":"2021-10-07T03:04:56.000Z","updated":"2021-10-31T06:14:39.295Z","comments":true,"path":"20211007/互联网是如何运作的/","link":"","permalink":"https://zouhualu.github.io/20211007/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/","excerpt":"","text":"原文：互联网是如何运作的 以下是我的总结,更好的学习建议阅读原文。 介绍互联网所有的传输都通过TCP/IP协议族来传输，TCP/IP是面向连接的可靠字节流服务协议 TCP/IP协议栈您的计算机已连接到 Internet 并具有唯一的地址。它如何与连接到 Internet 的其他计算机“交谈”？ 这里应该有一个例子：假设您的 IP 地址是 1.2.3.4，并且您想向计算机 5.6.7.8 发送一条消息。您要发送的消息是“Hello computer 5.6.7.8!”。显然，消息必须通过将您的计算机连接到 Internet 的任何类型的线路传输。假设您已从家里拨入您的 ISP，并且消息必须通过电话线传输。必须将消息从字母文本翻译成电子信号，通过互联网传输，然后再翻译回字母文本。 这是如何实现的？通过使用协议栈。每台计算机都需要一台在 Internet 上进行通信，它通常内置于计算机的操作系统（即 Windows、Unix 等）中。由于使用了两种主要的通信协议，Internet 上使用的协议栈被称为 TCP/IP 协议栈。TCP/IP 堆栈如下所示： 应用层：提供特定于应用程序的协议 HTTP FTP IMAP(邮件) 网络控制层(TCP)：发送数据包到计算机上使用特定的端口号的应用程序 网络层(IP)：使用IP地址将数据包发送到特定的计算 链路层：将二进制数据包与网络信号相互之间转换（例如以太网网卡、电话线调制解调器等） HTTPHTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中 TCP 层的顶部，并被特定应用程序用于相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。 HTTP是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送对 Web 元素（例如网页和图像）的请求。请求被服务器服务后，客户端和服务器之间通过 Internet 的连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端发出 HTTP 请求之前，必须建立到服务器的新连接。 当您在 Web 浏览器中键入 URL 时，会发生以下情况： 如果 URL 包含域名，则浏览器首先连接到域名服务器并为 Web 服务器检索相应的 IP 地址。 Web 浏览器连接到 Web 服务器并为所需的网页发送 HTTP 请求（通过协议栈）。 Web 服务器接收请求并检查所需页面。如果页面存在，则 Web 服务器发送它。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。（404 的意思是“找不到页面”，任何浏览过网络的人都可能知道。） Web 浏览器接收回页面并关闭连接。 然后浏览器解析页面并查找完成网页所需的其他页面元素。这些通常包括图像、小程序等。 对于每个需要的元素，浏览器会为每个元素向服务器发出额外的连接和 HTTP 请求。 当浏览器加载完所有图像、小程序等后，页面将完全加载到浏览器窗口中。 TCP（传输控制协议）在协议栈的应用层之下是TCP层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）会沿堆栈向下传递到 TCP 层。TCP 负责将应用程序协议路由到目标计算机上的正确应用程序。 为此，使用端口号。端口可以​​被认为是每台计算机上的独立通道。例如，您可以在阅读电子邮件时上网。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上时，TCP 层根据端口号决定哪个应用程序接收数据包。TCP 是这样工作的： 当 TCP 层从上面接收到应用层协议数据时，它会将其分段为可管理的“块”，然后将带有特定 TCP 信息的 TCP 标头添加到每个“块”。TCP 头中包含的信息包括数据需要发送到的应用程序的端口号。 当 TCP 层接收到来自其下方 IP 层的数据包时，TCP 层会从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。 这就是 TCP 将通过协议栈移动的数据路由到正确应用程序的方式。 TCP 不是文本协议。TCP 是面向连接的、可靠的字节流服务。面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于收到的每个数据包，都会向发送方发送确认以确认交付。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。tcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功 IP（互联网协议）与 TCP 不同，IP 是一种不可靠的无连接协议。IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 IP 的工作也是将数据包发送和路由到其他计算机。IP 数据包是独立的实体，可能无序到达或根本没有到达。TCP 的工作是确保数据包到达并以正确的顺序。IP 与 TCP 的唯一共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据。 IP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP Ip是一种协议 有两种标准 IPv4 2^32次方和IPv6 2^128 TCP传输的质量和顺序当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送 #网络传输 个人电脑 猫（调制解调器） local ISP 互联网服务提供商 regional ISP 经过多个主干网络 NSP 网络服务提供商 大型网络 卖带宽给ISP NAP 每个NSP连接到至少三个网络访问点 ISP NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。 DNS服务存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zouhualu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zouhualu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"leetcode每日算法（2021-09-27）","slug":"leetcode每日算法（2021-09-27）","date":"2021-09-27T03:06:43.000Z","updated":"2021-10-31T06:14:39.295Z","comments":true,"path":"20210927/leetcode每日算法（2021-09-27）/","link":"","permalink":"https://zouhualu.github.io/20210927/leetcode%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%EF%BC%882021-09-27%EF%BC%89/","excerpt":"","text":"1.两数之和 解题我首先想到的是暴力解法，就是对数组嵌套循环（时间复杂度是 O(n²)）：肯定有更好的办法看到评论区有人说用逆向解法，用target减去数组中的一个数，然后判断得到的结果是否在数组中 12345678910var twoSum = function(nums, target) &#123; map = new Map() for(let i = 0; i &lt; nums.length; i++) &#123; x = target - nums[i] if(map.has(x)) &#123; return [map.get(x),i] &#125; map.set(nums[i],i) &#125;&#125;; 12345678910var twoSum = function (nums, target) &#123; let hash = &#123;&#125;; for (let i = 0; i &lt; nums.length; i++) &#123; if (hash[target - nums[i]] !== undefined) &#123; return [i, hash[target - nums[i]]]; &#125; hash[nums[i]] = i; &#125; return [];&#125;;","categories":[{"name":"算法类","slug":"算法类","permalink":"https://zouhualu.github.io/categories/%E7%AE%97%E6%B3%95%E7%B1%BB/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zouhualu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://zouhualu.github.io/tags/leetcode/"}]},{"title":"日常-最爱的电影","slug":"浮生一日-最爱的电影","date":"2021-09-25T10:07:53.000Z","updated":"2021-12-18T11:07:41.866Z","comments":true,"path":"20210925/浮生一日-最爱的电影/","link":"","permalink":"https://zouhualu.github.io/20210925/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5-%E6%9C%80%E7%88%B1%E7%9A%84%E7%94%B5%E5%BD%B1/","excerpt":"","text":"今天重温了电影《第六感》，一部披着灵异外皮的心灵治愈电影。 有些电影无论第几遍看还是让人感动","categories":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"栈与队列的理解以及应用场景","slug":"栈与队列的理解以及应用场景","date":"2021-09-23T06:00:28.000Z","updated":"2021-10-31T06:14:39.294Z","comments":true,"path":"20210923/栈与队列的理解以及应用场景/","link":"","permalink":"https://zouhualu.github.io/20210923/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"1.栈栈（stack）又名堆栈，它是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表。 表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈 所以其按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用 实现一个栈： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Stack &#123; constructor() &#123; this.items = []; &#125; /** * 添加一个（或几个）新元素到栈顶 * @param &#123;*&#125; element 新元素 */ push(element) &#123; this.items.push(element) &#125; /** * 移除栈顶的元素，同时返回被移除的元素 */ pop() &#123; return this.items.pop() &#125; /** * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它） */ peek() &#123; return this.items[this.items.length - 1] &#125; /** * 如果栈里没有任何元素就返回true,否则返回false */ isEmpty() &#123; return this.items.length === 0 &#125; /** * 移除栈里的所有元素 */ clear() &#123; this.items = [] &#125; /** * 返回栈里的元素个数。这个方法和数组的length属性很类似 */ size() &#123; return this.items.length &#125;&#125; 关于栈的操作主要的方法如下： push：入栈操作 pop：出栈操作 二.队列跟栈十分相似，队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。 进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列 在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出 简单实现一个队列，如下： 123456789101112131415class Queue &#123; constructor() &#123; this.list = [] this.frontIndex = 0 this.tailIndex = 0 &#125; enqueue(item) &#123; this.list[this.tailIndex++] = item &#125; unqueue() &#123; const item = this.list[this.frontIndex] this.frontIndex++ return item &#125;&#125; 三.应用场景栈借助栈的先进后出的特性，可以简单实现一个逆序输出的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出 包括编译器的在对输入的语法进行分析的时候，例如”()”、”{}”、”[]”这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错 包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值 生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型 队列当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题 队列的使用广泛应用在广度优先搜索中，例如层次遍历一个二叉树的节点值 生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型 参考文献 https://baike.baidu.com/item/%E6%A0%88/12808149 https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zouhualu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zouhualu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue3(一)","slug":"Vue3-一","date":"2021-09-16T09:39:17.000Z","updated":"2021-10-31T06:14:39.295Z","comments":true,"path":"20210916/Vue3-一/","link":"","permalink":"https://zouhualu.github.io/20210916/Vue3-%E4%B8%80/","excerpt":"","text":"今天上课内容是 vue 3,共有两节课，一节讲基础，一节讲原理。 以下是课堂笔记：","categories":[{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://zouhualu.github.io/tags/Vue3/"}]},{"title":"通读vue3文档记录","slug":"vue3文档记录","date":"2021-09-15T11:03:11.000Z","updated":"2021-10-31T06:14:39.293Z","comments":true,"path":"20210915/vue3文档记录/","link":"","permalink":"https://zouhualu.github.io/20210915/vue3%E6%96%87%E6%A1%A3%E8%AE%B0%E5%BD%95/","excerpt":"","text":"之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是Object.defineProperty()，vue3用的是Proxy。vue3还新增了组合式API等等。 这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。 持续更新ing 应用&amp;组件实例应用实例每个 Vue 应用都是通过用 createApp 函数创建一个新的应用实例开始的： 1const app = Vue.createApp(&#123; /* 选项 */ &#125;) 该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子： 1234const app = Vue.createApp(&#123;&#125;)app.component(&#x27;SearchInput&#x27;, SearchInputComponent)app.directive(&#x27;focus&#x27;, FocusDirective)app.use(LocalePlugin) 应用实例暴露的大多数方法都会返回该同一实例，允许链式： 1234Vue.createApp(&#123;&#125;) .component(&#x27;SearchInput&#x27;, SearchInputComponent) .directive(&#x27;focus&#x27;, FocusDirective) .use(LocalePlugin) 根组件实例传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。 一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;，我们应该传递 #app： 123const RootComponent = &#123; /* 选项 */ &#125;const app = Vue.createApp(RootComponent)const vm = app.mount(&#x27;#app&#x27;) 与大多数应用方法不同的是，mount 不返回应用本身。相反，它返回的是根组件实例。 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。 计算属性&amp;侦听器计算属性缓存 vs 方法你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果： 1&lt;p&gt;&#123;&#123; calculateBooksMessage() &#125;&#125;&lt;/p&gt; 123456// 在组件中methods: &#123; calculateBooksMessage() &#123; return this.author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;&#125; 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要author.books 还没有发生改变，多次访问 publishedBookMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 这也同样意味着下面的计算属性将不再更新，因为 Date.now () 不是响应式依赖： 12345computed: &#123; now() &#123; return Date.now() &#125;&#125; 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 list，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 list。如果没有缓存，我们将不可避免的多次执行 list 的 getter！如果你不希望有缓存，请用 method 来替代 以下为2021.09.16更新计算属性的 Setter计算属性默认只有 getter，不过在需要时你也可以提供一个 setter： 12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get() &#123; return this.firstName + &#x27; &#x27; + this.lastName &#125;, // setter set(newValue) &#123; const names = newValue.split(&#x27; &#x27;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... 现在再运行 vm.fullName = &#39;John Doe&#39; 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 Class与Style绑定如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作： 1234567891011&lt;div id=&quot;app&quot;&gt; &lt;my-component class=&quot;baz&quot;&gt;&lt;/my-component&gt;&lt;/div&gt;const app = Vue.createApp(&#123;&#125;)app.component(&#x27;my-component&#x27;, &#123; template: ` &lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt; &lt;span&gt;This is a child component&lt;/span&gt; `&#125;) 条件渲染v-if vs v-showv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好 v-if 与 v-for 一起使用 提示 不推荐同时使用 v-if 和 v-for 当 v-if 与 v-for 一起使用时，v-if 具有比 v-for 更高的优先级。请查阅列表渲染指南以获取详细信息。 当它们处于同一节点，v-if 的优先级比 v-for 更高，这意味着 v-if 将没有权限访问 v-for 里的变量： 12345&lt;!-- This will throw an error because property &quot;todo&quot; is not defined on instance. --&gt;&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; 可以把 v-for 移动到&lt;template&gt; 标签中来修正： 12345&lt;template v-for=&quot;todo in todos&quot;&gt; &lt;li v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/template&gt; 表单绑定输入基础用法v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件： text 和 textarea 元素使用 value property 和 input 事件； checkbox 和 radio 使用 checked property 和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 组件基础基本实例这里有一个 Vue 组件的示例： 123456789101112131415// 创建一个Vue 应用const app = Vue.createApp(&#123;&#125;)// 定义一个名为 button-counter 的新全局组件app.component(&#x27;button-counter&#x27;, &#123; data() &#123; return &#123; count: 0 &#125; &#125;, template: ` &lt;button @click=&quot;count++&quot;&gt; You clicked me &#123;&#123; count &#125;&#125; times. &lt;/button&gt;`&#125;) 组件的复用你可以将组件进行任意次数的复用每个组件都会各自独立维护它的data。因为你每用一次组件，就会有一个它的新组件实例被创建 在组件上使用 v-model自定义事件也可以用于创建支持 v-model 的自定义输入组件。记住： 12345678910&lt;input v-model=&quot;searchText&quot; /&gt;等价于：&lt;input :value=&quot;searchText&quot; @input=&quot;searchText = $event.target.value&quot; /&gt;当用在组件上时，v-model 则会这样：&lt;custom-input :model-value=&quot;searchText&quot; @update:model-value=&quot;searchText = $event&quot;&gt;&lt;/custom-input&gt; 为了让它正常工作，这个组件内的 &lt;input&gt; 必须： 将其 value attribute 绑定到一个名叫 modelValue 的 prop 上在其 input 事件被触发时，将新的值通过自定义的 update:modelValue 事件抛出写成代码之后是这样的： 123456789app.component(&#x27;custom-input&#x27;, &#123; props: [&#x27;modelValue&#x27;], template: ` &lt;input :value=&quot;modelValue&quot; @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot; &gt; `&#125;) 现在 v-model 就应该可以在这个组件上完美地工作起来了： 1&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt; 深入组件非 Prop 的 AttributeAttribute 继承当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 &lt;date-picker&gt; 组件的实例中： 1234567app.component(&#x27;date-picker&#x27;, &#123; template: ` &lt;div class=&quot;date-picker&quot;&gt; &lt;input type=&quot;datetime&quot; /&gt; &lt;/div&gt; `&#125;) 如果我们需要通过 data status property 定义 &lt;date-picker&gt; 组件的状态，它将应用于根节点 (即 div.date-picker)。 1234567&lt;!-- 具有非prop attribute的Date-picker组件--&gt;&lt;date-picker data-status=&quot;activated&quot;&gt;&lt;/date-picker&gt;&lt;!-- 渲染 date-picker 组件 --&gt;&lt;div class=&quot;date-picker&quot; data-status=&quot;activated&quot;&gt; &lt;input type=&quot;datetime&quot; /&gt;&lt;/div&gt; 同样的规则适用于事件监听器： 1&lt;date-picker @change=&quot;submitChange&quot;&gt;&lt;/date-picker&gt; 12345app.component(&#x27;date-picker&#x27;, &#123; created() &#123; console.log(this.$attrs) // &#123; onChange: () =&gt; &#123;&#125; &#125; &#125;&#125;) 当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。 123456789app.component(&#x27;date-picker&#x27;, &#123; template: ` &lt;select&gt; &lt;option value=&quot;1&quot;&gt;Yesterday&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;Today&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;Tomorrow&lt;/option&gt; &lt;/select&gt; `&#125;) 在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件： 123&lt;div id=&quot;date-picker&quot; class=&quot;demo&quot;&gt; &lt;date-picker @change=&quot;showChange&quot;&gt;&lt;/date-picker&gt;&lt;/div&gt; 1234567const app = Vue.createApp(&#123; methods: &#123; showChange(event) &#123; console.log(event.target.value) // 将记录所选选项的值 &#125; &#125;&#125;) 禁用 Attribute 继承如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。例如： 禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。 通过将 inheritAttrs 选项设置为 false，你可以访问组件的 $attrs property，该 property 包括组件 props 和 emits property 中未包含的所有属性 (例如，class、style、v-on 监听器等)。 12345678app.component(&#x27;date-picker&#x27;, &#123; inheritAttrs: false, template: ` &lt;div class=&quot;date-picker&quot;&gt; &lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt; &lt;/div&gt; `&#125;) 有了这个新配置，data status attribute 将应用于 input 元素！ 1234567&lt;!-- Date-picker 组件 使用非 prop attribute --&gt;&lt;date-picker data-status=&quot;activated&quot;&gt;&lt;/date-picker&gt;&lt;!-- 渲染 date-picker 组件 --&gt;&lt;div class=&quot;date-picker&quot;&gt; &lt;input type=&quot;datetime&quot; data-status=&quot;activated&quot; /&gt;&lt;/div&gt; 多个根节点上的 Attribute 继承与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。 1&lt;custom-layout id=&quot;custom-layout&quot; @click=&quot;changeValue&quot;&gt;&lt;/custom-layout&gt; 1234567891011121314151617// 这将发出警告app.component(&#x27;custom-layout&#x27;, &#123; template: ` &lt;header&gt;...&lt;/header&gt; &lt;main&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt; `&#125;)// 没有警告，$attrs被传递到&lt;main&gt;元素app.component(&#x27;custom-layout&#x27;, &#123; template: ` &lt;header&gt;...&lt;/header&gt; &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt; `&#125;) 自定义事件处理 v-model 修饰符在 2.x 中，我们对组件 v-model 上的 .trim 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 v-model 的修饰符将通过 modelModifiers prop 提供给组件： 让我们创建一个示例自定义修饰符 capitalize，它将 v-model 绑定提供的字符串的第一个字母大写。 添加到组件 v-model 的修饰符将通过 modelModifiers prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 modelModifiers prop。 请注意，当组件的 created 生命周期钩子触发时，modelModifiers prop 包含 capitalize，其值为 true——因为它被设置在 v-model 绑定 v-model.capitalize=&quot;bar&quot;。 1&lt;my-component v-model.capitalize=&quot;bar&quot;&gt;&lt;/my-component&gt; 12345678910111213141516app.component(&#x27;my-component&#x27;, &#123; props: &#123; modelValue: String, modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125; &#125;, template: ` &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;&gt; `, created() &#123; console.log(this.modelModifiers) // &#123; capitalize: true &#125; &#125;&#125;) 现在我们已经设置了 prop，我们可以检查 modelModifiers 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 &lt;input/&gt; 元素触发 input 事件时，我们都将字符串大写。 1234&lt;div id=&quot;app&quot;&gt; &lt;my-component v-model.capitalize=&quot;myText&quot;&gt;&lt;/my-component&gt; &#123;&#123; myText &#125;&#125;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031const app = Vue.createApp(&#123; data() &#123; return &#123; myText: &#x27;&#x27; &#125; &#125;&#125;)app.component(&#x27;my-component&#x27;, &#123; props: &#123; modelValue: String, modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125; &#125;, methods: &#123; emitValue(e) &#123; let value = e.target.value if (this.modelModifiers.capitalize) &#123; value = value.charAt(0).toUpperCase() + value.slice(1) &#125; this.$emit(&#x27;update:modelValue&#x27;, value) &#125; &#125;, template: `&lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emitValue&quot;&gt;`&#125;)app.mount(&#x27;#app&#x27;) 对于带参数的 v-model 绑定，生成的 prop 名称将为 arg + &quot;Modifiers&quot;： 1&lt;my-component v-model:foo.capitalize=&quot;bar&quot;&gt;&lt;/my-component&gt; 1234567891011app.component(&#x27;my-component&#x27;, &#123; props: [&#x27;foo&#x27;, &#x27;fooModifiers&#x27;], template: ` &lt;input type=&quot;text&quot; :value=&quot;foo&quot; @input=&quot;$emit(&#x27;update:foo&#x27;, $event.target.value)&quot;&gt; `, created() &#123; console.log(this.fooModifiers) // &#123; capitalize: true &#125; &#125;&#125;) 2021.09.17更新提供/注入通常，当我们需要将数据从父组件传递到子组件时，我们使用props。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。 对于这种情况，我们可以使用 provide 和 inject 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 provide 选项来提供数据，子组件有一个 inject 选项来开始使用这个数据。 可复用&amp;组合渲染函数虚拟DOM树Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码： 1return Vue.h(&#x27;h1&#x27;, &#123;&#125;, this.blogTitle) h() 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 VNode。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。 h()参数h() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数： 1234567891011121314151617181920212223242526272829h( // &#123;String | Object | Function | null&#125; tag // 一个 HTML 标签名、一个组件、一个异步组件，或者 null。 // 使用 null 将会渲染一个注释。 // // 必需的。 &#x27;div&#x27;, // &#123;Object&#125; props // 与 attribute、prop 和事件相对应的对象。 // 我们会在模板中使用。 // // 可选的。 &#123;&#125;, // &#123;String | Array | Object&#125; children // 子 VNodes, 使用 `h()` 构建, // 或使用字符串获取 &quot;文本 Vnode&quot; 或者 // 有 slot 的对象。 // // 可选的。 [ &#x27;Some text comes first.&#x27;, h(&#x27;h1&#x27;, &#x27;A headline&#x27;), h(MyComponent, &#123; someProp: &#x27;foobar&#x27; &#125;) ]) 完整实例有了这些知识，我们现在可以完成我们最开始想实现的组件： 1234567891011121314151617181920212223242526272829303132333435363738394041const app = Vue.createApp(&#123;&#125;)/** Recursively get text from children nodes */function getChildrenTextContent(children) &#123; return children .map(node =&gt; &#123; return typeof node.children === &#x27;string&#x27; ? node.children : Array.isArray(node.children) ? getChildrenTextContent(node.children) : &#x27;&#x27; &#125;) .join(&#x27;&#x27;)&#125;app.component(&#x27;anchored-heading&#x27;, &#123; render() &#123; // create kebab-case id from the text contents of the children const headingId = getChildrenTextContent(this.$slots.default()) .toLowerCase() .replace(/\\W+/g, &#x27;-&#x27;) // replace non-word characters with dash .replace(/(^-|-$)/g, &#x27;&#x27;) // remove leading and trailing dashes return Vue.h(&#x27;h&#x27; + this.level, [ Vue.h( &#x27;a&#x27;, &#123; name: headingId, href: &#x27;#&#x27; + headingId &#125;, this.$slots.default() ) ]) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;)","categories":[{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://zouhualu.github.io/tags/Vue3/"}]},{"title":"web设计模式解析与实战（一）","slug":"web设计模式解析与实战","date":"2021-09-12T05:31:57.000Z","updated":"2021-10-31T06:14:39.293Z","comments":true,"path":"20210912/web设计模式解析与实战/","link":"","permalink":"https://zouhualu.github.io/20210912/web%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/","excerpt":"","text":"今天课程主要是讲前端设计模式，早上一节，晚上一节。 设计模式有利于 组织模块 设计沟通 代码质量 五大设计原则： 开闭原则（OCP：open close principle） 开-对拓展开放，对修改关闭 单一职责原则（SRP） 岗位职责单一，互不重叠 依赖倒置原则（DIP） 上层不应该依赖下层实现 接口隔离原则（ISP） 多个专业的接口比单个胖借口好用 里氏替换原则（LSP：the Lxxxx substitution principle） 子类能够覆盖父类 父类能够出现的地方子类就能出现 今天老师给的课后题： 某个停车场，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开， 车辆进入前，显示每层的空余车辆数量 车辆进入时，摄像头可识别车牌号和时间 车辆出来时，出口显示器显示车牌号和停车时长请设计一套系统。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"课程","slug":"课程","permalink":"https://zouhualu.github.io/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"浮生一日(20210911)","slug":"浮生一日","date":"2021-09-11T10:44:58.000Z","updated":"2021-12-18T11:07:41.866Z","comments":true,"path":"20210911/浮生一日/","link":"","permalink":"https://zouhualu.github.io/20210911/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/","excerpt":"","text":"今天老妈的生日🎂 猝不及防的狗粮 苹果的售后真的好，耳机检测了一下就说直接换新的","categories":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"TypeScript中函数的理解","slug":"TypeScript中函数的理解","date":"2021-09-10T08:55:32.000Z","updated":"2021-10-31T06:14:39.292Z","comments":true,"path":"20210910/TypeScript中函数的理解/","link":"","permalink":"https://zouhualu.github.io/20210910/TypeScript%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"使用方式和JavaScript使用方式类似，可以通过funciton关键字、箭头函数等形式去定义，例如下面一个简单的加法函数： 1const add = (a:number,b:number)=&gt; a+b 上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：当鼠标放置在第三行 add 函数名的时候，会出现完整的函数定义类型，通过 : 的形式来定义参数类型，通过 =&gt; 连接参数和返回值类型 我们也可以显式地写上返回类型，如下： 1const add = (a:number,b:number):number=&gt; a+b 当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示： 12345678// 方式一type LongHand = &#123; (a: number): number;&#125;;// 方式二type ShortHand = (a: number) =&gt; number; 当存在函数重载时，只能使用方式一的形式 可选参数当函数的参数可能是不存在的，只需要在参数后面加上 ? 代表参数可能不存在，如下： 1const add = (a: number, b?: number) =&gt; a + (b ? b : 0) 这时候参数b可以是number类型或者undefined类型，即可以传一个number类型或者不传都可以 剩余类型剩余参数与JavaScript的语法类似，需要用 ... 来表示剩余参数 如果剩余参数 rest 是一个由number类型组成的数组，则如下表示： 1const add = (a: number, ...rest: number[]) =&gt; rest.reduce(((a, b) =&gt; a + b), a) 函数重载允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力 关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，用于具体实现 这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并 例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下： 1234567891011121314// 上边是声明function add (arg1: string, arg2: string): stringfunction add (arg1: number, arg2: number): number// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字// 下边是实现function add (arg1: string | number, arg2: string | number) &#123; // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2 if (typeof arg1 === &#x27;string&#x27; &amp;&amp; typeof arg2 === &#x27;string&#x27;) &#123; return arg1 + arg2 &#125; else if (typeof arg1 === &#x27;number&#x27; &amp;&amp; typeof arg2 === &#x27;number&#x27;) &#123; return arg1 + arg2 &#125;&#125; 区别从上面可以看到： 从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型 typescript 在参数中，添加可选参数供使用者选择 typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型参考文章 https://www.tslang.cn/docs/handbook/functions.html https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD","categories":[{"name":"技术类-TypeScript","slug":"技术类-TypeScript","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://zouhualu.github.io/tags/TypeScript/"}]},{"title":"本博客说明书","slug":"about-me","date":"2021-09-07T03:19:02.000Z","updated":"2021-10-31T06:14:39.296Z","comments":true,"path":"20210907/about-me/","link":"","permalink":"https://zouhualu.github.io/20210907/about-me/","excerpt":"","text":"幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔 19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。所以我又重新搭了一个。后续会把写过的文档陆续上传到这边本博客主要记录学习过程，技术文档以及日常。 以下是功能测试：嵌入B站视频 代码块 123456console.log(&#x27;zouHuaLu&#x27;)hexo ghexo g -whexo serverhexo cleanhexo deploy 以后有时间弄一下评论功能 2021-09-23 本博客新增评论功能，支持评论啦！","categories":[{"name":"博客说明","slug":"博客说明","permalink":"https://zouhualu.github.io/categories/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}],"tags":[{"name":"博客说明","slug":"博客说明","permalink":"https://zouhualu.github.io/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]},{"title":"TypeScript中类的理解","slug":"TypeScript中类的理解","date":"2021-09-06T06:48:00.000Z","updated":"2021-10-31T06:14:39.292Z","comments":true,"path":"20210906/TypeScript中类的理解/","link":"","permalink":"https://zouhualu.github.io/20210906/TypeScript%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"一、是什么类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础 ❝类是一种用户定义的引用数据类型，也称类类型❞ 传统的面向对象语言基本都是基于类的，JavaScript 基于原型的方式让开发者多了很多理解成本在 ES6 之后，JavaScript 拥有了 class 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多但是JavaScript 的class依然有一些特性还没有加入，比如修饰符和抽象类TypeScript 的 class 支持面向对象的所有特性，比如 类、接口等 二、使用方式定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块(类的数据成员)： 「字段」：字段是类里面声明的变量。字段表示对象的有关数据。 「构造函数」：类实例化时调用，可以为类的对象分配内存。 「方法」：方法为对象要执行的操作如下例子： 123456789101112131415class Car &#123; // 字段 engine:string; // 构造函数 constructor(engine:string) &#123; this.engine = engine &#125; // 方法 disp():void &#123; console.log(&quot;发动机为 : &quot;+this.engine) &#125; &#125; 继承类的继承使用过extends的关键字 1234567891011121314151617class Animal &#123; move(distanceInMeters: number = 0) &#123; console.log(`Animal moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Dog extends Animal &#123; bark() &#123; console.log(&#x27;Woof! Woof!&#x27;); &#125;&#125;const dog = new Dog();dog.bark();dog.move(10);dog.bark(); Dog是一个 派生类，它派生自 Animal 基类，派生类通常被称作子类，基类通常被称作 超类。 Dog类继承了Animal类，因此实例dog也能够使用Animal类move方法。同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。 通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下： 12345678910111213class PrinterClass &#123; doPrint():void &#123; console.log(&quot;父类的 doPrint() 方法。&quot;) &#125; &#125; class StringPrinter extends PrinterClass &#123; doPrint():void &#123; super.doPrint() // 调用父类的函数 console.log(&quot;子类的 doPrint()方法。&quot;) &#125; &#125; 修饰符可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符： 公共 public：可以自由的访问类程序里定义的成员 私有 private：只能够在该类的内部进行访问 受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问 私有修饰符只能够在该类的内部进行访问，实例对象并不能够访问 12345678class Father&#123; private name:String constructor(name:String)&#123; this.name = name &#125;&#125;const father = new Father(&#x27;zouHuaLu&#x27;)father.name //会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot; 并且继承该类的子类并不能访问，如下图所示： 1234567891011class Father&#123; private name:String constructor(name:String)&#123; this.name = name &#125;&#125;class Son extends Father&#123; say()&#123; console.log(`my name is $&#123;this.name&#125;`) //会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot; &#125;&#125; 受保护修饰符跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下： 12345678class Father&#123; protected name:String constructor(name:String)&#123; this.name = name &#125;&#125;const father = new Father(&#x27;zouHuaLu&#x27;)father.name //会报错，提示 &quot;属性name受保护，只能在类Father及其子类中访问&quot; 有一点不同的是 protected 成员在子类中仍然可以访问 1234567891011class Father&#123; protected name:String constructor(name:String)&#123; this.name = name &#125;&#125;class Son extends Father&#123; say()&#123; console.log(`my name is $&#123;this.name&#125;`) &#125;&#125; 只读修饰符通过readonly关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下： 12345678class Father&#123; readonly name:String constructor(name:String)&#123; this.name = name &#125;&#125;const father = new Father(&#x27;zouHuaLu&#x27;)father.name //会报错,提示&quot;无法分配到name，因为它是只读属性&quot; 静态属性这些属性存在于类本身上面而不是类的实例上，通过static进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示： 12345class Square &#123; static width = &#x27;100px&#x27;&#125;console.log(Square.width) // 100px 抽象类抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示： 123456abstract class Animal &#123; abstract makeSound(): void; move(): void &#123; console.log(&#x27;roaming the earch...&#x27;); &#125;&#125; 这种类并不能被实例化，通常需要我们创建子类去继承，如下： 1234567891011class Cat extends Animal &#123; makeSound() &#123; console.log(&#x27;miao miao&#x27;) &#125;&#125;const cat = new Cat()cat.makeSound() // miao miaocat.move() // roaming the earch... 三、应用场景除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在React 工程中是很常用的，如下： 1export default class Carousel extends React.Component&lt;Props, State&gt; &#123;&#125; 由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。 先声明一个类，这个类包含组件 props 所需的类型和初始值： 12345678910111213// props的类型export default class Props &#123; public children: Array&lt;React.ReactElement&lt;any&gt;&gt; | React.ReactElement&lt;any&gt; | never[] = [] public speed: number = 500 public height: number = 160 public animation: string = &#x27;easeInOutQuad&#x27; public isAuto: boolean = true public autoPlayInterval: number = 4500 public afterChange: () =&gt; &#123;&#125; public beforeChange: () =&gt; &#123;&#125; public selesctedColor: string public showDots: boolean = true&#125; 当我们需要传入 props 类型的时候直接将 Props 作为接口传入，此时 Props 的作用就是接口，而当需要我们设置defaultProps初始值的时候，我们只需要: 1public static defaultProps = new Props() Props 的实例就是 defaultProps 的初始值，这就是 class作为接口的实际应用，我们用一个 class 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量 参考文章 https://www.tslang.cn/docs/handbook/classes.html https://www.runoob.com/typescript/ts-class.html","categories":[{"name":"技术类-TypeScript","slug":"技术类-TypeScript","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://zouhualu.github.io/tags/TypeScript/"}]},{"title":"export与export default的区别","slug":"export与export-default的区别","date":"2021-07-01T06:21:44.000Z","updated":"2021-10-31T06:14:39.294Z","comments":true,"path":"20210701/export与export-default的区别/","link":"","permalink":"https://zouhualu.github.io/20210701/export%E4%B8%8Eexport-default%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"node中导入模块：var 名称 = require(‘模块标识符’) node中向外暴露成员的形式：module.exports = {} 在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块 ES6中导入模块，使用 import 模块名称 from ‘模块标识符’ import ‘表示路径’ import * from * 是ES6中导入模块的方式 在ES6中，使用export default 和 export 向外暴露成员例如： 12345// test.jsexport default &#123; name: &#x27;zs&#x27;, age: 20&#125; 或是 123456// test.jsvar info = &#123; name: &#x27;zs&#x27;, age: 20&#125;export default info 在main.js中接收，test.js使用export default 向外暴露的成员 12import person from &#x27;./test.js&#x27;console.log(person); 注意：1、export default 向外暴露的成员，可以使用任意变量来接收 2、在一个模块中，export default 只允许向外暴露一次 3、在一个模块中，可以同时使用export default 和export 向外暴露成员 4、使用export向外暴露的成员，只能使用{ }的形式来接收，这种形式，叫做【按需导出】 5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义 6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收 7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名 例如： 12345678910// test.jsvar info = &#123; name: &#x27;zs&#x27;, age: 20&#125;export default infoexport var title = &#x27;小星星&#x27;export var content = &#x27;哈哈哈&#x27; 在main.js中接收，test.js使用export default 和 export 向外暴露的成员 123import person, &#123;title, content as content1&#125; from &#x27;./test.js&#x27;console.log(person);console.log(title + &#x27;=======&#x27; + content1);","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://zouhualu.github.io/tags/ES6/"}]},{"title":"new操作符的实现","slug":"new操作符的实现","date":"2021-06-18T21:23:44.000Z","updated":"2021-10-31T06:14:39.294Z","comments":true,"path":"20210619/new操作符的实现/","link":"","permalink":"https://zouhualu.github.io/20210619/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"JavaScript中的new操作符的原理例子123456function Person (name, age) &#123; this.name = name this.age = age&#125;const person1 = new Person(&#x27;走花路的长颈鹿&#x27;, 26)console.log(person1) //Person&#123;name:&#x27;走花路的长颈鹿&#x27;,age:26&#125; 先定义了一个构造函数Person，然后通过new操作符生成Person构造函数的一个实例并将其引用赋值给变量person1。然后控制台打印出person1的内容，可以看到该实例对象具有name和age属性，它们的值就是我们在调用构造函数时传入的值。 new关键字进行的操作 先创建一个空对象obj=&#123;&#125; 将obj的__proto__原型指向构造函数Person的prototype原型对象，即obj.__proto__ = Person.prototype 将构造函数Person内部的this指向obj，然后执行构造函数Person()（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象obj而已，就好像执行obj.Person()一样） 若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象obj（默认会添加return this）。否则，返回引用类型的值。 自己实现一个new操作符1234567891011121314151617function myNew (constr, ...args) &#123; // 1,2 创建一个对象obj，将obj的__proto__属性指向构造函数的原型对象 // 即实现：obj.__proto__ === constructor.prototype var obj = Object.create(constr.prototype) // 3.将constrc内部的this（即执行上下文）指向obj，并执行 var result = constr.apply(obj, args) // 4\\. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象 return result instanceof Object ? result : obj&#125;// 使用的例子：function Person(name, age)&#123; this.name = name; this.age = age;&#125;const person1 = myNew(Person, &#x27;Tom&#x27;, 20)console.log(person1) // Person &#123;name: &quot;Tom&quot;, age: 20&#125; 关键点 将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。 将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。 2021年7月1日补充看一个例子 123456789101112function Player(color) &#123; this.color = color&#125;Player.prototype.start = function() &#123;&#125;const white = new Player(&#x27;white&#x27;)const black = new Player(&#x27;black&#x27;)console.log(black.__proto__) // start()console.log(Object.getPrototypeOf(black)) // start()console.log(Player.prototype) // start()console.log(Player.__proto__) // &#123;&#125; 根据反推可以写一下思路 一个继承自Player.prototype的新对象 p1/p2被创建 p1.__proto__ === Player.prototype，p1.__proto__指向Player.prototype 将this指向新创建的对象p1/p2 返回一个新对象： 如果构造函数没有显示的返回值，那么返回this 如果有显式的返回值，是基本类型，那么还是返回this 如果构造函数有显式的返回值，是对象类型，比如是{a:1}，那么就返回{a:1}现在我们再来实现一个new指令的功能12345678910111213function Player(name)&#123; this.name = name&#125;function objectFactory() &#123; let o = new Object() let FunctionConstructor = [].shift.call(arguments) o.__proto__ = FunctionConstructor.prototype let resultObj = FunctionConstructor.apply(o, arguments) return typeof resultObj === &#x27;object&#x27; ? resultObj : o&#125;const p1 = objectFactory(Player, &#x27;花鹿&#x27;)console.log(p1) // 花鹿 完~","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"原型与原型链与constructor","slug":"原型与原型链与constructor","date":"2021-06-18T07:16:53.000Z","updated":"2021-10-31T06:14:39.294Z","comments":true,"path":"20210618/原型与原型链与constructor/","link":"","permalink":"https://zouhualu.github.io/20210618/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8Econstructor/","excerpt":"","text":"原型与原型链与constructor本文参考自：https://blog.csdn.net/cc18868876837/article/details/81211729 先来个总结： 我们需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。 __proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。 prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。 constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 基础知识__proto__翻译为原型，多个__proto__串连起来的叫做原型链。 prototype翻译为原型对象。 Object.getPrototypeOf()Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。 示例123456const prototype1 = &#123;&#125;;const object1 = Object.create(prototype1);console.log(Object.getPrototypeOf(object1) === prototype1);// expected output: trueObject.getPrototypeOf(object1) === object1.__proto__ 正式开始12function Foo() &#123;...&#125;;let f1 = new Foo(); 以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。 __proto__属性首先要记住两点： __proto__和constructor是对象才有的属性，在JavaScript中函数也是一种对象。 prototype是函数才有的属性。 这里我们仅留下 __proto__ 属性，它是对象所独有的，可以看到__proto__属性都是由一个对象指向一个对象，即指向它们构造函数的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。 其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠__proto__继承而来的。 prototype属性 prototype属性是函数独有的。他是从一个函数指向一个对象，他的含义是函数的原型对象 f1.__proto__ === Foo.prototype，它们两个完全一样。那prototype属性的作用又是什么呢？它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。 constructor属性 constructor属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合__proto__属性查看会更清楚点，如下图所示），从上图中可以看出Function这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。 函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身 完~","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Vue自定义全局组件","slug":"Vue自定义全局组件","date":"2021-06-18T07:15:40.000Z","updated":"2021-10-31T06:14:39.294Z","comments":true,"path":"20210618/Vue自定义全局组件/","link":"","permalink":"https://zouhualu.github.io/20210618/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6/","excerpt":"","text":"vue自定义全局弹框组件 在components文件夹下新增一个组件文件夹Dialog，新建一个模板组件Dialog.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;template&gt; &lt;div class=&quot;u_dialog_panel&quot; @touchmove.stop=&quot;noop&quot;&gt; &lt;div class=&quot;mask&quot; v-if=&quot;visible&quot; @click=&quot;handleClose&quot;&gt;&lt;/div&gt; &lt;transition name=&quot;open&quot;&gt; &lt;div v-if=&quot;visible&quot; class=&quot;dialog_body&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;div class=&quot;btns&quot; v-if=&quot;confirmText || cancleText&quot;&gt; &lt;div class=&quot;cancle btn&quot; v-if=&quot;cancleText&quot; @click=&quot;handleCancle&quot;&gt;&#123;&#123;cancleText&#125;&#125;&lt;/div&gt; &lt;div class=&quot;confirm btn&quot; :style=&quot;confirmStyle&quot; v-if=&quot;confirmText&quot; @click=&quot;handleConfirm&quot;&gt;&#123;&#123;confirmText&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;UDialog&#x27;, props: &#123; visible: &#123; type: Boolean, default: false, required: true &#125;, // 确定按钮的文案 confirmText: &#123; type: String, default: &#x27;确定&#x27; &#125;, confirmStyle: &#123; type: String, default: &#x27;&#x27; &#125;, // 取消按钮的文案 cancleText: &#123; type: String, default: &#x27;取消&#x27; &#125;, cancleStyle: &#123; type: String, default: &#x27;&#x27; &#125;, &#125;, created () &#123; this.$nextTick(() =&gt; &#123; document.body.insertBefore(this.$el, document.body.lastChild) &#125;) &#125;, beforeDestroy () &#123; document.body.removeChild(this.$el) &#125;, methods: &#123; // 关闭弹窗 handleClose () &#123; this.$emit(&#x27;close&#x27;) &#125;, // 确定按钮 handleConfirm () &#123; this.$emit(&#x27;confirm&#x27;) &#125;, // 取消按钮 handleCancle () &#123; this.$emit(&#x27;cancle&#x27;) &#125;, noop () &#123;&#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.u_dialog_panel &#123; .mask &#123; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); position: fixed; left: 0; top: 0; z-index: 100; backdrop-filter: blur(5px); &#125; .dialog_body&#123; width: 80vw; background-color: #fff; position: fixed; left: 50vw; top: 50vh; z-index: 100; transform: translate(-50%, -50%); transform-origin: 0 0; border-radius: .875rem; &amp;.open-enter &#123; opacity: 0; transform: scale(0.7) translate(-50%, -50%); transition: all 0.3s; &#125; &amp;.open-enter-to &#123; opacity: 1; transform: scale(1) translate(-50%, -50%); transition: all 0.3s; &#125; .btns &#123; display: flex; justify-content: space-between; align-items: center; .btn &#123; display: flex; justify-content: center; align-items: center; flex-grow: 1; width: 50%; height: 2.875rem; border-top: 1px solid #ddd; box-sizing: border-box; display: flex; justify-content: center; align-items: center; font-size: .875rem; &amp; + .btn &#123; border-left: 1px solid #ddd; &#125; &amp;.cancle &#123; color: #666666; &#125; &amp;.confirm &#123; color: #FF5883; &#125; &#125; &#125; &#125;&#125;&lt;/style&gt; 在此文件夹再新建一个index.js 12345678import Dialog from &#x27;./Dialog&#x27;Dialog.install = function (Vue, options) &#123; Vue.component(`$&#123;Dialog.name&#125;`, Dialog)&#125;export default Dialog 最后再main.js里注册为全局组件 123import Dialog from &#x27;./components/Dialog/index.js&#x27;Vue.use(Dialog) 这样就可以在其他组件里无需声明而使用此组件","categories":[{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://zouhualu.github.io/tags/Vue3/"}]},{"title":"JavaScript中的堆栈以及数据类型","slug":"JavaScript中的堆栈以及数据类型","date":"2021-06-17T07:08:21.000Z","updated":"2021-10-31T06:14:39.294Z","comments":true,"path":"20210617/JavaScript中的堆栈以及数据类型/","link":"","permalink":"https://zouhualu.github.io/20210617/JavaScript%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"JavaScript的堆栈以及数据类型本文参考此链接 堆 是堆内存的简称。堆是动态分配内存，内存大小不一，也不会自动释放。栈 是栈内存的简称。栈是自动分配相对固定大小的内存空间，并由系统自动释放。后进先出 基本数据类型javascript的基本类型就5种:Undefined、Null、Boolean、Number和String，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。 引用数据类型javascript中其他类型的数据被称为引用类型的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和new出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。 传值与传址123456789var arr1 = [1,2,5,8]; var arr2 = arr1 ; var str1 = arr1[2]; console.log(arr2);//1,2,5,8console.log(str1);//5arr2[4] = 99; str1 = 6; console.log(arr1);//1,2,5,8,99console.log(arr1[2]);//5 当我改变arr2中的数据时，arr1中数据也发生了变化，当改变str1的数据值时，arr1却没有发生改变。为什么？这就是传值与传址的区别。 因为arr1是数组，属于引用类型，所以它赋予给arr2的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1得到的是一个基本类型的赋值，因此，str1仅仅是从arr1堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2都指向同一块堆内存，arr2修改的堆内存的时候，也就会影响到arr1，str1是直接在栈中修改，并且不能影响到arr1堆内存中的数据。 深拷贝和浅拷贝上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将arr1的每个基本类型的数据都遍历一遍，依次的赋值给arr2的对应字段。避免产生因为地址引用带来的问题。 123456789var arr1 = [1,2,5,8]; var arr2 = []; for(var i=0;i&lt;arr1.length;i++)&#123; arr2[i]=arr1[i];&#125;;console.log(arr2)//1,2,5,8arr2[4]=99;console.log(arr2)//1,2,5,8,99console.log(arr1)//1,2,5,8 javascript面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。 完~","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"}]}],"categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"},{"name":"技术类-React","slug":"技术类-React","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-React/"},{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"技术类-Node.js","slug":"技术类-Node-js","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Node-js/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://zouhualu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"算法类","slug":"算法类","permalink":"https://zouhualu.github.io/categories/%E7%AE%97%E6%B3%95%E7%B1%BB/"},{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"},{"name":"技术类-TypeScript","slug":"技术类-TypeScript","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-TypeScript/"},{"name":"博客说明","slug":"博客说明","permalink":"https://zouhualu.github.io/categories/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"TODO","slug":"TODO","permalink":"https://zouhualu.github.io/tags/TODO/"},{"name":"React","slug":"React","permalink":"https://zouhualu.github.io/tags/React/"},{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Node.js","slug":"Node-js","permalink":"https://zouhualu.github.io/tags/Node-js/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://zouhualu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"算法","slug":"算法","permalink":"https://zouhualu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://zouhualu.github.io/tags/leetcode/"},{"name":"Vue3","slug":"Vue3","permalink":"https://zouhualu.github.io/tags/Vue3/"},{"name":"课程","slug":"课程","permalink":"https://zouhualu.github.io/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://zouhualu.github.io/tags/TypeScript/"},{"name":"博客说明","slug":"博客说明","permalink":"https://zouhualu.github.io/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"},{"name":"ES6","slug":"ES6","permalink":"https://zouhualu.github.io/tags/ES6/"}]}
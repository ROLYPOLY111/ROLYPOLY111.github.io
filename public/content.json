{"meta":{"title":"走花路的长颈鹿","subtitle":"走花路的长颈鹿","description":"走花路的长颈鹿,博客","author":"走花路的长颈鹿","url":"https://zouhualu.github.io","root":"/"},"pages":[{"title":"","date":"2021-10-31T06:14:39.296Z","updated":"2021-10-31T06:14:39.296Z","comments":false,"path":"baidu_verify_code-TmkkRxX4ps.html","permalink":"https://zouhualu.github.io/baidu_verify_code-TmkkRxX4ps.html","excerpt":"","text":"676194d86471561a70b8026338973ebc"},{"title":"about","date":"2021-09-07T07:20:04.000Z","updated":"2022-03-29T11:54:44.126Z","comments":true,"path":"about/index.html","permalink":"https://zouhualu.github.io/about/index.html","excerpt":"","text":"网速足够快或者翻墙的话会使本网站打开的更快一些，网站有缓存，第一次打开可能会比较慢，后面就好了。 我新写了一个博客并放在了自己的服务器上:我的新博客，点击跳转"}],"posts":[{"title":"七月日报","slug":"七月日报","date":"2022-07-02T06:03:00.000Z","updated":"2022-07-02T06:04:46.852Z","comments":true,"path":"20220702/七月日报/","link":"","permalink":"https://zouhualu.github.io/20220702/%E4%B8%83%E6%9C%88%E6%97%A5%E6%8A%A5/","excerpt":"","text":"2022/07/02 周六 复习 react 相关知识 2022/07/01 周五 视频带货页面接口对接完，已提测，翻译下周待完成","categories":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"六月阅读","slug":"六月阅读","date":"2022-06-30T05:09:15.000Z","updated":"2022-07-02T06:01:19.833Z","comments":true,"path":"20220630/六月阅读/","link":"","permalink":"https://zouhualu.github.io/20220630/%E5%85%AD%E6%9C%88%E9%98%85%E8%AF%BB/","excerpt":"","text":"《傅雷家书》（傅雷，朱梅馥，傅聪） 认知世界的经济学（珍大户）","categories":[{"name":"阅读","slug":"阅读","permalink":"https://zouhualu.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://zouhualu.github.io/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"六月日报","slug":"日报","date":"2022-06-07T01:48:44.000Z","updated":"2022-07-02T06:07:18.769Z","comments":true,"path":"20220607/日报/","link":"","permalink":"https://zouhualu.github.io/20220607/%E6%97%A5%E6%8A%A5/","excerpt":"","text":"2022/06/30 周四 后端请假两天，无法对接接口 跳绳 2000+ 2022/06/29 周三 复习 react 带货视频版块（50%） 货币算法封装（50%） 2022/06/28 周二 复习 react 带货视频版块 新增货币泰铢，重新封装了货币转换的方法，输入一种货币，输出多种货币 思考：像货币这种展示的数据，到底是放在前端算比较好还是后端比较好？ 我个人觉得放在后端计算比较好。首先后端计算一遍，h5 和 pc 都可以拿来用。其次，页面展示货币的地方非常多，以后每新增一种货币，页面每一处用到的地方都需要改，后端完全可以封装一种算法，把他算好存在表里，前端请求随取随用。 2022/06/26 周日 复习 React 相关 2022/06/25 周六 锻炼一个小时 2022/06/22 周三 用户协议与隐私 √ 支持修改用户名 √ 用户画像页面 √ 支付逻辑调整 √ 2022/06/21 周二 用户协议与隐私 √ 支持修改用户名 √ 用户画像页面 支付逻辑调整 √ 锻炼了半个小时 2022/06/20 周一 上周项目发布上线 用户协议与隐私 支持修改用户名 用户画像页面 支付逻辑调整 2022/06/19 周日祝老爸父亲节快乐 锻炼了一个半小时 2022/06/18 周六 锻炼了一个小时 2022/06/17 周五 页面的所有翻译 2022/06/16 周四 晴 兑完所有的接口 锻炼 2022/06/15 周三 晴 部分页面接口没有提供，先做页面翻译 2022/06/14 周二 雨 直播详情页面，在线流量分析模块新增字段：推流速度（√ 已完成） 新增用户邀约页面 （50%） 帮助中心页面 （√ 已完成） 个人中心页面 锻炼了一个小时 2022/06/13 周一 雨 直播详情页面，在线流量分析模块新增字段：推流速度（√ 已完成） 新增用户邀约页面 个人中心页面 帮助中心页面 锻炼一个小时 2022/06/12 周日 雨 英语学习 复习 webpack5 锻炼 2022/06/11 周六 晴 复习 webpack5 2022/06/10 周五 雨 修改测试反馈的问题，下周一可以上线了 复习 webpack5 2022/06/09 周四 晴 本周需求达人商品搜索功能已提测 复习 webpack5 锻炼了一个小时 2022/06/08 周三 晴 学习巩固 webpack5 相关知识 完成了本周需求，待提测 锻炼了一个小时 2022/06/07 周二 阴 开始做本周需求：达人和商品的搜索页面 学习巩固 webpack5 相关知识 跟着刘畊宏以及自由训练 1 小时 2022/06/06 周一 完成了 u10 支付页面的翻译工作 修复一个小 bug，页面字段无返回则显示 0 复习 webpack 知识","categories":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"常见的手写js","slug":"常见的手写js","date":"2022-05-28T07:20:46.000Z","updated":"2022-05-30T02:56:12.963Z","comments":true,"path":"20220528/常见的手写js/","link":"","permalink":"https://zouhualu.github.io/20220528/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%89%8B%E5%86%99js/","excerpt":"","text":"newnew 操作符 new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？ 在调用new的过程中会发生四件操作 新建了一个对象 新对象链接到原型对象上 绑定 this 返回这个新对象 123456789101112function create() &#123; // 1.创建一个新对象 let obj = &#123;&#125;; // 获取第一个参数，也就是获取构造函数 let Con = [].shift.call(arguments); // 2.新对象继承构造函数原型对象上的所有方法 obj.__proto__ = Con.prototype; // 3.构造函数的this指向新对象obj，并将剩余的参数传进去执行，得到结果result let result = Con.apply(obj, arguments); // 4.如果得到的结果是个对象的话就返回result，如果不是的话就返回对象obj return result instanceof Object ? result : obj;&#125; 关于上面代码的第四条注释：构造函数如果返回原始值，那么这个返回值毫无意义 123456function Test(name) &#123; this.name = name; return 1;&#125;const t = new Test(&quot;zhl&quot;);console.log(t.name); // &#x27;zhl&#x27; 对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题。 instanceof 原理 instanceof 的原理是什么？ instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype 123456789function myInstanceof(left, right) &#123; let prototype = right.prototype; left = left.__proto__; while (true) &#123; if (left === null || left === undefined) return false; if (prototype === left) return true; left = left.__proto__; &#125;&#125; 分析: 首先获取类型的原型 然后获得对象的原型 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null 防抖与节流 之前看到一个很形象的比喻。节流防抖就好比乘电梯，比如 delay 是 10 秒，防抖就是电梯每进来一个人就要等 10 秒再运行，而节流就是电梯保证每 10 秒可以运行一次","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"vue前端路由","slug":"vue前端路由","date":"2022-04-05T06:13:40.000Z","updated":"2022-04-16T07:56:51.733Z","comments":true,"path":"20220405/vue前端路由/","link":"","permalink":"https://zouhualu.github.io/20220405/vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/","excerpt":"","text":"实现一个 hash 路由HTML 部分 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;header&quot;&gt; &lt;div&gt; &lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;#about&quot;&gt;关于&lt;/a&gt; &lt;/div&gt; &lt;div&gt;&lt;a href=&quot;#me&quot;&gt;我的&lt;/a&gt;&lt;/div&gt; &lt;div onclick=&quot;window.history.go(-1)&quot;&gt;返回&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;style&gt; .header &#123; background-color: black; height: 100px; line-height: 100px; display: flex; color: #fff; justify-content: space-around; &#125; a:link, a:hover, a:active, a:visited &#123; color: #fff; text-decoration: none; &#125; &lt;/style&gt; &lt;script src=&quot;./hashroutes.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; JS 部分 1234567891011121314151617181920212223242526272829303132333435class Route &#123; constructor() &#123; console.log(this); this.routes = &#123;&#125;; this.refresh = this.refresh.bind(this); window.addEventListener(&quot;load&quot;, this.refresh); window.addEventListener(&quot;hashchange&quot;, this.refresh); &#125; route(path, callback) &#123; this.routes[path] = callback || function () &#123;&#125;; &#125; refresh() &#123; console.log(this); let path = `/$&#123;window.location.hash.slice(1) || &quot;&quot;&#125;`; console.log(path); let cb = this.routes[path]; cb &amp;&amp; cb(); &#125;&#125;let Router = new Route();let body = document.querySelector(&quot;body&quot;);Router.route(&quot;/&quot;, function (res) &#123; body.style.backgroundColor = &quot;red&quot;;&#125;);Router.route(&quot;/about&quot;, function () &#123; body.style.backgroundColor = &quot;blue&quot;;&#125;);Router.route(&quot;/me&quot;, function () &#123; body.style.backgroundColor = &quot;green&quot;;&#125;); 实现一个 history 路由hash 虽然能解决问题，但是带有#不太美观。 方法 window.history.back() window.history.forward() window.history.go(number) window.history.pushState() 新增=》A B =》 A B C window.history.replaceState() 覆盖/替换 A B =》 A C history 模式下可以使用 Popstate 事件来监听 url 的变化 pushState 和 replaceState 并不会触发 Popstate 事件 哪些情况会触发 popstate 呢？ 浏览器的前进/后退按钮 history/back/forward/go 参数 state:是一个对象，是一个指定网址相关的状态对象，如果不需要，可以为 null title：新页面的标题，null URL：新的网址，必须与当前页面出于同一个域，才会显示 部署 history 路由的时候，要使你的路由中的所有 path 都访问到 index.html 文件 HTML 部分123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;body&gt; &lt;div class=&quot;header&quot;&gt; &lt;div&gt; &lt;a href=&quot;/gray&quot;&gt;灰色&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;/green&quot;&gt;绿色&lt;/a&gt; &lt;/div&gt; &lt;div&gt;&lt;a href=&quot;/&quot;&gt;白色&lt;/a&gt;&lt;/div&gt; &lt;div onclick=&quot;window.history.go(-1)&quot;&gt;返回&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;style&gt; .header &#123; background-color: black; height: 100px; line-height: 100px; display: flex; color: #fff; justify-content: space-around; &#125; a:link, a:hover, a:active, a:visited &#123; color: #fff; text-decoration: none; &#125; &lt;/style&gt; &lt;script src=&quot;./hashroutes.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; JS 部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Route &#123; constructor() &#123; this.routes = &#123;&#125;; this.bindPopState(); &#125; route(path, callback) &#123; this.routes[path] = callback || function () &#123;&#125;; &#125; init(path) &#123; window.history.replaceState(&#123; path &#125;, null, path); this.execCallbackByPath(path); &#125; bindPopState() &#123; window.addEventListener(&quot;popstate&quot;, (e) =&gt; &#123; const path = e.state &amp;&amp; e.state.path; console.log(path); this.execCallbackByPath(path); &#125;); &#125; go(path) &#123; window.history.pushState( &#123; path, &#125;, null, path ); this.execCallbackByPath(path); &#125; execCallbackByPath(path) &#123; const cb = this.routes[path]; if (cb) &#123; cb(); &#125; &#125;&#125;let Router = new Route();let body = document.querySelector(&quot;body&quot;);Router.route(&quot;/&quot;, function (res) &#123; body.style.backgroundColor = &quot;red&quot;;&#125;);Router.route(&quot;/about&quot;, function () &#123; body.style.backgroundColor = &quot;blue&quot;;&#125;);Router.route(&quot;/me&quot;, function () &#123; body.style.backgroundColor = &quot;green&quot;;&#125;); VueRouter vue router 从列表浏览了一段时间,点击进了一个详情页,然后返回的时候,我期望回到列表页还是停留在原来的浏览位置,你可以怎么做? keep-alive localStorage/sessionStorage + scrollTop + scrollTo scrollBehavior router-view 是什么? 类似于动态的组件. 找到当前路径对应的 component, 并展示出来.","categories":[{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://zouhualu.github.io/tags/Vue3/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Promise输出顺序相关问题","slug":"Promise输出顺序相关问题","date":"2022-03-29T10:06:06.000Z","updated":"2022-04-05T02:22:49.978Z","comments":true,"path":"20220329/Promise输出顺序相关问题/","link":"","permalink":"https://zouhualu.github.io/20220329/Promise%E8%BE%93%E5%87%BA%E9%A1%BA%E5%BA%8F%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"","text":"题：1234567891011121314151617181920212223242526272829303132333435Promise.resolve() .then(() =&gt; &#123; console.log(0); setTimeout(() =&gt; &#123; console.log(&quot;宏任务&quot;); &#125;, 0); // return 4 return Promise.resolve(4); // 此处是迷惑点 &#125;) .then((res) =&gt; &#123; console.log(res); &#125;);Promise.resolve() .then(() =&gt; &#123; console.log(1); &#125;) .then(() =&gt; &#123; console.log(2); &#125;) .then(() =&gt; &#123; console.log(3); &#125;) .then(() =&gt; &#123; console.log(5); &#125;) .then(() =&gt; &#123; console.log(6); &#125;) .then(() =&gt; &#123; console.log(7); &#125;) .then(() =&gt; &#123; console.log(8); &#125;); 答：1234567891011// 输出结果0;1;2;3;4;5;6;7;8;宏任务; 解析：| return Promise.resolve(4)会产生一个叫 job 的函数，等到当前执行栈为空的时候会去执行 | 微任务的执行中生成了微任务，那么会继续执行微任务，直到微任务队列为空。 宏任务队列 1,执行Promise.resolve() 遇到then()回调,往微任务队列推入以下代码： 1234567// 微任务队列加入了以下代码// 微任务队列1console.log(0);setTimeout(() =&gt; &#123; console.log(&quot;宏任务&quot;);&#125;, 0);return Promise.resolve(4); 仍然在当前宏任务往下执行，执行第二个Promise.resolve() 遇到then()回调,往微任务队列推入以下代码: 1console.log(1); 所以此时微任务队列里有两个代码块待执行。队列就是先进先出的原则 123456789// 第一个:Aconsole.log(0);setTimeout(() =&gt; &#123; console.log(&quot;宏任务&quot;);&#125;, 0);return Promise.resolve(4);// 第二个:Bconsole.log(1); 此时代码模块里的宏任务都已经执行完了，开始捞取微任务到执行栈中执行。队列里第一个出来的也就是代码： 12345console.log(0);setTimeout(() =&gt; &#123; console.log(&quot;宏任务&quot;);&#125;, 0);return Promise.resolve(4); 输出 0。 注册一个 job，当执行栈为空的时候，job 进入队列。此时执行栈并不为空。A 出栈 B 入栈 6. 1console.log(1); 输出 1。then 的回调推入微任务队列。B 出栈。执行栈为空。job 也进入微任务队列 函数是:此时的微任务队列就有两个函数 123456789// 第一个.then(() =&gt; &#123; console.log(2); &#125;)// 第二个，job(4) =&gt; &#123; this.resolvePromise(promise2, 4, resolve, reject);&#125;; 输出 2 将它的回调函数推入微任务队列 123.then(() =&gt; &#123; console.log(3); &#125;) 再去执行 123(4) =&gt; &#123; this.resolvePromise(promise2, 4, resolve, reject);&#125;; 这个函数会将 123(res) =&gt; &#123; console.log(res);&#125;; 推入微任务队列 输出 3 和 4 输出 3 的回调再次推入微任务 123.then(() =&gt; &#123; console.log(5); &#125;) 输出 5 后续输出原理相同，输出 6,7,8 此时没有回调微任务进栈了，开始清空宏任务队列，也就是 setTimeout，输出宏任务","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://zouhualu.github.io/tags/ES6/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"vue源码","slug":"vue源码","date":"2022-02-22T03:36:51.000Z","updated":"2022-03-29T11:54:44.126Z","comments":true,"path":"20220222/vue源码/","link":"","permalink":"https://zouhualu.github.io/20220222/vue%E6%BA%90%E7%A0%81/","excerpt":"","text":"为什么data是函数，而components是对象？data函数如果没有返回值会报错吗？答：会 vue源码位置：src\\core\\instance\\state.js 1234567891011121314151617181920function initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125; // // 看这里！这里有一个判断 isPlainObject(data) if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( &#x27;data functions should return an object:\\n&#x27; + &#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;, vm ) &#125; 。。。 。。。 。。。 // observe data observe(data, true /* asRootData */)&#125; Vue源码位置：packages\\weex-template-compiler\\build.js 123function isPlainObject (obj) &#123; return _toString.call(obj) === &#x27;[object Object]&#x27;&#125; data函数执行之后将返回值重新赋值给data，如果data不是个object，name就会报出一个警告 为什么props定义的数据不能和data同名? vue源码路径：vue\\src\\core\\instance\\state.js 1234567891011121314151617181920212223242526// proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; 可以看到先获取data的key，然后再去调用hasOwn方法去判断methods和props里面是否有重复的key，有的话就会发出警告。最后都通过了之后就会调用proxy(vm, &#39;_data&#39;, key)，用封装的proxy方法对vm实例做了一层代理，使得我们可以直接通过this直接调用key vue2代理的实现123456789101112131415161718const sharedPropertyDefinition = &#123; enumerable: true, configurable: true, get: noop, set: noop&#125;export function proxy (target: Object, sourceKey: string, key: string) &#123; // 去掉_props，vm._props.xxx =&gt; vm.xxx，可以直接访问 sharedPropertyDefinition.get = function proxyGetter () &#123; return this[sourceKey][key] &#125; sharedPropertyDefinition.set = function proxySetter (val) &#123; this[sourceKey][key] = val &#125; // 代理， Object.defineProperty(target, key, sharedPropertyDefinition)&#125; 使用的是Object.defineProperty来实现的 Vue的初始化 Vue源码位置：src\\core\\instance\\index.js 12345initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue) 最先执行的是initMixin()，我们看看里面有啥。 Vue源码位置：src\\core\\instance\\init.js 1234567891011121314151617181920//init.js // 初始化 vm._self = vm // 生命周期 initLifecycle(vm) // 事件 initEvents(vm) // 渲染 initRender(vm) // 面试题：beforeCreae和created之间做了什么？或者说二者有什么区别？ // 答：初始化injected，初始化state，初始化provide callHook(vm, &#x27;beforeCreate&#x27;) // 初始化inject initInjections(vm) // resolve injections before data/props // 初始化state，state里面有data，computed，method，props，watch initState(vm) // 初始化provide initProvide(vm) // resolve provide after data/props callHook(vm, &#x27;created&#x27;) initState()是从state.js文件里面导入的，我们再去看看里面有什么。 src\\core\\instance\\state.js 1234567891011121314151617181920export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options // 初始化props if (opts.props) initProps(vm, opts.props) // 初始化方法 if (opts.methods) initMethods(vm, opts.methods) // 初始化data if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; // 初始化computed if (opts.computed) initComputed(vm, opts.computed) // 初始化watch if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 可见在beforeCreate与created之间初始化了inject,props,methods,data,computed,watch 基于Vue2的proxy，自己实现一个代理1234567891011121314151617181920212223242526272829303132333435const noop = &#123;&#125; const propertyDefinition = &#123; enumerable:true, configurable:true, get:noop, set:noop&#125;const Proxy = function(target,sourceKey,key)&#123; propertyDefinition.get = function getter() &#123; return target[sourceKey][key] &#125; propertyDefinition.set = function setter (val) &#123; target[sourceKey][key] = val &#125; Object.defineProperty(target,key,propertyDefinition)&#125;function Vue(data)&#123; this._data = data Object.keys(this._data).forEach(key =&gt; &#123; Proxy(this,&#x27;_data&#x27;,key) &#125;)&#125;const vueIns = new Vue(&#123;a:1,b:2&#125;)vueIns._data.b = &#x27;hhh&#x27;vueIns.a = 2222console.log(vueIns._data.a)console.log(vueIns.b) Vue的实例为什么不能挂载在body或根节点上？挂载了会报错吗？答：挂载节点会被虚拟dom生成的Dom替换，会报错 Vue源码位置：src\\platforms\\web\\entry-runtime-with-compiler.js 123456if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this &#125; 什么是虚拟节点，简述虚拟dom构成？vue和react虚拟dom的区别？","categories":[{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://zouhualu.github.io/tags/Vue/"}]},{"title":"数据结构与算法","slug":"数据结构与算法","date":"2022-01-27T02:48:53.000Z","updated":"2022-03-29T11:54:44.125Z","comments":true,"path":"20220127/数据结构与算法/","link":"","permalink":"https://zouhualu.github.io/20220127/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"","text":"1.线性表定义 线性表是具有相同数据类型的 n(n≥0)个数据元素的有限序列。其中 n 为表长，当 n=0 时该线性表是一个空表。 若用 L 命名线性表，则其一般表示如下： L=(a1,a2,...ai,ai+1,...,an) 其中，a1 是唯一的“第一个”数据元素，又称为表头元素；an 是唯一的“最后一个”数据元素，又称为表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。 特点线性表常见的特点如下： 表中元素的个数是有限的； 表中元素具有逻辑上的顺序性，在序列中各元素排列有先后次序； 表中元素都是数据元素，每一个表元素都是单个元素； 表中元素的数据类型都相同，这意味着每一个表元素占有相同数量的存储空间； 表中元素具有抽象性，就是说，仅讨论表元素之间的逻辑关系，不考虑表元素究竟表示什么内容 分类 线性表的基本操作12345678InitList(L); //初始化表。构造一个空的线性表；Legnth(L); //求表长度。返回线性表L的长度，即L中数据元素的个数；LocateElem(L, e); //按值查找操作。在表L中查找具有给定关键字值的元素；GetElem(L, i); //按位查找操作。获取表L中第i个位置的元素的值；ListInsert(L, i, e); //插入操作。在表L中第i个位置上插入制定元素；ListDelete(L, i, e); //删除操作。删除表L中第i个位置上的元素；PrintList(L); //输出操作。按前后顺序输出线性表L的所有元素的值；Empty(L); //判空操作 1.1 线性表的顺序表示(顺序表) 线性表的顺序存储又称之为顺序表。 它是用一组连续地址的存储单元，依次存储线性表的数据元素，从而使得逻辑上相邻的两个元素在物理上也相邻。 特点 顺序表中元素的逻辑顺序与物理顺序相同","categories":[{"name":"算法类","slug":"算法类","permalink":"https://zouhualu.github.io/categories/%E7%AE%97%E6%B3%95%E7%B1%BB/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zouhualu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://zouhualu.github.io/tags/leetcode/"}]},{"title":"vue-router随笔","slug":"vue-router随笔","date":"2022-01-19T09:13:37.000Z","updated":"2022-03-29T11:54:44.125Z","comments":true,"path":"20220119/vue-router随笔/","link":"","permalink":"https://zouhualu.github.io/20220119/vue-router%E9%9A%8F%E7%AC%94/","excerpt":"","text":"编程式导航导航到不同的位置除了使用 &lt;router-link&gt; 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。 在 Vue 实例中，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push。 该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如： 1234567891011121314// 字符串路径router.push(&#x27;/users/eduardo&#x27;)// 带有路径的对象router.push(&#123; path: &#x27;/users/eduardo&#x27; &#125;)// 命名的路由，并加上参数，让路由建立 urlrouter.push(&#123; name: &#x27;user&#x27;, params: &#123; username: &#x27;eduardo&#x27; &#125; &#125;)// 带查询参数，结果是 /register?plan=privaterouter.push(&#123; path: &#x27;/register&#x27;, query: &#123; plan: &#x27;private&#x27; &#125; &#125;)// 带 hash，结果是 /about#teamrouter.push(&#123; path: &#x27;/about&#x27;, hash: &#x27;#team&#x27; &#125;) 如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path ： 123456789const username = &#x27;eduardo&#x27;// 我们可以手动建立 url，但我们必须自己处理编码router.push(`/user/$&#123;username&#125;`) // -&gt; /user/eduardo// 同样router.push(&#123; path: `/user/$&#123;username&#125;` &#125;) // -&gt; /user/eduardo// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益router.push(&#123; name: &#x27;user&#x27;, params: &#123; username &#125; &#125;) // -&gt; /user/eduardo// `params` 不能与 `path` 一起使用router.push(&#123; path: &#x27;/user&#x27;, params: &#123; username &#125; &#125;) // -&gt; /user 替换当前位置router.replace()它的作用类似于 router.push，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。 也可以直接在传递给 router.push 的 routeLocation 中增加一个属性 replace: true ： 123router.push(&#123; path: &#x27;/home&#x27;, replace: true &#125;)// 相当于router.replace(&#123; path: &#x27;/home&#x27; &#125;) 命名视图有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default 1234567&lt;router-view class=&quot;view left-sidebar&quot; name=&quot;LeftSidebar&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view main-content&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view right-sidebar&quot; name=&quot;RightSidebar&quot;&gt;&lt;/router-view&gt; 123456789101112131415const router = createRouter(&#123; history: createWebHashHistory(), routes: [ &#123; path: &#x27;/&#x27;, components: &#123; default: Home, // LeftSidebar: LeftSidebar 的缩写 LeftSidebar, // 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配 RightSidebar, &#125;, &#125;, ],&#125;)","categories":[{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://zouhualu.github.io/tags/Vue/"}]},{"title":"ES6随笔","slug":"ES6随笔","date":"2022-01-14T02:34:45.000Z","updated":"2022-05-08T02:34:18.729Z","comments":true,"path":"20220114/ES6随笔/","link":"","permalink":"https://zouhualu.github.io/20220114/ES6%E9%9A%8F%E7%AC%94/","excerpt":"","text":"参考资料：阮一峰 ES6 标准入门教程第三版 本文用于记录我觉得 ES6 中重要的原理和使用技巧 class 的继承Class 可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + &quot; &quot; + super.toString(); // 调用父类的toString() &#125;&#125; 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。 ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。 20220502 更新 构造函数的 prototype 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 prototype 属性上面。 –阮一峰《ES6》 1234567891011121314151617class Point &#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; 当我想打印输出看一下console.log(Point.prototype)的时候输出却是&#123;&#125;,感到很奇怪，明明方法是定义在prototype属性上的，为什么输出确实空的呢？ 查了一下发现： 这是因为 console.log()使用了 util.inspect()，它使用了 Object。对象上的keys()，它只返回可枚举的属性。并且 Object.prototype 包含非可枚举属性，这就是它返回空节点的原因。 因为那些方法都默认是不可枚举的，所以当我们想定义一个可枚举的属性时可以使用Object.defineProperty() 12345678Object.defineProperty(Point.prototype, &quot;hh&quot;, &#123; value: function () &#123; console.log(3); &#125;, // 可枚举 enumerable: true,&#125;);console.log(Point.prototype); 这下打印出了&#123; hh: [Function: value] &#125;","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://zouhualu.github.io/tags/ES6/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"浏览器相关面试知识点","slug":"浏览器相关面试知识点","date":"2022-01-11T06:04:48.000Z","updated":"2022-03-29T11:54:44.125Z","comments":true,"path":"20220111/浏览器相关面试知识点/","link":"","permalink":"https://zouhualu.github.io/20220111/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"一.详解浏览器事件捕获与冒泡1. 事件委托/事件代理捕获阶段–&gt;目标阶段–&gt;冒泡阶段 1234567window.addEventListener( &quot;click&quot;, function (e) &#123; console.log(&quot;window捕获&quot;, e.target.nodeName, e.currentTarget.nodeName); &#125;, true); 第三个参数为 true，则监听捕获事件，不传或者传 false，则监听冒泡事件 e.target指的是点击的元素，e.currentTarget指的是当前触发事件的元素 2. 阻止事件的传播e.stopPropagation()真正的作用是阻止事件的传播，既可以阻止事件的捕获也可以阻止事件的冒泡 面试题现在有一个页面，这个页面上有许多元素，div、p、button 等每个元素都有自己的 click 事件，都不相同现在有一个新需求，一个用户进入这个页面的时候，会有一个状态：banned，我们可以在全局上拿到这个状态：window.banned，为true的话表示当前用户被封禁，用户点击页面的任何元素都不执行原有逻辑，而是alert弹窗，提示你被封禁了；为false的话表示有操作权限。请问：如何实现？答：方案一：在最外层的一个元素上绑定上一个捕获事件，即addEventListener里的第三个参数为true，如果window.banned为true则e.stopPropagation()。 123456789//const body = document.getElementsByTagName(&#x27;body&#x27;)window.addEventListener(&#x27;click&#x27;,function(e)&#123; if(window.banner)&#123; e.stopPropagation() alert(&#x27;你被封禁了&#x27;) return &#125; ...&#125;,true) 方案二：window.banner为true的时候展示一个全屏的最高层级（即：z-index:99999）的 div 遮罩，遮住整个页面。 3.阻止默认事件e.preventDefault()这个没啥好说的 4.兼容性问题addEventListener –&gt; firefox、Chrome、高版本 IE、safari、operaattachEvent –&gt; IE7、IE8，除了政府网站，大部分公司不会再去针对他们做兼容了IE 浏览器里没有事件捕获，只有事件冒泡 针对兼容性做一下封装1234567891011121314151617181920212223242526272829303132333435363738394041424344class BomEvent &#123; constructor(element) &#123; this.element = element; &#125; addEvent(type, handler) &#123; if (this.element.addEventListener) &#123; this.element.addEventListener(type, handler, false); &#125; else if (this.element.attachEvent) &#123; this.element.attachEvent(`on$&#123;type&#125;`, function () &#123; // 这是处于ie7或8的一个环境，不支持箭头函数，所以这里做一下绑定 handler.call(element); &#125;); &#125; else &#123; this.element[`on$&#123;type&#125;`] = handler; &#125; &#125; removeEvent(type, handler) &#123; if (this.element.removeEventListener) &#123; this.element.removeEventListener(type, handler, false); &#125; else if (this.element.detachEvent) &#123; this.element.detachEvent(`on$&#123;type&#125;`, handler); &#125; else &#123; this.element[`on$&#123;type&#125;`] = null; &#125; &#125;&#125;// IE浏览器里没有事件捕获，只有事件冒泡function stopPropagation(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); //标准w3c浏览器 &#125; else &#123; event.cancelBubble = true; // IE &#125;&#125;function preventDefault(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125;&#125; 二：浏览器请求相关内容 Ajax 与 fetch原生 ajax： 123456789101112131415161718192021222324252627282930const xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, &quot;http://domain/service&quot;); //建立连接，并没有发送请求//监听状态xhr.onreadystatechange = function () &#123; // 表示请求还没有完成 if (xhr.readyState !== 4) &#123; return; &#125; else if (xhr.status === 200) &#123; // 请求成功 console.log(xhr.responseText); &#125; else &#123; //报错了 console.error( `HTTP error,status=$&#123;xhr.status&#125;,errorText = $&#123;xhr.statusText&#125;` ); &#125;&#125;;// 超时时间xhr.timeout = 3000;xhr.ontimeout = () =&gt; &#123; console.log(&quot;请求超时&quot;);&#125;;// 上传进度条xhr.upload.onprogress = (p) =&gt; &#123; const percent = Math.round((p.loaded / p.total) * 100) + &quot;%&quot;;&#125;;xhr.send(); //发送请求 fetch:浏览器新增的 fetch，内部封装了 promise 1234567891011121314151617181920fetch(&quot;http://domain/service&quot;, &#123; method: &quot;GET&quot;, credentials: &quot;same-origin&quot;, // 同域的请求会带上cookie&#125;) .then((response) =&gt; &#123; if (response.ok) &#123; //请求成功 return response.json(); &#125; throw new Error(&quot; http error&quot;); &#125;) .then((json) =&gt; &#123; console.log(json); &#125;) .catch((error) =&gt; &#123; console.error(error); // 统一的错误管理 // 接收fetch出现的错误 // 接收请求错误信息 &#125;); fetch不能直接通过catch来获取请求错误信息，而是要通过判断response.ok来返回出错误信息再通过catch来抓到错误信息 fetch自身不支持设置请求超时，我们自己来封装一个 1234567function fetchTimeout(url,init.timeout=3000)&#123; return new Promise((resolve,reject)=&gt;&#123; fetch(url,init).then(resolve).catch(reject) setTimeOut(reject,timeout) &#125;)&#125; 中断一个请求1234567891011121314151617181920212223//用于中断请求const controller = new AbortController();fetch(&quot;http://domain/service&quot;, &#123; method: &quot;GET&quot;, credentials: &quot;same-origin&quot;, // 同域的请求会带上cookie signal: controller.sianal,&#125;) .then((response) =&gt; &#123; if (response.ok) &#123; //请求成功 return response.json(); &#125; throw new Error(&quot; http error&quot;); &#125;) .then((json) =&gt; &#123; console.log(json); &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;);controller.abort(); //用于中断请求 请求头 request-headerreferer：表示来源，你是从哪一个页面过来这个页面的，标识访问路径user-agent：用来判断环境，设备标识 响应头 response-headeraccess-control-allow-origin:跨域用于做域名限制，跨域 access-control-allow-origin:/* ,不做限制 content-encoding: 是一个实体消息首部，用于对特定媒体类型的数据进行压缩。当这个首部出现的时候，它的值表示消息主体进行了何种方式的内容编码转换。这个消息首部用来告知客户端应该怎样解码才能获取在 Content-Type 中标示的媒体类型内容。 Content-Encoding: gzipContent-Encoding: compressContent-Encoding: deflateContent-Encoding: identityContent-Encoding: br set-cookie:响应首部 Set-Cookie 被用来由服务器端向客户端发送 cookie。 status 状态码响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)。 200 OK 请求成功。成功的含义取决于 HTTP 方法： GET：资源已被提取并在消息正文中传输。 HEAD：实体标头位于消息正文中。 POST：描述动作结果的资源在消息体中传输。 TRACE：消息正文包含服务器收到的请求消息 201 Created 该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。 301 Moved Permanently 重定向。 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。 302 Found 临时重定向。 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。 304：协商缓存，服务器文件未修改 面试题vue/react创建的单页面应用（spa），生成的index.html如果要做缓存应该做什么缓存？ 答：一般不做缓存，如果非要做就做协商缓存","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Vue随笔","slug":"Vue随笔","date":"2022-01-07T09:20:21.000Z","updated":"2022-03-29T11:54:44.125Z","comments":true,"path":"20220107/Vue随笔/","link":"","permalink":"https://zouhualu.github.io/20220107/Vue%E9%9A%8F%E7%AC%94/","excerpt":"","text":"前言本文记录的是我个人认为在实际项目中不常用的，但是重要或者会在面试中遇到的。 表单输入绑定v-model在内部为不同的输入元素使用不同的 property 并抛出不同的事件： text 和 textarea 元素使用 value property 和 input 事件； checkbox 和 radio 使用 checked property 和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 .lazy在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步。你可以添加 lazy 修饰符，从而转为在 change 事件之后进行同步： 12&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; /&gt; .number如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符： 1&lt;input v-model.number=&quot;age&quot; type=&quot;text&quot; /&gt; 当输入类型为 text 时这通常很有用。如果输入类型是 number，Vue 能够自动将原始字符串转换为数字，无需为 v-model 添加 .number 修饰符。如果这个值无法被 parseFloat() 解析，则返回原始的值。 .trim如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符： 1&lt;input v-model.trim=&quot;msg&quot; /&gt; 全局APIh返回一个”虚拟节点“，通常缩写为VNode：一个普通对象，其中包含向 Vue 描述它应在页面上渲染哪种节点的信息，包括所有子节点的描述。它的目的是用于手动编写的渲染函数： render() { return h(‘h1’, {}, ‘Some title’)} 参数接收三个参数：type，props 和 children","categories":[{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://zouhualu.github.io/tags/Vue/"}]},{"title":"装饰器的使用","slug":"装饰器的使用","date":"2021-12-23T06:37:11.000Z","updated":"2021-12-24T07:15:50.878Z","comments":true,"path":"20211223/装饰器的使用/","link":"","permalink":"https://zouhualu.github.io/20211223/%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"在 create-react-app 搭建的项目中使用装饰器 执行yarn eject命令，暴露出配置项 因为装饰器是新的提案，许多浏览器和 Node 环境并不支持，所以我们需要安装插件：@babel/plugin-proposal-decorators。使用create-react-app创建的项目自带这个插件，不过我们需要配置一下，找到package.json文件加入一下代码： 1234567&#123; &quot;babel&quot;: &#123; &quot;presets&quot;: [&quot;react-app&quot;], &quot;plugins&quot;: [[&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125;]] &#125;&#125; 另外 vscode 可能会提示你需要配置tsconfig或jsconfig文件，我们在项目根目录创建jsconfig.js，并写入： 12345&#123; &quot;compilerOptions&quot;: &#123; &quot;experimentalDecorators&quot;: true &#125;&#125; 这样就能愉快的在项目中使用装饰器了 装饰器的使用使用装饰器修饰类1234567891011121314151617//声明一个装饰器function fn(target) &#123; //这个函数的`target`指的就是装饰器要修饰的类 target.test = false;&#125;@fn //使用装饰器class Person &#123; //声明一个类&#125;@fnclass Dog &#123; //声明另一个类&#125;console.log(Person.test); //falseconsole.log(Dog.test); //false 可以看到Person类和Dog类下面多出了一个test属性，这就体现了装饰器的优点，无需更改类的内部代码也无需去继承就可以给类添加新功能 使用装饰器传参1234567891011121314151617@fn@fn2(5)class Person &#123;&#125;function fn(target) &#123; target.test = false;&#125;function fn2(value) &#123; return function (target) &#123; //这个函数的`target`指的就是装饰器要修饰的类 target.count = value; &#125;;&#125;console.log(Person.test);console.log(Person.count); 声明一个装饰器fn2，它接收一个值，并且返回一个函数，这个函数的target指的就是装饰器要修饰的类 使用装饰器添加实例属性123456789101112131415161718192021@fn@fn2(5)@fn3class Person &#123;&#125;function fn(target) &#123; target.test = false;&#125;function fn2(value) &#123; return function (target) &#123; target.count = value; &#125;;&#125;function fn3(target) &#123; target.prototype.foo = &quot;hhh&quot;; // target指的就是装饰的类，在类的原型对象上添加一个属性foo&#125;const test1 = new Person(); // new一个实例出来console.log(test1.foo); 实现一个混入 mixins 功能1234567891011121314151617181920// 实现一个mixins功能export function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list); &#125;;&#125;import &#123; mixins &#125; from &quot;./mixins&quot;;const Test = &#123; test() &#123; console.log(&quot;这是测试&quot;); &#125;,&#125;;@mixins(Test)class Myclass &#123;&#125;const newMyclass = new Myclass();newMyclass.test(); //这是测试 使用装饰器修饰类的成员12345678910111213141516171819202122232425262728293031323334353637@fn@fn2(5)@fn3class Person &#123; @readonly message = &quot;hello&quot;;&#125;function fn(target) &#123; target.test = false;&#125;function fn2(value) &#123; return function (target) &#123; target.count = value; &#125;;&#125;function fn3(target) &#123; target.prototype.foo = &quot;hhh&quot;;&#125;function readonly(target, name, descriptor) &#123; console.log(target); //目标类的原型对象 xxx.prototype console.log(name); // 被修饰的类的成员名称 console.log(descriptor); /*被修饰的类的成员的描述对象： configurable: 能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true enumerable: 是否被遍历，对象属性是否可通过for-in循环，flase为不可循环，默认值为true initializer: 对象属性的默认值，默认值为undefined writable: 对象属性是否可修改,flase为不可修改，默认值为true */ descriptor.writable = false;&#125;const test1 = new Person();test1.message = &quot;你好&quot;; 它接收三个参数，具体看以上代码注释","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"目前感兴趣以及值得学习的技术","slug":"2021-12-23-每日TODO","date":"2021-12-23T06:00:54.000Z","updated":"2022-03-29T11:54:44.125Z","comments":true,"path":"20211223/2021-12-23-每日TODO/","link":"","permalink":"https://zouhualu.github.io/20211223/2021-12-23-%E6%AF%8F%E6%97%A5TODO/","excerpt":"","text":"mobx，状态管理工具 Flutter，Flutter 是 Google 开源的应用开发框架，仅通过一套代码库，就能构建精美的、原生平台编译的多平台应用。链接：https://flutter.cn/ Fiber，一个受express启发，用Go编写的web框架。Fiber是一个建立在fastttp之上的Go web框架，fastttp是Go最快的HTTP引擎。它的设计是为了在零内存分配和零性能的情况下简化快速开发。 Taro，Taro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ / 飞书 小程序 / H5 / RN 等应用。","categories":[],"tags":[{"name":"TODO","slug":"TODO","permalink":"https://zouhualu.github.io/tags/TODO/"}]},{"title":"React搭配Mobx开发","slug":"React搭配Mobx开发","date":"2021-12-22T08:06:55.000Z","updated":"2021-12-24T07:15:50.877Z","comments":true,"path":"20211222/React搭配Mobx开发/","link":"","permalink":"https://zouhualu.github.io/20211222/React%E6%90%AD%E9%85%8DMobx%E5%BC%80%E5%8F%91/","excerpt":"","text":"今天试了一下React搭配Mobx开发，确实好用 先挖个坑，有空来填","categories":[{"name":"技术类-React","slug":"技术类-React","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://zouhualu.github.io/tags/React/"}]},{"title":"React随笔","slug":"React随笔","date":"2021-12-18T11:08:44.000Z","updated":"2022-07-02T06:01:19.831Z","comments":true,"path":"20211218/React随笔/","link":"","permalink":"https://zouhualu.github.io/20211218/React%E9%9A%8F%E7%AC%94/","excerpt":"","text":"React 中的thisReact 的官方文档里写的自定义的方法都需要用 bind 方法绑定一下才能使用，否则 this 会出现指向问题，那究竟是为什么呢？ 探讨一12345678910111213141516class Person &#123; constructor(props)&#123; this.state = &#123; ...... &#125; &#125; render()&#123; return &lt;div onClick=&#123;demo&#125;&gt;你好，DexterHwang&lt;/div&gt; &#125;&#125;function demo()&#123; console.log(this.state) // 会报错，注意此处的this&#125;ReactDom.render(&lt;Person /&gt;,document.getElementById(&#x27;app&#x27;)) React 中的 Babel 使用了严格模式，所以写的全局的 this指向的是undefined 而且 demo 方法并不写在 Person 类中，所以这个 this 也不会指向 Person 的实例对象 探讨二123456789101112131415161718class Person &#123; constructor(props)&#123; this.state = &#123; ...... &#125; &#125; render()&#123; return &lt;div onClick=&#123;demo&#125;&gt;你好，DexterHwang&lt;/div&gt; // 会报错，报错信息为：`demo is not defined`。`onClick=&#123;demo&#125;`是找不到 `demo` 方法的 // return &lt;div onClick=&#123;this.demo&#125;&gt;你好，DexterHwang&lt;/div&gt; // 这样写也会报错，因为并不是通过实例对象去调用demo方法。由于demo是作为onClick的回调，不是通过实例调用的，是直接调用。类中的方法默认开启了局部的严格模式，所以this值是undefined &#125; // demo方法在Person的原型对象(prototype)上，也就是在Person的实例对象的原型链上(_proto_) // 只有通过Person实例对象调用demo方法时，demo里面的this指向的就是Person的实例对象 demo()&#123; console.log(this) &#125;&#125;ReactDom.render(&lt;Person /&gt;,document.getElementById(&#x27;app&#x27;)) 我们看下面的例子 1234567891011121314class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; study() &#123; console.log(this); &#125;&#125;const p1 = new Person(&quot;DexterHwang&quot;, 18);p1.study(); //&#123;name:&#x27;DexterHwang&#x27;,age:18&#125;const x = p1.study;x(); // 输出undefined p1 的原型链上是可以找到 study 方法的，然后把 study 方法赋值给了 x。也就相当于在栈上多了一个指针指向了 study 方法，这下 x 就彻底和 p1 没有关系了 另外，再明确一点：_类中自定义的方法，都会启用局部严格模式_。也就是说 this 的值是 undefined 也就是说 x 执行后 this 值就是 undefined 验证：类中自定义的方法，都会启用局部严格模式 1234567891011function test() &#123; console.log(this);&#125;function test2() &#123; &quot;use strict&quot;; console.log(this);&#125;test(); // windowtest2(); // undefined 分析 this.demo = this.demo.bind(this)为什么用 bind()就可以解决 this 指向问题呢？ 12345678910111213141516171819 class Person &#123; constructor(props)&#123; this.state = &#123; ...... &#125; this.demo = this.demo.bind(this) &#125; render()&#123; return &lt;div onClick=&#123;this.demo&#125;&gt;你好，DexterHwang&lt;/div&gt; &#125; demo()&#123; console.log(this) &#125;&#125;ReactDom.render(&lt;Person /&gt;,document.getElementById(&#x27;app&#x27;))// 点击后会输出：Person&#123;...&#125; 分析this.demo = this.demo.bind(this) 等号右侧的第一个 this 指向的是实例对象，这个实例对象上有 demo 方法吗？有，但是实在原型链上的。 bind 方法做两件事： 将 this 牢牢的绑定到传入的参数上 返回一个新的函数 等号右边第二个 this，也就是传入的参数，这个 this 指的就是实例对象 这样的话返回了一个新的函数，而且这个函数牢牢的绑定到了实例对象上，并不需要去原型链上找了 再看等号左侧，将返回的新函数赋值给了 this，这个 this 也是 Person 实例对象，用相同的方法名接收一下 这样就可以使用了 我们这样再去看onClick=&#123;this.demo&#125;,这下再点击后执行的就是实例自身上的 demo 方法了。 2021-12-25 更新—— React17 对比新旧生命周期新的生命周期和旧的生命周期相比，即将废弃三个钩子：componentWillMount、componentWillUpdate、componentWillReceiveProps 新增了两个新的钩子：getDerivedStateFromProps、getSnapshotBeforeUpdate 剩下的都和之前的一样的 2021-12-16 更新—— React 配置代理单个代理可以直接在package.json文件中配置proxy 多个代理则需要新建一个setupProxy.js文件，配置如下： 1234567891011121314151617const proxy = require(&quot;http-proxy-middleware&quot;);module.exports = function (app) &#123; app.use( proxy(&quot;/api1&quot;, &#123; //遇见api1前缀的请求，就会触发这个代理配置 target: &quot;http://localhost:5000&quot;, // 请求转发给谁，也就是服务器地址 changeOrigin: true, // 控制服务器收到的请求头中Host的值，这里是localhost:5000 pathRewrite: &#123; &quot;^/api1&quot;: &quot;&quot; &#125;, // 重写请求路径 &#125;), proxy(&quot;/api2&quot;, &#123; target: &quot;http://localhost:5001&quot;, changeOrigin: true, pathRewrite: &#123; &quot;^/api2&quot;: &quot;&quot; &#125;, &#125;) );&#125;; create-react-app脚手架会自动找到setupProxy.js文件，并将配置加入到 webpack 中 2021-12-27 更新—— React 路由原理靠的是 H5 推出的 history 上的 API 12345678910111213141516171819202122232425//路由跳转function push(path) &#123; history.push(path); return false;&#125;// 路由替换function replace(path) &#123; history.replace(path);&#125;// 路由回退function back() &#123; history.goBack();&#125;// 路由前进function forword() &#123; history.goForward();&#125;// 监听路由变化history.listen((location) =&gt; &#123; console.log(&quot;监听路由变化&quot;);&#125;); 2021-12-28 更新—— 全局事件总线用第三方库mitt或者pubsub，可以实现多层级的组件之间的通信 2021-12-30 更新—— React 的 setState()异步执行 多个 setState()会推到一个任务队列里面，将多次执行合并为一个来执行。 setState()的几种写法 1234567891011121314151617181920212223242526//常规写法，这种写法会将多次setState()方法合并// counter的初始值为1this.setState(&#123; counter: this.state.counter + 1,&#125;);this.setState(&#123; counter: this.state.counter + 1,&#125;);this.setState(&#123; counter: this.state.counter + 1,&#125;);// counter的值是2// ----------------------------------------// 这种写法和上面执行结果不同，preState拿到的是最新的设置后的值（上一个setState设置的值）this.setState((preState) =&gt; (&#123; counter: preState.counter + 1,&#125;));this.setState((preState) =&gt; (&#123; counter: preState.counter + 1,&#125;));this.setState((preState) =&gt; (&#123; counter: preState.counter + 1,&#125;));// counter的值是4 setState()方法里的第二个参数是一个回调函数，该函数能拿到设置之后的值 2021-12-31 更新—— 无副作用在 React 里经常看到无副作用这个词，它表示它只对自身有影响对自身以外的无影响，所有的输出都是由我的输入来决定的。 发一个请求，设置了 localstorage，对外部进行了操作这都叫做副作用 React 生命周期 组件初始化阶段 initialization, 比如 constructor 组件挂载阶段 mount componentWillMount 组件挂载到 DOM 前调用,只会被调用一次, 这里写 setState 不会引起组件重新渲染 render 返回一个 react 元素, react 根据此函数的返回值渲染 DOM. 不能在这里 setState componentDidMount 组件挂载到 DOM 后调用, 且只会被调用一次 组件的更新阶段 update componentWillReceiveProps(nextProps) 触发于 props 引起的组件更新过程中 shouldComponentUpdate(nextProps, nextState) 比较之前和当前的 props state 是否有变化 componentWillUpdate(nextProps, nextState) render 方法前执行 render componentDidUpdate(preProps, preState) 组件的卸载阶段 unmount componentWillUnmount 卸载前调用, 在这里可以清理一些定时器 componentWillMount,componentWillReceiveProps,componentWillUnmount在 React17 不建议使用，即将被废弃 2022-06-30 更新 React 的虚拟 DOM在 React，我们操作的元素被称为 React 元素，并不是真正的原生 DOM 元素。 React 通过虚拟 DOM，将 React 元素和原生 DOM，进行映射，虽然操作的是 React 元素，但是这些操作最终都会在真实的 DOM 中体现。 虚拟 DOM 的好处： 降低 api 复杂度（远离原生的复杂的 dom 操作） 解决兼容性问题 提升性能（减少 DOM 的不必要操作） 每当我们调用 root.render()时，页面就会发生重新渲染 React 会通过 diffing 算法，将新的元素和旧的元素进行比较 通过比较找到发生变化的元素，并且只对变化的元素进行修改，没有发生的变化不予处理。 比较两次数据时，React 会先比较父元素，父元素如果不同，直接所有元素全部替换。父元素一致，再去逐个比较子元素，直到找到所有发生变化的元素为止。 在 JSX 中显示数组时，数组中的每一个元素都需要设置一个唯一的 key，否则控制台会报警告。 重新渲染页面时，React 会按照顺序依次比较对应的元素，当渲染一个列表时如果不指定 key，同样也会按照顺序进行比较。如果列表的顺序永远不会发生变化，不加 key 没有问题。但是如果列表的顺序会发生变化，这可能会导致性能问题。 尽量用元素的 id 来做 key 用遍历的 索引 index 来做 key，没有意义，仍然会全部更新 当元素的顺序不会发生变化时，用索引 index 做 key，没有问题","categories":[{"name":"技术类-React","slug":"技术类-React","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-React/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"React","slug":"React","permalink":"https://zouhualu.github.io/tags/React/"}]},{"title":"JavaScript的同步与异步","slug":"JavaScript的同步与异步","date":"2021-12-14T07:10:10.000Z","updated":"2021-12-18T11:07:41.867Z","comments":true,"path":"20211214/JavaScript的同步与异步/","link":"","permalink":"https://zouhualu.github.io/20211214/JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/","excerpt":"","text":"更详细的可以点这里 异步JavaScript异步指两个或两个以上的对象或事件不同时存在或发生（或多个相关事物的发生无需等待其前一事物的完成） 同步JavaScript各方都实时（或者尽可能实时）地收取（而且必要的话也处理或者回复）信息的即时沟通方式，即为同步。 电话即为一个日常的例子：人们都倾向于在使用电话时即时地作出回应。 许多程序指令也是实时的：例如当输入一个算式时，除非编程人员有意为止，否则环境都会立即将结果反馈回来。 事件队列像promise这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境。 Promises 对比 callbackspromises与旧式callbacks有一些相似之处。它们本质上是一个返回的对象，您可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。 然而，Promise是专门为异步操作而设计的，与旧式回调相比具有许多优点: 您可以使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作。这种链接方式对回调来说要难得多，会使回调以混乱的“末日金字塔”告终。 (也称为回调地狱)。 Promise总是严格按照它们放置在事件队列中的顺序调用。 错误处理要好得多——所有的错误都由块末尾的一个.catch()块处理，而不是在“金字塔”的每一层单独处理。 异步代码的本质让我们研究一个示例，它进一步说明了异步代码的本质，展示了当我们不完全了解代码执行顺序以及将异步代码视为同步代码时可能发生的问题 12345678910111213141516console.log (&#x27;Starting&#x27;);let image;fetch(&#x27;coffee.jpg&#x27;).then((response) =&gt; &#123; console.log(&#x27;It worked :)&#x27;) return response.blob();&#125;).then((myBlob) =&gt; &#123; let objectURL = URL.createObjectURL(myBlob); image = document.createElement(&#x27;img&#x27;); image.src = objectURL; document.body.appendChild(image);&#125;).catch((error) =&gt; &#123; console.log(&#x27;There has been a problem with your fetch operation: &#x27; + error.message);&#125;);console.log (&#x27;All done!&#x27;); 浏览器将会执行代码，看见第一个console.log() 输出Starting ，然后创建image变量。 然后，它将移动到下一行并开始执行fetch()块，但是，因为fetch()是异步执行的，没有阻塞，所以在promise相关代码之后程序继续执行，从而到达最后的console.log()语句All done!并将其输出到控制台。 只有当fetch() 块完成运行返回结果给.then()，我们才最后看到第二个console.log()消息 It worked ;)。所以 这些消息可能以和你预期不同的顺序出现： Starting All done! It worked :) 如果你感到疑惑，考虑下面这个小例子： 1234567console.log(&quot;registering click handler&quot;);button.addEventListener(&#x27;click&#x27;, () =&gt; &#123; console.log(&quot;get click&quot;);&#125;);console.log(&quot;all done&quot;); 这在行为上非常相似——第一个和第三个console.log()消息将立即显示，但是第二个消息将被阻塞，直到有人单击鼠标按钮。前面的示例以相同的方式工作，只是在这种情况下，第二个消息在promise链上被阻塞，直到获取资源后再显示在屏幕上，而不是单击。 要查看实际情况，并将第三个console.log()调用更改为以下命令： 1console.log (&#x27;All done! &#x27; + image.src + &#x27;displayed.&#x27;); 此时控制台将会报错，而不会显示第三个 console.log 的信息： 1TypeError: image is undefined; can&#x27;t access its &quot;src&quot; property 这是因为：浏览器运行第三个console.log()的时候，fetch() 语句块还没有完成，因此image还没有赋值。 小结JavaScript是一种同步的、阻塞的、单线程的语言，在这种语言中，一次只能执行一个操作。 但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是异步地调用函数(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。 这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。 异步还是同步执行代码，取决于我们要做什么 同步-如果我们希望事情能够立即加载并发生。例如，当将一些用户定义的样式应用到一个页面时，您希望这些样式能够尽快被应用。 异步-如果我们正在运行一个需要时间的操作，比如查询数据库并使用结果填充模板，那么最好将该操作从主线程中移开使用异步完成任务。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"git rebase 用法","slug":"git-rebase-用法","date":"2021-12-02T09:16:28.000Z","updated":"2021-12-18T11:07:41.867Z","comments":true,"path":"20211202/git-rebase-用法/","link":"","permalink":"https://zouhualu.github.io/20211202/git-rebase-%E7%94%A8%E6%B3%95/","excerpt":"","text":"参考自此文章 以前提交代码一直是用命令行提交的 123456// 一把梭git pullgit add .git commit -m &#x27;xxxxxx&#x27;git push 在多人开发项目下，这样提交的话会有如下效果: 当很多人都把自己的分支合到主分支的时候，这样会显得主线很乱而且还会有自动生成的提交信息 所以提倡用git rebase 使用 rebase 和 merge 的基本原则 下游分支更新上游分支内容的时候使用 rebase 上游分支合并下游分支内容的时候使用 merge 更新当前分支的内容时一定要使用 –rebase 参数 例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 git rebase master 等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 git merge dev 实际开发中遇到操作当你和其他人在同一个分支开发时，在你提交的时候发现有人已经提交了一些东西上去了，你可以这样操作： git pull --rebase git push 你也可以使用vscode上下载的git插件来操作： 然后再push上去。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"create-react-app 搭建项目踩坑记录","slug":"create-react-app-搭建项目踩坑记录","date":"2021-11-29T11:44:25.000Z","updated":"2021-12-18T11:07:41.866Z","comments":true,"path":"20211129/create-react-app-搭建项目踩坑记录/","link":"","permalink":"https://zouhualu.github.io/20211129/create-react-app-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"中文说明搭建前端开发环境笔记由npx create-react-app articles_published_system创建的项目 后来漏掉了typescript支持，原本可以由命令npx create-react-app articles_published_system --template typescript可以直接创建支持ts的应用 后续要将ts添加到已有项目中，用以下命令： npm install --save typescript @types/node @types/react @types/react-dom @types/jest 项目中配置sass: 执行yarn add node-sass下载包（按理说执行npm install node-sass --save也应该有用，但是我这边报错了）。 报错如下： 我的vscode和node版本都是最新的 建议大家用yarn来安装项目 发现启动后sass会报错 解决办法：sass指定版本为^1.43.5，postcss-pxtorem为^5.1.1，不要安装node-sass了 前端生态配置仍然复杂 将样式文件后缀改为.scss并在tsx或者js文件中引入，项目会自动编译。 为了实现自适应，给项目配置postcss-pxtorem 执行yarn add lib-flexible postcss-pxtorem 在应用入口引入import &#39;lib-flexible&#39; 执行npm run eject可以打开create-react-app应用的配置文件 在config/webpack.config.js文件中配置postcss，位置及方法如下图： UI库使用antdesign 安装antd，yarn add antd 在App.css 中导入样式@import &#39;~antd/dist/antd.css&#39;，然后在组件中引入相应的ui组件就可以用了。 完~","categories":[{"name":"技术类-React","slug":"技术类-React","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://zouhualu.github.io/tags/React/"}]},{"title":"最近在忙什么","slug":"最近在忙什么","date":"2021-11-18T08:59:09.000Z","updated":"2021-12-18T11:07:41.866Z","comments":true,"path":"20211118/最近在忙什么/","link":"","permalink":"https://zouhualu.github.io/20211118/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%BF%99%E4%BB%80%E4%B9%88/","excerpt":"","text":"最近在做一个个人的全栈项目 前端技术栈是：Vite+Vue3+TypeScript+Scss 后端技术栈是：NodeJs+Express+MySQL 已经上线一部分功能,部署在阿里云上了 目前没啥功能。后续会慢慢完善优化 地址在：www.hjzouhualu.com","categories":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Node.js学习记录","slug":"Node-js学习记录","date":"2021-10-31T06:26:14.000Z","updated":"2021-12-18T11:10:28.717Z","comments":true,"path":"20211031/Node-js学习记录/","link":"","permalink":"https://zouhualu.github.io/20211031/Node-js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"使用 exports 从 Node.js 文件中公开功能两种方式： 第一种方式是将对象赋值给 module.exports（这是模块系统提供的对象），这会使文件只导出该对象: 12345678910const car = &#123; brand: &quot;Ford&quot;, model: &quot;Fiesta&quot;,&#125;;module.exports = car;//在另一个文件中const car = require(&quot;./car&quot;); 第二种方式是将要导出的对象添加为 exports 的属性。这种方式可以导出多个对象、函数或数据： 123456const car = &#123; brand: &quot;Ford&quot;, model: &quot;Fiesta&quot;,&#125;;exports.car = car; 或者直接 1234exports.car = &#123; brand: &quot;Ford&quot;, model: &quot;Fiesta&quot;,&#125;; 在另一个文件中，则通过引用导入的属性来使用它： 12const items = require(&quot;./items&quot;);items.car; 或 1const car = require(&quot;./items&quot;).car; module.exports 和 export 之间有什么区别？ 前者公开了它指向的对象。 后者公开了它指向的对象的属性。 package.json 指南package.json 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 npm 和 yarn 存储所有已安装软件包的名称和版本的地方。 对于应用程序，package.json 文件中的内容没有固定的要求。 唯一的要求是必须遵守 JSON 格式，否则，尝试以编程的方式访问其属性的程序则无法读取它。 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#123; &quot;name&quot;: &quot;test-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;A Vue.js project&quot;, &quot;main&quot;: &quot;src/main.js&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;, &quot;test&quot;: &quot;npm run unit&quot;, &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit&quot;, &quot;build&quot;: &quot;node build/build.js&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.5.2&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;^7.1.2&quot;, &quot;babel-core&quot;: &quot;^6.22.1&quot;, &quot;babel-eslint&quot;: &quot;^8.2.1&quot;, &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;, &quot;babel-jest&quot;: &quot;^21.0.2&quot;, &quot;babel-loader&quot;: &quot;^7.1.1&quot;, &quot;babel-plugin-dynamic-import-node&quot;: &quot;^1.2.0&quot;, &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;, &quot;babel-plugin-transform-es2015-modules-commonjs&quot;: &quot;^6.26.0&quot;, &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;, &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.5.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;, &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;, &quot;chalk&quot;: &quot;^2.0.1&quot;, &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;, &quot;css-loader&quot;: &quot;^0.28.0&quot;, &quot;eslint&quot;: &quot;^4.15.0&quot;, &quot;eslint-config-airbnb-base&quot;: &quot;^11.3.0&quot;, &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;, &quot;eslint-import-resolver-webpack&quot;: &quot;^0.8.3&quot;, &quot;eslint-loader&quot;: &quot;^1.7.1&quot;, &quot;eslint-plugin-import&quot;: &quot;^2.7.0&quot;, &quot;eslint-plugin-vue&quot;: &quot;^4.0.0&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;, &quot;file-loader&quot;: &quot;^1.1.4&quot;, &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;, &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;, &quot;jest&quot;: &quot;^22.0.4&quot;, &quot;jest-serializer-vue&quot;: &quot;^0.3.0&quot;, &quot;node-notifier&quot;: &quot;^5.1.2&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;ora&quot;: &quot;^1.2.0&quot;, &quot;portfinder&quot;: &quot;^1.0.13&quot;, &quot;postcss-import&quot;: &quot;^11.0.0&quot;, &quot;postcss-loader&quot;: &quot;^2.0.8&quot;, &quot;postcss-url&quot;: &quot;^7.2.1&quot;, &quot;rimraf&quot;: &quot;^2.6.0&quot;, &quot;semver&quot;: &quot;^5.3.0&quot;, &quot;shelljs&quot;: &quot;^0.7.6&quot;, &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.1&quot;, &quot;url-loader&quot;: &quot;^0.5.8&quot;, &quot;vue-jest&quot;: &quot;^1.0.2&quot;, &quot;vue-loader&quot;: &quot;^13.3.0&quot;, &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;, &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;, &quot;webpack&quot;: &quot;^3.6.0&quot;, &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;, &quot;webpack-merge&quot;: &quot;^4.1.0&quot; &#125;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;= 6.0.0&quot;, &quot;npm&quot;: &quot;&gt;= 3.0.0&quot; &#125;, &quot;browserslist&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]&#125; 这里有很多东西： version 表明了当前的版本。 name 设置了应用程序/软件包的名称。 description 是应用程序/软件包的简短描述。 main 设置了应用程序的入口点。 private 如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。 scripts 定义了一组可以运行的 node 脚本。 dependencies 设置了作为依赖安装的 npm 软件包的列表。 devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。 engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。 browserslist 用于告知要支持哪些浏览器（及其版本）。以上所有的这些属性都可被 npm 或其他工具使用。 package-lock.json 文件该文件旨在跟踪被安装的每个软件包的确切版本，以便产品可以以相同的方式被 100％ 复制（即使软件包的维护者更新了软件包）。 npm 依赖与开发依赖当使用 npm install &lt;package-name&gt; 安装 npm 软件包时，是将其安装为依赖项。 该软件包会被自动地列出在 package.json 文件中的 dependencies 列表下（在 npm 5 之前：必须手动指定 --save）。 当添加了 -D 或 --save-dev 标志时，则会将其安装为开发依赖项（会被添加到 devDependencies 列表）。 开发依赖是仅用于开发的程序包，在生产环境中并不需要。 例如测试的软件包、webpack 或 Babel。 当投入生产环境时，如果输入 npm install 且该文件夹包含 package.json 文件时，则会安装它们，因为 npm 会假定这是开发部署。 Node.js 包运行器 npxs 轻松地运行本地命令 Node.js 开发者过去通常将大多数可执行命令发布为全局的软件包，以使它们处于路径中且可被立即地执行。 运行 npx commandname 会自动地在项目的 node_modules 文件夹中找到命令的正确引用，而无需知道确切的路径，也不需要在全局和用户路径中安装软件包。 无需安装的命令执行 npx 的另一个重要的特性是，无需先安装命令即可运行命令。 使用不同的 Node.js 版本运行代码 直接从 URL 运行任意代码片段 Node.js 事件循环原文链接：Node.js 事件循环 一个简单的事件循环的阐释12345678910111213141516const bar = () =&gt; console.log(&quot;bar&quot;);const baz = () =&gt; console.log(&quot;baz&quot;);const foo = () =&gt; &#123; console.log(&quot;foo&quot;); bar(); baz();&#125;;foo();// 输出// foo// bar// baz 当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 bar()，然后调用 baz()。 此时，调用堆栈如下所示： 入队函数执行123456789101112131415161718const bar = () =&gt; console.log(&quot;bar&quot;);const baz = () =&gt; console.log(&quot;baz&quot;);const foo = () =&gt; &#123; console.log(&quot;foo&quot;); setTimeout(bar, 0); baz();&#125;;foo();/** * 打印输出： * foo * baz * bar */ 当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 setTimeout，将 bar 作为参数传入，并传入 0 作为定时器指示它尽快运行。 然后调用 baz()。 调用堆栈如图： 执行顺序是： 为什么会这样呢？ 消息队列当调用 setTimeout() 时，浏览器或 Node.js 会启动定时器。 当定时器到期时（在此示例中会立即到期，因为将超时值设为 0），则回调函数会被放入“消息队列”中。 在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 onLoad 这样的 DOM 事件也如此。 事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。 我们不必等待诸如 setTimeout、fetch、或其他的函数来完成它们自身的工作，因为它们是由浏览器提供的，并且位于它们自身的线程中。 例如，如果将 setTimeout 的超时设置为 2 秒，但不必等待 2 秒，等待发生在其他地方。 ES6 作业队列ECMAScript 2015 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。 在当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。 有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。 例子： 123456789101112131415161718192021const bar = () =&gt; console.log(&#x27;bar&#x27;)const baz = () =&gt; console.log(&#x27;baz&#x27;)const foo = () =&gt; &#123; console.log(&#x27;foo&#x27;) setTimeout(bar, 0) new Promise((resolve, reject) =&gt; resolve(&#x27;应该在 baz 之后、bar 之前&#x27;) ).then(resolve =&gt; console.log(resolve)) baz()&#125;foo()/** * 输出： * foo * baz * 应该在 baz 之后、bar 之前 * bar * / 这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。 了解 process.nextTick()当尝试了解 Node.js 事件循环时，其中一个重要的部分就是 process.nextTick()。 每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。 当将一个函数传给 process.nextTick() 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数 事件循环正在忙于处理当前的函数代码。 当该操作结束时，JS 引擎会运行在该操作期间传给 nextTick 调用的所有函数。 这是可以告诉 JS 引擎异步地（在当前函数之后）处理函数的方式，但是尽快执行而不是将其排入队列。 调用 setTimeout(() =&gt; {}, 0) 会在下一个滴答结束时执行该函数，比使用 nextTick()（其会优先执行该调用并在下一个滴答开始之前执行该函数）晚得多。 也就是说在当前调用堆栈的执行完成后就开始执行process.nextTick()里面的函数 了解 setImmediate()作为 setImmediate() 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调。 setImmediate() 与 setTimeout(() =&gt; {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？传给 process.nextTick() 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 setTimeout 和 setImmediate 之前执行。 延迟 0 毫秒的 setTimeout() 回调与 setImmediate() 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。","categories":[{"name":"技术类-Node.js","slug":"技术类-Node-js","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://zouhualu.github.io/tags/Node-js/"}]},{"title":"call,apply和bind","slug":"call-apply和bind","date":"2021-10-21T03:18:44.000Z","updated":"2021-10-31T06:14:39.296Z","comments":true,"path":"20211021/call-apply和bind/","link":"","permalink":"https://zouhualu.github.io/20211021/call-apply%E5%92%8Cbind/","excerpt":"","text":"call，apply和bind都是用来改变this的指向，但是他们在使用和功能上各有区别。 call() 方法call() 方法的作用call() 方法的作用：可以调用一个函数，与此同时，它还可以改变这个函数内部的 this 指向。 call() 方法的另一个应用：可以实现继承。之所以能实现继承，其实是利用了上面的作用。 语法1fn1.call(想要将this指向哪里, 函数实参1, 函数实参2); 备注：第一个参数中，如果不需要改变 this 指向，则传 null。 call() 方法举例举例 1、通过 call() 调用函数： 123456789const obj1 = &#123; nickName: &#x27;走花鹿&#x27;, age: 26,&#125;;function fn1() &#123; console.log(this); console.log(this.nickName);&#125;fn1.call(this); // this的指向并没有被改变，此时相当于 fn1(); 上方代码的打印结果： 12windowundefined 上面的代码，跟普通的函数调用 fn1() 没有区别。 举例 2、通过 call() 改变 this 指向： 123456789101112var obj1 = &#123; nickName: &#x27;走花鹿&#x27;, age: 26,&#125;;function fn1(a, b) &#123; console.log(this); console.log(this.nickName); console.log(a + b);&#125;fn1.call(obj1, 2, 4); // 先将 this 指向 obj1，然后执行 fn1() 函数 上方代码的打印结果： 123obj1走花鹿6 举例 3、通过 call() 实现继承： 1234567891011121314// 给 Father 增加 name 和 age 属性function Father(myName, myAge) &#123; this.name = myName; this.age = myAge;&#125;function Son(myName, myAge) &#123; // 【下面这一行，重要代码】 // 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承 Father.call(this, myName, myAge);&#125;const son1 = new Son(&#x27;走花鹿&#x27;, 26);console.log(JSON.stringify(son1)); 上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。 打印结果： 1&#123;&quot;myName&quot;:&quot;走花鹿&quot;,&quot;myAge&quot;:26&#125; apply() 方法apply() 方法的作用apply() 方法的作用：可以调用一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。 apply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。 语法1fn1.apply(想要将this指向哪里, [函数实参1, 函数实参2]); 备注：第一个参数中，如果不需要改变 this 指向，则传 null。 到这里可以看出， call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。 apply() 方法举例举例、通过 apply() 改变 this 指向： 123456789101112var obj1 = &#123; nickName: &#x27;走花鹿&#x27;, age: 26,&#125;;function fn1(a) &#123; console.log(this); console.log(this.nickName); console.log(a);&#125;fn1.apply(obj1, [&#x27;hello&#x27;]); // 先将 this 指向 obj1，然后执行 fn1() 函数 注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。 打印结果： 123obj1走花鹿hello apply() 方法的巧妙应用：求数组的最大值我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？ 虽然数组里没有获取最大值的方法，但是数值里面有 Math.max(数字1，数字2，数字3) 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。 举例：求数组中多个元素的最大值： 12345678const arr1 = [3, 7, 10, 8];// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。const maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值console.log(maxValue);const minValue = Math.min.apply(Math, arr1); // 求数组 arr1 中元素的最小值console.log(minValue); 打印结果： 12103 bind() 方法bind() 方法的作用bind() 方法不会调用函数，但是可以改变函数内部的 this 指向。 把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。 语法 1新函数 = fn1.bind(想要将this指向哪里, 函数实参1, 函数实参2); 参数： 第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。 其他参数：fn1 函数的实参。 解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Array数组的一些发现","slug":"Array数组的一些发现","date":"2021-10-20T05:49:22.000Z","updated":"2021-10-31T06:14:39.296Z","comments":true,"path":"20211020/Array数组的一些发现/","link":"","permalink":"https://zouhualu.github.io/20211020/Array%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%91%E7%8E%B0/","excerpt":"","text":"今天对一些元素都是纯数字的数组做forEach遍历操作，发现无法改变原数组，查找了一些资料发现，forEach只能处理数组中的引用类型，元素为基础类型的需要另外的写法。如下： 123456789101112131415161718192021let arr = [1, 2, 3, 4, 5]let arr1 = [1, 2, 3, 4, 5]let arr2 = [&#123;a:1,b:2&#125;]// 元素为基础类型number，原数组不变arr.forEach(item =&gt; &#123; item += 1&#125;)// 这种写法可行arr1.forEach((item, index) =&gt; &#123; arr1[index] += 1&#125;)// 元素为引用类型的，原数组会改变arr2.forEach(item=&gt;&#123; item.a = 66&#125;)console.log(arr);console.log(arr1);console.log(arr2); 这主要是和计算机的堆栈有关。基础类型是存储在栈中，forEach中得到item也是存储于栈中，所以它就和数组中的元素毫无关系了；而对象是存储于堆中，遍历的时候item虽然在栈中但是它的指针会指向堆中的位置，所以可以直接修改原数组。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"}]},{"title":"JavaScript事件循环","slug":"JavaScript事件循环","date":"2021-10-14T03:17:45.000Z","updated":"2021-10-31T06:14:39.295Z","comments":true,"path":"20211014/JavaScript事件循环/","link":"","permalink":"https://zouhualu.github.io/20211014/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"这一篇讲的也特别清楚，建议看看：这一次，彻底弄懂 JavaScript 执行机制 一、是什么JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事 为什么要这么设计，跟JavaScript的应用场景有关 JavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除 DOM ，另一个添加 DOM，此时浏览器该如何处理？ 为了解决单线程运行阻塞问题，JavaScript用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop） 事件循环（Event Loop）在JavaScript中，所有的任务都可以分为 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行 异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等 同步任务与异步任务的运行流程图如下： 从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环 二、宏任务与微任务如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子： 1234567891011121314console.log(1)setTimeout(()=&gt;&#123; console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123; console.log(&#x27;new Promise&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then&#x27;)&#125;)console.log(3) 如果按照上面流程图来分析代码，我们会得到下面的执行步骤： console.log(1)，同步任务，主线程中执行 setTimeout() ，异步任务，放到 Event Table，0 毫秒后console.log(2)回调推入 Event Queue 中 new Promise ，同步任务，主线程直接执行 .then ，异步任务，放到 Event Table console.log(3)，同步任务，主线程执行 所以按照分析，它的结果应该是 1 =&gt; &#39;new Promise&#39; =&gt; 3 =&gt; 2 =&gt; &#39;then&#39; 但是实际结果是：1=&gt;&#39;new Promise&#39;=&gt; 3 =&gt; &#39;then&#39; =&gt; 2 出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取 例子中 setTimeout回调事件是先进入队列中的，按理说应该先于 .then 中的执行，但是结果却偏偏相反 原因在于异步任务还可以细分为微任务与宏任务 微任务一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前 常见的微任务有： Promise.then MutaionObserver Object.observe（已废弃；Proxy 对象替代） process.nextTick（Node.js） 宏任务宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合 常见的宏任务有： script (可以理解为外层同步代码) setTimeout/setInterval UI rendering/UI事件 postMessage、MessageChannel setImmediate、I/O（Node.js） 这时候，事件循环，宏任务，微任务的关系如图所示 按照这个流程，它的执行机制是： 执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中 当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完 回到上面的题目 1234567891011console.log(1)setTimeout(()=&gt;&#123; console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123; console.log(&#x27;new Promise&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then&#x27;)&#125;)console.log(3) 流程如下 1234567// 遇到 console.log(1) ，直接打印 1// 遇到定时器，属于新的宏任务，留着后面执行// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;// .then 属于微任务，放入微任务队列，后面再执行// 遇到 console.log(3) 直接打印 3// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2 三、async与awaitasync 是异步的意思，await则可以理解为等待 放到一起可以理解async就是用来声明一个异步方法，而 await是用来等待异步方法执行 asyncasync函数返回一个promise对象，下面两种方法是等效的 12345678function f() &#123; return Promise.resolve(&#x27;TEST&#x27;);&#125;// asyncF is equivalent to f!async function asyncF() &#123; return &#x27;TEST&#x27;;&#125; await正常情况下，await命令后面是一个 Promise对象，返回该对象的结果。如果不是 Promise对象，就直接返回对应的值 123456async function f()&#123; // 等同于 // return 123 return await 123&#125;f().then(v =&gt; console.log(v)) // 123 不管await后面跟着的是什么，await都会阻塞后面的代码 123456789101112async function fn1 ()&#123; console.log(1) await fn2() console.log(2) // 阻塞&#125;async function fn2 ()&#123; console.log(&#x27;fn2&#x27;)&#125;fn1()console.log(3) 上面的例子中，await 会阻塞下面的代码（即加入微任务队列），先执行 async外面的同步代码，同步代码执行完，再回到 async 函数中，再执行之前阻塞的代码 所以上述输出结果为：1，fn2，3，2 四、流程分析通过对上面的了解，我们对JavaScript对各种场景的执行顺序有了大致的了解 这里直接上代码： 1234567891011121314151617181920async function async1() &#123; console.log(&#x27;async1 start&#x27;) await async2() console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123; console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;)setTimeout(function () &#123; console.log(&#x27;settimeout&#x27;)&#125;)async1()new Promise(function (resolve) &#123; console.log(&#x27;promise1&#x27;) resolve()&#125;).then(function () &#123; console.log(&#x27;promise2&#x27;)&#125;)console.log(&#x27;script end&#x27;) 分析过程： 执行整段代码，遇到 console.log(&#39;script start&#39;) 直接打印结果，输出 script start 遇到定时器了，它是宏任务，先放着不执行 遇到 async1()，执行 async1 函数，先打印 async1 start，下面遇到await怎么办？先执行 async2，打印 async2，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码 跳到 new Promise 这里，直接执行，打印 promise1，下面遇到 .then()，它是微任务，放到微任务列表等待执行 最后一行直接打印 script end，现在同步代码执行完了，开始执行微任务，即 await下面的代码，打印 async1 end 继续执行下一个微任务，即执行 then 的回调，打印 promise2 上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 settimeout 所以最后的结果是：script start、async1 start、async2、promise1、script end、async1 end、promise2、settimeout","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"深入理解javascript之typeof和instanceof","slug":"深入理解javascript之typeof和instanceof","date":"2021-10-13T08:41:28.000Z","updated":"2021-10-31T06:14:39.295Z","comments":true,"path":"20211013/深入理解javascript之typeof和instanceof/","link":"","permalink":"https://zouhualu.github.io/20211013/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E4%B9%8Btypeof%E5%92%8Cinstanceof/","excerpt":"","text":"typeoftypeof方法返回一个字符串，来表示数据的类型。 各个数据类型对应typeof的值： 数据类型 Type Undefined “undefined” Null “object” Boolean “boolean” Number “number” String “string” Symbol “symbol” 宿主对象(JS环境提供的，比如浏览器) Implementation-dependent 函数对象Function “function” 任何其他对象Object “object” 下面是代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Numberstypeof 37 === &#x27;number&#x27;;typeof 3.14 === &#x27;number&#x27;;typeof Math.LN2 === &#x27;number&#x27;;typeof Infinity === &#x27;number&#x27;;typeof NaN === &#x27;number&#x27;; // 尽管NaN是&quot;Not-A-Number&quot;的缩写,意思是&quot;不是一个数字&quot;typeof Number(1) === &#x27;number&#x27;; // 不要这样使用!// Stringstypeof &quot;&quot; === &#x27;string&#x27;;typeof &quot;bla&quot; === &#x27;string&#x27;;typeof (typeof 1) === &#x27;string&#x27;; // typeof返回的肯定是一个字符串typeof String(&quot;abc&quot;) === &#x27;string&#x27;; // 不要这样使用!// Booleanstypeof true === &#x27;boolean&#x27;;typeof false === &#x27;boolean&#x27;;typeof Boolean(true) === &#x27;boolean&#x27;; // 不要这样使用!// Symbolstypeof Symbol() === &#x27;symbol&#x27;;typeof Symbol(&#x27;foo&#x27;) === &#x27;symbol&#x27;;typeof Symbol.iterator === &#x27;symbol&#x27;;// Undefinedtypeof undefined === &#x27;undefined&#x27;;typeof blabla === &#x27;undefined&#x27;; // 一个未定义的变量,或者一个定义了却未赋初值的变量// Objectstypeof &#123;a:1&#125; === &#x27;object&#x27;;// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型typeof [1, 2, 4] === &#x27;object&#x27;;typeof new Date() === &#x27;object&#x27;;// 下面的容易令人迷惑，不要这样使用！typeof new Boolean(true) === &#x27;object&#x27;;typeof new Number(1) ==== &#x27;object&#x27;;typeof new String(&quot;abc&quot;) === &#x27;object&#x27;;// 函数typeof function()&#123;&#125; === &#x27;function&#x27;;typeof Math.sin === &#x27;function&#x27;; 发现typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象hj的typeof返回值都是object instanceofinstanceof运算符可以用来判断某个构造函数的prototype属性是否存在于另外一个要检测对象的原型链上。 1234567891011121314151617181920212223242526// 定义构造函数function C()&#123;&#125; function D()&#123;&#125; var o = new C();// true，因为 Object.getPrototypeOf(o) === C.prototypeo instanceof C; // false，因为 D.prototype不在o的原型链上o instanceof D; o instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回trueC.prototype instanceof Object // true,同上C.prototype = &#123;&#125;;var o2 = new C();o2 instanceof C; // trueo instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.D.prototype = new C(); // 继承var o3 = new D();o3 instanceof D; // trueo3 instanceof C; // true","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"互联网是如何运作的","slug":"互联网是如何运作的","date":"2021-10-07T03:04:56.000Z","updated":"2021-10-31T06:14:39.295Z","comments":true,"path":"20211007/互联网是如何运作的/","link":"","permalink":"https://zouhualu.github.io/20211007/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/","excerpt":"","text":"原文：互联网是如何运作的 以下是我的总结,更好的学习建议阅读原文。 介绍互联网所有的传输都通过TCP/IP协议族来传输，TCP/IP是面向连接的可靠字节流服务协议 TCP/IP协议栈您的计算机已连接到 Internet 并具有唯一的地址。它如何与连接到 Internet 的其他计算机“交谈”？ 这里应该有一个例子：假设您的 IP 地址是 1.2.3.4，并且您想向计算机 5.6.7.8 发送一条消息。您要发送的消息是“Hello computer 5.6.7.8!”。显然，消息必须通过将您的计算机连接到 Internet 的任何类型的线路传输。假设您已从家里拨入您的 ISP，并且消息必须通过电话线传输。必须将消息从字母文本翻译成电子信号，通过互联网传输，然后再翻译回字母文本。 这是如何实现的？通过使用协议栈。每台计算机都需要一台在 Internet 上进行通信，它通常内置于计算机的操作系统（即 Windows、Unix 等）中。由于使用了两种主要的通信协议，Internet 上使用的协议栈被称为 TCP/IP 协议栈。TCP/IP 堆栈如下所示： 应用层：提供特定于应用程序的协议 HTTP FTP IMAP(邮件) 网络控制层(TCP)：发送数据包到计算机上使用特定的端口号的应用程序 网络层(IP)：使用IP地址将数据包发送到特定的计算 链路层：将二进制数据包与网络信号相互之间转换（例如以太网网卡、电话线调制解调器等） HTTPHTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中 TCP 层的顶部，并被特定应用程序用于相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。 HTTP是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送对 Web 元素（例如网页和图像）的请求。请求被服务器服务后，客户端和服务器之间通过 Internet 的连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端发出 HTTP 请求之前，必须建立到服务器的新连接。 当您在 Web 浏览器中键入 URL 时，会发生以下情况： 如果 URL 包含域名，则浏览器首先连接到域名服务器并为 Web 服务器检索相应的 IP 地址。 Web 浏览器连接到 Web 服务器并为所需的网页发送 HTTP 请求（通过协议栈）。 Web 服务器接收请求并检查所需页面。如果页面存在，则 Web 服务器发送它。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。（404 的意思是“找不到页面”，任何浏览过网络的人都可能知道。） Web 浏览器接收回页面并关闭连接。 然后浏览器解析页面并查找完成网页所需的其他页面元素。这些通常包括图像、小程序等。 对于每个需要的元素，浏览器会为每个元素向服务器发出额外的连接和 HTTP 请求。 当浏览器加载完所有图像、小程序等后，页面将完全加载到浏览器窗口中。 TCP（传输控制协议）在协议栈的应用层之下是TCP层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）会沿堆栈向下传递到 TCP 层。TCP 负责将应用程序协议路由到目标计算机上的正确应用程序。 为此，使用端口号。端口可以​​被认为是每台计算机上的独立通道。例如，您可以在阅读电子邮件时上网。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上时，TCP 层根据端口号决定哪个应用程序接收数据包。TCP 是这样工作的： 当 TCP 层从上面接收到应用层协议数据时，它会将其分段为可管理的“块”，然后将带有特定 TCP 信息的 TCP 标头添加到每个“块”。TCP 头中包含的信息包括数据需要发送到的应用程序的端口号。 当 TCP 层接收到来自其下方 IP 层的数据包时，TCP 层会从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。 这就是 TCP 将通过协议栈移动的数据路由到正确应用程序的方式。 TCP 不是文本协议。TCP 是面向连接的、可靠的字节流服务。面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于收到的每个数据包，都会向发送方发送确认以确认交付。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。tcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功 IP（互联网协议）与 TCP 不同，IP 是一种不可靠的无连接协议。IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 IP 的工作也是将数据包发送和路由到其他计算机。IP 数据包是独立的实体，可能无序到达或根本没有到达。TCP 的工作是确保数据包到达并以正确的顺序。IP 与 TCP 的唯一共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据。 IP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP Ip是一种协议 有两种标准 IPv4 2^32次方和IPv6 2^128 TCP传输的质量和顺序当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送 #网络传输 个人电脑 猫（调制解调器） local ISP 互联网服务提供商 regional ISP 经过多个主干网络 NSP 网络服务提供商 大型网络 卖带宽给ISP NAP 每个NSP连接到至少三个网络访问点 ISP NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。 DNS服务存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zouhualu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zouhualu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"leetcode每日算法（2021-09-27）","slug":"leetcode每日算法（2021-09-27）","date":"2021-09-27T03:06:43.000Z","updated":"2021-10-31T06:14:39.295Z","comments":true,"path":"20210927/leetcode每日算法（2021-09-27）/","link":"","permalink":"https://zouhualu.github.io/20210927/leetcode%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%EF%BC%882021-09-27%EF%BC%89/","excerpt":"","text":"1.两数之和 解题我首先想到的是暴力解法，就是对数组嵌套循环（时间复杂度是 O(n²)）：肯定有更好的办法看到评论区有人说用逆向解法，用target减去数组中的一个数，然后判断得到的结果是否在数组中 12345678910var twoSum = function(nums, target) &#123; map = new Map() for(let i = 0; i &lt; nums.length; i++) &#123; x = target - nums[i] if(map.has(x)) &#123; return [map.get(x),i] &#125; map.set(nums[i],i) &#125;&#125;; 12345678910var twoSum = function (nums, target) &#123; let hash = &#123;&#125;; for (let i = 0; i &lt; nums.length; i++) &#123; if (hash[target - nums[i]] !== undefined) &#123; return [i, hash[target - nums[i]]]; &#125; hash[nums[i]] = i; &#125; return [];&#125;;","categories":[{"name":"算法类","slug":"算法类","permalink":"https://zouhualu.github.io/categories/%E7%AE%97%E6%B3%95%E7%B1%BB/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zouhualu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://zouhualu.github.io/tags/leetcode/"}]},{"title":"日常-最爱的电影","slug":"浮生一日-最爱的电影","date":"2021-09-25T10:07:53.000Z","updated":"2021-12-18T11:07:41.866Z","comments":true,"path":"20210925/浮生一日-最爱的电影/","link":"","permalink":"https://zouhualu.github.io/20210925/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5-%E6%9C%80%E7%88%B1%E7%9A%84%E7%94%B5%E5%BD%B1/","excerpt":"","text":"今天重温了电影《第六感》，一部披着灵异外皮的心灵治愈电影。 有些电影无论第几遍看还是让人感动","categories":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"栈与队列的理解以及应用场景","slug":"栈与队列的理解以及应用场景","date":"2021-09-23T06:00:28.000Z","updated":"2022-03-29T11:54:44.124Z","comments":true,"path":"20210923/栈与队列的理解以及应用场景/","link":"","permalink":"https://zouhualu.github.io/20210923/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"1.栈栈（stack）又名堆栈，它是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表。 表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈 所以其按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用 实现一个栈： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Stack &#123; constructor() &#123; this.items = []; &#125; /** * 添加一个（或几个）新元素到栈顶 * @param &#123;*&#125; element 新元素 */ push(element) &#123; this.items.push(element); &#125; /** * 移除栈顶的元素，同时返回被移除的元素 */ pop() &#123; return this.items.pop(); &#125; /** * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它） */ peek() &#123; return this.items[this.items.length - 1]; &#125; /** * 如果栈里没有任何元素就返回true,否则返回false */ isEmpty() &#123; return this.items.length === 0; &#125; /** * 移除栈里的所有元素 */ clear() &#123; this.items = []; &#125; /** * 返回栈里的元素个数。这个方法和数组的length属性很类似 */ size() &#123; return this.items.length; &#125;&#125; 关于栈的操作主要的方法如下： push：入栈操作 pop：出栈操作 二.队列跟栈十分相似，队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。 进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列 在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出 简单实现一个队列，如下： 123456789101112131415class Queue &#123; constructor() &#123; this.list = []; this.frontIndex = 0; this.tailIndex = 0; &#125; enqueue(item) &#123; this.list[this.tailIndex++] = item; &#125; unqueue() &#123; const item = this.list[this.frontIndex]; this.frontIndex++; return item; &#125;&#125; 三.应用场景栈借助栈的先进后出的特性，可以简单实现一个逆序输出的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出 包括编译器的在对输入的语法进行分析的时候，例如”()”、”{}”、”[]”这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错 包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值 生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型 队列当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题 队列的使用广泛应用在广度优先搜索中，例如层次遍历一个二叉树的节点值 生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型 参考文献 https://baike.baidu.com/item/%E6%A0%88/12808149 https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zouhualu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zouhualu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue3(一)","slug":"Vue3-一","date":"2021-09-16T09:39:17.000Z","updated":"2021-10-31T06:14:39.295Z","comments":true,"path":"20210916/Vue3-一/","link":"","permalink":"https://zouhualu.github.io/20210916/Vue3-%E4%B8%80/","excerpt":"","text":"今天上课内容是 vue 3,共有两节课，一节讲基础，一节讲原理。 以下是课堂笔记：","categories":[{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://zouhualu.github.io/tags/Vue3/"}]},{"title":"通读vue3文档记录","slug":"vue3文档记录","date":"2021-09-15T11:03:11.000Z","updated":"2021-10-31T06:14:39.293Z","comments":true,"path":"20210915/vue3文档记录/","link":"","permalink":"https://zouhualu.github.io/20210915/vue3%E6%96%87%E6%A1%A3%E8%AE%B0%E5%BD%95/","excerpt":"","text":"之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是Object.defineProperty()，vue3用的是Proxy。vue3还新增了组合式API等等。 这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。 持续更新ing 应用&amp;组件实例应用实例每个 Vue 应用都是通过用 createApp 函数创建一个新的应用实例开始的： 1const app = Vue.createApp(&#123; /* 选项 */ &#125;) 该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子： 1234const app = Vue.createApp(&#123;&#125;)app.component(&#x27;SearchInput&#x27;, SearchInputComponent)app.directive(&#x27;focus&#x27;, FocusDirective)app.use(LocalePlugin) 应用实例暴露的大多数方法都会返回该同一实例，允许链式： 1234Vue.createApp(&#123;&#125;) .component(&#x27;SearchInput&#x27;, SearchInputComponent) .directive(&#x27;focus&#x27;, FocusDirective) .use(LocalePlugin) 根组件实例传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。 一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;，我们应该传递 #app： 123const RootComponent = &#123; /* 选项 */ &#125;const app = Vue.createApp(RootComponent)const vm = app.mount(&#x27;#app&#x27;) 与大多数应用方法不同的是，mount 不返回应用本身。相反，它返回的是根组件实例。 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。 计算属性&amp;侦听器计算属性缓存 vs 方法你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果： 1&lt;p&gt;&#123;&#123; calculateBooksMessage() &#125;&#125;&lt;/p&gt; 123456// 在组件中methods: &#123; calculateBooksMessage() &#123; return this.author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;&#125; 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要author.books 还没有发生改变，多次访问 publishedBookMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 这也同样意味着下面的计算属性将不再更新，因为 Date.now () 不是响应式依赖： 12345computed: &#123; now() &#123; return Date.now() &#125;&#125; 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 list，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 list。如果没有缓存，我们将不可避免的多次执行 list 的 getter！如果你不希望有缓存，请用 method 来替代 以下为2021.09.16更新计算属性的 Setter计算属性默认只有 getter，不过在需要时你也可以提供一个 setter： 12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get() &#123; return this.firstName + &#x27; &#x27; + this.lastName &#125;, // setter set(newValue) &#123; const names = newValue.split(&#x27; &#x27;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... 现在再运行 vm.fullName = &#39;John Doe&#39; 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 Class与Style绑定如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作： 1234567891011&lt;div id=&quot;app&quot;&gt; &lt;my-component class=&quot;baz&quot;&gt;&lt;/my-component&gt;&lt;/div&gt;const app = Vue.createApp(&#123;&#125;)app.component(&#x27;my-component&#x27;, &#123; template: ` &lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt; &lt;span&gt;This is a child component&lt;/span&gt; `&#125;) 条件渲染v-if vs v-showv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好 v-if 与 v-for 一起使用 提示 不推荐同时使用 v-if 和 v-for 当 v-if 与 v-for 一起使用时，v-if 具有比 v-for 更高的优先级。请查阅列表渲染指南以获取详细信息。 当它们处于同一节点，v-if 的优先级比 v-for 更高，这意味着 v-if 将没有权限访问 v-for 里的变量： 12345&lt;!-- This will throw an error because property &quot;todo&quot; is not defined on instance. --&gt;&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; 可以把 v-for 移动到&lt;template&gt; 标签中来修正： 12345&lt;template v-for=&quot;todo in todos&quot;&gt; &lt;li v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/template&gt; 表单绑定输入基础用法v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件： text 和 textarea 元素使用 value property 和 input 事件； checkbox 和 radio 使用 checked property 和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 组件基础基本实例这里有一个 Vue 组件的示例： 123456789101112131415// 创建一个Vue 应用const app = Vue.createApp(&#123;&#125;)// 定义一个名为 button-counter 的新全局组件app.component(&#x27;button-counter&#x27;, &#123; data() &#123; return &#123; count: 0 &#125; &#125;, template: ` &lt;button @click=&quot;count++&quot;&gt; You clicked me &#123;&#123; count &#125;&#125; times. &lt;/button&gt;`&#125;) 组件的复用你可以将组件进行任意次数的复用每个组件都会各自独立维护它的data。因为你每用一次组件，就会有一个它的新组件实例被创建 在组件上使用 v-model自定义事件也可以用于创建支持 v-model 的自定义输入组件。记住： 12345678910&lt;input v-model=&quot;searchText&quot; /&gt;等价于：&lt;input :value=&quot;searchText&quot; @input=&quot;searchText = $event.target.value&quot; /&gt;当用在组件上时，v-model 则会这样：&lt;custom-input :model-value=&quot;searchText&quot; @update:model-value=&quot;searchText = $event&quot;&gt;&lt;/custom-input&gt; 为了让它正常工作，这个组件内的 &lt;input&gt; 必须： 将其 value attribute 绑定到一个名叫 modelValue 的 prop 上在其 input 事件被触发时，将新的值通过自定义的 update:modelValue 事件抛出写成代码之后是这样的： 123456789app.component(&#x27;custom-input&#x27;, &#123; props: [&#x27;modelValue&#x27;], template: ` &lt;input :value=&quot;modelValue&quot; @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot; &gt; `&#125;) 现在 v-model 就应该可以在这个组件上完美地工作起来了： 1&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt; 深入组件非 Prop 的 AttributeAttribute 继承当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 &lt;date-picker&gt; 组件的实例中： 1234567app.component(&#x27;date-picker&#x27;, &#123; template: ` &lt;div class=&quot;date-picker&quot;&gt; &lt;input type=&quot;datetime&quot; /&gt; &lt;/div&gt; `&#125;) 如果我们需要通过 data status property 定义 &lt;date-picker&gt; 组件的状态，它将应用于根节点 (即 div.date-picker)。 1234567&lt;!-- 具有非prop attribute的Date-picker组件--&gt;&lt;date-picker data-status=&quot;activated&quot;&gt;&lt;/date-picker&gt;&lt;!-- 渲染 date-picker 组件 --&gt;&lt;div class=&quot;date-picker&quot; data-status=&quot;activated&quot;&gt; &lt;input type=&quot;datetime&quot; /&gt;&lt;/div&gt; 同样的规则适用于事件监听器： 1&lt;date-picker @change=&quot;submitChange&quot;&gt;&lt;/date-picker&gt; 12345app.component(&#x27;date-picker&#x27;, &#123; created() &#123; console.log(this.$attrs) // &#123; onChange: () =&gt; &#123;&#125; &#125; &#125;&#125;) 当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。 123456789app.component(&#x27;date-picker&#x27;, &#123; template: ` &lt;select&gt; &lt;option value=&quot;1&quot;&gt;Yesterday&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;Today&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;Tomorrow&lt;/option&gt; &lt;/select&gt; `&#125;) 在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件： 123&lt;div id=&quot;date-picker&quot; class=&quot;demo&quot;&gt; &lt;date-picker @change=&quot;showChange&quot;&gt;&lt;/date-picker&gt;&lt;/div&gt; 1234567const app = Vue.createApp(&#123; methods: &#123; showChange(event) &#123; console.log(event.target.value) // 将记录所选选项的值 &#125; &#125;&#125;) 禁用 Attribute 继承如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。例如： 禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。 通过将 inheritAttrs 选项设置为 false，你可以访问组件的 $attrs property，该 property 包括组件 props 和 emits property 中未包含的所有属性 (例如，class、style、v-on 监听器等)。 12345678app.component(&#x27;date-picker&#x27;, &#123; inheritAttrs: false, template: ` &lt;div class=&quot;date-picker&quot;&gt; &lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt; &lt;/div&gt; `&#125;) 有了这个新配置，data status attribute 将应用于 input 元素！ 1234567&lt;!-- Date-picker 组件 使用非 prop attribute --&gt;&lt;date-picker data-status=&quot;activated&quot;&gt;&lt;/date-picker&gt;&lt;!-- 渲染 date-picker 组件 --&gt;&lt;div class=&quot;date-picker&quot;&gt; &lt;input type=&quot;datetime&quot; data-status=&quot;activated&quot; /&gt;&lt;/div&gt; 多个根节点上的 Attribute 继承与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。 1&lt;custom-layout id=&quot;custom-layout&quot; @click=&quot;changeValue&quot;&gt;&lt;/custom-layout&gt; 1234567891011121314151617// 这将发出警告app.component(&#x27;custom-layout&#x27;, &#123; template: ` &lt;header&gt;...&lt;/header&gt; &lt;main&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt; `&#125;)// 没有警告，$attrs被传递到&lt;main&gt;元素app.component(&#x27;custom-layout&#x27;, &#123; template: ` &lt;header&gt;...&lt;/header&gt; &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt; `&#125;) 自定义事件处理 v-model 修饰符在 2.x 中，我们对组件 v-model 上的 .trim 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 v-model 的修饰符将通过 modelModifiers prop 提供给组件： 让我们创建一个示例自定义修饰符 capitalize，它将 v-model 绑定提供的字符串的第一个字母大写。 添加到组件 v-model 的修饰符将通过 modelModifiers prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 modelModifiers prop。 请注意，当组件的 created 生命周期钩子触发时，modelModifiers prop 包含 capitalize，其值为 true——因为它被设置在 v-model 绑定 v-model.capitalize=&quot;bar&quot;。 1&lt;my-component v-model.capitalize=&quot;bar&quot;&gt;&lt;/my-component&gt; 12345678910111213141516app.component(&#x27;my-component&#x27;, &#123; props: &#123; modelValue: String, modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125; &#125;, template: ` &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;&gt; `, created() &#123; console.log(this.modelModifiers) // &#123; capitalize: true &#125; &#125;&#125;) 现在我们已经设置了 prop，我们可以检查 modelModifiers 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 &lt;input/&gt; 元素触发 input 事件时，我们都将字符串大写。 1234&lt;div id=&quot;app&quot;&gt; &lt;my-component v-model.capitalize=&quot;myText&quot;&gt;&lt;/my-component&gt; &#123;&#123; myText &#125;&#125;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031const app = Vue.createApp(&#123; data() &#123; return &#123; myText: &#x27;&#x27; &#125; &#125;&#125;)app.component(&#x27;my-component&#x27;, &#123; props: &#123; modelValue: String, modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125; &#125;, methods: &#123; emitValue(e) &#123; let value = e.target.value if (this.modelModifiers.capitalize) &#123; value = value.charAt(0).toUpperCase() + value.slice(1) &#125; this.$emit(&#x27;update:modelValue&#x27;, value) &#125; &#125;, template: `&lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emitValue&quot;&gt;`&#125;)app.mount(&#x27;#app&#x27;) 对于带参数的 v-model 绑定，生成的 prop 名称将为 arg + &quot;Modifiers&quot;： 1&lt;my-component v-model:foo.capitalize=&quot;bar&quot;&gt;&lt;/my-component&gt; 1234567891011app.component(&#x27;my-component&#x27;, &#123; props: [&#x27;foo&#x27;, &#x27;fooModifiers&#x27;], template: ` &lt;input type=&quot;text&quot; :value=&quot;foo&quot; @input=&quot;$emit(&#x27;update:foo&#x27;, $event.target.value)&quot;&gt; `, created() &#123; console.log(this.fooModifiers) // &#123; capitalize: true &#125; &#125;&#125;) 2021.09.17更新提供/注入通常，当我们需要将数据从父组件传递到子组件时，我们使用props。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。 对于这种情况，我们可以使用 provide 和 inject 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 provide 选项来提供数据，子组件有一个 inject 选项来开始使用这个数据。 可复用&amp;组合渲染函数虚拟DOM树Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码： 1return Vue.h(&#x27;h1&#x27;, &#123;&#125;, this.blogTitle) h() 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 VNode。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。 h()参数h() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数： 1234567891011121314151617181920212223242526272829h( // &#123;String | Object | Function | null&#125; tag // 一个 HTML 标签名、一个组件、一个异步组件，或者 null。 // 使用 null 将会渲染一个注释。 // // 必需的。 &#x27;div&#x27;, // &#123;Object&#125; props // 与 attribute、prop 和事件相对应的对象。 // 我们会在模板中使用。 // // 可选的。 &#123;&#125;, // &#123;String | Array | Object&#125; children // 子 VNodes, 使用 `h()` 构建, // 或使用字符串获取 &quot;文本 Vnode&quot; 或者 // 有 slot 的对象。 // // 可选的。 [ &#x27;Some text comes first.&#x27;, h(&#x27;h1&#x27;, &#x27;A headline&#x27;), h(MyComponent, &#123; someProp: &#x27;foobar&#x27; &#125;) ]) 完整实例有了这些知识，我们现在可以完成我们最开始想实现的组件： 1234567891011121314151617181920212223242526272829303132333435363738394041const app = Vue.createApp(&#123;&#125;)/** Recursively get text from children nodes */function getChildrenTextContent(children) &#123; return children .map(node =&gt; &#123; return typeof node.children === &#x27;string&#x27; ? node.children : Array.isArray(node.children) ? getChildrenTextContent(node.children) : &#x27;&#x27; &#125;) .join(&#x27;&#x27;)&#125;app.component(&#x27;anchored-heading&#x27;, &#123; render() &#123; // create kebab-case id from the text contents of the children const headingId = getChildrenTextContent(this.$slots.default()) .toLowerCase() .replace(/\\W+/g, &#x27;-&#x27;) // replace non-word characters with dash .replace(/(^-|-$)/g, &#x27;&#x27;) // remove leading and trailing dashes return Vue.h(&#x27;h&#x27; + this.level, [ Vue.h( &#x27;a&#x27;, &#123; name: headingId, href: &#x27;#&#x27; + headingId &#125;, this.$slots.default() ) ]) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;)","categories":[{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://zouhualu.github.io/tags/Vue3/"}]},{"title":"web设计模式解析与实战（一）","slug":"web设计模式解析与实战","date":"2021-09-12T05:31:57.000Z","updated":"2021-10-31T06:14:39.293Z","comments":true,"path":"20210912/web设计模式解析与实战/","link":"","permalink":"https://zouhualu.github.io/20210912/web%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/","excerpt":"","text":"今天课程主要是讲前端设计模式，早上一节，晚上一节。 设计模式有利于 组织模块 设计沟通 代码质量 五大设计原则： 开闭原则（OCP：open close principle） 开-对拓展开放，对修改关闭 单一职责原则（SRP） 岗位职责单一，互不重叠 依赖倒置原则（DIP） 上层不应该依赖下层实现 接口隔离原则（ISP） 多个专业的接口比单个胖借口好用 里氏替换原则（LSP：the Lxxxx substitution principle） 子类能够覆盖父类 父类能够出现的地方子类就能出现 今天老师给的课后题： 某个停车场，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开， 车辆进入前，显示每层的空余车辆数量 车辆进入时，摄像头可识别车牌号和时间 车辆出来时，出口显示器显示车牌号和停车时长请设计一套系统。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"课程","slug":"课程","permalink":"https://zouhualu.github.io/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"浮生一日(20210911)","slug":"浮生一日","date":"2021-09-11T10:44:58.000Z","updated":"2021-12-18T11:07:41.866Z","comments":true,"path":"20210911/浮生一日/","link":"","permalink":"https://zouhualu.github.io/20210911/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/","excerpt":"","text":"今天老妈的生日🎂 猝不及防的狗粮 苹果的售后真的好，耳机检测了一下就说直接换新的","categories":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"TypeScript中函数的理解","slug":"TypeScript中函数的理解","date":"2021-09-10T08:55:32.000Z","updated":"2021-10-31T06:14:39.292Z","comments":true,"path":"20210910/TypeScript中函数的理解/","link":"","permalink":"https://zouhualu.github.io/20210910/TypeScript%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"使用方式和JavaScript使用方式类似，可以通过funciton关键字、箭头函数等形式去定义，例如下面一个简单的加法函数： 1const add = (a:number,b:number)=&gt; a+b 上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：当鼠标放置在第三行 add 函数名的时候，会出现完整的函数定义类型，通过 : 的形式来定义参数类型，通过 =&gt; 连接参数和返回值类型 我们也可以显式地写上返回类型，如下： 1const add = (a:number,b:number):number=&gt; a+b 当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示： 12345678// 方式一type LongHand = &#123; (a: number): number;&#125;;// 方式二type ShortHand = (a: number) =&gt; number; 当存在函数重载时，只能使用方式一的形式 可选参数当函数的参数可能是不存在的，只需要在参数后面加上 ? 代表参数可能不存在，如下： 1const add = (a: number, b?: number) =&gt; a + (b ? b : 0) 这时候参数b可以是number类型或者undefined类型，即可以传一个number类型或者不传都可以 剩余类型剩余参数与JavaScript的语法类似，需要用 ... 来表示剩余参数 如果剩余参数 rest 是一个由number类型组成的数组，则如下表示： 1const add = (a: number, ...rest: number[]) =&gt; rest.reduce(((a, b) =&gt; a + b), a) 函数重载允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力 关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，用于具体实现 这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并 例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下： 1234567891011121314// 上边是声明function add (arg1: string, arg2: string): stringfunction add (arg1: number, arg2: number): number// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字// 下边是实现function add (arg1: string | number, arg2: string | number) &#123; // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2 if (typeof arg1 === &#x27;string&#x27; &amp;&amp; typeof arg2 === &#x27;string&#x27;) &#123; return arg1 + arg2 &#125; else if (typeof arg1 === &#x27;number&#x27; &amp;&amp; typeof arg2 === &#x27;number&#x27;) &#123; return arg1 + arg2 &#125;&#125; 区别从上面可以看到： 从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型 typescript 在参数中，添加可选参数供使用者选择 typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型参考文章 https://www.tslang.cn/docs/handbook/functions.html https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD","categories":[{"name":"技术类-TypeScript","slug":"技术类-TypeScript","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://zouhualu.github.io/tags/TypeScript/"}]},{"title":"Hi there!","slug":"about-me","date":"2021-09-07T03:19:02.000Z","updated":"2022-06-28T12:48:58.599Z","comments":true,"path":"20210907/about-me/","link":"","permalink":"https://zouhualu.github.io/20210907/about-me/","excerpt":"","text":"逆水行舟，不进则退 我的 github 仓库：https://github.com/zouHuaLu","categories":[{"name":"个人简介","slug":"个人简介","permalink":"https://zouhualu.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B/"}],"tags":[{"name":"个人简介","slug":"个人简介","permalink":"https://zouhualu.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B/"}]},{"title":"TypeScript中类的理解","slug":"TypeScript中类的理解","date":"2021-09-06T06:48:00.000Z","updated":"2021-10-31T06:14:39.292Z","comments":true,"path":"20210906/TypeScript中类的理解/","link":"","permalink":"https://zouhualu.github.io/20210906/TypeScript%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"一、是什么类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础 ❝类是一种用户定义的引用数据类型，也称类类型❞ 传统的面向对象语言基本都是基于类的，JavaScript 基于原型的方式让开发者多了很多理解成本在 ES6 之后，JavaScript 拥有了 class 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多但是JavaScript 的class依然有一些特性还没有加入，比如修饰符和抽象类TypeScript 的 class 支持面向对象的所有特性，比如 类、接口等 二、使用方式定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块(类的数据成员)： 「字段」：字段是类里面声明的变量。字段表示对象的有关数据。 「构造函数」：类实例化时调用，可以为类的对象分配内存。 「方法」：方法为对象要执行的操作如下例子： 123456789101112131415class Car &#123; // 字段 engine:string; // 构造函数 constructor(engine:string) &#123; this.engine = engine &#125; // 方法 disp():void &#123; console.log(&quot;发动机为 : &quot;+this.engine) &#125; &#125; 继承类的继承使用过extends的关键字 1234567891011121314151617class Animal &#123; move(distanceInMeters: number = 0) &#123; console.log(`Animal moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Dog extends Animal &#123; bark() &#123; console.log(&#x27;Woof! Woof!&#x27;); &#125;&#125;const dog = new Dog();dog.bark();dog.move(10);dog.bark(); Dog是一个 派生类，它派生自 Animal 基类，派生类通常被称作子类，基类通常被称作 超类。 Dog类继承了Animal类，因此实例dog也能够使用Animal类move方法。同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。 通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下： 12345678910111213class PrinterClass &#123; doPrint():void &#123; console.log(&quot;父类的 doPrint() 方法。&quot;) &#125; &#125; class StringPrinter extends PrinterClass &#123; doPrint():void &#123; super.doPrint() // 调用父类的函数 console.log(&quot;子类的 doPrint()方法。&quot;) &#125; &#125; 修饰符可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符： 公共 public：可以自由的访问类程序里定义的成员 私有 private：只能够在该类的内部进行访问 受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问 私有修饰符只能够在该类的内部进行访问，实例对象并不能够访问 12345678class Father&#123; private name:String constructor(name:String)&#123; this.name = name &#125;&#125;const father = new Father(&#x27;zouHuaLu&#x27;)father.name //会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot; 并且继承该类的子类并不能访问，如下图所示： 1234567891011class Father&#123; private name:String constructor(name:String)&#123; this.name = name &#125;&#125;class Son extends Father&#123; say()&#123; console.log(`my name is $&#123;this.name&#125;`) //会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot; &#125;&#125; 受保护修饰符跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下： 12345678class Father&#123; protected name:String constructor(name:String)&#123; this.name = name &#125;&#125;const father = new Father(&#x27;zouHuaLu&#x27;)father.name //会报错，提示 &quot;属性name受保护，只能在类Father及其子类中访问&quot; 有一点不同的是 protected 成员在子类中仍然可以访问 1234567891011class Father&#123; protected name:String constructor(name:String)&#123; this.name = name &#125;&#125;class Son extends Father&#123; say()&#123; console.log(`my name is $&#123;this.name&#125;`) &#125;&#125; 只读修饰符通过readonly关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下： 12345678class Father&#123; readonly name:String constructor(name:String)&#123; this.name = name &#125;&#125;const father = new Father(&#x27;zouHuaLu&#x27;)father.name //会报错,提示&quot;无法分配到name，因为它是只读属性&quot; 静态属性这些属性存在于类本身上面而不是类的实例上，通过static进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示： 12345class Square &#123; static width = &#x27;100px&#x27;&#125;console.log(Square.width) // 100px 抽象类抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示： 123456abstract class Animal &#123; abstract makeSound(): void; move(): void &#123; console.log(&#x27;roaming the earch...&#x27;); &#125;&#125; 这种类并不能被实例化，通常需要我们创建子类去继承，如下： 1234567891011class Cat extends Animal &#123; makeSound() &#123; console.log(&#x27;miao miao&#x27;) &#125;&#125;const cat = new Cat()cat.makeSound() // miao miaocat.move() // roaming the earch... 三、应用场景除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在React 工程中是很常用的，如下： 1export default class Carousel extends React.Component&lt;Props, State&gt; &#123;&#125; 由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。 先声明一个类，这个类包含组件 props 所需的类型和初始值： 12345678910111213// props的类型export default class Props &#123; public children: Array&lt;React.ReactElement&lt;any&gt;&gt; | React.ReactElement&lt;any&gt; | never[] = [] public speed: number = 500 public height: number = 160 public animation: string = &#x27;easeInOutQuad&#x27; public isAuto: boolean = true public autoPlayInterval: number = 4500 public afterChange: () =&gt; &#123;&#125; public beforeChange: () =&gt; &#123;&#125; public selesctedColor: string public showDots: boolean = true&#125; 当我们需要传入 props 类型的时候直接将 Props 作为接口传入，此时 Props 的作用就是接口，而当需要我们设置defaultProps初始值的时候，我们只需要: 1public static defaultProps = new Props() Props 的实例就是 defaultProps 的初始值，这就是 class作为接口的实际应用，我们用一个 class 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量 参考文章 https://www.tslang.cn/docs/handbook/classes.html https://www.runoob.com/typescript/ts-class.html","categories":[{"name":"技术类-TypeScript","slug":"技术类-TypeScript","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://zouhualu.github.io/tags/TypeScript/"}]},{"title":"export与export default的区别","slug":"export与export-default的区别","date":"2021-07-01T06:21:44.000Z","updated":"2021-10-31T06:14:39.294Z","comments":true,"path":"20210701/export与export-default的区别/","link":"","permalink":"https://zouhualu.github.io/20210701/export%E4%B8%8Eexport-default%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"node中导入模块：var 名称 = require(‘模块标识符’) node中向外暴露成员的形式：module.exports = {} 在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块 ES6中导入模块，使用 import 模块名称 from ‘模块标识符’ import ‘表示路径’ import * from * 是ES6中导入模块的方式 在ES6中，使用export default 和 export 向外暴露成员例如： 12345// test.jsexport default &#123; name: &#x27;zs&#x27;, age: 20&#125; 或是 123456// test.jsvar info = &#123; name: &#x27;zs&#x27;, age: 20&#125;export default info 在main.js中接收，test.js使用export default 向外暴露的成员 12import person from &#x27;./test.js&#x27;console.log(person); 注意：1、export default 向外暴露的成员，可以使用任意变量来接收 2、在一个模块中，export default 只允许向外暴露一次 3、在一个模块中，可以同时使用export default 和export 向外暴露成员 4、使用export向外暴露的成员，只能使用{ }的形式来接收，这种形式，叫做【按需导出】 5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义 6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收 7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名 例如： 12345678910// test.jsvar info = &#123; name: &#x27;zs&#x27;, age: 20&#125;export default infoexport var title = &#x27;小星星&#x27;export var content = &#x27;哈哈哈&#x27; 在main.js中接收，test.js使用export default 和 export 向外暴露的成员 123import person, &#123;title, content as content1&#125; from &#x27;./test.js&#x27;console.log(person);console.log(title + &#x27;=======&#x27; + content1);","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://zouhualu.github.io/tags/ES6/"}]},{"title":"new操作符的实现","slug":"new操作符的实现","date":"2021-06-18T21:23:44.000Z","updated":"2021-10-31T06:14:39.294Z","comments":true,"path":"20210619/new操作符的实现/","link":"","permalink":"https://zouhualu.github.io/20210619/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"JavaScript中的new操作符的原理例子123456function Person (name, age) &#123; this.name = name this.age = age&#125;const person1 = new Person(&#x27;走花路的长颈鹿&#x27;, 26)console.log(person1) //Person&#123;name:&#x27;走花路的长颈鹿&#x27;,age:26&#125; 先定义了一个构造函数Person，然后通过new操作符生成Person构造函数的一个实例并将其引用赋值给变量person1。然后控制台打印出person1的内容，可以看到该实例对象具有name和age属性，它们的值就是我们在调用构造函数时传入的值。 new关键字进行的操作 先创建一个空对象obj=&#123;&#125; 将obj的__proto__原型指向构造函数Person的prototype原型对象，即obj.__proto__ = Person.prototype 将构造函数Person内部的this指向obj，然后执行构造函数Person()（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象obj而已，就好像执行obj.Person()一样） 若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象obj（默认会添加return this）。否则，返回引用类型的值。 自己实现一个new操作符1234567891011121314151617function myNew (constr, ...args) &#123; // 1,2 创建一个对象obj，将obj的__proto__属性指向构造函数的原型对象 // 即实现：obj.__proto__ === constructor.prototype var obj = Object.create(constr.prototype) // 3.将constrc内部的this（即执行上下文）指向obj，并执行 var result = constr.apply(obj, args) // 4\\. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象 return result instanceof Object ? result : obj&#125;// 使用的例子：function Person(name, age)&#123; this.name = name; this.age = age;&#125;const person1 = myNew(Person, &#x27;Tom&#x27;, 20)console.log(person1) // Person &#123;name: &quot;Tom&quot;, age: 20&#125; 关键点 将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。 将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。 2021年7月1日补充看一个例子 123456789101112function Player(color) &#123; this.color = color&#125;Player.prototype.start = function() &#123;&#125;const white = new Player(&#x27;white&#x27;)const black = new Player(&#x27;black&#x27;)console.log(black.__proto__) // start()console.log(Object.getPrototypeOf(black)) // start()console.log(Player.prototype) // start()console.log(Player.__proto__) // &#123;&#125; 根据反推可以写一下思路 一个继承自Player.prototype的新对象 p1/p2被创建 p1.__proto__ === Player.prototype，p1.__proto__指向Player.prototype 将this指向新创建的对象p1/p2 返回一个新对象： 如果构造函数没有显示的返回值，那么返回this 如果有显式的返回值，是基本类型，那么还是返回this 如果构造函数有显式的返回值，是对象类型，比如是{a:1}，那么就返回{a:1}现在我们再来实现一个new指令的功能12345678910111213function Player(name)&#123; this.name = name&#125;function objectFactory() &#123; let o = new Object() let FunctionConstructor = [].shift.call(arguments) o.__proto__ = FunctionConstructor.prototype let resultObj = FunctionConstructor.apply(o, arguments) return typeof resultObj === &#x27;object&#x27; ? resultObj : o&#125;const p1 = objectFactory(Player, &#x27;花鹿&#x27;)console.log(p1) // 花鹿 完~","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"原型与原型链与constructor","slug":"原型与原型链与constructor","date":"2021-06-18T07:16:53.000Z","updated":"2021-10-31T06:14:39.294Z","comments":true,"path":"20210618/原型与原型链与constructor/","link":"","permalink":"https://zouhualu.github.io/20210618/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8Econstructor/","excerpt":"","text":"原型与原型链与constructor本文参考自：https://blog.csdn.net/cc18868876837/article/details/81211729 先来个总结： 我们需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。 __proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。 prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。 constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 基础知识__proto__翻译为原型，多个__proto__串连起来的叫做原型链。 prototype翻译为原型对象。 Object.getPrototypeOf()Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。 示例123456const prototype1 = &#123;&#125;;const object1 = Object.create(prototype1);console.log(Object.getPrototypeOf(object1) === prototype1);// expected output: trueObject.getPrototypeOf(object1) === object1.__proto__ 正式开始12function Foo() &#123;...&#125;;let f1 = new Foo(); 以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。 __proto__属性首先要记住两点： __proto__和constructor是对象才有的属性，在JavaScript中函数也是一种对象。 prototype是函数才有的属性。 这里我们仅留下 __proto__ 属性，它是对象所独有的，可以看到__proto__属性都是由一个对象指向一个对象，即指向它们构造函数的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。 其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠__proto__继承而来的。 prototype属性 prototype属性是函数独有的。他是从一个函数指向一个对象，他的含义是函数的原型对象 f1.__proto__ === Foo.prototype，它们两个完全一样。那prototype属性的作用又是什么呢？它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。 constructor属性 constructor属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合__proto__属性查看会更清楚点，如下图所示），从上图中可以看出Function这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。 函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身 完~","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Vue自定义全局组件","slug":"Vue自定义全局组件","date":"2021-06-18T07:15:40.000Z","updated":"2021-10-31T06:14:39.294Z","comments":true,"path":"20210618/Vue自定义全局组件/","link":"","permalink":"https://zouhualu.github.io/20210618/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6/","excerpt":"","text":"vue自定义全局弹框组件 在components文件夹下新增一个组件文件夹Dialog，新建一个模板组件Dialog.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;template&gt; &lt;div class=&quot;u_dialog_panel&quot; @touchmove.stop=&quot;noop&quot;&gt; &lt;div class=&quot;mask&quot; v-if=&quot;visible&quot; @click=&quot;handleClose&quot;&gt;&lt;/div&gt; &lt;transition name=&quot;open&quot;&gt; &lt;div v-if=&quot;visible&quot; class=&quot;dialog_body&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;div class=&quot;btns&quot; v-if=&quot;confirmText || cancleText&quot;&gt; &lt;div class=&quot;cancle btn&quot; v-if=&quot;cancleText&quot; @click=&quot;handleCancle&quot;&gt;&#123;&#123;cancleText&#125;&#125;&lt;/div&gt; &lt;div class=&quot;confirm btn&quot; :style=&quot;confirmStyle&quot; v-if=&quot;confirmText&quot; @click=&quot;handleConfirm&quot;&gt;&#123;&#123;confirmText&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;UDialog&#x27;, props: &#123; visible: &#123; type: Boolean, default: false, required: true &#125;, // 确定按钮的文案 confirmText: &#123; type: String, default: &#x27;确定&#x27; &#125;, confirmStyle: &#123; type: String, default: &#x27;&#x27; &#125;, // 取消按钮的文案 cancleText: &#123; type: String, default: &#x27;取消&#x27; &#125;, cancleStyle: &#123; type: String, default: &#x27;&#x27; &#125;, &#125;, created () &#123; this.$nextTick(() =&gt; &#123; document.body.insertBefore(this.$el, document.body.lastChild) &#125;) &#125;, beforeDestroy () &#123; document.body.removeChild(this.$el) &#125;, methods: &#123; // 关闭弹窗 handleClose () &#123; this.$emit(&#x27;close&#x27;) &#125;, // 确定按钮 handleConfirm () &#123; this.$emit(&#x27;confirm&#x27;) &#125;, // 取消按钮 handleCancle () &#123; this.$emit(&#x27;cancle&#x27;) &#125;, noop () &#123;&#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.u_dialog_panel &#123; .mask &#123; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); position: fixed; left: 0; top: 0; z-index: 100; backdrop-filter: blur(5px); &#125; .dialog_body&#123; width: 80vw; background-color: #fff; position: fixed; left: 50vw; top: 50vh; z-index: 100; transform: translate(-50%, -50%); transform-origin: 0 0; border-radius: .875rem; &amp;.open-enter &#123; opacity: 0; transform: scale(0.7) translate(-50%, -50%); transition: all 0.3s; &#125; &amp;.open-enter-to &#123; opacity: 1; transform: scale(1) translate(-50%, -50%); transition: all 0.3s; &#125; .btns &#123; display: flex; justify-content: space-between; align-items: center; .btn &#123; display: flex; justify-content: center; align-items: center; flex-grow: 1; width: 50%; height: 2.875rem; border-top: 1px solid #ddd; box-sizing: border-box; display: flex; justify-content: center; align-items: center; font-size: .875rem; &amp; + .btn &#123; border-left: 1px solid #ddd; &#125; &amp;.cancle &#123; color: #666666; &#125; &amp;.confirm &#123; color: #FF5883; &#125; &#125; &#125; &#125;&#125;&lt;/style&gt; 在此文件夹再新建一个index.js 12345678import Dialog from &#x27;./Dialog&#x27;Dialog.install = function (Vue, options) &#123; Vue.component(`$&#123;Dialog.name&#125;`, Dialog)&#125;export default Dialog 最后再main.js里注册为全局组件 123import Dialog from &#x27;./components/Dialog/index.js&#x27;Vue.use(Dialog) 这样就可以在其他组件里无需声明而使用此组件","categories":[{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://zouhualu.github.io/tags/Vue3/"}]},{"title":"JavaScript中的堆栈以及数据类型","slug":"JavaScript中的堆栈以及数据类型","date":"2021-06-17T07:08:21.000Z","updated":"2022-03-29T11:54:44.124Z","comments":true,"path":"20210617/JavaScript中的堆栈以及数据类型/","link":"","permalink":"https://zouhualu.github.io/20210617/JavaScript%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"JavaScript 的堆栈以及数据类型本文参考此链接 堆 是堆内存的简称。 需要程序员自己申请空间，内存大小不一，也不会自动释放。 堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片 栈 是栈内存的简称。 是自动分配相对固定大小的内存空间，并由系统自动释放，所以生命周期只在函数的运行过程中。 后进先出 栈是向低地址扩展的数据结构，是一块连续的内存的区域 队列 是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。 先进先出 基本数据类型javascript的基本类型就 5 种:Undefined、Null、Boolean、Number和String，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。 引用数据类型javascript中其他类型的数据被称为引用类型的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和 new 出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。 传值与传址123456789var arr1 = [1, 2, 5, 8];var arr2 = arr1;var str1 = arr1[2];console.log(arr2); //1,2,5,8console.log(str1); //5arr2[4] = 99;str1 = 6;console.log(arr1); //1,2,5,8,99console.log(arr1[2]); //5 当我改变 arr2 中的数据时，arr1 中数据也发生了变化，当改变 str1 的数据值时，arr1 却没有发生改变。为什么？这就是传值与传址的区别。 因为 arr1 是数组，属于引用类型，所以它赋予给 arr2 的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1 得到的是一个基本类型的赋值，因此，str1 仅仅是从 arr1 堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2 都指向同一块堆内存，arr2 修改的堆内存的时候，也就会影响到 arr1，str1 是直接在栈中修改，并且不能影响到 arr1 堆内存中的数据。 深拷贝和浅拷贝上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将 arr1 的每个基本类型的数据都遍历一遍，依次的赋值给 arr2 的对应字段。避免产生因为地址引用带来的问题。 123456789var arr1 = [1, 2, 5, 8];var arr2 = [];for (var i = 0; i &lt; arr1.length; i++) &#123; arr2[i] = arr1[i];&#125;console.log(arr2); //1,2,5,8arr2[4] = 99;console.log(arr2); //1,2,5,8,99console.log(arr1); //1,2,5,8 javascript 面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。 完~","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"}]}],"categories":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"阅读","slug":"阅读","permalink":"https://zouhualu.github.io/categories/%E9%98%85%E8%AF%BB/"},{"name":"技术类-前端","slug":"技术类-前端","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-%E5%89%8D%E7%AB%AF/"},{"name":"技术类-Vue","slug":"技术类-Vue","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Vue/"},{"name":"算法类","slug":"算法类","permalink":"https://zouhualu.github.io/categories/%E7%AE%97%E6%B3%95%E7%B1%BB/"},{"name":"技术类-React","slug":"技术类-React","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-React/"},{"name":"技术类-Node.js","slug":"技术类-Node-js","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-Node-js/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://zouhualu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"技术类-TypeScript","slug":"技术类-TypeScript","permalink":"https://zouhualu.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB-TypeScript/"},{"name":"个人简介","slug":"个人简介","permalink":"https://zouhualu.github.io/categories/%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://zouhualu.github.io/tags/%E6%97%A5%E5%B8%B8/"},{"name":"阅读","slug":"阅读","permalink":"https://zouhualu.github.io/tags/%E9%98%85%E8%AF%BB/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zouhualu.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://zouhualu.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue3","slug":"Vue3","permalink":"https://zouhualu.github.io/tags/Vue3/"},{"name":"ES6","slug":"ES6","permalink":"https://zouhualu.github.io/tags/ES6/"},{"name":"Vue","slug":"Vue","permalink":"https://zouhualu.github.io/tags/Vue/"},{"name":"算法","slug":"算法","permalink":"https://zouhualu.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://zouhualu.github.io/tags/leetcode/"},{"name":"TODO","slug":"TODO","permalink":"https://zouhualu.github.io/tags/TODO/"},{"name":"React","slug":"React","permalink":"https://zouhualu.github.io/tags/React/"},{"name":"Node.js","slug":"Node-js","permalink":"https://zouhualu.github.io/tags/Node-js/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://zouhualu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"课程","slug":"课程","permalink":"https://zouhualu.github.io/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://zouhualu.github.io/tags/TypeScript/"},{"name":"个人简介","slug":"个人简介","permalink":"https://zouhualu.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B/"}]}
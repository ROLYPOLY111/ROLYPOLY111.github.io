<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浮生一日(20210911)</title>
    <link href="/20210911/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/"/>
    <url>/20210911/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>今天老妈的生日🎂</p><p>猝不及防的狗粮</p><p><img src="/img/20210911/pic1.jpeg" alt="老妈的朋友圈"><br><img src="/img/20210911/pic2.jpeg" alt="老妈的朋友圈"></p><hr><p>苹果的售后真的好，耳机检测了一下就说直接换新的</p><p><img src="/img/20210911/AirPods.jpeg" alt="苹果售后"></p>]]></content>
    
    
    <categories>
      
      <category>浮生一日</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浮生一日</tag>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript中函数的理解</title>
    <link href="/20210910/TypeScript%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/20210910/TypeScript%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>和JavaScript使用方式类似，可以通过<code>funciton</code>关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a:<span class="hljs-built_in">number</span>,b:<span class="hljs-built_in">number</span></span>)=&gt;</span> a+b<br></code></pre></td></tr></table></figure><p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：<br><img src="https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg" alt="TypeScript编译器的提示"><br>当鼠标放置在第三行 <code>add</code> 函数名的时候，会出现完整的函数定义类型，通过 <code>:</code> 的形式来定义参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p><p>我们也可以显式地写上返回类型，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> add = (a:<span class="hljs-built_in">number</span>,<span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span>):<span class="hljs-function"><span class="hljs-params">number</span>=&gt;</span> a+b<br></code></pre></td></tr></table></figure><p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 方式一</span><br><span class="hljs-keyword">type</span> LongHand = &#123;<br>  (a: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>&#125;;<br><br><span class="hljs-comment">// 方式二</span><br><span class="hljs-keyword">type</span> ShortHand = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br><br></code></pre></td></tr></table></figure><p>当存在函数重载时，只能使用方式一的形式</p><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b?: <span class="hljs-built_in">number</span></span>) =&gt;</span> a + (b ? b : <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>这时候参数<code>b</code>可以是<code>number类型</code>或者<code>undefined类型</code>，即可以传一个<code>number类型</code>或者不传都可以</p><h2 id="剩余类型"><a href="#剩余类型" class="headerlink" title="剩余类型"></a>剩余类型</h2><p>剩余参数与JavaScript的语法类似，需要用 <code>...</code> 来表示剩余参数</p><p>如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, ...rest: <span class="hljs-built_in">number</span>[]</span>) =&gt;</span> rest.reduce((<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b), a)<br></code></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p><p>关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|操作符</code>或者<code>?操作符</code>，把所有可能的输入类型全部包含进去，用于具体实现</p><p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并</p><p>例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 上边是声明</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">arg1: <span class="hljs-built_in">string</span>, arg2: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span><br><span class="hljs-function"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">arg1: <span class="hljs-built_in">number</span>, arg2: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span></span><br><span class="hljs-function"><span class="hljs-function">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 <span class="hljs-title">declare</span> 关键字</span></span><br><span class="hljs-function"><span class="hljs-function"></span></span><br><span class="hljs-function"><span class="hljs-function">// 下边是实现</span></span><br><span class="hljs-function"><span class="hljs-function"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">arg1: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, arg2: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>&#123;</span></span><br><span class="hljs-function"><span class="hljs-function">  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 <span class="hljs-title">arg1</span> + <span class="hljs-title">arg2</span></span></span><br><span class="hljs-function"><span class="hljs-function">  <span class="hljs-title">if</span> (<span class="hljs-params"><span class="hljs-keyword">typeof</span> arg1 === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> arg2 === <span class="hljs-string">&#x27;string&#x27;</span></span>) </span>&#123;</span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">arg1</span> + <span class="hljs-title">arg2</span></span><br><span class="hljs-function">  &#125; <span class="hljs-title">else</span> <span class="hljs-title">if</span> (<span class="hljs-params"><span class="hljs-keyword">typeof</span> arg1 === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> arg2 === <span class="hljs-string">&#x27;number&#x27;</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> arg1 + arg2<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>从上面可以看到：</p><ul><li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li><li>typescript 在参数中，添加可选参数供使用者选择</li><li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1></li><li><a href="https://www.tslang.cn/docs/handbook/functions.html">https://www.tslang.cn/docs/handbook/functions.html</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD</a></li><li><a href="https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD">https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术类-TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本博客说明书</title>
    <link href="/20210907/about-me/"/>
    <url>/20210907/about-me/</url>
    
    <content type="html"><![CDATA[<blockquote><p>幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔</p></blockquote><p>19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。<br>所以我又重新搭了一个。<br>后续会把写过的文档陆续上传到这边</p><p>以下是功能测试：</p><p>嵌入YOUTUBE视频</p><div class="video-container"><iframe src="https://www.youtube.com/embed/lJIrF4YjHfQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>嵌入B站视频</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=846655043&bvid=BV1e54y1n7XK&cid=371989206&page=1" scrolling="no" border="0" frameborder="no" framespacing="0"allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;"> </iframe></div><p>嵌入图片<br><img src="/img/bg/bg.jpg" alt="背景图"><br><img src="/img/user/zoo.jpeg" alt="长颈鹿"></p><p>代码块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;zouHuaLu&#x27;</span>)<br>hexo g<br>hexo g -w<br>hexo server<br>hexo clean<br>hexo deploy<br></code></pre></td></tr></table></figure><p>如果你看到<code>We were unable to load Disqus. If you are a moderator please see our troubleshooting guide.</code>,说明本博客的评论功能有问题，后续有时间再改吧</p>]]></content>
    
    
    <categories>
      
      <category>博客说明</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客说明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript中类的理解</title>
    <link href="/20210906/TypeScript%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/20210906/TypeScript%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h1><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p><blockquote><p>❝类是一种用户定义的引用数据类型，也称类类型❞</p></blockquote><p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本<br>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多<br>但是<code>JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类<br><code>TypeScript</code> 的 <code>class</code>  支持面向对象的所有特性，比如 类、接口等</p><h1 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h1><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：</p><p>「字段」：字段是类里面声明的变量。字段表示对象的有关数据。</p><p>「构造函数」：类实例化时调用，可以为类的对象分配内存。</p><p>「方法」：方法为对象要执行的操作<br>如下例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123; <br>    <span class="hljs-comment">// 字段 </span><br>    <span class="hljs-attr">engine</span>:<span class="hljs-built_in">string</span>; <br> <br>    <span class="hljs-comment">// 构造函数 </span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">engine:<span class="hljs-built_in">string</span></span>)</span> &#123; <br>        <span class="hljs-built_in">this</span>.engine = engine <br>    &#125;  <br> <br>    <span class="hljs-comment">// 方法 </span><br>    disp():<span class="hljs-built_in">void</span> &#123; <br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;发动机为 :   &quot;</span>+<span class="hljs-built_in">this</span>.engine) <br>    &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>类的继承使用过<code>extends</code>的关键字</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Animal moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">bark</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Woof! Woof!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> Dog();<br>dog.bark();<br>dog.move(<span class="hljs-number">10</span>);<br>dog.bark();<br><br></code></pre></td></tr></table></figure><p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 <strong>超类</strong>。</p><p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法。<br>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。</p><p>通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrinterClass</span> </span>&#123; <br>   doPrint():<span class="hljs-built_in">void</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;父类的 doPrint() 方法。&quot;</span>) <br>   &#125; <br>&#125; <br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringPrinter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PrinterClass</span> </span>&#123; <br>   doPrint():<span class="hljs-built_in">void</span> &#123; <br>      <span class="hljs-built_in">super</span>.doPrint() <span class="hljs-comment">// 调用父类的函数</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;子类的 doPrint()方法。&quot;</span>)<br>   &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：</p><ul><li>公共 public：可以自由的访问类程序里定义的成员</li><li>私有 private：只能够在该类的内部进行访问</li><li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li></ul><h3 id="私有修饰符"><a href="#私有修饰符" class="headerlink" title="私有修饰符"></a>私有修饰符</h3><p>只能够在该类的内部进行访问，实例对象并不能够访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">private</span> name:<span class="hljs-built_in">String</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">String</span></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> father = <span class="hljs-keyword">new</span> Father(<span class="hljs-string">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class="hljs-comment">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br></code></pre></td></tr></table></figure><p>并且继承该类的子类并不能访问，如下图所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">private</span> name:<span class="hljs-built_in">String</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">String</span></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`my name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)  <span class="hljs-comment">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="受保护修饰符"><a href="#受保护修饰符" class="headerlink" title="受保护修饰符"></a>受保护修饰符</h3><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> name:<span class="hljs-built_in">String</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">String</span></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> father = <span class="hljs-keyword">new</span> Father(<span class="hljs-string">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class="hljs-comment">//会报错，提示 &quot;属性name受保护，只能在类Father及其子类中访问&quot;</span><br></code></pre></td></tr></table></figure><p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> name:<span class="hljs-built_in">String</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">String</span></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`my name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="只读修饰符"><a href="#只读修饰符" class="headerlink" title="只读修饰符"></a>只读修饰符</h3><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">readonly</span> name:<span class="hljs-built_in">String</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">String</span></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> father = <span class="hljs-keyword">new</span> Father(<span class="hljs-string">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class="hljs-comment">//会报错,提示&quot;无法分配到name，因为它是只读属性&quot;</span><br></code></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 <code>类型.静态属性</code> 的这种形式访问，如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> width = <span class="hljs-string">&#x27;100px&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(Square.width) <span class="hljs-comment">// 100px</span><br></code></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节<br><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-keyword">abstract</span> makeSound(): <span class="hljs-built_in">void</span>;<br>    move(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;roaming the earch...&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">makeSound</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;miao miao&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> cat = <span class="hljs-keyword">new</span> Cat()<br><br>cat.makeSound() <span class="hljs-comment">// miao miao</span><br>cat.move() <span class="hljs-comment">// roaming the earch...</span><br></code></pre></td></tr></table></figure><h1 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h1><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在<code>React</code> 工程中是很常用的，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Carousel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">Props</span>, <span class="hljs-title">State</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。</p><p>先声明一个类，这个类包含组件 props 所需的类型和初始值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// props的类型</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Props</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> children: <span class="hljs-built_in">Array</span>&lt;React.ReactElement&lt;<span class="hljs-built_in">any</span>&gt;&gt; | React.ReactElement&lt;<span class="hljs-built_in">any</span>&gt; | <span class="hljs-built_in">never</span>[] = []<br>  <span class="hljs-keyword">public</span> speed: <span class="hljs-built_in">number</span> = <span class="hljs-number">500</span><br>  <span class="hljs-keyword">public</span> height: <span class="hljs-built_in">number</span> = <span class="hljs-number">160</span><br>  <span class="hljs-keyword">public</span> animation: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;easeInOutQuad&#x27;</span><br>  <span class="hljs-keyword">public</span> isAuto: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">public</span> autoPlayInterval: <span class="hljs-built_in">number</span> = <span class="hljs-number">4500</span><br>  <span class="hljs-keyword">public</span> afterChange: <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> beforeChange: <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> selesctedColor: <span class="hljs-built_in">string</span><br>  <span class="hljs-keyword">public</span> showDots: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> defaultProps = <span class="hljs-keyword">new</span> Props()<br></code></pre></td></tr></table></figure><p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class</code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://www.tslang.cn/docs/handbook/classes.html">https://www.tslang.cn/docs/handbook/classes.html</a></li><li><a href="https://www.runoob.com/typescript/ts-class.html">https://www.runoob.com/typescript/ts-class.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术类-TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

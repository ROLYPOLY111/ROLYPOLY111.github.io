<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2023版Nodejs知识记录（更新ing）</title>
    <link href="/20231010/2023%E7%89%88Nodejs%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95%EF%BC%88%E6%9B%B4%E6%96%B0ing%EF%BC%89/"/>
    <url>/20231010/2023%E7%89%88Nodejs%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95%EF%BC%88%E6%9B%B4%E6%96%B0ing%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>仅作为个人学习笔记，不适用于Nodejs系统性学习，如有错误，欢迎指正</p></blockquote><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ol><li>一个函数返回一个函数</li><li>一个函数的参数是一个函数</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>高阶函数，可以对原有的函数进行拓展</li><li>函数柯里化，把一个函数拆分成小的函数，每一个函数的参数只能有一个</li></ul><h2 id="异步与同步"><a href="#异步与同步" class="headerlink" title="异步与同步"></a>异步与同步</h2><ul><li>异步：我们不会立刻拿到返回值，但是可以继续做别的事（非阻塞）</li><li>同步：按照顺序的去做事，同步阻塞</li></ul><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">let</span> event = &#123;<br>    <span class="hljs-attr">_arr</span>: [],<br>    <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">callback</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>._arr.push(callback)<br>    &#125;, <span class="hljs-comment">//订阅：把函数存起来</span><br>    <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">...args</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>._arr.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn(...args))<br>    &#125; <span class="hljs-comment">//发布，把函数拿出来执行 </span><br>&#125;<br><br>event.on(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;读取成功一次&#x27;</span>)<br>&#125;)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术类-Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023版react知识记录（更新ing）</title>
    <link href="/20231009/2023%E7%89%88-react%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
    <url>/20231009/2023%E7%89%88-react%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是JSX？"><a href="#1-什么是JSX？" class="headerlink" title="1. 什么是JSX？"></a>1. 什么是<code>JSX</code>？</h2><p><code>JSX</code>是JavaScript的扩展标记语言，它允许在JavaScript中嵌入HTML代码。<code>JSX</code>可以让你在JavaScript代码中编写类似于HTML的代码，从而使你的代码更加简洁和易读。</p><p>例如，在<code>React</code>库中，你可以使用<code>JSX</code>编写组件的<code>HTML</code>结构。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;h1 className=<span class="hljs-string">&quot;title&quot;</span> style=&#123;&#123;<span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;red&#x27;</span>&#125;&#125;&gt;hello&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p>经过<code>babel</code>编译后，会变成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">React.createElement(<span class="hljs-string">&#x27;h1&#x27;</span>, &#123;<span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-attr">style</span>: &#123;<span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;red&#x27;</span>&#125;&#125;, <span class="hljs-string">&#x27;hello&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>createElement</code>执行后，会变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json5">&#123;<br>  type:&#x27;h1&#x27;,<br>  props:&#123;<br>    className: &quot;title&quot;,<br>    style: &#123;<br>      color: &#x27;red&#x27;<br>    &#125;<br>  &#125;,<br>  children:&quot;hello&quot;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术类-React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript通关秘籍</title>
    <link href="/20230816/TypeScript%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D/"/>
    <url>/20230816/TypeScript%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="TS类型系统支持哪些类型和类型运算"><a href="#TS类型系统支持哪些类型和类型运算" class="headerlink" title="TS类型系统支持哪些类型和类型运算"></a>TS类型系统支持哪些类型和类型运算</h1><h2 id="TS中的类型"><a href="#TS中的类型" class="headerlink" title="TS中的类型"></a>TS中的类型</h2><p>静态类型系统的目的是把类型检查从运行时提前到编译时。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">基础类型：number、boolean、string、object、symbol、undefined、null<br>包装类型：Number、Boolean、String、Object、Symbol<br>复合类型：class、Array<br>新增了三种类型：Tuple（元组）、Enum（枚举）、Interface（接口）<br></code></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组是一种特殊的数组，它限定了数组元素的类型和个数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> tuple: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>];<br>tuple[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>tuple[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>tuple[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>; <span class="hljs-comment">// Error: 不能将类型“3”分配给类型“undefined”</span><br></code></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口(Interface)是一种类型，它可以描述函数、对象、构造器的结构：</p><p>描述对象：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> person: Person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;;<br>person.name = <span class="hljs-string">&#x27;Jerry&#x27;</span>;<br>person.age = <span class="hljs-string">&#x27;25&#x27;</span>; <span class="hljs-comment">// Error: 不能将类型“&quot;25&quot;”分配给类型“number”</span><br></code></pre></td></tr></table></figure><p>描述函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SearchFunc &#123;<br>    (source: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> mySearch: SearchFunc;<br>mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> source.search(subString) !== -<span class="hljs-number">1</span>;<br>&#125;;<br>mySearch(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>);<br></code></pre></td></tr></table></figure><p>描述构造器：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> PersonConstructor &#123;<br>    <span class="hljs-keyword">new</span>(name: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>): IPerson;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPerson</span>(<span class="hljs-params">ctor: PersonConstructor</span>): <span class="hljs-title">IPerson</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ctor(<span class="hljs-string">&#x27;guang&#x27;</span>, <span class="hljs-number">18</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对象类型、class类型在TS中也叫做<code>索引类型</code>，因为它们都可以通过索引的方式访问属性。对象可以动态添加属性，如果不知道有什么属性，可以用索引签名。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IPerson &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age: <span class="hljs-built_in">number</span>;<br><br>    [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj: IPerson = &#123;&#125;<br>obj.name = <span class="hljs-string">&#x27;hualu&#x27;</span><br>obj.age = <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>总之，接口可以用来描述函数、构造器、索引类型（对象、class、数组）等复合类型。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举（Enum）是一系列值的复合：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Color &#123;Red, Green, Blue&#125;<br><br><span class="hljs-keyword">let</span> c: Color = Color.Green;<br><span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>枚举的值默认从0开始，也可以手动指定：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Color &#123;Red = <span class="hljs-number">1</span>, Green = <span class="hljs-number">2</span>, Blue = <span class="hljs-number">4</span>&#125;<br><br><span class="hljs-keyword">let</span> c: Color = Color.Green;<br><span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>枚举的值可以是字符串：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Color &#123;Red = <span class="hljs-string">&#x27;red&#x27;</span>, Green = <span class="hljs-string">&#x27;green&#x27;</span>, Blue = <span class="hljs-string">&#x27;blue&#x27;</span>&#125;<br><br><span class="hljs-keyword">let</span> c: Color = Color.Green;<br><span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// green</span><br></code></pre></td></tr></table></figure><p>枚举的值可以是计算出来的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Color &#123;Red = <span class="hljs-string">&#x27;red&#x27;</span>.length, Green = <span class="hljs-string">&#x27;green&#x27;</span>.length, Blue = <span class="hljs-string">&#x27;blue&#x27;</span>.length&#125;<br><br><span class="hljs-keyword">let</span> c: Color = Color.Green;<br><span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>TypeScript 还支持<code>字面量类型</code>，也就是类似 1111、’aaaa’、{ a: 1} 这种值也可以做为类型。</p><p>字符串的字面量类型有两种，一种是普通的字符串字面量，比如 ‘aaa’，另一种是模版字面量，比如 aaa${string}，它的意思是以 aaa<br>开头，后面是任意 string 的字符串字面量类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> a: <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>a = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>a = <span class="hljs-string">&#x27;bbb&#x27;</span>; <span class="hljs-comment">// Error: 不能将类型“&quot;bbb&quot;”分配给类型“&quot;aaa&quot;”</span><br><br><span class="hljs-keyword">let</span> b: <span class="hljs-string">`aaa<span class="hljs-subst">$&#123;<span class="hljs-built_in">string</span>&#125;</span>`</span>;<br>b = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>b = <span class="hljs-string">&#x27;aaabbb&#x27;</span>;<br></code></pre></td></tr></table></figure><p>还有四种特殊的类型：<code>void</code>、<code>never</code>、<code>any</code>、<code>unknown</code>：</p><p><code>never</code> 代表不可达，比如函数抛异常的时候，返回值就是 never。</p><p><code>void</code> 代表空，可以是 undefined 或 never。</p><p><code>any</code> 是任意类型，任何类型都可以赋值给它，它也可以赋值给任何类型（除了 never）。</p><p><code>unknown</code> 是未知类型，任何类型都可以赋值给它，但是它不可以赋值给别的类型。</p><p>这些就是 TypeScript 类型系统中的全部类型了，大部分是从 JS 中迁移过来的，比如基础类型、Array、class 等，也添加了一些类型，比如<br>枚举（enum）、接口（interface）、元组等，还支持了字面量类型和 void、never、any、unknown 的特殊类型。</p><h2 id="类型的装饰"><a href="#类型的装饰" class="headerlink" title="类型的装饰"></a>类型的装饰</h2><p>除了描述类型的结构外，TypeScript 的类型系统还支持描述类型的属性，比如是否可选，是否只读等：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IPerson &#123;<br>    <span class="hljs-keyword">readonly</span> name: <span class="hljs-built_in">string</span>;<br>    age?: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> tuple = [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>?];<br></code></pre></td></tr></table></figure><hr><h1 id="TypeScript-类型系统中的类型运算"><a href="#TypeScript-类型系统中的类型运算" class="headerlink" title="TypeScript 类型系统中的类型运算"></a>TypeScript 类型系统中的类型运算</h1><h2 id="条件：extends"><a href="#条件：extends" class="headerlink" title="条件：extends ? :"></a>条件：extends ? :</h2><p>TypeScript 里的条件判断是 extends ? :，叫做条件类型（Conditional Type）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> res = <span class="hljs-number">1</span> <span class="hljs-keyword">extends</span> <span class="hljs-number">2</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>这就是 TypeScript 类型系统里的 if else。</p><p>但是，上面这样的逻辑没啥意义，静态的值自己就能算出结果来，为什么要用代码去判断呢？</p><p>所以，类型运算逻辑都是用来做一些动态的类型的运算的，也就是对类型参数的运算。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> isTwo&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-number">2</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">type</span> res = isTwo&lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-keyword">type</span> res2 = isTwo&lt;<span class="hljs-number">2</span>&gt;;<br></code></pre></td></tr></table></figure><p>这种类型也叫做<code>高级类型</code>。</p><p><strong>高级类型的特点是传入类型参数，经过一系列类型运算逻辑后，返回新的类型。</strong></p><h2 id="推倒：infer"><a href="#推倒：infer" class="headerlink" title="推倒：infer"></a>推倒：infer</h2><p>如何提取类型的一部分呢？答案是 infer。</p><p>比如提取元组类型的第一个元素：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> First&lt;Tuple <span class="hljs-keyword">extends</span> unknown[]&gt; = Tuple <span class="hljs-keyword">extends</span> [infer T, ...infer R] ? T : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-keyword">type</span> res = First&lt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&gt;;<br></code></pre></td></tr></table></figure><h2 id="联合："><a href="#联合：" class="headerlink" title="联合：|"></a>联合：|</h2><p>联合类型（Union Type）是指一个变量可以有多种类型，比如 number | string，表示这个变量可以是 number 类型，也可以是 string 类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> res = <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h2 id="交叉：-amp"><a href="#交叉：-amp" class="headerlink" title="交叉：&amp;"></a>交叉：&amp;</h2><p>交叉类型（Intersection Type）是指一个变量可以同时拥有多种类型的属性，比如 number &amp; string，表示这个变量既拥有 number<br>类型的属性，也拥有 string 类型的属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> res = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125; &amp; &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br></code></pre></td></tr></table></figure><p>注意，同一类型可以合并，不同的类型没法合并，会被舍弃：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> res = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125; &amp; &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;  <span class="hljs-comment">// res:never</span><br></code></pre></td></tr></table></figure><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>对象、class 在 TypeScript 对应的类型是索引类型（Index Type），那么如何对索引类型作修改呢？</p><p>答案是映射类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> MapType&lt;T&gt; = &#123;<br>    [Key <span class="hljs-keyword">in</span> keyof T]?: T[Key]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>keyof T</code>是查询索引类型中所有的索引，叫做<code>索引查询</code></p><p><code>T[Key]</code>是查询索引类型中索引对应的类型，叫做<code>索引访问</code></p><p><code>in</code>是用于便利联合类型的运算符。</p><p>比如我们把一个索引类型的值变成 3 个元素的数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> MapType&lt;T&gt; = &#123;<br>    [Key <span class="hljs-keyword">in</span> keyof T]: [T[Key], T[Key], T[Key]]<br>&#125;<br><br><span class="hljs-keyword">type</span> res = MapType&lt;&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;&gt;;<br></code></pre></td></tr></table></figure><p>除了值可以变化，索引也可以做变化，用 as 运算符，叫做<code>重映射</code>。</p><p>比如我们把一个索引类型的值变成 3 个元素的数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> MapType&lt;T&gt; = &#123;<br>    [Key <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> <span class="hljs-string">`new_<span class="hljs-subst">$&#123;Key&#125;</span>`</span>]: T[Key]<br>&#125;<br><br><span class="hljs-keyword">type</span> res = MapType&lt;&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;&gt;;<br></code></pre></td></tr></table></figure><h1 id="套路一：模式匹配做提取"><a href="#套路一：模式匹配做提取" class="headerlink" title="套路一：模式匹配做提取"></a>套路一：模式匹配做提取</h1><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>比如这样一个 Promise 类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> p = <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-string">&#x27;guang&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>我们想提取value的类型，可以这样做：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> res = p <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Promise</span>&lt;infer T&gt; ? T : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><p>通过 extends 对传入的类型参数 P 做模式匹配，其中值的类型是需要提取的，通过 infer 声明一个局部变量 Value 来保存，如果匹配，就返回匹配到的<br>Value，否则就返回 never 代表没匹配到。</p><p>这就是 Typescript 类型的模式匹配：</p><p>Typescript 类型的模式匹配是通过 extends 对类型参数做匹配，结果保存到通过 infer 声明的局部类型变量里，如果匹配就能从该局部变量里拿到提取出的类型。</p><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>数组类型想提取第一个元素的类型怎么做呢？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> GetArrFirst&lt;Arr <span class="hljs-keyword">extends</span> unknown[]&gt; = Arr <span class="hljs-keyword">extends</span> [infer T, ...infer arr] ? T : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p><code>构造器</code>和<code>函数</code>的区别是，<code>构造器</code>是用于创建对象的，所以可以被<code>new</code>。</p><h1 id="套路二：重新构造做变换"><a href="#套路二：重新构造做变换" class="headerlink" title="套路二：重新构造做变换"></a>套路二：重新构造做变换</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Zip&lt;One <span class="hljs-keyword">extends</span> [unknown, unknown], Other <span class="hljs-keyword">extends</span> [unknown, unknown]&gt; =<br>    One <span class="hljs-keyword">extends</span> [infer OneFirst, infer OneSecond] ? (Other <span class="hljs-keyword">extends</span> [infer OtherFirst, infer OtherSecond] ? [[OneFirst, OtherFirst], [OneSecond, OtherSecond]] : []) : [];<br><br><span class="hljs-keyword">type</span> ZipResult = Zip&lt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">&#x27;huang&#x27;</span>, <span class="hljs-string">&#x27;jie&#x27;</span>]&gt;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 首字母大写</span><br><span class="hljs-keyword">type</span> CapitalizeStr&lt;Str <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = Str <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer first&#125;</span><span class="hljs-subst">$&#123;infer left&#125;</span>`</span> ? <span class="hljs-string">`<span class="hljs-subst">$&#123;Uppercase&lt;first&gt;&#125;</span><span class="hljs-subst">$&#123;left&#125;</span>`</span> : Str<br><br><span class="hljs-keyword">type</span> UseString = CapitalizeStr&lt;<span class="hljs-string">&#x27;huang&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 实现 dong_dong_dong 到 dongDongDong 的变换</span><br><br><span class="hljs-keyword">type</span> CamelCase&lt;Str <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = Str <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer left&#125;</span>_<span class="hljs-subst">$&#123;infer right&#125;</span><span class="hljs-subst">$&#123;infer rest&#125;</span>`</span> ? <span class="hljs-string">`<span class="hljs-subst">$&#123;left&#125;</span><span class="hljs-subst">$&#123;Uppercase&lt;right&gt;&#125;</span><span class="hljs-subst">$&#123;CamelCase&lt;rest&gt;&#125;</span>`</span> : Str<br><br><span class="hljs-keyword">type</span> tryCamelCase = CamelCase&lt;<span class="hljs-string">&#x27;dong_dong_dong&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 删除字符串中的某个子串</span><br><br><span class="hljs-keyword">type</span> DropSubStr&lt;Str <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, SubStr <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = Str <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer prefix&#125;</span><span class="hljs-subst">$&#123;SubStr&#125;</span><span class="hljs-subst">$&#123;infer suffix&#125;</span>`</span> ? DropSubStr&lt;<span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span><span class="hljs-subst">$&#123;suffix&#125;</span>`</span>, SubStr&gt; : Str<br><br><span class="hljs-keyword">type</span> TeyDropSubStr = DropSubStr&lt;<span class="hljs-string">&#x27;hello,world&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><br><span class="hljs-comment">// 函数类型的重新构造</span><br><span class="hljs-keyword">type</span> AppendArgument&lt;Func <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Function</span>, Arg&gt; = Func <span class="hljs-keyword">extends</span> (...args: infer Args) =&gt; infer ReturnType ? <span class="hljs-function">(<span class="hljs-params">...args: [...Args, Arg]</span>) =&gt;</span> ReturnType : <span class="hljs-built_in">never</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-keyword">type</span> TryAppendArgument = AppendArgument&lt;<span class="hljs-keyword">typeof</span> Add, <span class="hljs-number">3</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="索引类型的重新构造"><a href="#索引类型的重新构造" class="headerlink" title="索引类型的重新构造"></a>索引类型的重新构造</h2><p>索引类型是聚合多个元素的类型，class、对象等都是索引类型，比如这就是一个索引类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age: <span class="hljs-built_in">number</span>;<br>    gender: <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>索引类型可以添加修饰符 readonly（只读）、?（可选）:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> obj = &#123;<br>    <span class="hljs-keyword">readonly</span> name: <span class="hljs-built_in">string</span>;<br>    age?: <span class="hljs-built_in">number</span>;<br>    gender: <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><p>对它的修改和构造新类型涉及到了映射类型的语法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Mapping&lt;Obj <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>    [Key <span class="hljs-keyword">in</span> keyof Obj]: Obj[Key]<br>&#125;<br></code></pre></td></tr></table></figure><p>用 <code>keyof</code> 取出 <code>Obj</code> 的索引，作为新的索引类型的索引，也就是 <code>Key in keyof Obj</code>。</p><h3 id="UppercaseKey"><a href="#UppercaseKey" class="headerlink" title="UppercaseKey"></a>UppercaseKey</h3><p>除了可以对 <code>Value</code> 做修改，也可以对 <code>Key</code> 做修改，使用 <code>as</code>，这叫做<strong>重映射</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 把索引类型的key变成大写</span><br><span class="hljs-keyword">type</span> UppercaseKey&lt;Obj <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>    [Key <span class="hljs-keyword">in</span> keyof Obj <span class="hljs-keyword">as</span> Uppercase&lt;Key &amp; <span class="hljs-built_in">string</span>&gt;]: Obj[Key]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p>TypeScript 提供了内置的高级类型 <code>Record</code> 来创建索引类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Record&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | symbol, T&gt; = &#123; [P <span class="hljs-keyword">in</span> K]: T; &#125;<br></code></pre></td></tr></table></figure><p>指定索引和值的类型分别为 <code>K</code> 和 <code>T</code>，就可以创建一个对应的索引类型。</p><p>上面的索引类型的约束我们用的 object，其实更语义化一点我推荐用 Record&lt;string, any&gt;:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> UppercaseKey&lt;Obj <span class="hljs-keyword">extends</span> Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;&gt; = &#123;<br>    [Key <span class="hljs-keyword">in</span> keyof Obj <span class="hljs-keyword">as</span> Uppercase&lt;Key &amp; <span class="hljs-built_in">string</span>&gt;]: Obj[Key]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="去掉readonly修饰"><a href="#去掉readonly修饰" class="headerlink" title="去掉readonly修饰"></a>去掉readonly修饰</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> RemoveReadonly&lt;Obj <span class="hljs-keyword">extends</span> Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;&gt; = &#123;<br>    -<span class="hljs-keyword">readonly</span> [Key <span class="hljs-keyword">in</span> keyof Obj]: Obj[Key]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="去掉可选修饰符"><a href="#去掉可选修饰符" class="headerlink" title="去掉可选修饰符"></a>去掉可选修饰符</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> RemoveOptional&lt;Obj <span class="hljs-keyword">extends</span> Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;&gt; = &#123;<br>    [Key <span class="hljs-keyword">in</span> keyof Obj]-?: Obj[Key]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FilterByValueType"><a href="#FilterByValueType" class="headerlink" title="FilterByValueType"></a>FilterByValueType</h3><p>可以在构造新索引类型的时候根据值的类型做下过滤：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> FilterByValueType&lt;<br>    Obj <span class="hljs-keyword">extends</span> Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;,<br>    ValueType<br>&gt; = &#123;<br>    [Key <span class="hljs-keyword">in</span> keyof Obj <span class="hljs-keyword">as</span> Obj[Key] <span class="hljs-keyword">extends</span> ValueType ? Key : <span class="hljs-built_in">never</span>]<br>    : Obj[Key]<br>&#125;<br></code></pre></td></tr></table></figure><p>如果原来索引的值 <code>Obj[Key]</code> 是 <code>ValueType</code> 类型，索引依然为之前的索引 <code>Key</code>，否则索引设置为 <code>never</code>，<code>never</code><br>的索引会在生成新的索引类型时被去掉。</p><p>值保持不变，依然为原来索引的值，也就是 <code>Obj[Key]</code>。</p><p>这样就达到了过滤索引类型的索引，产生新的索引类型的目的。</p><hr><h1 id="递归复用做变换"><a href="#递归复用做变换" class="headerlink" title="递归复用做变换"></a>递归复用做变换</h1><p><code>递归</code>是把问题分解为一系列相似的小问题，通过函数不断调用自身来解决这一个个小问题，直到满足结束条件，就完成了问题的求解。</p><p>TypeScript<br>类型系统不支持循环，但支持递归。当处理数量（个数、长度、层数）不固定的类型的时候，可以只处理一个类型，然后递归的调用自身处理下一个类型，直到结束条件也就是所有的类型都处理完了，就完成了不确定数量的类型编程，达到循环的效果。</p><h2 id="Promise-的递归复用"><a href="#Promise-的递归复用" class="headerlink" title="Promise 的递归复用"></a>Promise 的递归复用</h2><h3 id="DeepPromiseValueType"><a href="#DeepPromiseValueType" class="headerlink" title="DeepPromiseValueType"></a>DeepPromiseValueType</h3><p>先用 Promise 热热身，实现一个提取不确定层数的 Promise 中的 value 类型的高级类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts">    <span class="hljs-keyword">type</span> ttt = <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">Promise</span>&lt;Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;&gt;&gt;&gt;;<br><span class="hljs-keyword">type</span> DeepPromiseValueType&lt;P <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Promise</span>&lt;unknown&gt;&gt; =<br>    P <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Promise</span>&lt;infer ValueType&gt;<br>        ? ValueType <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Promise</span>&lt;unknown&gt;<br>            ? DeepPromiseValueType&lt;ValueType&gt; : ValueType<br>        : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><p>其实这个类型的实现可以进一步的简化：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> DeepPromiseValueType&lt;P&gt; =<br>P <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Promise</span>&lt;infer ValueType&gt;<br>    ? DeepPromiseValueType&lt;ValueType&gt; : P;<br></code></pre></td></tr></table></figure><h2 id="数组类型的递归"><a href="#数组类型的递归" class="headerlink" title="数组类型的递归"></a>数组类型的递归</h2><h3 id="ReverseArr"><a href="#ReverseArr" class="headerlink" title="ReverseArr"></a>ReverseArr</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 将 type arr = [1,2,3,4,5] 变成 type arr = [5,4,3,2,1]</span><br><span class="hljs-comment">// 假如数组长度不确定，怎么做呢？ 用递归！</span><br><br><span class="hljs-keyword">type</span> ReverseArr&lt;Arr <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Array</span>&lt;unknown&gt;&gt; = Arr <span class="hljs-keyword">extends</span> [infer First, ...infer Rest] ? [...ReverseArr&lt;Rest&gt;, First] : Arr;<br></code></pre></td></tr></table></figure><h3 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a>Includes</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 查找 [1, 2, 3, 4, 5] 中是否存在 4，是就返回 true，否则返回 false。</span><br><br><span class="hljs-keyword">type</span> Includes&lt;Arr <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Array</span>&lt;unknown&gt;, FindItem&gt; = Arr <span class="hljs-keyword">extends</span> [infer First, ...infer Rest] ? (First <span class="hljs-keyword">extends</span> FindItem ? <span class="hljs-literal">true</span> : Includes&lt;Rest, FindItem&gt;) : <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h3 id="RemoveItem"><a href="#RemoveItem" class="headerlink" title="RemoveItem"></a>RemoveItem</h3><p>可以查找自然就可以删除，只需要改下返回结果，构造一个新的数组返回。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> RemoveItem&lt;Arr <span class="hljs-keyword">extends</span> unknown[], Item, Result <span class="hljs-keyword">extends</span> unknown[] = []&gt;<br>    = Arr <span class="hljs-keyword">extends</span> [infer First, ...infer Rest]<br>    ? (First <span class="hljs-keyword">extends</span> Item<br>        ? RemoveItem&lt;Rest, Item, Result&gt;<br>        : RemoveItem&lt;Rest, Item, [...Result, First]&gt;)<br>    : Result; <br></code></pre></td></tr></table></figure><h3 id="BuildArray"><a href="#BuildArray" class="headerlink" title="BuildArray"></a>BuildArray</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 传入 5 和元素类型，构造一个长度为 5 的该元素类型构成的数组。</span><br><span class="hljs-keyword">type</span> BuildArray&lt;Length <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>, Ele = unknown, Arr <span class="hljs-keyword">extends</span> unknown[] = []&gt; = Arr[<span class="hljs-string">&#x27;length&#x27;</span>] <span class="hljs-keyword">extends</span> Length ? Arr : BuildArray&lt;Length, Ele, [Ele, ...Arr]&gt;<br><br><span class="hljs-keyword">type</span> BuildArrResult = BuildArray&lt;<span class="hljs-number">5</span>, <span class="hljs-built_in">string</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="字符串类型的递归"><a href="#字符串类型的递归" class="headerlink" title="字符串类型的递归"></a>字符串类型的递归</h2><p><strong>在类型体操里，遇到数量不确定的问题，就要条件反射的想到递归。</strong></p><h3 id="ReplaceAll"><a href="#ReplaceAll" class="headerlink" title="ReplaceAll"></a>ReplaceAll</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ReplaceAll&lt;<br>    Str <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,<br>    From <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,<br>    To <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span><br>&gt; = Str <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer Left&#125;</span><span class="hljs-subst">$&#123;From&#125;</span><span class="hljs-subst">$&#123;infer Right&#125;</span>`</span><br>    ? <span class="hljs-string">`<span class="hljs-subst">$&#123;Left&#125;</span><span class="hljs-subst">$&#123;To&#125;</span><span class="hljs-subst">$&#123;ReplaceAll&lt;Right, From, To&gt;&#125;</span>`</span><br>    : Str;<br><br><span class="hljs-keyword">type</span> ReplaceAllResult = ReplaceAll&lt;<span class="hljs-string">&#x27;hello,world&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="StringToUnion"><a href="#StringToUnion" class="headerlink" title="StringToUnion"></a>StringToUnion</h3><p>把字符串字面量类型的每个字符都提取出来组成联合类型，也就是把 ‘dong’ 转为 ‘d’ | ‘o’ | ‘n’ | ‘g’。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><br><span class="hljs-comment">// 首字母放到first字段，其余字符放到Rest字段</span><br><span class="hljs-keyword">type</span> StringToUnion&lt;Str <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = Str <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer first&#125;</span><span class="hljs-subst">$&#123;infer Rest&#125;</span>`</span> ? first | StringToUnion&lt;Rest&gt; : <span class="hljs-built_in">never</span><br><br><span class="hljs-keyword">type</span> StringToUnionResult = StringToUnion&lt;<span class="hljs-string">&#x27;dong&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="ReverseStr"><a href="#ReverseStr" class="headerlink" title="ReverseStr"></a>ReverseStr</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ReverseStr&lt;Str <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, Result <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>&gt; = Str <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer First&#125;</span><span class="hljs-subst">$&#123;infer Rest&#125;</span>`</span> ? ReverseStr&lt;Rest, <span class="hljs-string">`<span class="hljs-subst">$&#123;First&#125;</span><span class="hljs-subst">$&#123;Result&#125;</span>`</span>&gt; : Result<br><br><span class="hljs-keyword">type</span> ReverseStrResult = ReverseStr&lt;<span class="hljs-string">&#x27;dong&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="对象类型的递归"><a href="#对象类型的递归" class="headerlink" title="对象类型的递归"></a>对象类型的递归</h2><h3 id="DeepReadonly"><a href="#DeepReadonly" class="headerlink" title="DeepReadonly"></a>DeepReadonly</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs ts"><br><span class="hljs-comment">// 如果对象的层数不确定，就需要递归来解决</span><br><br><span class="hljs-comment">// type DeepReadonly&lt;Obj extends Record&lt;string, any&gt;&gt; = &#123;</span><br><span class="hljs-comment">//     readonly [Key in keyof Obj]:</span><br><span class="hljs-comment">//     Obj[Key] extends object</span><br><span class="hljs-comment">//         ? Obj[Key] extends Function</span><br><span class="hljs-comment">//             ? Obj[Key]</span><br><span class="hljs-comment">//             : DeepReadonly&lt;Obj[Key]&gt;</span><br><span class="hljs-comment">//         : Obj[Key]</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">type</span> DeepReadonly&lt;T <span class="hljs-keyword">extends</span> Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; = &#123;&#125;&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span> ? &#123;<br>    <span class="hljs-keyword">readonly</span> [k <span class="hljs-keyword">in</span> keyof T]: T[k] <span class="hljs-keyword">extends</span> Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; ? DeepReadonly&lt;T[k]&gt; : T[k]<br>&#125; : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-keyword">type</span> TestDeepReadonly = DeepReadonly&lt;&#123;<br>    <span class="hljs-attr">a</span>: &#123;<br>        <span class="hljs-attr">b</span>: &#123;<br>            <span class="hljs-attr">c</span>: &#123;<br>                <span class="hljs-attr">f</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;dong&#x27;</span>,<br>                <span class="hljs-attr">d</span>: &#123;<br>                    <span class="hljs-attr">e</span>: &#123;<br>                        <span class="hljs-attr">guang</span>: <span class="hljs-built_in">string</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">k</span>: <span class="hljs-number">1</span><br>&#125;&gt;<br><br></code></pre></td></tr></table></figure><h1 id="元组长度做计算"><a href="#元组长度做计算" class="headerlink" title="元组长度做计算"></a>元组长度做计算</h1><p>**TypeScript 类型系统中没有加减乘除运算符，但是可以通过构造不同的元组然后取 length 的方式来完成数值计算，把数值的加减乘除转化为对元组的提取和构造。<br>**</p><h2 id="元组长度实现加减乘除"><a href="#元组长度实现加减乘除" class="headerlink" title="元组长度实现加减乘除"></a>元组长度实现加减乘除</h2><h3 id="Add加法"><a href="#Add加法" class="headerlink" title="Add加法"></a>Add加法</h3><p>构造两个数组，然后合并成一个，取 length。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> BuildArray&lt;<br>    Length <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>,<br>    Ele = unknown,<br>    Arr <span class="hljs-keyword">extends</span> unknown[] = []<br>&gt; = Arr[<span class="hljs-string">&#x27;length&#x27;</span>] <span class="hljs-keyword">extends</span> Length<br>    ? Arr<br>    : BuildArray&lt;Length, Ele, [...Arr, Ele]&gt;;<br></code></pre></td></tr></table></figure><p>类型参数 Length 是要构造的数组的长度。类型参数 Ele 是数组元素，默认为 unknown。类型参数 Arr 为构造出的数组，默认是 []。</p><p>基于它就能实现加法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Add&lt;Num1 <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>, Num2 <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>&gt; =<br>    [...BuildArray&lt;Num1&gt;, ...BuildArray&lt;Num2&gt;][<span class="hljs-string">&#x27;length&#x27;</span>];<br></code></pre></td></tr></table></figure><h3 id="Subtract减法"><a href="#Subtract减法" class="headerlink" title="Subtract减法"></a>Subtract减法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Subtract&lt;Num1 <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>, Num2 <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>&gt; =<br>    BuildArray&lt;Num1&gt; <span class="hljs-keyword">extends</span> [...arr1: BuildArray&lt;Num2&gt;, ...arr2: infer Rest]<br>        ? Rest[<span class="hljs-string">&#x27;length&#x27;</span>]<br>        : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><p>类型参数 Num1、Num2 分别是被减数和减数，通过 extends 约束为 number。</p><p>构造 Num1 长度的数组，通过模式匹配提取出 Num2 长度个元素，剩下的放到 infer 声明的局部变量 Rest 里。</p><p>取 Rest 的长度返回，就是减法的结果。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> SubstractResult = Subtract&lt;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="Multiply乘法"><a href="#Multiply乘法" class="headerlink" title="Multiply乘法"></a>Multiply乘法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Multiply&lt;Num1 <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>, Num2 <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>&gt; =<br>    BuildArray&lt;Num2&gt; <span class="hljs-keyword">extends</span> [...arr: BuildArray&lt;Num1&gt;]<br>        ? arr[<span class="hljs-string">&#x27;length&#x27;</span>]<br>        : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><h1 id="TS内置的高级类型有哪些？"><a href="#TS内置的高级类型有哪些？" class="headerlink" title="TS内置的高级类型有哪些？"></a>TS内置的高级类型有哪些？</h1><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p><code>Parameters</code>用于提取函数类型的参数类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Parameters&lt;T <span class="hljs-keyword">extends</span> (...args: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt;<br>    = T <span class="hljs-keyword">extends</span> (...args: infer P) =&gt; <span class="hljs-built_in">any</span><br>    ? P<br>    : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><p>类型参数 T 为待处理的类型，通过 extends 约束为函数，参数和返回值任意。</p><p>通过 extends 匹配一个模式类型，提取参数的类型到 infer 声明的局部变量 P 中返回。</p><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h2><p><code>ReturnType</code> 用于提取函数类型的返回值类型。</p><p>源码是这样的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ReturnType&lt;T <span class="hljs-keyword">extends</span> (...args: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt; =<br>    T <span class="hljs-keyword">extends</span> (...args: <span class="hljs-built_in">any</span>) =&gt; infer P ? P : <span class="hljs-built_in">any</span> <br></code></pre></td></tr></table></figure><p>类型参数 T 为待处理的类型，通过 extends 约束为函数类型，参数和返回值任意。</p><p>用 T 匹配一个模式类型，提取返回值的类型到 infer 声明的局部变量 P 里返回。</p><h2 id="ConstructorParameters"><a href="#ConstructorParameters" class="headerlink" title="ConstructorParameters"></a>ConstructorParameters</h2><p>构造器类型和函数类型的区别就是可以被<code>new</code></p><p><code>Parameters</code> 用于提取函数参数的类型，而 <code>ConstructorParameters</code> 用于提取构造器参数的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ConstructorParameters&lt;<br>    T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">new</span> (...args: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span><br>&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">new</span> (...args: infer P) =&gt; <span class="hljs-built_in">any</span><br>    ? P<br>    : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><p>类型参数 T 是待处理的类型，通过 extends 约束为构造器类型，加个 abstract 代表不能直接被实例化（其实不加也行）。</p><p>用 T 匹配一个模式类型，提取参数的部分到 infer 声明的局部变量 P 里，返回 P。</p><h2 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType</h2><p>提取构造器返回值的类型，就是 <code>InstanceType</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> InstanceType&lt;<br>    T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">new</span> (...args: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span><br>&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">new</span> (...args: <span class="hljs-built_in">any</span>) =&gt; infer R<br>    ? R<br>    : <span class="hljs-built_in">any</span>;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术类-TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang笔记</title>
    <link href="/20230728/Golang%E7%AC%94%E8%AE%B0/"/>
    <url>/20230728/Golang%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>1.</p><p><strong>数组</strong>是值类型，赋值和传参会复制整个数组，而不是指针。<br><strong>切片</strong>是引用类型，赋值和传参都会复制指针，而不是数据。</p><p>2.</p><p>函数的参数有两种传递方式，按值传递和按引用传递。按值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到原来的实际参数。按引用传递是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到原来的实际参数。</p><p>引用类型（slice、map、interface、channel）都默认使用引用传递</p><p>3.</p><p>切片传入方法中，如果方法内部没有对切片进行扩容，那么切片的修改会影响到原切片，如果方法内部对切片进行了扩容，那么切片的修改不会影响到原切片。</p><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><ol><li>延迟执行，在当前栈退出时执行</li><li>一般用于资源清理工作</li><li>解锁、关闭文件</li><li>多次调用defer，执行时类似于栈的机制：先进后出</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker知识整理</title>
    <link href="/20230519/docker%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <url>/20230519/docker%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>构建镜像的方式有两种：</p><ol><li>docker commit命令</li><li>Dockerfile构建文件</li></ol><h3 id="docker-commit命令"><a href="#docker-commit命令" class="headerlink" title="docker commit命令"></a>docker commit命令</h3><p>三个步骤：</p><ul><li>运行容器</li><li>修改容器</li><li>将容器保存为新的镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 运行容器</span><br>docker run -it --name <span class="hljs-built_in">test</span> ubuntu:latest /bin/bash<br><br><span class="hljs-comment"># 修改容器</span><br>apt-get update<br>apt-get install vim<br><br><span class="hljs-comment"># 将容器保存为新的镜像</span><br>docker commit -m=<span class="hljs-string">&quot;add vim&quot;</span> -a=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>:1.0<br><br></code></pre></td></tr></table></figure><p>此时执行docker images命令，可以看到新的镜像已经生成。</p><p><strong>Docker不建议用户通过这种方式构建镜像。容易出错，效率低且 可重复性低，而且使用者并不知道镜像是如何创建出来的，里面是否有恶意程序</strong></p><h3 id="Dockerfile构建文件"><a href="#Dockerfile构建文件" class="headerlink" title="Dockerfile构建文件"></a>Dockerfile构建文件</h3><p>Dockerfile是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><ol><li><p>新建一个Dockerfile文件</p></li><li><p>编写Dockerfile文件，输入如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM ubuntu:latest<br>RUN apt-get update<br>RUN apt-get install -y vim<br></code></pre></td></tr></table></figure></li><li><p>执行docker build命令，构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t <span class="hljs-built_in">test</span>:1.0 .<br></code></pre></td></tr></table></figure></li></ol><p><code>-t</code>将镜像命名为test:1.0，<code>.</code>表示Dockerfile文件所在的路径，表明当前目录，会自动查找当前目录下的Dockerfile文件。<br>我们也可以通过-f指定Dockerfile文件的路径。</p><h4 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h4><ul><li>FROM：指定基础镜像，必须为第一条指令</li><li>MAINTAINER：指定镜像的作者和联系方式</li><li>RUN：构建镜像时需要运行的命令</li><li>EXPOSE：指定容器运行时监听的端口</li><li>WORKDIR：指定容器中的工作目录</li><li>ENV：用来在构建镜像过程中设置环境变量</li><li>ADD：将宿主机目录下的文件拷贝到镜像中</li><li>COPY：将宿主机目录下的文件拷贝到镜像中</li><li>VOLUME：用于指定持久化目录，或者挂载目录</li><li>CMD：指定容器启动时要运行的命令，每个Dockerfile只能有一条CMD命令，多条则只有最后一条生效</li><li>ENTRYPOINT：指定容器启动时要运行的命令，每个Dockerfile只能有一条ENTRYPOINT命令，多条则只有最后一条生效</li><li>ONBUILD：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</li><li>USER：指定运行容器时的用户名或UID，后续的RUN、CMD、ENTRYPOINT都会以指定用户运行</li><li>LABEL：为镜像添加元数据，元数据可以被Docker Hub等平台识别</li><li>ARG：构建参数，构建时使用–build-arg <varname>=<value>可以覆盖默认值</li><li>SHELL：指定SHELL类型，SHELL [“executable”, “parameters”]，SHELL /bin/bash</li><li>STOPSIGNAL：指定接收到什么信号时停止容器运行，STOPSIGNAL signal</li><li>HEALTHCHECK：健康检查，用于检查应用的健康状态，包括：检查容器是否存活、检查容器是否能够响应请求、检查容器中的应用是否正常运行等</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端工程化</title>
    <link href="/20230420/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <url>/20230420/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d62b9a148e14be298cad627cac1de6b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="前端工程化"></p><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><p><code>前端工程化</code>指使用软件工程的技术与方法对前端开发的技术、工具、流程、经验、方案等指标标准化，<br>它具备<strong>模块化、组件化、规范化、自动化</strong>四大特性，<br>主要目的是<strong>降低成本</strong>与<strong>增加效率</strong>。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p><code>模块化</code>是前端工程化的重中之重。它在前端工程化中具体表现为：在文件层面上对代码与资源实现拆分与组装，将一个大文件拆分为互相依赖的小文件，再统一拼装与加载。</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p><code>组件化</code>是前端工程化的重要基础。它实现了代码更高层次的复用性，提升开发效率。组件的封装也是对象的封装，同样要做到**高内聚低耦合<br>**，组件化的项目不仅利于单元测试的进行，同样也利于需求迭代的推进。</p><p>优秀的组件化遵循以下设计哲学。</p><ul><li>将设计图划分为最小组件层级</li><li>使用预设规范创建组件静态版本</li><li>确定组件内部最小且完整的状态的表示方式</li><li>确定组件内部最小且完整的状态的存放方式</li><li>实现数据流的正向传递与反向传递</li></ul><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p><code>规范化</code>指将一系列预设规范接入工程各个阶段，通过各项指标标准化开发者的工作流程，引导开发者在团队协作中往更好的方向发展。</p><p><code>规范化</code><br>是前端工程化的重要部分。它有效地将一盘松散的规范通过指定标准凝聚在一起，将所有工作流程标准化，协同所有开发者以标准化的方式定义工作流程，同时也影响着代码、文档和日志，甚至影响着每个开发者及其团队发展方向，因此每个成熟的前端团队都有一套身经百战的规范化方案。</p><p><code>规范化</code>更多应用在团队协作中，为每个开发者指明一个方向，引领着成员往该方向走。若团队无规范化，每个开发者各做各的事情，在合并代码时肯定会发生争吵，甚至影响工作效率。</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p><code>自动化</code>指将一系列繁琐重复的工作流程交由程序根据预设脚本自动处理，整个工作流程无需人工参与，以解放开发者双手让其更专注业务需求的开发。</p><p><code>自动化</code><br>是前端工程化的智能部分。它既可解放双手又能节省大量时间做更多有意义的事情，常见自动化场景包括但不限于<code>自动化构建</code>、<code>自动化测试</code>、<code>自动化打包</code>、<code>自动化发布</code><br>和<code>自动化部署</code>，更高级的自动化场景包括但不限于<code>持续集成</code>、<code>持续交付</code>和<code>持续部署</code><br>。以自动化构建为例，又可将其划分为以下子任务，这些子任务分布在自动化构建不同阶段，在不同阶段的最佳时刻会调用相关工具处理相关流程。</p><table><thead><tr><th>任务</th><th>职责</th></tr></thead><tbody><tr><td>Stylelint</td><td>校验样式代码</td></tr><tr><td>Eslint</td><td>校验脚本代码</td></tr><tr><td>Postcss</td><td>Postcss → CSS</td></tr><tr><td>Sass</td><td>SASS → CSS</td></tr><tr><td>Less</td><td>LESS → CSS</td></tr><tr><td>Babel</td><td>ES6 → ES5</td></tr><tr><td>TypeScript</td><td>TS → JS</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>前端工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx知识整理&amp;记录</title>
    <link href="/20230303/Nginx%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%B0%E5%BD%95/"/>
    <url>/20230303/Nginx%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd0a614838ac4aafb10f0275a32ab130~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p><h2 id="Nginx是什么？"><a href="#Nginx是什么？" class="headerlink" title="Nginx是什么？"></a>Nginx是什么？</h2><p><code>Nginx (engine x)</code> 是一个<strong>轻量级</strong>、<strong>高性能</strong>的<strong>HTTP和反向代理服务器</strong>,同时也是一个通用代理服务器(<br>TCP/UDP/IMAP/POP3/SMTP)。</p><ul><li>Nginx是一个拥有高性能HTTP和反向代理服务器，其特点是占用内存少，并发能力强，并且在现实中，nginx的并发能力要比在同类型的网页服务器中表现要好</li><li>Nginx专为性能优化而开发，最重要的要求便是性能，且十分注重效率，有报告nginx能支持高达50000个并发连接数</li></ul><h2 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h2><ul><li>正向代理，代理客户端,客户端不想让服务器知道客户端的ip，所以让代理服务器去访问，再返回给客户端。</li><li>反向代理，代理服务器,服务器不想客户端知道是哪个服务器响应的，所以让代理服务器去分配，让空闲的服务器去响应。</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡：是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6c634ec69f54d5ab76644d8dd78b0c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="负载均衡"></p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a91e7a373df14e90891e6f4f62a629d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="动静分离"></p><h2 id="服务器端配置和使用Nginx"><a href="#服务器端配置和使用Nginx" class="headerlink" title="服务器端配置和使用Nginx"></a>服务器端配置和使用Nginx</h2><p><a href="https://juejin.cn/post/7052952117425733663">此文写的比较详细，点击链接跳转</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>M1版本Mac电脑前端开发环境配置</title>
    <link href="/20221106/M1%E7%89%88%E6%9C%ACMac%E7%94%B5%E8%84%91%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/20221106/M1%E7%89%88%E6%9C%ACMac%E7%94%B5%E8%84%91%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>〉Mac电脑的开发环境配置比Windows的要麻烦许多，特别是M1版本的Mac发布之后，配置方面也有些变化，对此做一些记录。</p><h2 id="1-安装Homebrew"><a href="#1-安装Homebrew" class="headerlink" title="1.安装Homebrew"></a>1.安装Homebrew</h2><p>文档地址：<a href="https://brew.sh/">https://brew.sh/</a></p><p>打开苹果终端，输入<code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</code>，但是此方法由于没有科学上网往往会比较慢，所以我们可以用国内的镜像去安装，<code>/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</code>，按照给出的提示一步步来完成安装。</p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><p>在终端输入命令<code>brew install git</code>，完成Git的安装</p><h2 id="3-安装nvm来控制nodejs版本"><a href="#3-安装nvm来控制nodejs版本" class="headerlink" title="3.安装nvm来控制nodejs版本"></a>3.安装nvm来控制nodejs版本</h2><p>文档：<a href="https://nvm.uihtm.com/#nvm-mac">https://nvm.uihtm.com/#nvm-mac</a></p><p>按照文档来执行：<code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash</code></p><p>按照文档安装完成之后你会发现，每次关闭终端后，都需要重新执行<code>source .bash_profile</code>才能重新使用nvm命令，下面是解决方案。</p><p>原因：没有将配置添加到.zshrc文件中</p><ol><li><p>到这里的时候需要看看我们是否有.zshrc，如果有直接打开 <code>open ~/.zshrc</code>，然后粘贴下边这两行代码</p><pre><code class="hljs">         export NVM_DIR=~/.nvm         [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot;     </code></pre></li><li><p>如果没有<code>.zshrc</code></p><ul><li>第一步创建<code>zshrc</code>，<code>touch .zshrc</code></li><li>第二步打开<code>zshrc</code>, <code>open -e .zshrc</code></li><li>第三部在<code>zshrc</code>文件里输入<code>source ~/.bash_profile</code>然后保存。</li><li>第四步刷新环境。<code>source .zshrc</code></li></ul></li></ol><p>执行完以上操作后再重新打开终端，看是否有nvm命令</p><p>完～</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面响应式布局的要点</title>
    <link href="/20220720/%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E8%A6%81%E7%82%B9/"/>
    <url>/20220720/%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E8%A6%81%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903814332432397#heading-3">参考文章</a></p><h2 id="响应式设计与自适应设计的区别"><a href="#响应式设计与自适应设计的区别" class="headerlink" title="响应式设计与自适应设计的区别"></a>响应式设计与自适应设计的区别</h2><p>响应式开发一套界面，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容；自适应需要开发多套界面，通过检测视口分辨率，来判断当前访问的设备是 pc 端、平板、手机，从而请求服务层，返回不同的页面。</p><h2 id="响应式布局实现方案"><a href="#响应式布局实现方案" class="headerlink" title="响应式布局实现方案"></a>响应式布局实现方案</h2><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>不管是移动优先还是 PC 优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是 min-width，PC 端优先使用的 max-width。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* iphone6 7 8 */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br><span class="hljs-comment">/* iphone 5 */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">320px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/* iphoneX */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">375px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-device-pixel-ratio</span>: <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0ff000</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/* iphone6 7 8 plus */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">414px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h3><p>我们必须要弄清楚 css 中子元素的百分比到底是相对谁的百分比。直接上结论吧：</p><ul><li>子元素的 height 或 width 中使用百分比，是相对于子元素的直接父元素。width 相对于直接父元素的 width，height 相对于直接父元素的 height。</li><li>子元素的 top 和 bottom 如果设置百分比，则相对于直接非 static 定位(默认定位)的父元素的高度。</li><li>同样子元素的 left 和 right 如果设置百分比，则相对于直接非 static 定位(默认定位的)父元素的宽度。</li><li>子元素的 padding 如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的 width，而与父元素的 height 无关。</li><li>子元素的 margin 如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的 width</li><li>border-radius 不一样，如果设置 border-radius 为百分比，则是相对于自身的宽度，除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。</li></ul><h3 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h3><p><code>rem</code>是<code>css3</code>中新增的单位，并且移动端支持度很高。</p><p><code>rem</code>单位都是相对于根元素 html 的<code>font-size</code>来决定大小的,根元素的<code>font-size</code>相当于提供了一个基准，当页面的 size 发生变化时，只需要改变<code>font-size</code>的值，那么以<code>rem</code>为固定单位的元素的大小也会发生响应的变化。 因此，如果通过<code>rem</code>来实现响应式的布局，只需要根据视图容器的大小，动态的改变<code>font-size</code>即可（而 em 是相对于父元素的）。</p><p>rem 响应式的布局思想：</p><ul><li>一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值</li><li>高度值可以设置固定值，设计稿有多大，我们就严格有多大</li><li>所有设置的固定值都用 rem 做单位（首先在 HTML 总设置一个基准值：px 和 rem 的对应比例，然后在效果图上获取 px 值，布局的时候转化为 rem 值)</li><li>js 获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了</li></ul><p><code>rem</code>布局也是目前多屏幕适配的最佳方式。</p><h3 id="vw-vh-视口单位"><a href="#vw-vh-视口单位" class="headerlink" title="vw/vh 视口单位"></a>vw/vh 视口单位</h3><p><code>vw</code>表示相对于视图窗口的宽度，<code>vh</code>表示相对于视图窗口高度，除了<code>vw</code>和<code>vh</code>外，还有<code>vmin</code>和<code>vmax</code>两个相关的单位。</p><table><thead><tr><th>单位</th><th>含义</th></tr></thead><tbody><tr><td>vw</td><td>相对于视窗的宽度，1vw 等于视口宽度的 1%，即视窗宽度是 100vw</td></tr><tr><td>vh</td><td>相对于视窗的高度，1vh 等于视口高度的 1%，即视窗高度是 100vh</td></tr><tr><td>vmin</td><td>vw 和 vh 中的较小值</td></tr><tr><td>vmax</td><td>vw 和 vh 中的较大值</td></tr></tbody></table><p>vw 和%的区别为：<br>| 单位 | 含义 |<br>| —– | —————————————————————————- |<br>| % | 大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate 等) |<br>| vw/vh | 相对于视窗的尺寸 |</p><ul><li>1 物理像素线（也就是普通屏幕下 1px,高清屏幕下 0.5px 的情况）采用 transform 属性 scale 实现</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">2</span>) &#123;<br>  -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);<br>  -webkit-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">50%</span> <span class="hljs-number">0%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图片响应式"><a href="#图片响应式" class="headerlink" title="图片响应式"></a>图片响应式</h3><ul><li>1.使用 max-width（图片自适应）</li></ul><p>图片自适应意思就是图片能随着容器的大小进行缩放</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>2.使用<code>srcset</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">img</span> srcset=&quot;photo_w350<span class="hljs-selector-class">.jpg</span> <span class="hljs-number">1</span>x, photo_w640<span class="hljs-selector-class">.jpg</span> <span class="hljs-number">2</span>x&quot; <span class="hljs-attribute">src</span>=&quot;photo_w350<span class="hljs-selector-class">.jpg</span>&quot; alt=&quot;&quot;&gt;<br></code></pre></td></tr></table></figure><p>如果屏幕的 dpi = 1 的话则加载 1 倍图，而 dpi = 2 则加载 2 倍图，手机和 mac 基本上 dpi 都达到了 2 以上，这样子对于普通屏幕来说不会浪费流量，而对于视网膜屏来说又有高清的体验。</p><h2 id="响应式布局的成型方案"><a href="#响应式布局的成型方案" class="headerlink" title="响应式布局的成型方案"></a>响应式布局的成型方案</h2><p>现在的 css，UI 框架等都已经考虑到了适配不同屏幕分辨率的问题，实际项目中我们可以直接使用这些新特性和框架来实现响应式布局。可以有以下选择方案：</p><ul><li>利用上面的方法自己来实现，比如 CSS3 Media Query,rem，vw 等</li><li>Flex 弹性布局，兼容性较差</li><li>Grid 网格布局，兼容性较差</li><li>Columns 栅格系统，往往需要依赖某个 UI 库，如 Bootstrap</li></ul><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>在实际项目中，我们可能需要综合使用响应式布局方案，比如用 rem 来做字体的适配，用 srcset 来做图片的响应式，宽度可以用 rem，flex，栅格系统等来实现响应式，然后可能还需要利用媒体查询来作为响应式布局的基础，因此综合上面的实现方案，项目中实现响应式布局需要注意下面几点：</p><ul><li>设置 viewport</li><li>媒体查询</li><li>字体的适配（字体单位）</li><li>百分比布局</li><li>图片的适配（图片的响应式）</li><li>结合 flex，grid，BFC，栅格系统等已经成型的方案</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>响应式布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年中总结</title>
    <link href="/20220715/2022%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    <url>/20220715/2022%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>今年上半年一直在独立负责“UTen 项目”的前端开发工作。该项目基于 vue2 全家桶，提供海外客户在线选品的功能，收入在于功能付费。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的手写js</title>
    <link href="/20220528/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%89%8B%E5%86%99js/"/>
    <url>/20220528/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%89%8B%E5%86%99js/</url>
    
    <content type="html"><![CDATA[<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p><a href="https://github.com/KieSun/Dream/issues/14">new 操作符</a></p><blockquote><p>new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？</p></blockquote><p>在调用<code>new</code>的过程中会发生四件操作</p><ol><li>新建了一个对象</li><li>新对象链接到原型对象上</li><li>绑定 this</li><li>返回这个新对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 1.创建一个新对象</span><br>  <span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>  <span class="hljs-comment">// 获取第一个参数，也就是获取构造函数</span><br>  <span class="hljs-keyword">let</span> Con = [].shift.call(<span class="hljs-built_in">arguments</span>);<br>  <span class="hljs-comment">// 2.新对象继承构造函数原型对象上的所有方法</span><br>  obj.__proto__ = Con.prototype;<br>  <span class="hljs-comment">// 3.构造函数的this指向新对象obj，并将剩余的参数传进去执行，得到结果result</span><br>  <span class="hljs-keyword">let</span> result = Con.apply(obj, <span class="hljs-built_in">arguments</span>);<br>  <span class="hljs-comment">// 4.如果得到的结果是个对象的话就返回result，如果不是的话就返回对象obj</span><br>  <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> ? result : obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于上面代码的第四条注释：构造函数如果返回原始值，那么这个返回值毫无意义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">const</span> t = <span class="hljs-keyword">new</span> Test(<span class="hljs-string">&quot;zhl&quot;</span>);<br><span class="hljs-built_in">console</span>.log(t.name); <span class="hljs-comment">// &#x27;zhl&#x27;</span><br></code></pre></td></tr></table></figure><p>对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题。</p><h2 id="instanceof-原理"><a href="#instanceof-原理" class="headerlink" title="instanceof 原理"></a>instanceof 原理</h2><blockquote><p><code>instanceof</code> 的原理是什么？</p></blockquote><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">left, right</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> prototype = right.prototype;<br>  left = left.__proto__;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (left === <span class="hljs-literal">null</span> || left === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (prototype === left) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    left = left.__proto__;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析:</p><ul><li>首先获取类型的原型</li><li>然后获得对象的原型</li><li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></li></ul><h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><blockquote><p>之前看到一个很形象的比喻。节流防抖就好比乘电梯，比如 delay 是 10 秒，防抖就是电梯每进来一个人就要等 10 秒再运行，而节流就是电梯保证每 10 秒可以运行一次</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue前端路由</title>
    <link href="/20220405/vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    <url>/20220405/vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="实现一个-hash-路由"><a href="#实现一个-hash-路由" class="headerlink" title="实现一个 hash 路由"></a>实现一个 hash 路由</h1><p><strong>HTML 部分</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#about&quot;</span>&gt;</span>关于<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#me&quot;</span>&gt;</span>我的<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;window.history.go(-1)&quot;</span>&gt;</span>返回<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.header</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: black;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">      <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="css">      <span class="hljs-attribute">justify-content</span>: space-around;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,</span><br><span class="css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>,</span><br><span class="css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>,</span><br><span class="css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="css">      <span class="hljs-attribute">text-decoration</span>: none;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./hashroutes.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>JS 部分</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Route</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.routes = &#123;&#125;;<br>    <span class="hljs-built_in">this</span>.refresh = <span class="hljs-built_in">this</span>.refresh.bind(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-built_in">this</span>.refresh);<br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;hashchange&quot;</span>, <span class="hljs-built_in">this</span>.refresh);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">route</span>(<span class="hljs-params">path, callback</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.routes[path] = callback || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">refresh</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">let</span> path = <span class="hljs-string">`/<span class="hljs-subst">$&#123;<span class="hljs-built_in">window</span>.location.hash.slice(<span class="hljs-number">1</span>) || <span class="hljs-string">&quot;&quot;</span>&#125;</span>`</span>;<br>    <span class="hljs-built_in">console</span>.log(path);<br>    <span class="hljs-keyword">let</span> cb = <span class="hljs-built_in">this</span>.routes[path];<br>    cb &amp;&amp; cb();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> Router = <span class="hljs-keyword">new</span> Route();<br><span class="hljs-keyword">let</span> body = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;body&quot;</span>);<br>Router.route(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>  body.style.backgroundColor = <span class="hljs-string">&quot;red&quot;</span>;<br>&#125;);<br><br>Router.route(<span class="hljs-string">&quot;/about&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  body.style.backgroundColor = <span class="hljs-string">&quot;blue&quot;</span>;<br>&#125;);<br><br>Router.route(<span class="hljs-string">&quot;/me&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  body.style.backgroundColor = <span class="hljs-string">&quot;green&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="实现一个-history-路由"><a href="#实现一个-history-路由" class="headerlink" title="实现一个 history 路由"></a>实现一个 history 路由</h1><p>hash 虽然能解决问题，但是带有#不太美观。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>window.history.back()</li><li>window.history.forward()</li><li>window.history.go(number)</li><li>window.history.pushState() 新增=》A B =》 A B C</li><li>window.history.replaceState() 覆盖/替换 A B =》 A C</li></ol><ul><li>history 模式下可以使用 Popstate 事件来监听 url 的变化</li><li>pushState 和 replaceState 并不会触发 Popstate 事件</li><li>哪些情况会触发 popstate 呢？<ul><li>浏览器的前进/后退按钮</li><li>history/back/forward/go</li></ul></li></ul><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ol><li>state:是一个对象，是一个指定网址相关的状态对象，如果不需要，可以为 null</li><li>title：新页面的标题，null</li><li>URL：新的网址，必须与当前页面出于同一个域，才会显示</li></ol><p><strong>部署 history 路由的时候，要使你的路由中的所有 path 都访问到 index.html 文件</strong></p><h2 id="HTML-部分"><a href="#HTML-部分" class="headerlink" title="HTML 部分"></a>HTML 部分</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/gray&quot;</span>&gt;</span>灰色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/green&quot;</span>&gt;</span>绿色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>白色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;window.history.go(-1)&quot;</span>&gt;</span>返回<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.header</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: black;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">      <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="css">      <span class="hljs-attribute">justify-content</span>: space-around;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,</span><br><span class="css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>,</span><br><span class="css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>,</span><br><span class="css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="css">      <span class="hljs-attribute">text-decoration</span>: none;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./hashroutes.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="JS-部分"><a href="#JS-部分" class="headerlink" title="JS 部分"></a>JS 部分</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Route</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.routes = &#123;&#125;;<br>    <span class="hljs-built_in">this</span>.bindPopState();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">route</span>(<span class="hljs-params">path, callback</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.routes[path] = callback || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-built_in">window</span>.history.replaceState(&#123; path &#125;, <span class="hljs-literal">null</span>, path);<br>    <span class="hljs-built_in">this</span>.execCallbackByPath(path);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">bindPopState</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;popstate&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> path = e.state &amp;&amp; e.state.path;<br>      <span class="hljs-built_in">console</span>.log(path);<br>      <span class="hljs-built_in">this</span>.execCallbackByPath(path);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">go</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-built_in">window</span>.history.pushState(<br>      &#123;<br>        path,<br>      &#125;,<br>      <span class="hljs-literal">null</span>,<br>      path<br>    );<br>    <span class="hljs-built_in">this</span>.execCallbackByPath(path);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">execCallbackByPath</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> cb = <span class="hljs-built_in">this</span>.routes[path];<br>    <span class="hljs-keyword">if</span> (cb) &#123;<br>      cb();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> Router = <span class="hljs-keyword">new</span> Route();<br><span class="hljs-keyword">let</span> body = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;body&quot;</span>);<br>Router.route(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>  body.style.backgroundColor = <span class="hljs-string">&quot;red&quot;</span>;<br>&#125;);<br><br>Router.route(<span class="hljs-string">&quot;/about&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  body.style.backgroundColor = <span class="hljs-string">&quot;blue&quot;</span>;<br>&#125;);<br><br>Router.route(<span class="hljs-string">&quot;/me&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  body.style.backgroundColor = <span class="hljs-string">&quot;green&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h1><ol><li>vue router 从列表浏览了一段时间,点击进了一个详情页,然后返回的时候,我期望回到列表页还是停留在原来的浏览位置,你可以怎么做?</li></ol><ul><li>keep-alive</li><li>localStorage/sessionStorage + scrollTop + scrollTo</li><li>scrollBehavior</li></ul><ol start="2"><li>router-view 是什么?</li></ol><p>类似于动态的组件.</p><p>找到当前路径对应的 component, 并展示出来.</p>]]></content>
    
    
    <categories>
      
      <category>技术类-Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise输出顺序相关问题</title>
    <link href="/20220329/Promise%E8%BE%93%E5%87%BA%E9%A1%BA%E5%BA%8F%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/20220329/Promise%E8%BE%93%E5%87%BA%E9%A1%BA%E5%BA%8F%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve()<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;宏任务&quot;</span>);<br>    &#125;, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// return 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">4</span>); <span class="hljs-comment">// 此处是迷惑点</span><br>  &#125;)<br>  .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(res);<br>  &#125;);<br><br><span class="hljs-built_in">Promise</span>.resolve()<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>  &#125;)<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>  &#125;)<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>  &#125;)<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);<br>  &#125;)<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);<br>  &#125;)<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>);<br>  &#125;)<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure><h2 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 输出结果</span><br><span class="hljs-number">0</span>;<br><span class="hljs-number">1</span>;<br><span class="hljs-number">2</span>;<br><span class="hljs-number">3</span>;<br><span class="hljs-number">4</span>;<br><span class="hljs-number">5</span>;<br><span class="hljs-number">6</span>;<br><span class="hljs-number">7</span>;<br><span class="hljs-number">8</span>;<br>宏任务;<br></code></pre></td></tr></table></figure><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>| <code>return Promise.resolve(4)</code>会产生一个叫 job 的函数，等到当前执行栈为空的时候会去执行</p><p>| 微任务的执行中生成了微任务，那么会继续执行微任务，直到微任务队列为空。</p><ol><li><strong>宏任务队列 1</strong>,执行<code>Promise.resolve()</code></li><li>遇到<code>then()</code>回调,往微任务队列推入以下代码：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 微任务队列加入了以下代码</span><br><span class="hljs-comment">// 微任务队列1</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;宏任务&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li>仍然在当前宏任务往下执行，执行第二个<code>Promise.resolve()</code></li><li>遇到<code>then()</code>回调,往微任务队列推入以下代码:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>所以此时微任务队列里有两个代码块待执行。队列就是先进先出的原则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一个:A</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;宏任务&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">// 第二个:B</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><ol start="5"><li>此时代码模块里的宏任务都已经执行完了，开始捞取微任务到执行栈中执行。队列里第一个出来的也就是代码：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;宏任务&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>输出 0。</p><p>注册一个 job，当执行栈为空的时候，job 进入队列。此时执行栈并不为空。A 出栈 B 入栈</p><p>6.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>输出 1。then 的回调推入微任务队列。B 出栈。执行栈为空。job 也进入微任务队列</p><p>函数是:<br>此时的微任务队列就有两个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一个</span><br>.then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>  &#125;)<br><br><span class="hljs-comment">// 第二个，job</span><br>(<span class="hljs-number">4</span>) =&gt; &#123;<br>  <span class="hljs-built_in">this</span>.resolvePromise(promise2, <span class="hljs-number">4</span>, resolve, reject);<br>&#125;;<br></code></pre></td></tr></table></figure><hr><ol start="7"><li>输出 2 将它的回调函数推入微任务队列</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">.then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>  &#125;)<br></code></pre></td></tr></table></figure><p>再去执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-number">4</span>) =&gt; &#123;<br>  <span class="hljs-built_in">this</span>.resolvePromise(promise2, <span class="hljs-number">4</span>, resolve, reject);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个函数会将</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(res) =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(res);<br>&#125;;<br></code></pre></td></tr></table></figure><p>推入微任务队列</p><ol start="8"><li>输出 3 和 4</li></ol><p>输出 3 的回调再次推入微任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">.then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);<br>  &#125;)<br></code></pre></td></tr></table></figure><ol start="9"><li><p> 输出 5</p></li><li><p>后续输出原理相同，输出 6,7,8</p></li><li><p>此时没有回调微任务进栈了，开始清空宏任务队列，也就是 setTimeout，输出<code>宏任务</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue源码</title>
    <link href="/20220222/vue%E6%BA%90%E7%A0%81/"/>
    <url>/20220222/vue%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么data是函数，而components是对象？"><a href="#为什么data是函数，而components是对象？" class="headerlink" title="为什么data是函数，而components是对象？"></a>为什么data是函数，而components是对象？</h2><h2 id="data函数如果没有返回值会报错吗？"><a href="#data函数如果没有返回值会报错吗？" class="headerlink" title="data函数如果没有返回值会报错吗？"></a>data函数如果没有返回值会报错吗？</h2><p>答：会</p><blockquote><p>vue源码位置：src\core\instance\state.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initData</span> (<span class="hljs-params">vm: Component</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> data = vm.$options.data<br>  data = vm._data = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span><br>    ? getData(data, vm)<br>    : data || &#123;&#125;<br>    <span class="hljs-comment">// //   看这里！这里有一个判断 isPlainObject(data)</span><br>  <span class="hljs-keyword">if</span> (!isPlainObject(data)) &#123;<br>    data = &#123;&#125;<br>    process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; warn(<br>      <span class="hljs-string">&#x27;data functions should return an object:\n&#x27;</span> +<br>      <span class="hljs-string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,<br>      vm<br>    )<br>  &#125;<br>    。。。<br>    。。。<br>    。。。<br>  <span class="hljs-comment">// observe data</span><br>  observe(data, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Vue源码位置：packages\weex-template-compiler\build.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPlainObject</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> _toString.call(obj) === <span class="hljs-string">&#x27;[object Object]&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>data函数</code>执行之后将返回值重新赋值给<code>data</code>，如果<code>data</code>不是个<code>object</code>，<code>name</code>就会报出一个警告</p><h2 id="为什么props定义的数据不能和data同名"><a href="#为什么props定义的数据不能和data同名" class="headerlink" title="为什么props定义的数据不能和data同名?"></a>为什么props定义的数据不能和data同名?</h2><blockquote><p>vue源码路径：vue\src\core\instance\state.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">// proxy data on instance</span><br>  <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(data)<br>  <span class="hljs-keyword">const</span> props = vm.$options.props<br>  <span class="hljs-keyword">const</span> methods = vm.$options.methods<br>  <span class="hljs-keyword">let</span> i = keys.length<br>  <span class="hljs-keyword">while</span> (i--) &#123;<br>    <span class="hljs-keyword">const</span> key = keys[i]<br>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;<br>        warn(<br>          <span class="hljs-string">`Method &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,<br>          vm<br>        )<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;<br>      process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; warn(<br>        <span class="hljs-string">`The data property &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +<br>        <span class="hljs-string">`Use prop default value instead.`</span>,<br>        vm<br>      )<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isReserved(key)) &#123;<br>      proxy(vm, <span class="hljs-string">`_data`</span>, key)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看到先获取<code>data</code>的<code>key</code>，然后再去调用<code>hasOwn</code>方法去判断<code>methods</code>和<code>props</code>里面是否有重复的<code>key</code>，有的话就会发出警告。最后都通过了之后就会调用<code>proxy(vm, &#39;_data&#39;, key)</code>，用封装的<code>proxy</code>方法对<code>vm实例</code>做了一层代理，使得我们可以直接通过<code>this</code>直接调用<code>key</code></p><h2 id="vue2代理的实现"><a href="#vue2代理的实现" class="headerlink" title="vue2代理的实现"></a>vue2代理的实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sharedPropertyDefinition = &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">get</span>: noop,<br>  <span class="hljs-attr">set</span>: noop<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxy</span> (<span class="hljs-params">target: <span class="hljs-built_in">Object</span>, sourceKey: string, key: string</span>) </span>&#123;<br>  <span class="hljs-comment">// 去掉_props，vm._props.xxx =&gt; vm.xxx，可以直接访问</span><br>  sharedPropertyDefinition.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxyGetter</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[sourceKey][key]<br>  &#125;<br>  sharedPropertyDefinition.set = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxySetter</span> (<span class="hljs-params">val</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>[sourceKey][key] = val<br>  &#125;<br>  <span class="hljs-comment">// 代理，</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的是<code>Object.defineProperty</code>来实现的</p><h2 id="Vue的初始化"><a href="#Vue的初始化" class="headerlink" title="Vue的初始化"></a>Vue的初始化</h2><blockquote><p>Vue源码位置：src\core\instance\index.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">initMixin(Vue)<br>stateMixin(Vue)<br>eventsMixin(Vue)<br>lifecycleMixin(Vue)<br>renderMixin(Vue)<br></code></pre></td></tr></table></figure><p>最先执行的是<code>initMixin()</code>，我们看看里面有啥。</p><blockquote><p>Vue源码位置：src\core\instance\init.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//init.js</span><br><br>    <span class="hljs-comment">// 初始化</span><br>    vm._self = vm<br>    <span class="hljs-comment">// 生命周期</span><br>    initLifecycle(vm)<br>    <span class="hljs-comment">// 事件</span><br>    initEvents(vm)<br>    <span class="hljs-comment">// 渲染</span><br>    initRender(vm)<br>    <span class="hljs-comment">// 面试题：beforeCreae和created之间做了什么？或者说二者有什么区别？</span><br>    <span class="hljs-comment">// 答：初始化injected，初始化state，初始化provide</span><br>    callHook(vm, <span class="hljs-string">&#x27;beforeCreate&#x27;</span>)<br>    <span class="hljs-comment">// 初始化inject</span><br>    initInjections(vm) <span class="hljs-comment">// resolve injections before data/props</span><br>    <span class="hljs-comment">// 初始化state，state里面有data，computed，method，props，watch</span><br>    initState(vm)<br>    <span class="hljs-comment">// 初始化provide</span><br>    initProvide(vm) <span class="hljs-comment">// resolve provide after data/props</span><br>    callHook(vm, <span class="hljs-string">&#x27;created&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>initState()</code>是从<code>state.js</code>文件里面导入的，我们再去看看里面有什么。</p><blockquote><p>src\core\instance\state.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initState</span> (<span class="hljs-params">vm: Component</span>) </span>&#123;<br>  vm._watchers = []<br>  <span class="hljs-keyword">const</span> opts = vm.$options<br>  <span class="hljs-comment">// 初始化props</span><br>  <span class="hljs-keyword">if</span> (opts.props) initProps(vm, opts.props)<br>  <span class="hljs-comment">// 初始化方法</span><br>  <span class="hljs-keyword">if</span> (opts.methods) initMethods(vm, opts.methods)<br>  <span class="hljs-comment">// 初始化data</span><br>  <span class="hljs-keyword">if</span> (opts.data) &#123;<br>    initData(vm)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    observe(vm._data = &#123;&#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>)<br>  &#125;<br>  <span class="hljs-comment">// 初始化computed</span><br>  <span class="hljs-keyword">if</span> (opts.computed) initComputed(vm, opts.computed)<br>  <span class="hljs-comment">// 初始化watch</span><br>  <span class="hljs-keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;<br>    initWatch(vm, opts.watch)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见在<code>beforeCreate</code>与<code>created</code>之间初始化了<code>inject</code>,<code>props</code>,<code>methods</code>,<code>data</code>,<code>computed</code>,<code>watch</code></p><h2 id="基于Vue2的proxy，自己实现一个代理"><a href="#基于Vue2的proxy，自己实现一个代理" class="headerlink" title="基于Vue2的proxy，自己实现一个代理"></a>基于Vue2的proxy，自己实现一个代理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> noop = &#123;&#125; <br><br><span class="hljs-keyword">const</span> propertyDefinition = &#123;<br>    <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">get</span>:noop,<br>    <span class="hljs-attr">set</span>:noop<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">Proxy</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target,sourceKey,key</span>)</span>&#123;<br>    propertyDefinition.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getter</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> target[sourceKey][key]<br>    &#125;<br><br>    propertyDefinition.set = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setter</span> (<span class="hljs-params">val</span>) </span>&#123;        <br>        target[sourceKey][key] = val<br>    &#125;<br><br>    <span class="hljs-built_in">Object</span>.defineProperty(target,key,propertyDefinition)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vue</span>(<span class="hljs-params">data</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>._data = data<br>    <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>._data).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">Proxy</span>(<span class="hljs-built_in">this</span>,<span class="hljs-string">&#x27;_data&#x27;</span>,key)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> vueIns = <span class="hljs-keyword">new</span> Vue(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;)<br><br>vueIns._data.b = <span class="hljs-string">&#x27;hhh&#x27;</span><br>vueIns.a = <span class="hljs-number">2222</span><br><span class="hljs-built_in">console</span>.log(vueIns._data.a)<br><span class="hljs-built_in">console</span>.log(vueIns.b)<br><br></code></pre></td></tr></table></figure><h2 id="Vue的实例为什么不能挂载在body或根节点上？挂载了会报错吗？"><a href="#Vue的实例为什么不能挂载在body或根节点上？挂载了会报错吗？" class="headerlink" title="Vue的实例为什么不能挂载在body或根节点上？挂载了会报错吗？"></a>Vue的实例为什么不能挂载在body或根节点上？挂载了会报错吗？</h2><p>答：挂载节点会被虚拟dom生成的Dom替换，会报错</p><blockquote><p>Vue源码位置：src\platforms\web\entry-runtime-with-compiler.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (el === <span class="hljs-built_in">document</span>.body || el === <span class="hljs-built_in">document</span>.documentElement) &#123;<br>    process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; warn(<br>      <span class="hljs-string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span><br>    )<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="什么是虚拟节点，简述虚拟dom构成？"><a href="#什么是虚拟节点，简述虚拟dom构成？" class="headerlink" title="什么是虚拟节点，简述虚拟dom构成？"></a>什么是虚拟节点，简述虚拟dom构成？</h2><h2 id="vue和react虚拟dom的区别？"><a href="#vue和react虚拟dom的区别？" class="headerlink" title="vue和react虚拟dom的区别？"></a>vue和react虚拟dom的区别？</h2>]]></content>
    
    
    <categories>
      
      <category>技术类-Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法</title>
    <link href="/20220127/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/20220127/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>线性表是具有相同数据类型的 n(n≥0)个数据元素的有限序列。其中 n 为表长，当 n=0 时该线性表是一个空表。</p></blockquote><p>若用 L 命名线性表，则其一般表示如下：</p><pre><code class="hljs">L=(a1,a2,...ai,ai+1,...,an)</code></pre><p>其中，a1 是唯一的“第一个”数据元素，又称为表头元素；an 是唯一的“最后一个”数据元素，又称为表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>线性表常见的特点如下：</p><ul><li><p>表中元素的个数是有限的；</p></li><li><p>表中元素具有逻辑上的顺序性，在序列中各元素排列有先后次序；</p></li><li><p>表中元素都是数据元素，每一个表元素都是单个元素；</p></li><li><p>表中元素的数据类型都相同，这意味着每一个表元素占有相同数量的存储空间；</p></li><li><p>表中元素具有抽象性，就是说，仅讨论表元素之间的逻辑关系，不考虑表元素究竟表示什么内容</p></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><img src="/20220127/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB.jpg" class="" title="线性表的分类"><h3 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h3><pre><code class="hljs"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">InitList(L); <span class="hljs-comment">//初始化表。构造一个空的线性表；</span><br>Legnth(L); <span class="hljs-comment">//求表长度。返回线性表L的长度，即L中数据元素的个数；</span><br>LocateElem(L, e); <span class="hljs-comment">//按值查找操作。在表L中查找具有给定关键字值的元素；</span><br>GetElem(L, i); <span class="hljs-comment">//按位查找操作。获取表L中第i个位置的元素的值；</span><br>ListInsert(L, i, e); <span class="hljs-comment">//插入操作。在表L中第i个位置上插入制定元素；</span><br>ListDelete(L, i, e); <span class="hljs-comment">//删除操作。删除表L中第i个位置上的元素；</span><br>PrintList(L); <span class="hljs-comment">//输出操作。按前后顺序输出线性表L的所有元素的值；</span><br>Empty(L); <span class="hljs-comment">//判空操作</span><br></code></pre></td></tr></table></figure></code></pre><h2 id="1-1-线性表的顺序表示-顺序表"><a href="#1-1-线性表的顺序表示-顺序表" class="headerlink" title="1.1 线性表的顺序表示(顺序表)"></a>1.1 线性表的顺序表示(顺序表)</h2><blockquote><p>线性表的顺序存储又称之为<strong>顺序表</strong>。</p></blockquote><p>它是用一组连续地址的存储单元，依次存储线性表的数据元素，从而使得逻辑上相邻的两个元素在物理上也相邻。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>顺序表中元素的逻辑顺序与物理顺序相同</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-router随笔</title>
    <link href="/20220119/vue-router%E9%9A%8F%E7%AC%94/"/>
    <url>/20220119/vue-router%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><h3 id="导航到不同的位置"><a href="#导航到不同的位置" class="headerlink" title="导航到不同的位置"></a>导航到不同的位置</h3><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p><p>在 Vue 实例中，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</p><p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 字符串路径</span><br>router.push(<span class="hljs-string">&#x27;/users/eduardo&#x27;</span>)<br><br><span class="hljs-comment">// 带有路径的对象</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/eduardo&#x27;</span> &#125;)<br><br><span class="hljs-comment">// 命名的路由，并加上参数，让路由建立 url</span><br>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;eduardo&#x27;</span> &#125; &#125;)<br><br><span class="hljs-comment">// 带查询参数，结果是 /register?plan=private</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&#x27;private&#x27;</span> &#125; &#125;)<br><br><span class="hljs-comment">// 带 hash，结果是 /about#team</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">hash</span>: <span class="hljs-string">&#x27;#team&#x27;</span> &#125;)<br></code></pre></td></tr></table></figure><p>如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> username = <span class="hljs-string">&#x27;eduardo&#x27;</span><br><span class="hljs-comment">// 我们可以手动建立 url，但我们必须自己处理编码</span><br>router.push(<span class="hljs-string">`/user/<span class="hljs-subst">$&#123;username&#125;</span>`</span>) <span class="hljs-comment">// -&gt; /user/eduardo</span><br><span class="hljs-comment">// 同样</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">`/user/<span class="hljs-subst">$&#123;username&#125;</span>`</span> &#125;) <span class="hljs-comment">// -&gt; /user/eduardo</span><br><span class="hljs-comment">// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益</span><br>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; username &#125; &#125;) <span class="hljs-comment">// -&gt; /user/eduardo</span><br><span class="hljs-comment">// `params` 不能与 `path` 一起使用</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; username &#125; &#125;) <span class="hljs-comment">// -&gt; /user</span><br></code></pre></td></tr></table></figure><h3 id="替换当前位置router-replace"><a href="#替换当前位置router-replace" class="headerlink" title="替换当前位置router.replace()"></a>替换当前位置<code>router.replace()</code></h3><p>它的作用类似于 router.push，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。</p><p>也可以直接在传递给 <code>router.push</code> 的 <code>routeLocation</code> 中增加一个属性 <code>replace: true</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span> &#125;)<br><span class="hljs-comment">// 相当于</span><br>router.replace(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span> &#125;)<br></code></pre></td></tr></table></figure><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar (侧导航)</code> 和 <code>main (主内容)</code> 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。<strong>如果 router-view 没有设置名字，那么默认为 default</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><br>&lt;router-view <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;view left-sidebar&quot;</span> name=<span class="hljs-string">&quot;LeftSidebar&quot;</span>&gt;&lt;/router-view&gt;<br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;view main-content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;view right-sidebar&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RightSidebar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = createRouter(&#123;<br>  <span class="hljs-attr">history</span>: createWebHashHistory(),<br>  <span class="hljs-attr">routes</span>: [<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>      <span class="hljs-attr">components</span>: &#123;<br>        <span class="hljs-attr">default</span>: Home,<br>        <span class="hljs-comment">// LeftSidebar: LeftSidebar 的缩写</span><br>        LeftSidebar,<br>        <span class="hljs-comment">// 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配</span><br>        RightSidebar,<br>      &#125;,<br>    &#125;,<br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术类-Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6随笔</title>
    <link href="/20220114/ES6%E9%9A%8F%E7%AC%94/"/>
    <url>/20220114/ES6%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bookstack.cn/read/es6-3rd/sidebar.md">参考资料：阮一峰 ES6 标准入门教程第三版</a></p><blockquote><p>本文用于记录我觉得 ES6 中重要的原理和使用技巧</p></blockquote><h2 id="class-的继承"><a href="#class-的继承" class="headerlink" title="class 的继承"></a>class 的继承</h2><p>Class 可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y, color</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(x, y); <span class="hljs-comment">// 调用父类的constructor(x, y)</span><br>    <span class="hljs-built_in">this</span>.color = color;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">super</span>.toString(); <span class="hljs-comment">// 调用父类的toString()</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。</p><p>ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。</p><hr><h2 id="20220502-更新"><a href="#20220502-更新" class="headerlink" title="20220502 更新"></a>20220502 更新</h2><blockquote><p>构造函数的 prototype 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 prototype 属性上面。 –阮一峰《ES6》</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">toValue</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// 等同于</span><br>Point.prototype = &#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;&#125;,<br>  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;&#125;,<br>  <span class="hljs-function"><span class="hljs-title">toValue</span>(<span class="hljs-params"></span>)</span> &#123;&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我想打印输出看一下<code>console.log(Point.prototype)</code>的时候输出却是<code>&#123;&#125;</code>,感到很奇怪，明明方法是定义在<code>prototype</code>属性上的，为什么输出确实空的呢？</p><p>查了一下发现：</p><blockquote><p>这是因为 <code>console.log()</code>使用了 <code>util.inspect()</code>，它使用了 Object。对象上的<code>keys()</code>，它只返回可枚举的属性。并且 <code>Object.prototype</code> 包含非可枚举属性，这就是它返回空节点的原因。</p></blockquote><p>因为那些方法都默认是不可枚举的，所以当我们想定义一个可枚举的属性时可以使用<code>Object.defineProperty()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.defineProperty(Point.prototype, <span class="hljs-string">&quot;hh&quot;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>  &#125;,<br>  <span class="hljs-comment">// 可枚举</span><br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>&#125;);<br><span class="hljs-built_in">console</span>.log(Point.prototype);<br></code></pre></td></tr></table></figure><p>这下打印出了<code>&#123; hh: [Function: value] &#125;</code></p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰器的使用</title>
    <link href="/20211223/%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/20211223/%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="在-create-react-app-搭建的项目中使用装饰器"><a href="#在-create-react-app-搭建的项目中使用装饰器" class="headerlink" title="在 create-react-app 搭建的项目中使用装饰器"></a>在 create-react-app 搭建的项目中使用装饰器</h2><ol><li><p>执行<code>yarn eject</code>命令，暴露出配置项</p></li><li><p>因为装饰器是新的提案，许多浏览器和 Node 环境并不支持，所以我们需要安装插件：<code>@babel/plugin-proposal-decorators</code>。使用<code>create-react-app</code>创建的项目自带这个插件，不过我们需要配置一下，找到<code>package.json</code>文件加入一下代码：</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;babel&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;presets&quot;</span>: [<span class="hljs-string">&quot;react-app&quot;</span>],<br><br>    <span class="hljs-attr">&quot;plugins&quot;</span>: [[<span class="hljs-string">&quot;@babel/plugin-proposal-decorators&quot;</span>, &#123; <span class="hljs-attr">&quot;legacy&quot;</span>: <span class="hljs-literal">true</span> &#125;]]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外 vscode 可能会提示你需要配置<code>tsconfig</code>或<code>jsconfig</code>文件，我们在项目根目录创建<code>jsconfig.js</code>，并写入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;experimentalDecorators&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就能愉快的在项目中使用装饰器了</p><h2 id="装饰器的使用"><a href="#装饰器的使用" class="headerlink" title="装饰器的使用"></a>装饰器的使用</h2><h3 id="使用装饰器修饰类"><a href="#使用装饰器修饰类" class="headerlink" title="使用装饰器修饰类"></a>使用装饰器修饰类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//声明一个装饰器</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">target</span>) </span>&#123;<br>  <span class="hljs-comment">//这个函数的`target`指的就是装饰器要修饰的类</span><br>  target.test = <span class="hljs-literal">false</span>;<br>&#125;<br><br>@fn <span class="hljs-comment">//使用装饰器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-comment">//声明一个类</span><br>&#125;<br>@fn<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>  <span class="hljs-comment">//声明另一个类</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(Person.test); <span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(Dog.test); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/13931286-758df1981c769cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p><p>可以看到<code>Person</code>类和<code>Dog</code>类下面多出了一个<code>test</code>属性，这就体现了装饰器的优点，无需更改类的内部代码也无需去继承就可以给类添加新功能</p><h3 id="使用装饰器传参"><a href="#使用装饰器传参" class="headerlink" title="使用装饰器传参"></a>使用装饰器传参</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">@fn<br>@fn2(<span class="hljs-number">5</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">target</span>) </span>&#123;<br>  target.test = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>&#123;<br>    <span class="hljs-comment">//这个函数的`target`指的就是装饰器要修饰的类</span><br>    target.count = value;<br>  &#125;;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(Person.test);<br><span class="hljs-built_in">console</span>.log(Person.count);<br></code></pre></td></tr></table></figure><p>声明一个装饰器<code>fn2</code>，它接收一个值，并且返回一个函数，这个函数的<code>target</code>指的就是装饰器要修饰的类<br><img src="https://upload-images.jianshu.io/upload_images/13931286-446a1e6ba77e0c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p><h3 id="使用装饰器添加实例属性"><a href="#使用装饰器添加实例属性" class="headerlink" title="使用装饰器添加实例属性"></a>使用装饰器添加实例属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">@fn<br>@fn2(<span class="hljs-number">5</span>)<br>@fn3<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">target</span>) </span>&#123;<br>  target.test = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>&#123;<br>    target.count = value;<br>  &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn3</span>(<span class="hljs-params">target</span>) </span>&#123;<br>  target.prototype.foo = <span class="hljs-string">&quot;hhh&quot;</span>; <span class="hljs-comment">// target指的就是装饰的类，在类的原型对象上添加一个属性foo</span><br>&#125;<br><br><span class="hljs-keyword">const</span> test1 = <span class="hljs-keyword">new</span> Person(); <span class="hljs-comment">// new一个实例出来</span><br><span class="hljs-built_in">console</span>.log(test1.foo);<br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/13931286-d69f263c088633e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p><h3 id="实现一个混入-mixins-功能"><a href="#实现一个混入-mixins-功能" class="headerlink" title="实现一个混入 mixins 功能"></a>实现一个混入 mixins 功能</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实现一个mixins功能</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mixins</span>(<span class="hljs-params">...list</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>&#123;<br>    <span class="hljs-built_in">Object</span>.assign(target.prototype, ...list);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">import</span> &#123; mixins &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./mixins&quot;</span>;<br><br><span class="hljs-keyword">const</span> Test = &#123;<br>  <span class="hljs-function"><span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是测试&quot;</span>);<br>  &#125;,<br>&#125;;<br><br>@mixins(Test)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Myclass</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">const</span> newMyclass = <span class="hljs-keyword">new</span> Myclass();<br>newMyclass.test(); <span class="hljs-comment">//这是测试</span><br></code></pre></td></tr></table></figure><h3 id="使用装饰器修饰类的成员"><a href="#使用装饰器修饰类的成员" class="headerlink" title="使用装饰器修饰类的成员"></a>使用装饰器修饰类的成员</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">@fn<br>@fn2(<span class="hljs-number">5</span>)<br>@fn3<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  @readonly message = <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">target</span>) </span>&#123;<br>  target.test = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>&#123;<br>    target.count = value;<br>  &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn3</span>(<span class="hljs-params">target</span>) </span>&#123;<br>  target.prototype.foo = <span class="hljs-string">&quot;hhh&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readonly</span>(<span class="hljs-params">target, name, descriptor</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(target); <span class="hljs-comment">//目标类的原型对象 xxx.prototype</span><br>  <span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// 被修饰的类的成员名称</span><br>  <span class="hljs-built_in">console</span>.log(descriptor);<br>  <span class="hljs-comment">/*被修饰的类的成员的描述对象：</span><br><span class="hljs-comment">    configurable: 能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true</span><br><span class="hljs-comment">    enumerable: 是否被遍历，对象属性是否可通过for-in循环，flase为不可循环，默认值为true</span><br><span class="hljs-comment">    initializer: 对象属性的默认值，默认值为undefined</span><br><span class="hljs-comment">    writable: 对象属性是否可修改,flase为不可修改，默认值为true</span><br><span class="hljs-comment">  */</span><br><br>  descriptor.writable = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> test1 = <span class="hljs-keyword">new</span> Person();<br>test1.message = <span class="hljs-string">&quot;你好&quot;</span>;<br></code></pre></td></tr></table></figure><p>它接收三个参数，具体看以上代码注释</p><p><img src="https://upload-images.jianshu.io/upload_images/13931286-4f66e2ca9e5b7c34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React随笔</title>
    <link href="/20211218/React%E9%9A%8F%E7%AC%94/"/>
    <url>/20211218/React%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h2 id="React-中的this"><a href="#React-中的this" class="headerlink" title="React 中的this"></a>React 中的<code>this</code></h2><p>React 的官方文档里写的自定义的方法都需要用 bind 方法绑定一下才能使用，否则 this 会出现指向问题，那究竟是为什么呢？</p><h3 id="探讨一"><a href="#探讨一" class="headerlink" title="探讨一"></a>探讨一</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            ......<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;demo&#125;</span>&gt;</span>你好，DexterHwang<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state)   <span class="hljs-comment">// 会报错，注意此处的this</span><br>&#125;<br><br>ReactDom.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> /&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>))<br></code></pre></td></tr></table></figure><p><code>React</code> 中的 <code>Babel</code> 使用了严格模式，所以写的全局的 <code>this</code>指向的是<code>undefined</code></p><p>而且 <code>demo</code> 方法并不写在 <code>Person</code> 类中，所以这个 <code>this</code> 也不会指向 <code>Person</code> 的实例对象</p><h3 id="探讨二"><a href="#探讨二" class="headerlink" title="探讨二"></a>探讨二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            ......<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;demo&#125;</span>&gt;</span>你好，DexterHwang<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <span class="hljs-comment">// 会报错，报错信息为：`demo is not defined`。`onClick=&#123;demo&#125;`是找不到 `demo` 方法的</span><br>        <span class="hljs-comment">// return &lt;div onClick=&#123;this.demo&#125;&gt;你好，DexterHwang&lt;/div&gt; // 这样写也会报错，因为并不是通过实例对象去调用demo方法。由于demo是作为onClick的回调，不是通过实例调用的，是直接调用。类中的方法默认开启了局部的严格模式，所以this值是undefined</span><br>    &#125;<br>    <span class="hljs-comment">// demo方法在Person的原型对象(prototype)上，也就是在Person的实例对象的原型链上(_proto_)</span><br>    <span class="hljs-comment">// 只有通过Person实例对象调用demo方法时，demo里面的this指向的就是Person的实例对象</span><br>    <span class="hljs-function"><span class="hljs-title">demo</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>    &#125;<br>&#125;<br><br>ReactDom.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> /&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>))<br></code></pre></td></tr></table></figure><p>我们看下面的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">study</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;DexterHwang&quot;</span>, <span class="hljs-number">18</span>);<br><br>p1.study(); <span class="hljs-comment">//&#123;name:&#x27;DexterHwang&#x27;,age:18&#125;</span><br><span class="hljs-keyword">const</span> x = p1.study;<br>x(); <span class="hljs-comment">// 输出undefined</span><br></code></pre></td></tr></table></figure><p>p1 的原型链上是可以找到 study 方法的，然后把 study 方法赋值给了 x。也就相当于在栈上多了一个指针指向了 study 方法，这下 x 就彻底和 p1 没有关系了</p><p>另外，再明确一点：_类中自定义的方法，都会启用局部严格模式_。也就是说 this 的值是 undefined</p><p>也就是说 x 执行后 this 值就是 undefined</p><p>验证：<em>类中自定义的方法，都会启用局部严格模式</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test2</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &quot;use strict&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;<br><br>test(); <span class="hljs-comment">// window</span><br>test2(); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="分析-this-demo-this-demo-bind-this"><a href="#分析-this-demo-this-demo-bind-this" class="headerlink" title="分析 this.demo = this.demo.bind(this)"></a>分析 <code>this.demo = this.demo.bind(this)</code></h3><p>为什么用 bind()就可以解决 this 指向问题呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            ......<br>        &#125;<br>        <span class="hljs-built_in">this</span>.demo = <span class="hljs-built_in">this</span>.demo.bind(<span class="hljs-built_in">this</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.demo&#125;</span>&gt;</span>你好，DexterHwang<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">demo</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>    &#125;<br>&#125;<br><br>ReactDom.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> /&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>))<br><br><span class="hljs-comment">// 点击后会输出：Person&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>分析<code>this.demo = this.demo.bind(this)</code></p><p>等号右侧的第一个 this 指向的是实例对象，这个实例对象上有 demo 方法吗？有，但是实在原型链上的。</p><p>bind 方法做两件事：</p><ol><li>将 this 牢牢的绑定到传入的参数上</li><li>返回一个新的函数</li></ol><p>等号右边第二个 this，也就是传入的参数，这个 this 指的就是实例对象</p><p>这样的话返回了一个新的函数，而且这个函数牢牢的绑定到了实例对象上，并不需要去原型链上找了</p><p>再看等号左侧，将返回的新函数赋值给了 this，这个 this 也是 Person 实例对象，用相同的方法名接收一下</p><p>这样就可以使用了</p><p>我们这样再去看<code>onClick=&#123;this.demo&#125;</code>,这下再点击后执行的就是实例自身上的 demo 方法了。</p><hr><h2 id="2021-12-25-更新——-React17-对比新旧生命周期"><a href="#2021-12-25-更新——-React17-对比新旧生命周期" class="headerlink" title="2021-12-25 更新—— React17 对比新旧生命周期"></a>2021-12-25 更新—— React17 对比新旧生命周期</h2><p>新的生命周期和旧的生命周期相比，即将废弃三个钩子：<code>componentWillMount</code>、<code>componentWillUpdate</code>、<code>componentWillReceiveProps</code></p><p>新增了两个新的钩子：<code>getDerivedStateFromProps</code>、<code>getSnapshotBeforeUpdate</code></p><p>剩下的都和之前的一样的</p><h2 id="2021-12-16-更新——-React-配置代理"><a href="#2021-12-16-更新——-React-配置代理" class="headerlink" title="2021-12-16 更新—— React 配置代理"></a>2021-12-16 更新—— React 配置代理</h2><p>单个代理可以直接在<code>package.json</code>文件中配置<code>proxy</code></p><p>多个代理则需要新建一个<code>setupProxy.js</code>文件，配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http-proxy-middleware&quot;</span>);<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">app</span>) </span>&#123;<br>  app.use(<br>    proxy(<span class="hljs-string">&quot;/api1&quot;</span>, &#123;<br>      <span class="hljs-comment">//遇见api1前缀的请求，就会触发这个代理配置</span><br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://localhost:5000&quot;</span>, <span class="hljs-comment">// 请求转发给谁，也就是服务器地址</span><br>      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 控制服务器收到的请求头中Host的值，这里是localhost:5000</span><br>      <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&quot;^/api1&quot;</span>: <span class="hljs-string">&quot;&quot;</span> &#125;, <span class="hljs-comment">// 重写请求路径</span><br>    &#125;),<br>    proxy(<span class="hljs-string">&quot;/api2&quot;</span>, &#123;<br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://localhost:5001&quot;</span>,<br>      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&quot;^/api2&quot;</span>: <span class="hljs-string">&quot;&quot;</span> &#125;,<br>    &#125;)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>create-react-app</code>脚手架会自动找到<code>setupProxy.js</code>文件，并将配置加入到 webpack 中</p><h2 id="2021-12-27-更新——-React-路由原理"><a href="#2021-12-27-更新——-React-路由原理" class="headerlink" title="2021-12-27 更新—— React 路由原理"></a>2021-12-27 更新—— React 路由原理</h2><p>靠的是 H5 推出的 history 上的 API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//路由跳转</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">path</span>) </span>&#123;<br>  history.push(path);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 路由替换</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replace</span>(<span class="hljs-params">path</span>) </span>&#123;<br>  history.replace(path);<br>&#125;<br><br><span class="hljs-comment">// 路由回退</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">back</span>(<span class="hljs-params"></span>) </span>&#123;<br>  history.goBack();<br>&#125;<br><br><span class="hljs-comment">// 路由前进</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forword</span>(<span class="hljs-params"></span>) </span>&#123;<br>  history.goForward();<br>&#125;<br><br><span class="hljs-comment">// 监听路由变化</span><br>history.listen(<span class="hljs-function">(<span class="hljs-params">location</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;监听路由变化&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="2021-12-28-更新——-全局事件总线"><a href="#2021-12-28-更新——-全局事件总线" class="headerlink" title="2021-12-28 更新—— 全局事件总线"></a>2021-12-28 更新—— 全局事件总线</h2><p>用第三方库<code>mitt</code>或者<code>pubsub</code>，可以实现多层级的组件之间的通信</p><h2 id="2021-12-30-更新——-React-的-setState"><a href="#2021-12-30-更新——-React-的-setState" class="headerlink" title="2021-12-30 更新—— React 的 setState()"></a>2021-12-30 更新—— React 的 setState()</h2><p>异步执行</p><ol><li><p>多个 setState()会推到一个任务队列里面，将多次执行合并为一个来执行。</p></li><li><p>setState()的几种写法</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//常规写法，这种写法会将多次setState()方法合并</span><br><span class="hljs-comment">// counter的初始值为1</span><br><span class="hljs-built_in">this</span>.setState(&#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-built_in">this</span>.state.counter + <span class="hljs-number">1</span>,<br>&#125;);<br><span class="hljs-built_in">this</span>.setState(&#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-built_in">this</span>.state.counter + <span class="hljs-number">1</span>,<br>&#125;);<br><span class="hljs-built_in">this</span>.setState(&#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-built_in">this</span>.state.counter + <span class="hljs-number">1</span>,<br>&#125;);<br><span class="hljs-comment">// counter的值是2</span><br><span class="hljs-comment">// ----------------------------------------</span><br><span class="hljs-comment">// 这种写法和上面执行结果不同，preState拿到的是最新的设置后的值（上一个setState设置的值）</span><br><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">preState</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">counter</span>: preState.counter + <span class="hljs-number">1</span>,<br>&#125;));<br><br><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">preState</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">counter</span>: preState.counter + <span class="hljs-number">1</span>,<br>&#125;));<br><br><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">preState</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">counter</span>: preState.counter + <span class="hljs-number">1</span>,<br>&#125;));<br><span class="hljs-comment">// counter的值是4</span><br></code></pre></td></tr></table></figure><p>setState()方法里的第二个参数是一个回调函数，该函数能拿到设置之后的值</p><h2 id="2021-12-31-更新——-无副作用"><a href="#2021-12-31-更新——-无副作用" class="headerlink" title="2021-12-31 更新—— 无副作用"></a>2021-12-31 更新—— 无副作用</h2><p>在 React 里经常看到<code>无副作用</code>这个词，它表示它只对自身有影响对自身以外的无影响，所有的输出都是由我的输入来决定的。</p><p>发一个请求，设置了 localstorage，对外部进行了操作这都叫做<strong>副作用</strong></p><h2 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h2><ol><li>组件初始化阶段 initialization, 比如 constructor</li><li>组件挂载阶段 mount<ol><li>componentWillMount 组件挂载到 DOM 前调用,只会被调用一次, 这里写 setState 不会引起组件重新渲染</li><li>render 返回一个 react 元素, react 根据此函数的返回值渲染 DOM. 不能在这里 setState</li><li>componentDidMount 组件挂载到 DOM 后调用, 且只会被调用一次</li></ol></li><li>组件的更新阶段 update<ol><li>componentWillReceiveProps(nextProps) 触发于 props 引起的组件更新过程中</li><li>shouldComponentUpdate(nextProps, nextState) 比较之前和当前的 props state 是否有变化</li><li>componentWillUpdate(nextProps, nextState) render 方法前执行</li><li>render</li><li>componentDidUpdate(preProps, preState)</li></ol></li><li>组件的卸载阶段 unmount<ol><li>componentWillUnmount 卸载前调用, 在这里可以清理一些定时器</li></ol></li></ol><p><code>componentWillMount</code>,<code>componentWillReceiveProps</code>,<code>componentWillUnmount</code>在 React17 不建议使用，即将被废弃</p><h2 id="2022-06-30-更新-React-的虚拟-DOM"><a href="#2022-06-30-更新-React-的虚拟-DOM" class="headerlink" title="2022-06-30 更新 React 的虚拟 DOM"></a>2022-06-30 更新 React 的虚拟 DOM</h2><p>在 React，我们操作的元素被称为 React 元素，并不是真正的原生 DOM 元素。</p><p>React 通过虚拟 DOM，将 React 元素和原生 DOM，进行映射，虽然操作的是 React 元素，但是这些操作最终都会在真实的 DOM 中体现。</p><p>虚拟 DOM 的好处：</p><ul><li>降低 api 复杂度（远离原生的复杂的 dom 操作）</li><li>解决兼容性问题</li><li>提升性能（减少 DOM 的不必要操作）</li></ul><p>每当我们调用 root.render()时，页面就会发生重新渲染</p><p>React 会通过 diffing 算法，将新的元素和旧的元素进行比较</p><p>通过比较找到发生变化的元素，并且只对变化的元素进行修改，没有发生的变化不予处理。</p><p>比较两次数据时，React 会先比较父元素，父元素如果不同，直接所有元素全部替换。父元素一致，再去逐个比较子元素，直到找到所有发生变化的元素为止。</p><p>在 JSX 中显示数组时，数组中的每一个元素都需要设置一个唯一的 key，否则控制台会报警告。</p><p>重新渲染页面时，React 会按照顺序依次比较对应的元素，当渲染一个列表时如果不指定 key，同样也会按照顺序进行比较。如果列表的顺序永远不会发生变化，不加 key 没有问题。但是如果列表的顺序会发生变化，这可能会导致性能问题。</p><ul><li>尽量用元素的 id 来做 key</li><li>用遍历的 索引 index 来做 key，没有意义，仍然会全部更新</li><li>当元素的顺序不会发生变化时，用索引 index 做 key，没有问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术类-React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的同步与异步</title>
    <link href="/20211214/JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <url>/20211214/JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing">更详细的可以点这里</a></p><h2 id="异步JavaScript"><a href="#异步JavaScript" class="headerlink" title="异步JavaScript"></a><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Asynchronous">异步JavaScript</a></h2><p><strong>异步</strong>指两个或两个以上的对象或事件<strong>不</strong>同时存在或发生（或多个相关事物的发生<strong>无需</strong>等待其前一事物的完成）</p><h2 id="同步JavaScript"><a href="#同步JavaScript" class="headerlink" title="同步JavaScript"></a><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Synchronous">同步JavaScript</a></h2><p>各方都实时（或者尽可能实时）地收取（而且必要的话也处理或者回复）信息的即时沟通方式，即为<strong>同步</strong>。</p><p>电话即为一个日常的例子：人们都倾向于在使用电话时即时地作出回应。</p><p>许多程序指令也是实时的：例如当输入一个算式时，除非编程人员有意为止，否则环境都会立即将结果反馈回来。</p><h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h2><p>像<code>promise</code>这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境。</p><h2 id="Promises-对比-callbacks"><a href="#Promises-对比-callbacks" class="headerlink" title="Promises 对比 callbacks"></a>Promises 对比 callbacks</h2><p>promises与旧式callbacks有一些相似之处。它们本质上是一个返回的对象，您可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。</p><p>然而，Promise是专门为异步操作而设计的，与旧式回调相比具有许多优点:</p><ul><li>您可以使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作。这种链接方式对回调来说要难得多，会使回调以混乱的“末日金字塔”告终。 (也称为回调地狱)。</li><li>Promise总是严格按照它们放置在事件队列中的顺序调用。</li><li>错误处理要好得多——所有的错误都由块末尾的一个.catch()块处理，而不是在“金字塔”的每一层单独处理。</li></ul><h2 id="异步代码的本质"><a href="#异步代码的本质" class="headerlink" title="异步代码的本质"></a>异步代码的本质</h2><p>让我们研究一个示例，它进一步说明了异步代码的本质，展示了当我们不完全了解代码执行顺序以及将异步代码视为同步代码时可能发生的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log (<span class="hljs-string">&#x27;Starting&#x27;</span>);<br><span class="hljs-keyword">let</span> image;<br><br>fetch(<span class="hljs-string">&#x27;coffee.jpg&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;It worked :)&#x27;</span>)<br>  <span class="hljs-keyword">return</span> response.blob();<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">myBlob</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> objectURL = URL.createObjectURL(myBlob);<br>  image = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;img&#x27;</span>);<br>  image.src = objectURL;<br>  <span class="hljs-built_in">document</span>.body.appendChild(image);<br>&#125;).catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + error.message);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log (<span class="hljs-string">&#x27;All done!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>浏览器将会执行代码，看见第一个<code>console.log()</code> 输出<code>Starting</code> ，然后创建<code>image</code>变量。</p><p>然后，它将移动到下一行并开始执行<code>fetch()</code>块，但是，因为<code>fetch()</code>是异步执行的，没有阻塞，所以在<code>promise</code>相关代码之后程序继续执行，从而到达最后的<code>console.log()</code>语句<code>All done!</code>并将其输出到控制台。</p><p>只有当<code>fetch()</code> 块完成运行返回结果给<code>.then()</code>，我们才最后看到第二个<code>console.log()</code>消息 <code>It worked ;)</code>。所以 这些消息可能以和你预期不同的顺序出现：</p><ul><li>Starting</li><li>All done!</li><li>It worked :)</li></ul><p>如果你感到疑惑，考虑下面这个小例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;registering click handler&quot;</span>);<br><br>button.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;get click&quot;</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;all done&quot;</span>);<br></code></pre></td></tr></table></figure><p>这在行为上非常相似——第一个和第三个<code>console.log()</code>消息将立即显示，但是第二个消息将被阻塞，直到有人单击鼠标按钮。前面的示例以相同的方式工作，只是在这种情况下，第二个消息在<code>promise</code>链上被阻塞，直到获取资源后再显示在屏幕上，而不是单击。</p><p>要查看实际情况，并将第三个<code>console.log()</code>调用更改为以下命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log (<span class="hljs-string">&#x27;All done! &#x27;</span> + image.src + <span class="hljs-string">&#x27;displayed.&#x27;</span>);<br></code></pre></td></tr></table></figure><p>此时控制台将会报错，而不会显示第三个 console.log 的信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">TypeError</span>: image is <span class="hljs-literal">undefined</span>; can<span class="hljs-string">&#x27;t access its &quot;src&quot; property</span><br></code></pre></td></tr></table></figure><p>这是因为：浏览器运行第三个console.log()的时候，fetch() 语句块还没有完成，因此image还没有赋值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>JavaScript</code>是一种同步的、阻塞的、单线程的语言，在这种语言中，一次只能执行一个操作。</p><p>但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是异步地调用函数(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。</p><p>这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。</p><h3 id="异步还是同步执行代码，取决于我们要做什么"><a href="#异步还是同步执行代码，取决于我们要做什么" class="headerlink" title="异步还是同步执行代码，取决于我们要做什么"></a>异步还是同步执行代码，取决于我们要做什么</h3><ul><li><p>同步-如果我们希望事情能够立即加载并发生。例如，当将一些用户定义的样式应用到一个页面时，您希望这些样式能够尽快被应用。</p></li><li><p>异步-如果我们正在运行一个需要时间的操作，比如查询数据库并使用结果填充模板，那么最好将该操作从主线程中移开使用异步完成任务。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git rebase 用法</title>
    <link href="/20211202/git-rebase-%E7%94%A8%E6%B3%95/"/>
    <url>/20211202/git-rebase-%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://zhuanlan.zhihu.com/p/34197548">参考自此文章</a></p><p>以前提交代码一直是用命令行提交的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">// 一把梭</span><br>git pull<br>git add .<br>git commit -m <span class="hljs-string">&#x27;xxxxxx&#x27;</span><br>git push<br></code></pre></td></tr></table></figure><p>在多人开发项目下，这样提交的话会有如下效果:</p><p><img src="https://upload-images.jianshu.io/upload_images/13931286-3d42d72b334fc7c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/594/format/webp" alt="显示效果"></p><p><img src="https://upload-images.jianshu.io/upload_images/13931286-d0fb965ce204e6f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/222/format/webp" alt="显示效果"></p><p>当很多人都把自己的分支合到主分支的时候，这样会显得主线很乱而且还会有自动生成的提交信息</p><p><strong>所以提倡用<code>git rebase</code></strong></p><h2 id="使用-rebase-和-merge-的基本原则"><a href="#使用-rebase-和-merge-的基本原则" class="headerlink" title="使用 rebase 和 merge 的基本原则"></a>使用 rebase 和 merge 的基本原则</h2><ol><li>下游分支更新上游分支内容的时候使用 rebase</li><li>上游分支合并下游分支内容的时候使用 merge</li><li>更新当前分支的内容时一定要使用 –rebase 参数</li></ol><p>例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 <code>git rebase master</code></p><p>等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 <code>git merge dev</code></p><h2 id="实际开发中遇到操作"><a href="#实际开发中遇到操作" class="headerlink" title="实际开发中遇到操作"></a>实际开发中遇到操作</h2><p>当你和其他人在同一个分支开发时，在你提交的时候发现有人已经提交了一些东西上去了，你可以这样操作：</p><ol><li><p><code>git pull --rebase</code></p></li><li><p><code>git push</code></p></li></ol><p>你也可以使用vscode上下载的git插件来操作：</p><p><img src="https://upload-images.jianshu.io/upload_images/13931286-ecca9bb5bd96dc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vscode操作"></p><p>然后再push上去。</p>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>create-react-app 搭建项目踩坑记录</title>
    <link href="/20211129/create-react-app-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/20211129/create-react-app-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="中文说明"><a href="#中文说明" class="headerlink" title="中文说明"></a>中文说明</h1><h2 id="搭建前端开发环境笔记"><a href="#搭建前端开发环境笔记" class="headerlink" title="搭建前端开发环境笔记"></a>搭建前端开发环境笔记</h2><p>由<code>npx create-react-app articles_published_system</code>创建的项目</p><p>后来漏掉了<code>typescript</code>支持，原本可以由命令<code>npx create-react-app articles_published_system --template typescript</code>可以直接创建支持ts的应用</p><p>后续要将ts添加到已有项目中，用以下命令：</p><p><code>npm install --save typescript @types/node @types/react @types/react-dom @types/jest</code></p><p>项目中配置<code>sass</code>:</p><ol><li><p>执行<code>yarn add node-sass</code>下载包（按理说执行<code>npm install node-sass --save</code>也应该有用，但是我这边报错了）。</p><p> 报错如下：</p><p> <img src="https://upload-images.jianshu.io/upload_images/13931286-44bf5ea859ce44fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/672/format/webp" alt="npm安装sass报错"></p><p> 我的vscode和node版本都是最新的</p><p> 建议大家用<code>yarn</code>来安装项目</p><p> <strong>发现启动后sass会报错</strong></p><p> 解决办法：sass指定版本为<code>^1.43.5</code>，postcss-pxtorem为<code>^5.1.1</code>，不要安装node-sass了</p><p> 前端生态配置仍然复杂</p></li><li><p>将样式文件后缀改为<code>.scss</code>并在tsx或者js文件中引入，项目会自动编译。</p></li></ol><p>为了实现自适应，给项目配置postcss-pxtorem</p><ol><li><p>执行<code>yarn add lib-flexible postcss-pxtorem</code></p></li><li><p>在应用入口引入<code>import &#39;lib-flexible&#39;</code></p></li><li><p>执行<code>npm run eject</code>可以打开<code>create-react-app</code>应用的配置文件</p></li><li><p>在<code>config/webpack.config.js</code>文件中配置postcss，位置及方法如下图：</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/13931286-da7732a5f0bf175d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="引入postcss"></p><p><img src="https://upload-images.jianshu.io/upload_images/13931286-7f538e5227508fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp" alt="配置postcss"></p><p>UI库使用antdesign</p><ol><li><p>安装antd，<code>yarn add antd</code></p></li><li><p>在App.css 中导入样式<code>@import &#39;~antd/dist/antd.css&#39;</code>，然后在组件中引入相应的ui组件就可以用了。</p></li></ol><hr><p>完~</p>]]></content>
    
    
    <categories>
      
      <category>技术类-React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最近在忙什么</title>
    <link href="/20211118/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%BF%99%E4%BB%80%E4%B9%88/"/>
    <url>/20211118/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%BF%99%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>最近在做一个个人的全栈项目</p><p>前端技术栈是：Vite+Vue3+TypeScript+Scss</p><p>后端技术栈是：NodeJs+Express+MySQL</p><p>已经上线一部分功能,部署在阿里云上了</p><p>目前没啥功能。后续会慢慢完善优化</p><p>地址在：<a href="http://www.hjzouhualu.com/">www.hjzouhualu.com</a></p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>call,apply和bind</title>
    <link href="/20211021/call-apply%E5%92%8Cbind/"/>
    <url>/20211021/call-apply%E5%92%8Cbind/</url>
    
    <content type="html"><![CDATA[<p><code>call</code>，<code>apply</code>和<code>bind</code>都是用来改变this的指向，但是他们在使用和功能上各有区别。</p><h1 id="call-方法"><a href="#call-方法" class="headerlink" title="call() 方法"></a>call() 方法</h1><h2 id="call-方法的作用"><a href="#call-方法的作用" class="headerlink" title="call() 方法的作用"></a>call() 方法的作用</h2><p>call() 方法的作用：可以<strong>调用</strong>一个函数，与此同时，它还可以改变这个函数内部的 this 指向。</p><p>call() 方法的另一个应用：<strong>可以实现继承</strong>。之所以能实现继承，其实是利用了上面的作用。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">fn1.call(想要将<span class="hljs-built_in">this</span>指向哪里, 函数实参<span class="hljs-number">1</span>, 函数实参<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>备注：第一个参数中，如果不需要改变 this 指向，则传 null。</p><h2 id="call-方法举例"><a href="#call-方法举例" class="headerlink" title="call() 方法举例"></a>call() 方法举例</h2><p>举例 1、通过 call() 调用函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123;<br>    <span class="hljs-attr">nickName</span>: <span class="hljs-string">&#x27;走花鹿&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>,<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.nickName);<br>&#125;<br>fn1.call(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// this的指向并没有被改变，此时相当于 fn1();</span><br></code></pre></td></tr></table></figure><p>上方代码的打印结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span><br><span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><p>上面的代码，跟普通的函数调用 <code>fn1()</code> 没有区别。</p><p>举例 2、通过 call() 改变 this 指向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">nickName</span>: <span class="hljs-string">&#x27;走花鹿&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.nickName);<br>    <span class="hljs-built_in">console</span>.log(a + b);<br>&#125;<br><br>fn1.call(obj1, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 先将 this 指向 obj1，然后执行 fn1() 函数</span><br></code></pre></td></tr></table></figure><p>上方代码的打印结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">obj1<br>走花鹿<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>举例 3、通过 call() 实现继承：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 给 Father 增加 name 和 age 属性</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">myName, myAge</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = myName;<br>    <span class="hljs-built_in">this</span>.age = myAge;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">myName, myAge</span>) </span>&#123;<br>    <span class="hljs-comment">// 【下面这一行，重要代码】</span><br>    <span class="hljs-comment">// 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承</span><br>    Father.call(<span class="hljs-built_in">this</span>, myName, myAge);<br>&#125;<br><br><span class="hljs-keyword">const</span> son1 = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">&#x27;走花鹿&#x27;</span>, <span class="hljs-number">26</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(son1));<br></code></pre></td></tr></table></figure><p>上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。</p><p>打印结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;myName&quot;</span>:<span class="hljs-string">&quot;走花鹿&quot;</span>,<span class="hljs-attr">&quot;myAge&quot;</span>:<span class="hljs-number">26</span>&#125;<br></code></pre></td></tr></table></figure><h1 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply() 方法"></a>apply() 方法</h1><h2 id="apply-方法的作用"><a href="#apply-方法的作用" class="headerlink" title="apply() 方法的作用"></a>apply() 方法的作用</h2><p>apply() 方法的作用：可以<strong>调用</strong>一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。</p><p>apply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">fn1.apply(想要将<span class="hljs-built_in">this</span>指向哪里, [函数实参<span class="hljs-number">1</span>, 函数实参<span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure><p>备注：第一个参数中，如果不需要改变 this 指向，则传 null。</p><p>到这里可以看出， <strong>call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。</strong></p><h2 id="apply-方法举例"><a href="#apply-方法举例" class="headerlink" title="apply() 方法举例"></a>apply() 方法举例</h2><p>举例、通过 apply() 改变 this 指向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">nickName</span>: <span class="hljs-string">&#x27;走花鹿&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params">a</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.nickName);<br>    <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br><br>fn1.apply(obj1, [<span class="hljs-string">&#x27;hello&#x27;</span>]); <span class="hljs-comment">// 先将 this 指向 obj1，然后执行 fn1() 函数</span><br></code></pre></td></tr></table></figure><p>注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。</p><p>打印结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">obj1<br>走花鹿<br>hello<br></code></pre></td></tr></table></figure><h2 id="apply-方法的巧妙应用：求数组的最大值"><a href="#apply-方法的巧妙应用：求数组的最大值" class="headerlink" title="apply() 方法的巧妙应用：求数组的最大值"></a>apply() 方法的巧妙应用：求数组的最大值</h2><p>我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？</p><p>虽然数组里没有获取最大值的方法，但是数值里面有 <code>Math.max(数字1，数字2，数字3)</code> 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。</p><p>举例：求数组中多个元素的最大值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">8</span>];<br><br><span class="hljs-comment">// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。</span><br><span class="hljs-keyword">const</span> maxValue = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-built_in">Math</span>, arr1); <span class="hljs-comment">// 求数组 arr1 中元素的最大值</span><br><span class="hljs-built_in">console</span>.log(maxValue);<br><br><span class="hljs-keyword">const</span> minValue = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-built_in">Math</span>, arr1); <span class="hljs-comment">// 求数组 arr1 中元素的最小值</span><br><span class="hljs-built_in">console</span>.log(minValue);<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">10</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h1 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind() 方法"></a>bind() 方法</h1><h2 id="bind-方法的作用"><a href="#bind-方法的作用" class="headerlink" title="bind() 方法的作用"></a>bind() 方法的作用</h2><p>bind() 方法<strong>不会调用函数</strong>，但是可以改变函数内部的 this 指向。</p><p>把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。</p><p>语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">新函数 = fn1.bind(想要将<span class="hljs-built_in">this</span>指向哪里, 函数实参<span class="hljs-number">1</span>, 函数实参<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li><p>第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。</p></li><li><p>其他参数：fn1 函数的实参。</p></li></ul><p>解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。</p>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Array数组的一些发现</title>
    <link href="/20211020/Array%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%91%E7%8E%B0/"/>
    <url>/20211020/Array%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%91%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>今天对一些元素都是纯数字的数组做<code>forEach</code>遍历操作，发现无法改变原数组，查找了一些资料发现，<code>forEach</code>只能处理数组中的引用类型，元素为基础类型的需要另外的写法。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">let</span> arr2 = [&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;]<br><br><span class="hljs-comment">// 元素为基础类型number，原数组不变</span><br>arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    item += <span class="hljs-number">1</span><br>&#125;)<br><br><span class="hljs-comment">// 这种写法可行</span><br>arr1.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    arr1[index] += <span class="hljs-number">1</span><br>&#125;)<br><br><span class="hljs-comment">// 元素为引用类型的，原数组会改变</span><br>arr2.forEach(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>    item.a = <span class="hljs-number">66</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr);<br><span class="hljs-built_in">console</span>.log(arr1);<br><span class="hljs-built_in">console</span>.log(arr2);<br></code></pre></td></tr></table></figure><p>这主要是和计算机的堆栈有关。基础类型是存储在栈中，<code>forEach</code>中得到item也是存储于栈中，所以它就和数组中的元素毫无关系了；而对象是存储于堆中，遍历的时候item虽然在栈中但是它的指针会指向堆中的位置，所以可以直接修改原数组。</p>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript事件循环</title>
    <link href="/20211014/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/20211014/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>这一篇讲的也特别清楚，建议看看：<a href="https://juejin.cn/post/6844903512845860872">这一次，彻底弄懂 JavaScript 执行机制</a></p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>JavaScript</code> 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事</p><p>为什么要这么设计，跟<code>JavaScript</code>的应用场景有关</p><p><code>JavaScript</code> 初期作为一门浏览器脚本语言，通常用于操作 <code>DOM</code> ，如果是多线程，一个线程进行了删除 <code>DOM</code> ，另一个添加 <code>DOM</code>，此时浏览器该如何处理？</p><p>为了解决单线程运行阻塞问题，<code>JavaScript</code>用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）</p><h4 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h4><p>在<code>JavaScript</code>中，所有的任务都可以分为</p><ul><li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</li><li>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等</li></ul><p>同步任务与异步任务的运行流程图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/13931286-a4cefb0d8aa74774?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环</p><h2 id="二、宏任务与微任务"><a href="#二、宏任务与微任务" class="headerlink" title="二、宏任务与微任务"></a>二、宏任务与微任务</h2><p>如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;new Promise&#x27;</span>)<br>    resolve()<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>如果按照上面流程图来分析代码，我们会得到下面的执行步骤：</p><ul><li><code>console.log(1)</code>，同步任务，主线程中执行</li><li><code>setTimeout()</code> ，异步任务，放到 <code>Event Table</code>，0 毫秒后<code>console.log(2)</code>回调推入 <code>Event Queue</code> 中</li><li><code>new Promise</code> ，同步任务，主线程直接执行</li><li><code>.then</code> ，异步任务，放到 <code>Event Table</code></li><li><code>console.log(3)</code>，同步任务，主线程执行</li></ul><p>所以按照分析，它的结果应该是 <code>1</code> =&gt; <code>&#39;new Promise&#39;</code> =&gt; <code>3</code> =&gt; <code>2</code> =&gt; <code>&#39;then&#39;</code></p><p>但是实际结果是：<code>1</code>=&gt;<code>&#39;new Promise&#39;</code>=&gt; <code>3</code> =&gt; <code>&#39;then&#39;</code> =&gt; <code>2</code></p><p>出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取</p><p>例子中 <code>setTimeout</code>回调事件是先进入队列中的，按理说应该先于 <code>.then</code> 中的执行，但是结果却偏偏相反</p><p>原因在于异步任务还可以细分为微任务与宏任务</p><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p><p>常见的微任务有：</p><ul><li>Promise.then</li><li>MutaionObserver</li><li>Object.observe（已废弃；Proxy 对象替代）</li><li>process.nextTick（Node.js）</li></ul><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p><p>常见的宏任务有：</p><ul><li>script (可以理解为外层同步代码)</li><li>setTimeout/setInterval</li><li>UI rendering/UI事件</li><li>postMessage、MessageChannel</li><li>setImmediate、I/O（Node.js）</li></ul><p>这时候，事件循环，宏任务，微任务的关系如图所示</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibSNwS2EBDtHnxMysjAib2yvIh75NUHZic4J4n5mPSe5jcMcWtsO0LuhRDuqdHVWicqejmPAI8NLLjuKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>按照这个流程，它的执行机制是：</p><ul><li>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中</li><li>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</li></ul><p>回到上面的题目</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;new Promise&#x27;</span>)<br>    resolve()<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>流程如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 遇到 console.log(<span class="hljs-number">1</span>) ，直接打印 <span class="hljs-number">1</span><br><span class="hljs-regexp">//</span> 遇到定时器，属于新的宏任务，留着后面执行<br><span class="hljs-regexp">//</span> 遇到 new Promise，这个是直接执行的，打印 <span class="hljs-string">&#x27;new Promise&#x27;</span><br><span class="hljs-regexp">//</span> .then 属于微任务，放入微任务队列，后面再执行<br><span class="hljs-regexp">//</span> 遇到 console.log(<span class="hljs-number">3</span>) 直接打印 <span class="hljs-number">3</span><br><span class="hljs-regexp">//</span> 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 <span class="hljs-string">&#x27;then&#x27;</span><br><span class="hljs-regexp">//</span> 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="三、async与await"><a href="#三、async与await" class="headerlink" title="三、async与await"></a>三、async与await</h2><p><code>async</code> 是异步的意思，<code>await</code>则可以理解为等待</p><p>放到一起可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await</code>是用来等待异步方法执行</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p><code>async</code>函数返回一个<code>promise</code>对象，下面两种方法是等效的</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Promise.resolve(&#x27;TEST&#x27;)</span>;<br>&#125;<br><br>// asyncF <span class="hljs-keyword">is</span> equivalent to f!<br>async <span class="hljs-keyword">function</span> <span class="hljs-title">asyncF</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">&#x27;TEST&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code>对象，返回该对象的结果。如果不是 <code>Promise</code>对象，就直接返回对应的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 等同于</span><br>    <span class="hljs-comment">// return 123</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-number">123</span><br>&#125;<br>f().then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v)) <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span> (<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">await</span> fn2()<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>) <span class="hljs-comment">// 阻塞</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span> (<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fn2&#x27;</span>)<br>&#125;<br><br>fn1()<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async</code>外面的同步代码，同步代码执行完，再回到 <code>async</code> 函数中，再执行之前阻塞的代码</p><p>所以上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p><h2 id="四、流程分析"><a href="#四、流程分析" class="headerlink" title="四、流程分析"></a>四、流程分析</h2><p>通过对上面的了解，我们对<code>JavaScript</code>对各种场景的执行顺序有了大致的了解</p><p>这里直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 start&#x27;</span>)<br>    <span class="hljs-keyword">await</span> async2()<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;settimeout&#x27;</span>)<br>&#125;)<br>async1()<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    resolve()<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure><p>分析过程：</p><ol><li>执行整段代码，遇到 <code>console.log(&#39;script start&#39;)</code> 直接打印结果，输出 <code>script start</code></li><li>遇到定时器了，它是宏任务，先放着不执行</li><li>遇到 <code>async1()</code>，执行 <code>async1</code> 函数，先打印 <code>async1 start</code>，下面遇到<code>await</code>怎么办？先执行 <code>async2</code>，打印 <code>async2</code>，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码</li><li>跳到 <code>new Promise</code> 这里，直接执行，打印 <code>promise1</code>，下面遇到 <code>.then()</code>，它是微任务，放到微任务列表等待执行</li><li>最后一行直接打印 <code>script end</code>，现在同步代码执行完了，开始执行微任务，即 <code>await</code>下面的代码，打印 <code>async1 end</code></li><li>继续执行下一个微任务，即执行 <code>then</code> 的回调，打印 <code>promise2</code></li><li>上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 <code>settimeout</code></li></ol><p>所以最后的结果是：<code>script start</code>、<code>async1 start</code>、<code>async2</code>、<code>promise1</code>、<code>script end</code>、<code>async1 end</code>、<code>promise2</code>、<code>settimeout</code></p>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解javascript之typeof和instanceof</title>
    <link href="/20211013/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E4%B9%8Btypeof%E5%92%8Cinstanceof/"/>
    <url>/20211013/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E4%B9%8Btypeof%E5%92%8Cinstanceof/</url>
    
    <content type="html"><![CDATA[<h1 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h1><p>typeof方法<strong>返回一个字符串</strong>，来表示<strong>数据的类型</strong>。</p><p>各个数据类型对应typeof的值：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>Type</strong></th></tr></thead><tbody><tr><td>Undefined</td><td>“undefined”</td></tr><tr><td>Null</td><td>“object”</td></tr><tr><td>Boolean</td><td>“boolean”</td></tr><tr><td>Number</td><td>“number”</td></tr><tr><td>String</td><td>“string”</td></tr><tr><td>Symbol</td><td>“symbol”</td></tr><tr><td>宿主对象(JS环境提供的，比如浏览器)</td><td>Implementation-dependent</td></tr><tr><td>函数对象Function</td><td>“function”</td></tr><tr><td>任何其他对象Object</td><td>“object”</td></tr></tbody></table><p>下面是代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Numbers</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-number">37</span> === <span class="hljs-string">&#x27;number&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-number">3.14</span> === <span class="hljs-string">&#x27;number&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Math</span>.LN2 === <span class="hljs-string">&#x27;number&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">Infinity</span> === <span class="hljs-string">&#x27;number&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span> === <span class="hljs-string">&#x27;number&#x27;</span>; <span class="hljs-comment">// 尽管NaN是&quot;Not-A-Number&quot;的缩写,意思是&quot;不是一个数字&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;number&#x27;</span>; <span class="hljs-comment">// 不要这样使用!</span><br><br><span class="hljs-comment">// Strings</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;&quot;</span> === <span class="hljs-string">&#x27;string&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;bla&quot;</span> === <span class="hljs-string">&#x27;string&#x27;</span>;<br><span class="hljs-keyword">typeof</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;string&#x27;</span>; <span class="hljs-comment">// typeof返回的肯定是一个字符串</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;abc&quot;</span>) === <span class="hljs-string">&#x27;string&#x27;</span>; <span class="hljs-comment">// 不要这样使用!</span><br><br><span class="hljs-comment">// Booleans</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span> === <span class="hljs-string">&#x27;boolean&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">false</span> === <span class="hljs-string">&#x27;boolean&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>) === <span class="hljs-string">&#x27;boolean&#x27;</span>; <span class="hljs-comment">// 不要这样使用!</span><br><br><span class="hljs-comment">// Symbols</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>() === <span class="hljs-string">&#x27;symbol&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>) === <span class="hljs-string">&#x27;symbol&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>.iterator === <span class="hljs-string">&#x27;symbol&#x27;</span>;<br><br><span class="hljs-comment">// Undefined</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> === <span class="hljs-string">&#x27;undefined&#x27;</span>;<br><span class="hljs-keyword">typeof</span> blabla === <span class="hljs-string">&#x27;undefined&#x27;</span>; <span class="hljs-comment">// 一个未定义的变量,或者一个定义了却未赋初值的变量</span><br><br><span class="hljs-comment">// Objects</span><br><span class="hljs-keyword">typeof</span> &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125; === <span class="hljs-string">&#x27;object&#x27;</span>;<br><br><span class="hljs-comment">// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型</span><br><span class="hljs-keyword">typeof</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>] === <span class="hljs-string">&#x27;object&#x27;</span>;<br><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() === <span class="hljs-string">&#x27;object&#x27;</span>;<br><br><span class="hljs-comment">// 下面的容易令人迷惑，不要这样使用！</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>) === <span class="hljs-string">&#x27;object&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">1</span>) ==== <span class="hljs-string">&#x27;object&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;abc&quot;</span>) === <span class="hljs-string">&#x27;object&#x27;</span>;<br><br><span class="hljs-comment">// 函数</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125; === <span class="hljs-string">&#x27;function&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Math</span>.sin === <span class="hljs-string">&#x27;function&#x27;</span>;<br></code></pre></td></tr></table></figure><p>发现typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象hj的typeof返回值都是object</p><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>instanceof运算符可以用来判断某个构造函数的prototype属性<strong>是否存在于另外一个</strong>要检测对象<strong>的原型链上</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">C</span>(<span class="hljs-params"></span>)</span>&#123;&#125; <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">D</span>(<span class="hljs-params"></span>)</span>&#123;&#125; <br><br><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> C();<br><br><span class="hljs-comment">// true，因为 Object.getPrototypeOf(o) === C.prototype</span><br>o <span class="hljs-keyword">instanceof</span> C; <br><br><span class="hljs-comment">// false，因为 D.prototype不在o的原型链上</span><br>o <span class="hljs-keyword">instanceof</span> D; <br><br>o <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// true,因为Object.prototype.isPrototypeOf(o)返回true</span><br>C.prototype <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true,同上</span><br><br>C.prototype = &#123;&#125;;<br><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> C();<br><br>o2 <span class="hljs-keyword">instanceof</span> C; <span class="hljs-comment">// true</span><br><br>o <span class="hljs-keyword">instanceof</span> C; <span class="hljs-comment">// false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.</span><br><br>D.prototype = <span class="hljs-keyword">new</span> C(); <span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">var</span> o3 = <span class="hljs-keyword">new</span> D();<br>o3 <span class="hljs-keyword">instanceof</span> D; <span class="hljs-comment">// true</span><br>o3 <span class="hljs-keyword">instanceof</span> C; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网是如何运作的</title>
    <link href="/20211007/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/"/>
    <url>/20211007/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm">互联网是如何运作的</a></p><p>以下是我的总结,更好的学习建议阅读原文。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>互联网所有的传输都通过TCP/IP协议族来传输，TCP/IP是<strong>面向连接</strong>的<strong>可靠</strong>字节流服务协议</p><h1 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h1><p>您的计算机已连接到 Internet 并具有唯一的地址。它如何与连接到 Internet 的其他计算机“交谈”？</p><p>这里应该有一个例子：假设您的 IP 地址是 1.2.3.4，并且您想向计算机 5.6.7.8 发送一条消息。您要发送的消息是“Hello computer 5.6.7.8!”。显然，消息必须通过将您的计算机连接到 Internet 的任何类型的线路传输。假设您已从家里拨入您的 ISP，并且消息必须通过电话线传输。必须将消息从字母文本翻译成电子信号，通过互联网传输，然后再翻译回字母文本。 这是如何实现的？<br><strong>通过使用协议栈</strong>。每台计算机都需要一台在 Internet 上进行通信，它通常内置于计算机的操作系统（即 Windows、Unix 等）中。由于使用了两种主要的通信协议，Internet 上使用的协议栈被称为 <strong>TCP/IP 协议栈</strong>。TCP/IP 堆栈如下所示：</p><ul><li>应用层：提供特定于应用程序的协议  HTTP   FTP   IMAP(邮件)</li><li>网络控制层(TCP)：发送数据包到计算机上使用特定的端口号的应用程序</li><li>网络层(IP)：使用IP地址将数据包发送到特定的计算</li><li>链路层：将二进制数据包与网络信号相互之间转换（例如以太网网卡、电话线调制解调器等）</li></ul><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中 TCP 层的顶部，并被特定应用程序用于相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。</p><p>HTTP是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送对 Web 元素（例如网页和图像）的请求。请求被服务器服务后，客户端和服务器之间通过 Internet 的连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端发出 HTTP 请求之前，必须建立到服务器的新连接。</p><p>当您在 Web 浏览器中键入 URL 时，会发生以下情况：</p><ol><li>如果 URL 包含域名，则浏览器首先连接到域名服务器并为 Web 服务器检索相应的 IP 地址。</li><li>Web 浏览器连接到 Web 服务器并为所需的网页发送 HTTP 请求（通过协议栈）。</li><li>Web 服务器接收请求并检查所需页面。如果页面存在，则 Web 服务器发送它。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。（404 的意思是“找不到页面”，任何浏览过网络的人都可能知道。）</li><li>Web 浏览器接收回页面并关闭连接。</li><li>然后浏览器解析页面并查找完成网页所需的其他页面元素。这些通常包括图像、小程序等。</li><li>对于每个需要的元素，浏览器会为每个元素向服务器发出额外的连接和 HTTP 请求。</li><li>当浏览器加载完所有图像、小程序等后，页面将完全加载到浏览器窗口中。</li></ol><h1 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h1><p>在协议栈的应用层之下是TCP层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）会沿堆栈向下传递到 TCP 层。<strong>TCP 负责将应用程序协议路由到目标计算机上的正确应用程序。</strong> 为此，使用端口号。端口可以​​被认为是每台计算机上的独立通道。例如，您可以在阅读电子邮件时上网。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上时，TCP 层根据端口号决定哪个应用程序接收数据包。<br>TCP 是这样工作的：</p><ul><li>当 TCP 层从上面接收到应用层协议数据时，它会将其分段为可管理的“块”，然后将带有特定 TCP 信息的 TCP 标头添加到每个“块”。TCP 头中包含的信息包括数据需要发送到的应用程序的端口号。</li><li>当 TCP 层接收到来自其下方 IP 层的数据包时，TCP 层会从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。</li></ul><p>这就是 TCP 将通过协议栈移动的数据路由到正确应用程序的方式。</p><p>TCP 不是文本协议。<strong>TCP 是面向连接的、可靠的字节流服务。</strong>面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于收到的每个数据包，都会向发送方发送确认以确认交付。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。<br>tcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功</p><h1 id="IP（互联网协议）"><a href="#IP（互联网协议）" class="headerlink" title="IP（互联网协议）"></a>IP（互联网协议）</h1><p>与 TCP 不同，<strong>IP 是一种不可靠的无连接协议。</strong>IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 IP 的工作也是将数据包发送和路由到其他计算机。IP 数据包是独立的实体，可能无序到达或根本没有到达。TCP 的工作是确保数据包到达并以正确的顺序。IP 与 TCP 的唯一共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据。</p><p>IP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP</p><p>Ip是一种协议  有两种标准  IPv4 2^32次方和IPv6  2^128</p><h1 id="TCP传输的质量和顺序"><a href="#TCP传输的质量和顺序" class="headerlink" title="TCP传输的质量和顺序"></a>TCP传输的质量和顺序</h1><p>当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送</p><p>#网络传输</p><ol><li>个人电脑</li><li>猫（调制解调器）</li><li>local ISP   互联网服务提供商</li><li>regional ISP   经过多个主干网络</li><li>NSP   网络服务提供商  大型网络  卖带宽给ISP</li><li>NAP   每个NSP连接到至少三个网络访问点</li><li>ISP  NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。</li></ol><h1 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h1><p>存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日常-最爱的电影</title>
    <link href="/20210925/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5-%E6%9C%80%E7%88%B1%E7%9A%84%E7%94%B5%E5%BD%B1/"/>
    <url>/20210925/%E6%B5%AE%E7%94%9F%E4%B8%80%E6%97%A5-%E6%9C%80%E7%88%B1%E7%9A%84%E7%94%B5%E5%BD%B1/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><img src="https://img9.doubanio.com/view/photo/l/public/p2220184425.webp" alt="第六感海报"><br>今天重温了电影《第六感》，一部披着灵异外皮的心灵治愈电影。</p><p>有些电影无论第几遍看还是让人感动<br><img src="https://img2.doubanio.com/view/photo/l/public/p2351243392.webp" alt="第六感剧照"><br><img src="https://img1.doubanio.com/view/photo/l/public/p2356175109.webp" alt="第六感剧照"></p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列的理解以及应用场景</title>
    <link href="/20210923/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/20210923/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h1><p><strong>栈（stack）</strong>又名堆栈，它是一种运算受限的线性表，<strong>限定仅在表尾进行插入和删除操作的线性表</strong>。</p><p>表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈</p><p>所以其按照<strong>先进后出</strong>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用</p><p>实现一个栈：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.items = [];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 添加一个（或几个）新元素到栈顶</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>element 新元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">element</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.items.push(element);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 移除栈顶的元素，同时返回被移除的元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.pop();<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.items.length - <span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 如果栈里没有任何元素就返回true,否则返回false</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">isEmpty</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length === <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 移除栈里的所有元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.items = [];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 返回栈里的元素个数。这个方法和数组的length属性很类似</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于栈的操作主要的方法如下：</p><ul><li>push：入栈操作</li><li>pop：出栈操作</li></ul><h1 id="二-队列"><a href="#二-队列" class="headerlink" title="二.队列"></a>二.队列</h1><p>跟栈十分相似，队列是一种特殊的线性表，特殊之处在于<strong>它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</strong>。</p><p>进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列</p><p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为<strong>先进先出</strong></p><p>简单实现一个队列，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.list = [];<br>    <span class="hljs-built_in">this</span>.frontIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.tailIndex = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">enqueue</span>(<span class="hljs-params">item</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.list[<span class="hljs-built_in">this</span>.tailIndex++] = item;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">unqueue</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> item = <span class="hljs-built_in">this</span>.list[<span class="hljs-built_in">this</span>.frontIndex];<br>    <span class="hljs-built_in">this</span>.frontIndex++;<br>    <span class="hljs-keyword">return</span> item;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三-应用场景"><a href="#三-应用场景" class="headerlink" title="三.应用场景"></a>三.应用场景</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>借助栈的先进后出的特性，可以简单实现一个逆序输出的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出</p><p>包括编译器的在对输入的语法进行分析的时候，例如”()”、”{}”、”[]”这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p><p>包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值</p><p>生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题</p><p>队列的使用广泛应用在广度优先搜索中，例如层次遍历一个二叉树的节点值</p><p>生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型</p><p>参考文献</p><ul><li><a href="https://baike.baidu.com/item/%E6%A0%88/12808149">https://baike.baidu.com/item/%E6%A0%88/12808149</a></li><li><a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481">https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通读vue3文档记录</title>
    <link href="/20210915/vue3%E6%96%87%E6%A1%A3%E8%AE%B0%E5%BD%95/"/>
    <url>/20210915/vue3%E6%96%87%E6%A1%A3%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是<code>Object.defineProperty()</code>，vue3用的是<code>Proxy</code>。vue3还新增了<code>组合式API</code>等等。</p><p>这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。</p><p>持续更新ing</p><h1 id="应用-amp-组件实例"><a href="#应用-amp-组件实例" class="headerlink" title="应用&amp;组件实例"></a>应用&amp;组件实例</h1><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>每个 Vue 应用都是通过用 createApp 函数创建一个新的<strong>应用实例</strong>开始的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> app = Vue.createApp(&#123; <span class="hljs-comment">/* 选项 */</span> &#125;)<br></code></pre></td></tr></table></figure><p>该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;&#125;)<br>app.component(<span class="hljs-string">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>app.directive(<span class="hljs-string">&#x27;focus&#x27;</span>, FocusDirective)<br>app.use(LocalePlugin)<br></code></pre></td></tr></table></figure><p>应用实例暴露的大多数方法都会返回该同一实例，允许链式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.createApp(&#123;&#125;)<br>  .component(<span class="hljs-string">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>  .directive(<span class="hljs-string">&#x27;focus&#x27;</span>, FocusDirective)<br>  .use(LocalePlugin)<br></code></pre></td></tr></table></figure><h2 id="根组件实例"><a href="#根组件实例" class="headerlink" title="根组件实例"></a>根组件实例</h2><p>传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。</p><p>一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，我们应该传递 <code>#app</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> RootComponent = &#123; <span class="hljs-comment">/* 选项 */</span> &#125;<br><span class="hljs-keyword">const</span> app = Vue.createApp(RootComponent)<br><span class="hljs-keyword">const</span> vm = app.mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>与大多数应用方法不同的是，<code>mount</code> 不返回应用本身。相反，它返回的是<strong>根组件实例</strong>。</p><p>虽然没有完全遵循 <code>MVVM</code> 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。</p><h1 id="计算属性-amp-侦听器"><a href="#计算属性-amp-侦听器" class="headerlink" title="计算属性&amp;侦听器"></a>计算属性&amp;侦听器</h1><h2 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h2><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; calculateBooksMessage() &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在组件中</span><br><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-function"><span class="hljs-title">calculateBooksMessage</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.author.books.length &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;Yes&#x27;</span> : <span class="hljs-string">&#x27;No&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要<code>author.books</code> 还没有发生改变，多次访问 <code>publishedBookMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。 </p><p>这也同样意味着下面的计算属性将不再更新，因为 <strong>Date.now () 不是响应式依赖</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">computed: &#123;<br>  <span class="hljs-function"><span class="hljs-title">now</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p><p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <code>list</code>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <code>list</code>。如果没有缓存，我们将不可避免的多次执行 <code>list</code> 的 getter！如果你不希望有缓存，请用 method 来替代</p><hr><h2 id="以下为2021-09-16更新"><a href="#以下为2021-09-16更新" class="headerlink" title="以下为2021.09.16更新"></a>以下为2021.09.16更新</h2><h2 id="计算属性的-Setter"><a href="#计算属性的-Setter" class="headerlink" title="计算属性的 Setter"></a>计算属性的 Setter</h2><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ...</span><br><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-attr">fullName</span>: &#123;<br>    <span class="hljs-comment">// getter</span><br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.lastName<br>    &#125;,<br>    <span class="hljs-comment">// setter</span><br>    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> names = newValue.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>      <span class="hljs-built_in">this</span>.firstName = names[<span class="hljs-number">0</span>]<br>      <span class="hljs-built_in">this</span>.lastName = names[names.length - <span class="hljs-number">1</span>]<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p><h1 id="Class与Style绑定"><a href="#Class与Style绑定" class="headerlink" title="Class与Style绑定"></a>Class与Style绑定</h1><p>如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;baz&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span></span><br>&lt;/div&gt;<br><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;&#125;)<br><br>app.component(<span class="hljs-string">&#x27;my-component&#x27;</span>, &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;</span><br><span class="hljs-string">    &lt;span&gt;This is a child component&lt;/span&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好</p><h2 id="v-if-与-v-for-一起使用"><a href="#v-if-与-v-for-一起使用" class="headerlink" title="v-if 与 v-for 一起使用"></a>v-if 与 v-for 一起使用</h2><blockquote><p>提示 不推荐同时使用 v-if 和 v-for</p></blockquote><p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-if</code> 具有比 <code>v-for</code> 更高的优先级。请查阅列表渲染指南以获取详细信息。</p><p>当它们处于同一节点，<code>v-if</code> 的优先级比 <code>v-for</code> 更高，这意味着 <code>v-if</code> 将没有权限访问 <code>v-for</code> 里的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- This will <span class="hljs-keyword">throw</span> an error because property <span class="hljs-string">&quot;todo&quot;</span> is not defined on instance. --&gt;<br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class="xml">  &#123;&#123; todo &#125;&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>可以把 v-for 移动到<code>&lt;template&gt;</code> 标签中来修正：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span>&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class="xml">    &#123;&#123; todo &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h1 id="表单绑定输入"><a href="#表单绑定输入" class="headerlink" title="表单绑定输入"></a>表单绑定输入</h1><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value property 和 input 事件；</li><li>checkbox 和 radio 使用 checked property 和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul><h1 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h1><h2 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h2><p>这里有一个 Vue 组件的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个Vue 应用</span><br><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class="hljs-comment">// 定义一个名为 button-counter 的新全局组件</span><br>app.component(<span class="hljs-string">&#x27;button-counter&#x27;</span>, &#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;button @click=&quot;count++&quot;&gt;</span><br><span class="hljs-string">      You clicked me &#123;&#123; count &#125;&#125; times.</span><br><span class="hljs-string">    &lt;/button&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h2><p>你可以将组件进行任意次数的复用<br>每个组件都会各自独立维护它的<code>data</code>。因为你每用一次组件，就会有一个它的新组件实例被创建</p><h2 id="在组件上使用-v-model"><a href="#在组件上使用-v-model" class="headerlink" title="在组件上使用 v-model"></a>在组件上使用 v-model</h2><p>自定义事件也可以用于创建支持 <code>v-model</code> 的自定义输入组件。记住：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input v-model=<span class="hljs-string">&quot;searchText&quot;</span> /&gt;<br>等价于：<br><br>&lt;input :value=<span class="hljs-string">&quot;searchText&quot;</span> @input=<span class="hljs-string">&quot;searchText = $event.target.value&quot;</span> /&gt;<br>当用在组件上时，v-model 则会这样：<br><br>&lt;custom-input<br>  :model-value=<span class="hljs-string">&quot;searchText&quot;</span><br>  @update:model-value=<span class="hljs-string">&quot;searchText = $event&quot;</span><br>&gt;&lt;/custom-input&gt;<br></code></pre></td></tr></table></figure><p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code> 必须：</p><p>将其 <code>value</code> attribute 绑定到一个名叫 <code>modelValue</code> 的 prop 上<br>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>update:modelValue</code> 事件抛出<br>写成代码之后是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">app.component(<span class="hljs-string">&#x27;custom-input&#x27;</span>, &#123;<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;modelValue&#x27;</span>],<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;input</span><br><span class="hljs-string">      :value=&quot;modelValue&quot;</span><br><span class="hljs-string">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span><br><span class="hljs-string">    &gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>现在 <code>v-model</code> 就应该可以在这个组件上完美地工作起来了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">custom-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;searchText&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">custom-input</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="深入组件"><a href="#深入组件" class="headerlink" title="深入组件"></a>深入组件</h1><h2 id="非-Prop-的-Attribute"><a href="#非-Prop-的-Attribute" class="headerlink" title="非 Prop 的 Attribute"></a>非 Prop 的 Attribute</h2><h3 id="Attribute-继承"><a href="#Attribute-继承" class="headerlink" title="Attribute 继承"></a>Attribute 继承</h3><p>当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 <code>&lt;date-picker&gt;</code> 组件的实例中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">app.component(<span class="hljs-string">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class="hljs-string">      &lt;input type=&quot;datetime&quot; /&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>如果我们需要通过 <code>data status</code> property 定义 <code>&lt;date-picker&gt;</code> 组件的状态，它将应用于根节点 (即 <code>div.date-picker</code>)。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 具有非prop attribute的Date-picker组件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">date-picker</span> <span class="hljs-attr">data-status</span>=<span class="hljs-string">&quot;activated&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">date-picker</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;date-picker&quot;</span> <span class="hljs-attr">data-status</span>=<span class="hljs-string">&quot;activated&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;datetime&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同样的规则适用于事件监听器：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">date-picker</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;submitChange&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">date-picker</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">app.component(<span class="hljs-string">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.$attrs) <span class="hljs-comment">// &#123; onChange: () =&gt; &#123;&#125;  &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">app.component(<span class="hljs-string">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;select&gt;</span><br><span class="hljs-string">      &lt;option value=&quot;1&quot;&gt;Yesterday&lt;/option&gt;</span><br><span class="hljs-string">      &lt;option value=&quot;2&quot;&gt;Today&lt;/option&gt;</span><br><span class="hljs-string">      &lt;option value=&quot;3&quot;&gt;Tomorrow&lt;/option&gt;</span><br><span class="hljs-string">    &lt;/select&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;date-picker&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">date-picker</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;showChange&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">date-picker</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">showChange</span>(<span class="hljs-params">event</span>)</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(event.target.value) <span class="hljs-comment">// 将记录所选选项的值</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="禁用-Attribute-继承"><a href="#禁用-Attribute-继承" class="headerlink" title="禁用 Attribute 继承"></a>禁用 Attribute 继承</h3><p>如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p><p>禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。</p><p>通过将 <code>inheritAttrs</code> 选项设置为 <code>false</code>，你可以访问组件的 <code>$attrs</code> property，该 property 包括组件 <code>props</code> 和 <code>emits</code> property 中未包含的所有属性 (例如，<code>class</code>、<code>style</code>、<code>v-on</code> 监听器等)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">app.component(<span class="hljs-string">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class="hljs-string">      &lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>有了这个新配置，<code>data status</code> attribute 将应用于 <code>input</code> 元素！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Date-picker 组件 使用非 prop attribute --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">date-picker</span> <span class="hljs-attr">data-status</span>=<span class="hljs-string">&quot;activated&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">date-picker</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;date-picker&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;datetime&quot;</span> <span class="hljs-attr">data-status</span>=<span class="hljs-string">&quot;activated&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="多个根节点上的-Attribute-继承"><a href="#多个根节点上的-Attribute-继承" class="headerlink" title="多个根节点上的 Attribute 继承"></a>多个根节点上的 Attribute 继承</h3><p>与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">custom-layout</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;custom-layout&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeValue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">custom-layout</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这将发出警告</span><br>app.component(<span class="hljs-string">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;header&gt;...&lt;/header&gt;</span><br><span class="hljs-string">    &lt;main&gt;...&lt;/main&gt;</span><br><span class="hljs-string">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br><br><span class="hljs-comment">// 没有警告，$attrs被传递到&lt;main&gt;元素</span><br>app.component(<span class="hljs-string">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;header&gt;...&lt;/header&gt;</span><br><span class="hljs-string">    &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class="hljs-string">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><h3 id="处理-v-model-修饰符"><a href="#处理-v-model-修饰符" class="headerlink" title="处理 v-model 修饰符"></a>处理 v-model 修饰符</h3><p>在 2.x 中，我们对组件 <code>v-model</code> 上的 <code>.trim</code> 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件：</p><p>让我们创建一个示例自定义修饰符 <code>capitalize</code>，它将 <code>v-model</code> 绑定提供的字符串的第一个字母大写。</p><p>添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 <code>modelModifiers</code> prop。</p><p>请注意，当组件的 <code>created</code> 生命周期钩子触发时，<code>modelModifiers</code> prop 包含 <code>capitalize</code>，其值为 <code>true</code>——因为它被设置在 <code>v-model</code> 绑定 <code>v-model.capitalize=&quot;bar&quot;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-model.capitalize</span>=<span class="hljs-string">&quot;bar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">app.component(<span class="hljs-string">&#x27;my-component&#x27;</span>, &#123;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">modelValue</span>: <span class="hljs-built_in">String</span>,<br>    <span class="hljs-attr">modelModifiers</span>: &#123;<br>      <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;input type=&quot;text&quot; </span><br><span class="hljs-string">      :value=&quot;modelValue&quot;</span><br><span class="hljs-string">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;&gt;</span><br><span class="hljs-string">  `</span>,<br>  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.modelModifiers) <span class="hljs-comment">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>现在我们已经设置了 prop，我们可以检查 <code>modelModifiers</code> 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 <code>&lt;input/&gt;</code> 元素触发 <code>input</code> 事件时，我们都将字符串大写。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-model.capitalize</span>=<span class="hljs-string">&quot;myText&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br>  &#123;&#123; myText &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">myText</span>: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br><br>app.component(<span class="hljs-string">&#x27;my-component&#x27;</span>, &#123;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">modelValue</span>: <span class="hljs-built_in">String</span>,<br>    <span class="hljs-attr">modelModifiers</span>: &#123;<br>      <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">emitValue</span>(<span class="hljs-params">e</span>)</span> &#123;<br>      <span class="hljs-keyword">let</span> value = e.target.value<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.modelModifiers.capitalize) &#123;<br>        value = value.charAt(<span class="hljs-number">0</span>).toUpperCase() + value.slice(<span class="hljs-number">1</span>)<br>      &#125;<br>      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;update:modelValue&#x27;</span>, value)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;input</span><br><span class="hljs-string">    type=&quot;text&quot;</span><br><span class="hljs-string">    :value=&quot;modelValue&quot;</span><br><span class="hljs-string">    @input=&quot;emitValue&quot;&gt;`</span><br>&#125;)<br><br>app.mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>对于带参数的 <code>v-model</code> 绑定，生成的 prop 名称将为 <code>arg + &quot;Modifiers&quot;</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-model:foo.capitalize</span>=<span class="hljs-string">&quot;bar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">app.component(<span class="hljs-string">&#x27;my-component&#x27;</span>, &#123;<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;fooModifiers&#x27;</span>],<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;input type=&quot;text&quot; </span><br><span class="hljs-string">      :value=&quot;foo&quot;</span><br><span class="hljs-string">      @input=&quot;$emit(&#x27;update:foo&#x27;, $event.target.value)&quot;&gt;</span><br><span class="hljs-string">  `</span>,<br>  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.fooModifiers) <span class="hljs-comment">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><hr><h2 id="2021-09-17更新"><a href="#2021-09-17更新" class="headerlink" title="2021.09.17更新"></a>2021.09.17更新</h2><h2 id="提供-注入"><a href="#提供-注入" class="headerlink" title="提供/注入"></a>提供/注入</h2><p>通常，当我们需要将数据从父组件传递到子组件时，我们使用<code>props</code>。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。</p><p>对于这种情况，我们可以使用 <code>provide</code> 和 <code>inject</code> 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这个数据。</p><h1 id="可复用-amp-组合"><a href="#可复用-amp-组合" class="headerlink" title="可复用&amp;组合"></a>可复用&amp;组合</h1><h2 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h2><h3 id="虚拟DOM树"><a href="#虚拟DOM树" class="headerlink" title="虚拟DOM树"></a>虚拟DOM树</h3><p>Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">return</span> Vue.h(<span class="hljs-string">&#x27;h1&#x27;</span>, &#123;&#125;, <span class="hljs-built_in">this</span>.blogTitle)<br></code></pre></td></tr></table></figure><p><code>h()</code> 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 <strong>VNode</strong>。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p><h3 id="h-参数"><a href="#h-参数" class="headerlink" title="h()参数"></a>h()参数</h3><p>h() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">h(<br>  <span class="hljs-comment">// &#123;String | Object | Function | null&#125; tag</span><br>  <span class="hljs-comment">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span><br>  <span class="hljs-comment">// 使用 null 将会渲染一个注释。</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// 必需的。</span><br>  <span class="hljs-string">&#x27;div&#x27;</span>,<br><br>  <span class="hljs-comment">// &#123;Object&#125; props</span><br>  <span class="hljs-comment">// 与 attribute、prop 和事件相对应的对象。</span><br>  <span class="hljs-comment">// 我们会在模板中使用。</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// 可选的。</span><br>  &#123;&#125;,<br><br>  <span class="hljs-comment">// &#123;String | Array | Object&#125; children</span><br>  <span class="hljs-comment">// 子 VNodes, 使用 `h()` 构建,</span><br>  <span class="hljs-comment">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span><br>  <span class="hljs-comment">// 有 slot 的对象。</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// 可选的。</span><br>  [<br>    <span class="hljs-string">&#x27;Some text comes first.&#x27;</span>,<br>    h(<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-string">&#x27;A headline&#x27;</span>),<br>    h(MyComponent, &#123;<br>      <span class="hljs-attr">someProp</span>: <span class="hljs-string">&#x27;foobar&#x27;</span><br>    &#125;)<br>  ]<br>)<br></code></pre></td></tr></table></figure><h3 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h3><p>有了这些知识，我们现在可以完成我们最开始想实现的组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class="hljs-comment">/** Recursively get text from children nodes */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChildrenTextContent</span>(<span class="hljs-params">children</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> children<br>    .map(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> node.children === <span class="hljs-string">&#x27;string&#x27;</span><br>        ? node.children<br>        : <span class="hljs-built_in">Array</span>.isArray(node.children)<br>        ? getChildrenTextContent(node.children)<br>        : <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;)<br>    .join(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br><br>app.component(<span class="hljs-string">&#x27;anchored-heading&#x27;</span>, &#123;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// create kebab-case id from the text contents of the children</span><br>    <span class="hljs-keyword">const</span> headingId = getChildrenTextContent(<span class="hljs-built_in">this</span>.$slots.default())<br>      .toLowerCase()<br>      .replace(<span class="hljs-regexp">/\W+/g</span>, <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-comment">// replace non-word characters with dash</span><br>      .replace(<span class="hljs-regexp">/(^-|-$)/g</span>, <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// remove leading and trailing dashes</span><br><br>    <span class="hljs-keyword">return</span> Vue.h(<span class="hljs-string">&#x27;h&#x27;</span> + <span class="hljs-built_in">this</span>.level, [<br>      Vue.h(<br>        <span class="hljs-string">&#x27;a&#x27;</span>,<br>        &#123;<br>          <span class="hljs-attr">name</span>: headingId,<br>          <span class="hljs-attr">href</span>: <span class="hljs-string">&#x27;#&#x27;</span> + headingId<br>        &#125;,<br>        <span class="hljs-built_in">this</span>.$slots.default()<br>      )<br>    ])<br>  &#125;,<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">level</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>,<br>      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术类-Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web设计模式解析与实战（一）</title>
    <link href="/20210912/web%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <url>/20210912/web%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>有利于</p><ol><li><p>组织模块</p></li><li><p>设计沟通</p></li><li><p>代码质量</p></li></ol><h1 id="五大设计原则："><a href="#五大设计原则：" class="headerlink" title="五大设计原则："></a>五大设计原则：</h1><ol><li>开闭原则（OCP：open close principle）<ul><li>开-对拓展开放，对修改关闭</li></ul></li><li>单一职责原则（SRP）<ul><li>岗位职责单一，互不重叠</li></ul></li><li>依赖倒置原则（DIP）<ul><li>上层不应该依赖下层实现</li></ul></li><li>接口隔离原则（ISP）<ul><li>多个专业的接口比单个胖借口好用</li></ul></li><li>里氏替换原则（LSP：the Lxxxx substitution principle）<ul><li>子类能够覆盖父类</li><li>父类能够出现的地方子类就能出现</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript中函数的理解</title>
    <link href="/20210910/TypeScript%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/20210910/TypeScript%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>和JavaScript使用方式类似，可以通过<code>funciton</code>关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a:<span class="hljs-built_in">number</span>,b:<span class="hljs-built_in">number</span></span>)=&gt;</span> a+b<br></code></pre></td></tr></table></figure><p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：<br><img src="https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg" alt="TypeScript编译器的提示"><br>当鼠标放置在第三行 <code>add</code> 函数名的时候，会出现完整的函数定义类型，通过 <code>:</code> 的形式来定义参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p><p>我们也可以显式地写上返回类型，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> add = (a:<span class="hljs-built_in">number</span>,<span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span>):<span class="hljs-function"><span class="hljs-params">number</span>=&gt;</span> a+b<br></code></pre></td></tr></table></figure><p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 方式一</span><br><span class="hljs-keyword">type</span> LongHand = &#123;<br>  (a: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>&#125;;<br><br><span class="hljs-comment">// 方式二</span><br><span class="hljs-keyword">type</span> ShortHand = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br><br></code></pre></td></tr></table></figure><p>当存在函数重载时，只能使用方式一的形式</p><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b?: <span class="hljs-built_in">number</span></span>) =&gt;</span> a + (b ? b : <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>这时候参数<code>b</code>可以是<code>number类型</code>或者<code>undefined类型</code>，即可以传一个<code>number类型</code>或者不传都可以</p><h2 id="剩余类型"><a href="#剩余类型" class="headerlink" title="剩余类型"></a>剩余类型</h2><p>剩余参数与JavaScript的语法类似，需要用 <code>...</code> 来表示剩余参数</p><p>如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, ...rest: <span class="hljs-built_in">number</span>[]</span>) =&gt;</span> rest.reduce((<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b), a)<br></code></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p><p>关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|操作符</code>或者<code>?操作符</code>，把所有可能的输入类型全部包含进去，用于具体实现</p><p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并</p><p>例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 上边是声明</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">arg1: <span class="hljs-built_in">string</span>, arg2: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span><br><span class="hljs-function"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">arg1: <span class="hljs-built_in">number</span>, arg2: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span></span><br><span class="hljs-function"><span class="hljs-function">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 <span class="hljs-title">declare</span> 关键字</span></span><br><span class="hljs-function"><span class="hljs-function"></span></span><br><span class="hljs-function"><span class="hljs-function">// 下边是实现</span></span><br><span class="hljs-function"><span class="hljs-function"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">arg1: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, arg2: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>&#123;</span></span><br><span class="hljs-function"><span class="hljs-function">  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 <span class="hljs-title">arg1</span> + <span class="hljs-title">arg2</span></span></span><br><span class="hljs-function"><span class="hljs-function">  <span class="hljs-title">if</span> (<span class="hljs-params"><span class="hljs-keyword">typeof</span> arg1 === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> arg2 === <span class="hljs-string">&#x27;string&#x27;</span></span>) </span>&#123;</span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">arg1</span> + <span class="hljs-title">arg2</span></span><br><span class="hljs-function">  &#125; <span class="hljs-title">else</span> <span class="hljs-title">if</span> (<span class="hljs-params"><span class="hljs-keyword">typeof</span> arg1 === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> arg2 === <span class="hljs-string">&#x27;number&#x27;</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> arg1 + arg2<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>从上面可以看到：</p><ul><li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li><li>typescript 在参数中，添加可选参数供使用者选择</li><li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1></li><li><a href="https://www.tslang.cn/docs/handbook/functions.html">https://www.tslang.cn/docs/handbook/functions.html</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD</a></li><li><a href="https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD">https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术类-TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hi there!</title>
    <link href="/20210907/about-me/"/>
    <url>/20210907/about-me/</url>
    
    <content type="html"><![CDATA[<blockquote><p>逆水行舟，不进则退</p></blockquote><p><a href="https://github.com/anuraghazra/github-readme-stats"><img src="https://github-readme-stats.vercel.app/api?username=zouHuaLu&count_private=true&show_icons=true&theme=radical" alt="Anurag&#39;s GitHub stats"></a></p><p>我的 github 仓库：<a href="https://github.com/zouHuaLu">https://github.com/zouHuaLu</a></p>]]></content>
    
    
    <categories>
      
      <category>个人简介</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript中类的理解</title>
    <link href="/20210906/TypeScript%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/20210906/TypeScript%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h1><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p><blockquote><p>❝类是一种用户定义的引用数据类型，也称类类型❞</p></blockquote><p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本<br>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多<br>但是<code>JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类<br><code>TypeScript</code> 的 <code>class</code>  支持面向对象的所有特性，比如 类、接口等</p><h1 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h1><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：</p><p>「字段」：字段是类里面声明的变量。字段表示对象的有关数据。</p><p>「构造函数」：类实例化时调用，可以为类的对象分配内存。</p><p>「方法」：方法为对象要执行的操作<br>如下例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123; <br>    <span class="hljs-comment">// 字段 </span><br>    <span class="hljs-attr">engine</span>:<span class="hljs-built_in">string</span>; <br> <br>    <span class="hljs-comment">// 构造函数 </span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">engine:<span class="hljs-built_in">string</span></span>)</span> &#123; <br>        <span class="hljs-built_in">this</span>.engine = engine <br>    &#125;  <br> <br>    <span class="hljs-comment">// 方法 </span><br>    disp():<span class="hljs-built_in">void</span> &#123; <br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;发动机为 :   &quot;</span>+<span class="hljs-built_in">this</span>.engine) <br>    &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>类的继承使用过<code>extends</code>的关键字</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Animal moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">bark</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Woof! Woof!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> Dog();<br>dog.bark();<br>dog.move(<span class="hljs-number">10</span>);<br>dog.bark();<br><br></code></pre></td></tr></table></figure><p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 <strong>超类</strong>。</p><p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法。<br>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。</p><p>通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrinterClass</span> </span>&#123; <br>   doPrint():<span class="hljs-built_in">void</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;父类的 doPrint() 方法。&quot;</span>) <br>   &#125; <br>&#125; <br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringPrinter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PrinterClass</span> </span>&#123; <br>   doPrint():<span class="hljs-built_in">void</span> &#123; <br>      <span class="hljs-built_in">super</span>.doPrint() <span class="hljs-comment">// 调用父类的函数</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;子类的 doPrint()方法。&quot;</span>)<br>   &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：</p><ul><li>公共 public：可以自由的访问类程序里定义的成员</li><li>私有 private：只能够在该类的内部进行访问</li><li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li></ul><h3 id="私有修饰符"><a href="#私有修饰符" class="headerlink" title="私有修饰符"></a>私有修饰符</h3><p>只能够在该类的内部进行访问，实例对象并不能够访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">private</span> name:<span class="hljs-built_in">String</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">String</span></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> father = <span class="hljs-keyword">new</span> Father(<span class="hljs-string">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class="hljs-comment">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br></code></pre></td></tr></table></figure><p>并且继承该类的子类并不能访问，如下图所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">private</span> name:<span class="hljs-built_in">String</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">String</span></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`my name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)  <span class="hljs-comment">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="受保护修饰符"><a href="#受保护修饰符" class="headerlink" title="受保护修饰符"></a>受保护修饰符</h3><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> name:<span class="hljs-built_in">String</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">String</span></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> father = <span class="hljs-keyword">new</span> Father(<span class="hljs-string">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class="hljs-comment">//会报错，提示 &quot;属性name受保护，只能在类Father及其子类中访问&quot;</span><br></code></pre></td></tr></table></figure><p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> name:<span class="hljs-built_in">String</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">String</span></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`my name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="只读修饰符"><a href="#只读修饰符" class="headerlink" title="只读修饰符"></a>只读修饰符</h3><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">readonly</span> name:<span class="hljs-built_in">String</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">String</span></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> father = <span class="hljs-keyword">new</span> Father(<span class="hljs-string">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class="hljs-comment">//会报错,提示&quot;无法分配到name，因为它是只读属性&quot;</span><br></code></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 <code>类型.静态属性</code> 的这种形式访问，如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> width = <span class="hljs-string">&#x27;100px&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(Square.width) <span class="hljs-comment">// 100px</span><br></code></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节<br><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-keyword">abstract</span> makeSound(): <span class="hljs-built_in">void</span>;<br>    move(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;roaming the earch...&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">makeSound</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;miao miao&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> cat = <span class="hljs-keyword">new</span> Cat()<br><br>cat.makeSound() <span class="hljs-comment">// miao miao</span><br>cat.move() <span class="hljs-comment">// roaming the earch...</span><br></code></pre></td></tr></table></figure><h1 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h1><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在<code>React</code> 工程中是很常用的，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Carousel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">Props</span>, <span class="hljs-title">State</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。</p><p>先声明一个类，这个类包含组件 props 所需的类型和初始值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// props的类型</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Props</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> children: <span class="hljs-built_in">Array</span>&lt;React.ReactElement&lt;<span class="hljs-built_in">any</span>&gt;&gt; | React.ReactElement&lt;<span class="hljs-built_in">any</span>&gt; | <span class="hljs-built_in">never</span>[] = []<br>  <span class="hljs-keyword">public</span> speed: <span class="hljs-built_in">number</span> = <span class="hljs-number">500</span><br>  <span class="hljs-keyword">public</span> height: <span class="hljs-built_in">number</span> = <span class="hljs-number">160</span><br>  <span class="hljs-keyword">public</span> animation: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;easeInOutQuad&#x27;</span><br>  <span class="hljs-keyword">public</span> isAuto: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">public</span> autoPlayInterval: <span class="hljs-built_in">number</span> = <span class="hljs-number">4500</span><br>  <span class="hljs-keyword">public</span> afterChange: <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> beforeChange: <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>  <span class="hljs-keyword">public</span> selesctedColor: <span class="hljs-built_in">string</span><br>  <span class="hljs-keyword">public</span> showDots: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> defaultProps = <span class="hljs-keyword">new</span> Props()<br></code></pre></td></tr></table></figure><p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class</code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://www.tslang.cn/docs/handbook/classes.html">https://www.tslang.cn/docs/handbook/classes.html</a></li><li><a href="https://www.runoob.com/typescript/ts-class.html">https://www.runoob.com/typescript/ts-class.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术类-TypeScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>export与export default的区别</title>
    <link href="/20210701/export%E4%B8%8Eexport-default%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/20210701/export%E4%B8%8Eexport-default%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>node中导入模块：var 名称 = require(‘模块标识符’)</p><p>node中向外暴露成员的形式：module.exports = {}</p><p>在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块</p><p>ES6中导入模块，使用 import 模块名称 from ‘模块标识符’    import ‘表示路径’</p><p>import * from * 是ES6中导入模块的方式</p><h3 id="在ES6中，使用export-default-和-export-向外暴露成员"><a href="#在ES6中，使用export-default-和-export-向外暴露成员" class="headerlink" title="在ES6中，使用export default 和 export 向外暴露成员"></a>在ES6中，使用export default 和 export 向外暴露成员</h3><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><span class="hljs-keyword">var</span> info = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> info<br></code></pre></td></tr></table></figure><p>在main.js中接收，test.js使用export default 向外暴露的成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> person <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.js&#x27;</span><br><span class="hljs-built_in">console</span>.log(person);<br></code></pre></td></tr></table></figure><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>1、export default 向外暴露的成员，可以使用任意变量来接收</p><p>2、在一个模块中，export default 只允许向外暴露一次</p><p>3、在一个模块中，可以同时使用export default 和export 向外暴露成员</p><p>4、使用export向外暴露的成员，只能使用{  }的形式来接收，这种形式，叫做【按需导出】</p><p>5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义</p><p>6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收</p><p>7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><span class="hljs-keyword">var</span> info = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> info<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> title = <span class="hljs-string">&#x27;小星星&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> content = <span class="hljs-string">&#x27;哈哈哈&#x27;</span><br></code></pre></td></tr></table></figure><p>在main.js中接收，test.js使用export default 和 export 向外暴露的成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> person, &#123;title, content <span class="hljs-keyword">as</span> content1&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.js&#x27;</span><br><span class="hljs-built_in">console</span>.log(person);<br><span class="hljs-built_in">console</span>.log(title + <span class="hljs-string">&#x27;=======&#x27;</span> + content1);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>new操作符的实现</title>
    <link href="/20210619/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/20210619/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="JavaScript中的new操作符的原理"><a href="#JavaScript中的new操作符的原理" class="headerlink" title="JavaScript中的new操作符的原理"></a>JavaScript中的new操作符的原理</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name, age</span>) </span>&#123;<br> <span class="hljs-built_in">this</span>.name = name<br> <span class="hljs-built_in">this</span>.age = age<br>&#125;<br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;走花路的长颈鹿&#x27;</span>, <span class="hljs-number">26</span>)<br><span class="hljs-built_in">console</span>.log(person1) <span class="hljs-comment">//Person&#123;name:&#x27;走花路的长颈鹿&#x27;,age:26&#125;</span><br></code></pre></td></tr></table></figure><p>先定义了一个构造函数<code>Person</code>，然后通过<code>new</code>操作符生成Person构造函数的一个实例并将其引用赋值给变量<code>person1</code>。然后控制台打印出<code>person1</code>的内容，可以看到该实例对象具有<code>name</code>和<code>age</code>属性，它们的值就是我们在调用构造函数时传入的值。</p><h2 id="new关键字进行的操作"><a href="#new关键字进行的操作" class="headerlink" title="new关键字进行的操作"></a>new关键字进行的操作</h2><ol><li><p> 先创建一个空对象<code>obj=&#123;&#125;</code></p></li><li><p> 将obj的<code>__proto__</code>原型指向构造函数Person的<code>prototype</code>原型对象，即<code>obj.__proto__ = Person.prototype</code></p></li><li><p> 将构造函数Person内部的this指向obj，然后执行构造函数<code>Person()</code>（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象<code>obj</code>而已，就好像执行<code>obj.Person()</code>一样）</p></li><li><p> 若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象<code>obj</code>（默认会添加<code>return this</code>）。否则，返回引用类型的值。</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/13931286-2638e8196f6e699b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="new操作符的执行过程"> </p><h2 id="自己实现一个new操作符"><a href="#自己实现一个new操作符" class="headerlink" title="自己实现一个new操作符"></a>自己实现一个new操作符</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span> <span class="hljs-params">(constr, <span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br> <span class="hljs-comment">// 1,2 创建一个对象obj，将obj的__proto__属性指向构造函数的原型对象</span><br> <span class="hljs-comment">// 即实现：obj.__proto__ === constructor.prototype</span><br> <span class="hljs-keyword">var</span> obj = Object.create(constr.prototype)<br> <span class="hljs-comment">// 3.将constrc内部的this（即执行上下文）指向obj，并执行</span><br> <span class="hljs-keyword">var</span> result = constr.apply(obj, args)<br> <span class="hljs-comment">// 4\. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象</span><br> <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> Object ? result : obj<br>&#125;<br><br><span class="hljs-comment">// 使用的例子：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span><span class="hljs-params">(name, age)</span></span>&#123;<br> <span class="hljs-keyword">this</span>.name = name;<br> <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">const</span> person1 = myNew(Person, <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">20</span>)<br>console.log(person1)  <span class="hljs-comment">// Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span><br></code></pre></td></tr></table></figure><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ol><li><p> 将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。</p></li><li><p> 将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。</p></li></ol><hr><h2 id="2021年7月1日补充"><a href="#2021年7月1日补充" class="headerlink" title="2021年7月1日补充"></a>2021年7月1日补充</h2><p>看一个例子</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Player(<span class="hljs-params">color</span>)</span> &#123;<br>  this.color = color<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Player</span>.</span></span>prototype.start = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;&#125;<br><br>const white = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Player(&#x27;<span class="hljs-params">white</span>&#x27;)</span><br>const black = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Player(&#x27;<span class="hljs-params">black</span>&#x27;)</span><br><br>console.log(black.__proto__)  <span class="hljs-comment">// start()</span><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">black</span>)</span>) <span class="hljs-comment">// start()</span><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Player</span>.</span></span>prototype) <span class="hljs-comment">// start()</span><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Player</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span>)</span></span> <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>根据反推可以写一下思路</p><ol><li>一个继承自<code>Player.prototype</code>的新对象 p1/p2被创建</li><li><code>p1.__proto__ === Player.prototype</code>，<code>p1.__proto__</code>指向<code>Player.prototype</code></li><li>将this指向新创建的对象p1/p2</li><li>返回一个新对象：<ol><li>如果构造函数没有显示的返回值，那么返回this</li><li>如果有显式的返回值，是基本类型，那么还是返回this</li><li>如果构造函数有显式的返回值，是对象类型，比如是{a:1}，那么就返回{a:1}<br>现在我们再来实现一个new指令的功能<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Player</span>(<span class="hljs-params">name</span>)</span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br>  <span class="hljs-keyword">let</span> FunctionConstructor = [].shift.call(<span class="hljs-built_in">arguments</span>)<br>  o.__proto__ = FunctionConstructor.prototype<br>  <span class="hljs-keyword">let</span> resultObj = FunctionConstructor.apply(o, <span class="hljs-built_in">arguments</span>) <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> resultObj === <span class="hljs-string">&#x27;object&#x27;</span> ? resultObj : o<br>&#125;<br><span class="hljs-keyword">const</span> p1 = objectFactory(Player, <span class="hljs-string">&#x27;花鹿&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(p1) <span class="hljs-comment">// 花鹿</span><br></code></pre></td></tr></table></figure><h2 id="完"><a href="#完" class="headerlink" title="完~"></a>完~</h2></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型与原型链与constructor</title>
    <link href="/20210618/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8Econstructor/"/>
    <url>/20210618/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8Econstructor/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="原型与原型链与constructor"><a href="#原型与原型链与constructor" class="headerlink" title="原型与原型链与constructor"></a>原型与原型链与constructor</h1><p>本文参考自：<a href="https://blog.csdn.net/cc18868876837/article/details/81211729">https://blog.csdn.net/cc18868876837/article/details/81211729</a></p><h2 id="先来个总结："><a href="#先来个总结：" class="headerlink" title="先来个总结："></a>先来个总结：</h2><ol><li><p> 我们需要牢记两点：①<code>__proto__</code>和<code>constructor</code>属性是对象所独有的；② <code>prototype</code>属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性。</p></li><li><p> __<code>proto__</code>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（父对象）里找，一直找，直到<code>__proto__</code>属性的终点null，再往上找就相当于在null上取值，会报错。通过<code>__proto__</code>属性将对象连接起来的这条链路即我们所谓的原型链。</p></li><li><p> <code>prototype</code>属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即<code>f1.__proto__ === Foo.prototype</code>。</p></li><li><p> <code>constructor</code>属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向<code>Function</code>。</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/13931286-5467dbdb42fd91ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体的联系"> </p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><code>__proto__</code>翻译为<strong>原型</strong>，多个<code>__proto__</code>串连起来的叫做<strong>原型链</strong>。</p><p><code>prototype</code>翻译为<strong>原型对象</strong>。</p><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf()</code> 方法返回指定对象的原型（内部<code>[[Prototype]]</code>属性的值）。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const prototype1 = &#123;&#125;;<br>const object1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(prototype1);<br><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">object1</span>)</span><span class="hljs-operator"> === </span>prototype1);<br><span class="hljs-comment">// expected output: true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">object1</span>)</span><span class="hljs-operator"> === </span>object1.__proto__<br></code></pre></td></tr></table></figure><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nim">function <span class="hljs-type">Foo</span>() <span class="hljs-meta">&#123;...&#125;</span>;<br><span class="hljs-keyword">let</span> f1 = new <span class="hljs-type">Foo</span>();<br></code></pre></td></tr></table></figure><p>以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：<strong>函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。</strong></p><h2 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a><code>__proto__</code>属性</h2><p>首先要记住两点：</p><ol><li><p> <code>__proto__</code>和<code>constructor</code>是对象才有的属性，在JavaScript中函数也是一种对象。</p></li><li><p> <code>prototype</code>是函数才有的属性。</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/13931286-9355e730b53d1879?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="__proto__"> </p><p>这里我们仅留下 <code>__proto__</code> 属性，它是对象所独有的，可以看到<code>__proto__</code>属性都是由<strong>一个对象指向一个对象</strong>，即指向它们构造函数的<strong>原型对象</strong>（也可以理解为父对象），那么这个属性的作用是什么呢？它的<strong>作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的<code>__proto__</code>属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点）</strong>，由以上这种通过<code>__proto__</code>属性来连接对象直到null的一条链即为我们所谓的原型链。    其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠<code>__proto__</code>继承而来的。</p><h2 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a><code>prototype</code>属性</h2><p><img src="https://upload-images.jianshu.io/upload_images/13931286-a68d7e7851adf580?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="prototype属性"> </p><p><code>prototype</code>属性是函数独有的。他是从一个函数指向一个对象，他的含义是函数的原型对象</p><p><code>f1.__proto__ === Foo.prototype</code>，它们两个完全一样。那prototype属性的作用又是什么呢？<strong>它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。</strong>任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。</p><h2 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h2><p><img src="https://upload-images.jianshu.io/upload_images/13931286-8de481f4fbc04fee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="constructor属性"> </p><p><code>constructor</code>属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合<code>__proto__</code>属性查看会更清楚点，如下图所示），从上图中可以看出<code>Function</code>这个对象比较特殊，它的构造函数就是它自己（因为<code>Function</code>可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由<code>Function</code>构造函数得来，所以<code>constructor</code>属性的终点就是<code>Function</code>这个函数。</p><p><code>函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身</code></p><h2 id="完"><a href="#完" class="headerlink" title="完~"></a>完~</h2>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue自定义全局组件</title>
    <link href="/20210618/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6/"/>
    <url>/20210618/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="vue自定义全局弹框组件"><a href="#vue自定义全局弹框组件" class="headerlink" title="vue自定义全局弹框组件"></a>vue自定义全局弹框组件</h1><ol><li><p>在components文件夹下新增一个组件文件夹Dialog，新建一个模板组件Dialog.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;u_dialog_panel&quot; @touchmove.stop=&quot;noop&quot;&gt;<br>    &lt;div class=&quot;mask&quot; v-if=&quot;visible&quot; @click=&quot;handleClose&quot;&gt;&lt;/div&gt;<br>    &lt;transition name=&quot;open&quot;&gt;<br>      &lt;div v-if=&quot;visible&quot; class=&quot;dialog_body&quot;&gt;<br>        &lt;slot&gt;&lt;/slot&gt;<br>        &lt;div class=&quot;btns&quot; v-if=&quot;confirmText || cancleText&quot;&gt;<br>          &lt;div class=&quot;cancle btn&quot; v-if=&quot;cancleText&quot; @click=&quot;handleCancle&quot;&gt;&#123;&#123;cancleText&#125;&#125;&lt;/div&gt;<br>          &lt;div class=&quot;confirm btn&quot; :style=&quot;confirmStyle&quot; v-if=&quot;confirmText&quot; @click=&quot;handleConfirm&quot;&gt;&#123;&#123;confirmText&#125;&#125;&lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/transition&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  name: &#x27;UDialog&#x27;,<br>  props: &#123;<br>    visible: &#123; type: Boolean, default: false, required: true &#125;,<br>    // 确定按钮的文案<br>    confirmText: &#123; type: String, default: &#x27;确定&#x27; &#125;,<br>    confirmStyle: &#123; type: String, default: &#x27;&#x27; &#125;,<br>    // 取消按钮的文案<br>    cancleText: &#123; type: String, default: &#x27;取消&#x27; &#125;,<br>    cancleStyle: &#123; type: String, default: &#x27;&#x27; &#125;,<br>  &#125;,<br>  created () &#123;<br>    this.$nextTick(() =&gt; &#123;<br>      document.body.insertBefore(this.$el, document.body.lastChild)<br>    &#125;)<br>  &#125;,<br>  beforeDestroy () &#123;<br>    document.body.removeChild(this.$el)<br>  &#125;,<br>  methods: &#123;<br>    // 关闭弹窗<br>    handleClose () &#123; this.$emit(&#x27;close&#x27;) &#125;,<br>    // 确定按钮<br>    handleConfirm () &#123; this.$emit(&#x27;confirm&#x27;) &#125;,<br>    // 取消按钮<br>    handleCancle () &#123; this.$emit(&#x27;cancle&#x27;) &#125;,<br>    noop () &#123;&#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;<br>.u_dialog_panel &#123;<br>  .mask &#123;<br>    width: 100vw;<br>    height: 100vh;<br>    background-color: rgba(0, 0, 0, 0.5);<br>    position: fixed;<br>    left: 0;<br>    top: 0;<br>    z-index: 100;<br>    backdrop-filter: blur(5px);<br>  &#125;<br>  .dialog_body&#123;<br>    width: 80vw;<br>    background-color: #fff;<br>    position: fixed;<br>    left: 50vw;<br>    top: 50vh;<br>    z-index: 100;<br>    transform: translate(-50%, -50%);<br>    transform-origin: 0 0;<br>    border-radius: .875rem;<br>    &amp;.open-enter &#123;<br>      opacity: 0;<br>      transform: scale(0.7) translate(-50%, -50%);<br>      transition: all 0.3s;<br>    &#125;<br>    &amp;.open-enter-to &#123;<br>      opacity: 1;<br>      transform: scale(1) translate(-50%, -50%);<br>      transition: all 0.3s;<br>    &#125;<br>    .btns &#123;<br>      display: flex;<br>      justify-content: space-between;<br>      align-items: center;<br>      .btn &#123;<br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br>        flex-grow: 1;<br>        width: 50%;<br>        height: 2.875rem;<br>        border-top: 1px solid #ddd;<br>        box-sizing: border-box;<br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br>        font-size: .875rem;<br>        &amp; + .btn &#123;<br>          border-left: 1px solid #ddd;<br>        &#125;<br>        &amp;.cancle &#123;<br>          color: #666666;<br>        &#125;<br>        &amp;.confirm &#123;<br>          color: #FF5883;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure></li><li><p>在此文件夹再新建一个index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">import Dialog from &#x27;./Dialog&#x27;<br><br>Dialog.install = function (Vue, options) &#123;<br>  Vue.component(`$&#123;Dialog.name&#125;`, Dialog)<br>&#125;<br><br>export default Dialog<br><br></code></pre></td></tr></table></figure></li><li><p>最后再main.js里注册为全局组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">import Dialog from &#x27;./components/Dialog/index.js&#x27;<br><br>Vue.use(Dialog)<br></code></pre></td></tr></table></figure></li></ol><h2 id="这样就可以在其他组件里无需声明而使用此组件"><a href="#这样就可以在其他组件里无需声明而使用此组件" class="headerlink" title="这样就可以在其他组件里无需声明而使用此组件"></a>这样就可以在其他组件里无需声明而使用此组件</h2>]]></content>
    
    
    <categories>
      
      <category>技术类-Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中的堆栈以及数据类型</title>
    <link href="/20210617/JavaScript%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/20210617/JavaScript%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="JavaScript-的堆栈以及数据类型"><a href="#JavaScript-的堆栈以及数据类型" class="headerlink" title="JavaScript 的堆栈以及数据类型"></a>JavaScript 的堆栈以及数据类型</h1><p><a href="https://www.jianshu.com/p/5e0e8d183102">本文参考此链接</a></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li><p>是堆内存的简称。</p></li><li><p>需要程序员自己申请空间，内存大小不一，也不会自动释放。</p></li><li><p>堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大</p></li><li><p>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片</p></li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li><p>是栈内存的简称。</p></li><li><p>是自动分配相对固定大小的内存空间，并由系统自动释放，所以生命周期只在函数的运行过程中。</p></li><li><p>后进先出</p></li><li><p>栈是向低地址扩展的数据结构，是一块连续的内存的区域</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4037795-707975f1f45a6a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1136/format/webp" alt="栈"></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul><li><p>是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。</p></li><li><p>先进先出</p></li></ul><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><code>javascript</code>的<strong>基本类型</strong>就 5 种:<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是<strong>确定</strong>的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p><code>javascript</code>中其他类型的数据被称为<strong>引用类型</strong>的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和 new 出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。</p><h3 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>];<br><span class="hljs-keyword">var</span> arr2 = arr1;<br><span class="hljs-keyword">var</span> str1 = arr1[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">console</span>.log(arr2); <span class="hljs-comment">//1,2,5,8</span><br><span class="hljs-built_in">console</span>.log(str1); <span class="hljs-comment">//5</span><br>arr2[<span class="hljs-number">4</span>] = <span class="hljs-number">99</span>;<br>str1 = <span class="hljs-number">6</span>;<br><span class="hljs-built_in">console</span>.log(arr1); <span class="hljs-comment">//1,2,5,8,99</span><br><span class="hljs-built_in">console</span>.log(arr1[<span class="hljs-number">2</span>]); <span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><p>当我改变 arr2 中的数据时，arr1 中数据也发生了变化，当改变 str1 的数据值时，arr1 却没有发生改变。为什么？这就是<strong>传值与传址</strong>的区别。</p><p>因为 arr1 是数组，属于引用类型，所以它赋予给 arr2 的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1 得到的是一个基本类型的赋值，因此，str1 仅仅是从 arr1 堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2 都指向同一块堆内存，arr2 修改的堆内存的时候，也就会影响到 arr1，str1 是直接在栈中修改，并且不能影响到 arr1 堆内存中的数据。</p><p><img src="https://images2018.cnblogs.com/blog/1402663/201808/1402663-20180802132101478-2092833591.png" alt="img"></p><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将 arr1 的每个基本类型的数据都遍历一遍，依次的赋值给 arr2 的对应字段。避免产生因为地址引用带来的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>];<br><span class="hljs-keyword">var</span> arr2 = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<br>  arr2[i] = arr1[i];<br>&#125;<br><span class="hljs-built_in">console</span>.log(arr2); <span class="hljs-comment">//1,2,5,8</span><br>arr2[<span class="hljs-number">4</span>] = <span class="hljs-number">99</span>;<br><span class="hljs-built_in">console</span>.log(arr2); <span class="hljs-comment">//1,2,5,8,99</span><br><span class="hljs-built_in">console</span>.log(arr1); <span class="hljs-comment">//1,2,5,8</span><br></code></pre></td></tr></table></figure><p>javascript 面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。</p><h1 id="完"><a href="#完" class="headerlink" title="完~"></a>完~</h1>]]></content>
    
    
    <categories>
      
      <category>技术类-前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"source/img/20210911/AirPods.jpeg","path":"img/20210911/AirPods.jpeg","modified":0,"renderable":0},{"_id":"source/img/20210911/pic1.jpeg","path":"img/20210911/pic1.jpeg","modified":0,"renderable":0},{"_id":"source/img/20210911/pic2.jpeg","path":"img/20210911/pic2.jpeg","modified":0,"renderable":0},{"_id":"source/img/20210911/图片.jpeg","path":"img/20210911/图片.jpeg","modified":0,"renderable":0},{"_id":"source/img/20210913/renshengdezhihui.png","path":"img/20210913/renshengdezhihui.png","modified":0,"renderable":0},{"_id":"source/img/20210913/renshengdezhihui2.png","path":"img/20210913/renshengdezhihui2.png","modified":0,"renderable":0},{"_id":"source/img/user/bilibili.jpeg","path":"img/user/bilibili.jpeg","modified":0,"renderable":0},{"_id":"source/img/user/cjl.jpeg","path":"img/user/cjl.jpeg","modified":0,"renderable":0},{"_id":"source/img/user/jianshu.jpeg","path":"img/user/jianshu.jpeg","modified":0,"renderable":0},{"_id":"source/img/user/user.jpg","path":"img/user/user.jpg","modified":0,"renderable":0},{"_id":"source/img/user/weChat.jpg","path":"img/user/weChat.jpg","modified":0,"renderable":0},{"_id":"source/img/user/webo.jpg","path":"img/user/webo.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/1988.jpeg","path":"img/bg/1988.jpeg","modified":0,"renderable":0},{"_id":"source/img/bg/benjamin.jpeg","path":"img/bg/benjamin.jpeg","modified":0,"renderable":0},{"_id":"source/img/bg/feiwuhuanyouji.jpeg","path":"img/bg/feiwuhuanyouji.jpeg","modified":0,"renderable":0},{"_id":"source/img/bg/pengranxindong.jpeg","path":"img/bg/pengranxindong.jpeg","modified":0,"renderable":0},{"_id":"source/img/bg/tianruoyouqing.jpeg","path":"img/bg/tianruoyouqing.jpeg","modified":0,"renderable":0},{"_id":"source/img/bg/tianruoyouqing2.jpeg","path":"img/bg/tianruoyouqing2.jpeg","modified":0,"renderable":0},{"_id":"source/img/bg/zhimingyuchunjiao.jpeg","path":"img/bg/zhimingyuchunjiao.jpeg","modified":0,"renderable":0},{"_id":"source/img/bg/zhimingyuchunjiao2.jpeg","path":"img/bg/zhimingyuchunjiao2.jpeg","modified":0,"renderable":0},{"_id":"source/img/bg/zhimingyuchunjiao4.jpeg","path":"img/bg/zhimingyuchunjiao4.jpeg","modified":0,"renderable":0},{"_id":"source/img/bg/zoo.jpeg","path":"img/bg/zoo.jpeg","modified":0,"renderable":0},{"_id":"source/img/bg/zoo2.jpeg","path":"img/bg/zoo2.jpeg","modified":0,"renderable":0}],"Cache":[{"_id":"source/baidu_verify_code-TmkkRxX4ps.html","hash":"59ea65a0795dc0964e8b356cb89b666fef6e1a53","modified":1631151814047},{"_id":"source/_posts/2021-09-11-浮生一日.md","hash":"b77b5da42558cd2a77b7ffaaf1cc838c79cb78b2","modified":1631703679021},{"_id":"source/.DS_Store","hash":"19332cfdf39a2776f27d87208af7b99819d9425f","modified":1631151814046},{"_id":"source/_posts/2021-09-09-TypeScript中类的理解.md","hash":"e308ebb054af702062bc20534344f00c6492f4d0","modified":1631172900949},{"_id":"source/_posts/2021-09-15-vue3文档记录.md","hash":"bac16fa39b89ee7aeec60e0af9c56918626e6973","modified":1631875319128},{"_id":"source/_posts/2021-09-10-TypeScript中函数的理解.md","hash":"8e9a73fcd541ec49244f4ada6837c61b75fc514c","modified":1631264607141},{"_id":"source/about/index.md","hash":"aa86ca5928080082fd2db5ec9da4cd180ffedeb0","modified":1631151814047},{"_id":"source/_posts/about-me.md","hash":"67e9877a8378af1445ac56bf83cfb9d738031b1c","modified":1631151814046},{"_id":"source/_posts/2021-09-13-叔本华《人生的智慧》第一章节.md","hash":"6082a816bdc9ea7a180dc79f81da68e1c17a1f73","modified":1631703679022},{"_id":"source/img/.DS_Store","hash":"9ce77c9f9c098f72174548c7e3ec2e4a75e20803","modified":1631703679023},{"_id":"source/_posts/2021-09-12-web设计模式解析与实战.md","hash":"6f02ff9c2fa125e342532b97598fffd8cd82d027","modified":1631703679021},{"_id":"source/img/user/cjl.jpeg","hash":"8965600c5e613420121715435f69547c80040033","modified":1631151814051},{"_id":"source/img/user/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1631703679061},{"_id":"source/img/user/jianshu.jpeg","hash":"e3f77ae1071b74c68f0a7237850a3dc7a41a9936","modified":1631012709659},{"_id":"source/img/bg/zhimingyuchunjiao2.jpeg","hash":"d69f0fad1d332cbccba580440039e91b8b694062","modified":1631703679059},{"_id":"source/img/bg/zhimingyuchunjiao4.jpeg","hash":"bfd085b6094073740fdf104d9430812949eaf4e4","modified":1631703679059},{"_id":"source/img/20210911/AirPods.jpeg","hash":"8601c573436498d33b4016f948869ad8de42c543","modified":1631703679024},{"_id":"source/img/20210911/pic1.jpeg","hash":"dc36460fc6f228a5f85c9906359a3e777ec4f9ea","modified":1631703679026},{"_id":"source/img/user/weChat.jpg","hash":"1c490e9ab2206003f6d84446bf8dc347b2d416ef","modified":1631012709662},{"_id":"source/img/bg/1988.jpeg","hash":"b2e716315092f447a1c56e79d9ebf102d5e19ca7","modified":1631703679053},{"_id":"source/img/user/user.jpg","hash":"5a1c8f2385741605649bacf36bfe84f3d0b7983a","modified":1631012709660},{"_id":"source/img/bg/feiwuhuanyouji.jpeg","hash":"05b300041712ab37f2a1f946e29455e9b9dad1ae","modified":1631703679055},{"_id":"source/img/bg/benjamin.jpeg","hash":"83c5636568ee5c2fe4602edf4a418414d242d155","modified":1631703679054},{"_id":"source/img/bg/pengranxindong.jpeg","hash":"9855c234288822b61aeece0b17c4f09f3c881b62","modified":1631703679056},{"_id":"source/img/bg/tianruoyouqing2.jpeg","hash":"620243d332754c7e32e2614862b1d5ed8a7ca78b","modified":1631703679058},{"_id":"source/img/bg/zoo.jpeg","hash":"3b1b416383a1b3ddc040cabbac8dcc2793f4dacd","modified":1631703679060},{"_id":"source/img/bg/zhimingyuchunjiao.jpeg","hash":"03f9c96b520c0976c03c5bc45901b0c0e64b1c4d","modified":1631703679058},{"_id":"source/img/20210911/pic2.jpeg","hash":"e66ac1c464555050a5e57d610d41df3ea2300772","modified":1631703679028},{"_id":"source/img/20210911/图片.jpeg","hash":"ce86726a54981795d8a5f6cc166af0b2ed050afb","modified":1631703679030},{"_id":"source/img/user/bilibili.jpeg","hash":"2a1493d349d20f5b682a43639104ceeda3734ba1","modified":1631012709659},{"_id":"source/img/bg/tianruoyouqing.jpeg","hash":"c03c2d638c9858b48791019759e06f54c57f3730","modified":1631703679057},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"dac9d10d95b9e179e8cd7c439300b450db51f0c2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"523b9db3801ca892124502c17d72864457cc4b21","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"76c2cf56f16dccb2fc057977f9dd7b39800a5cb4","modified":1630999001319},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"6cbd88a2ef9dd2198d72ccc1899c4966ac5f49f9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"a154785aef120988d29409847977f24069d3a3d5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"9d6ff8772bf54d7458ae4e846e5a2d1f2921b8a7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"19c6db0ccebc8f59fa4ef9567a066b33223eccd6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"source/img/bg/zoo2.jpeg","hash":"554f430900e9fedc1cf0f94b4e3613a711ea127c","modified":1631703679061},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/lint.yaml","hash":"64d521c9c5b61d3a4852c74894fb574082dc7009","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"8723aa57f61134a2c1dc84cc7ea88ea366f4fda3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"6ec30a9dd56341590af07f4227324f619025c109","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"cdcb607f1104543a42beda647f3c9cf0f3d11623","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"39e63b3e1502803c9e8ea0c44ea662a7bbe15744","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"9328ebe2abbe00f82cd6f701230e80e04618ade0","modified":1631093425550},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"245f49aad0e4124b52aa82d981281ad9c871f1f8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"3e0fa1731b6e54dbcf52ccf8e200e83dc4549bfa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"b3d93135d9ae74f006da31ec54343308bbd77cb5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"606131cb807846bf43776a9073fcc1473d359ec9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/gulpfile.js","hash":"a7c87a83becf7080bddd14e81a6f09ce8c3df109","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"cc712fc71bf33d561e1ba74fe1d52d2353092171","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"bf00f5786bb8de7241f635455b67243d26656222","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"342b1fbc30d1465687ce389a4e07f967266d5d86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"9d492fab9c26311ad0ab553c890e09b9575a76f2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"725a1fe23c672fca87edc57739b748c3adf705da","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"fb4502fc9204284f8b4e8dabde8477d478e826e5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"ffe08e76c9ebd4fc27715b8a60f385b3f10d0348","modified":1631097677877},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"9238063c5e2928bb6fce2b99cd25ad85e78c4d1c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"5b61661fbc65752f54f99402077dbb03044149a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"ab71df2e56b60e8e193ff827e81704e5b358a977","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"a2d08e3b9f98b6371b2e64d664f079c99571494b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"deed966f38cf0c8dee3f72e5b1f2e878510db0e1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"26d29403d8ecb0b533e63bde3ca73b2c91f171ff","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"dabd87267d60240c0daea0f35a46f30ee1b2337a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"32fb938d72b2d86159cb315a98b086bd17fa4415","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"4c6fffc6d4a3b8830931800ee7da99dccf1be36e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"ad7dcc8a060d94d3c44ca5e0788a24ca38be0f79","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"3a6b4f8a29648d9d2c1e99b52a7b42df3f15cf62","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"766fcf017deb4c8b0c260ac4c8d2e3489407ad89","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"35539a1ce8476e75515015a06d01ec66e4af6834","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"461d609a802a4f9aa9f492411ed8074813a956b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"b7985ac3cff9ee2722db43ee6b32b5484c43f5f2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"source/img/20210913/renshengdezhihui.png","hash":"7981415b28a16c4ac3fc282c53b488c779a7eacc","modified":1631703679039},{"_id":"source/img/20210913/renshengdezhihui2.png","hash":"b217a9b7523a7300876a97bf32959f678794ed38","modified":1631703679053},{"_id":"source/img/user/webo.jpg","hash":"e13a0af612e0944a2014104058242b4fbebe8e56","modified":1631012709670},{"_id":"public/baidu_verify_code-TmkkRxX4ps.html","hash":"e38c85c4546a055dfa8e38926f8b25a657ab1c3d","modified":1631787973749},{"_id":"public/baidu_urls.txt","hash":"e0de44c843f4a8a8f7b48c3989bc93981aa1c047","modified":1631787973749},{"_id":"public/baidusitemap.xml","hash":"ec1a973fb455087b7683ff560468d28ba01dab6a","modified":1631875335418},{"_id":"public/content.json","hash":"23cb06ff527e1525e814c946a3d0ed05e0aad75b","modified":1631875335418},{"_id":"public/sitemap.xml","hash":"2cce30989053b865cb2b2d30c11e5731ee0e9fb3","modified":1631875335418},{"_id":"public/local-search.xml","hash":"079348abdc56f0faa2aa9604707c44a1803ce298","modified":1631875335418},{"_id":"public/about/index.html","hash":"7e0026693399af841884dd3ced9c1313d35a5acc","modified":1631787973749},{"_id":"public/20210912/web设计模式解析与实战/index.html","hash":"5a2ef9f6475c8880d05a5a11dc9d0e0b69bff054","modified":1631787973749},{"_id":"public/20210911/浮生一日/index.html","hash":"b85ad30c820217b8eb2427365beaca26ae0f644e","modified":1631787973749},{"_id":"public/20210907/about-me/index.html","hash":"54b532abf6eeb1bb80f57c83d2d26c1d62440f81","modified":1631787973749},{"_id":"public/archives/index.html","hash":"a2d21188fc28c04b2b9edb807985fefa46ce5a08","modified":1631787973749},{"_id":"public/archives/2021/index.html","hash":"a2d21188fc28c04b2b9edb807985fefa46ce5a08","modified":1631787973749},{"_id":"public/archives/2021/09/index.html","hash":"a2d21188fc28c04b2b9edb807985fefa46ce5a08","modified":1631787973749},{"_id":"public/categories/技术类-TypeScript/index.html","hash":"ae4093eb2cf75e6c05e983e7526c70f37ce96969","modified":1631787973749},{"_id":"public/categories/浮生一日/index.html","hash":"0963ce3684402ecb120a6bdadb702146992b71bd","modified":1631787973749},{"_id":"public/categories/技术类/index.html","hash":"deac9619203f95817dae408eafce92f574dfb2ed","modified":1631787973749},{"_id":"public/categories/阅读/index.html","hash":"b28069709930f7cceca7aafd54edca8815cb09b9","modified":1631787973749},{"_id":"public/categories/技术类-Vue/index.html","hash":"43c0a69d61eee4175d939c53ee6a767bf2e2dca0","modified":1631787973749},{"_id":"public/categories/博客说明/index.html","hash":"da9a4a86274588d803ed416ec9a1402dd39ff311","modified":1631787973749},{"_id":"public/tags/TypeScript/index.html","hash":"f6b82d2cc74c13c0adbfd94fa5220eec8e2a6fc4","modified":1631787973749},{"_id":"public/tags/浮生一日/index.html","hash":"fa7fc7419c864660669ca3524500a5cc4d2c2550","modified":1631787973749},{"_id":"public/tags/日常/index.html","hash":"5bb23bde87bc7a9353b8c339ff13f186ef497f5b","modified":1631787973749},{"_id":"public/tags/课程/index.html","hash":"099090bd3bbf573235a94a384d5e91186933b25a","modified":1631787973749},{"_id":"public/tags/人生的智慧/index.html","hash":"97d3be07ab79c79ad03636a8338bc83e8091912c","modified":1631787973749},{"_id":"public/tags/叔本华/index.html","hash":"0ca0c2fd7ed7f0254f763c0b808df12ce5556304","modified":1631787973749},{"_id":"public/tags/哲学/index.html","hash":"398ba0e5a8e9dd85570b492771b86b51b2a5dab9","modified":1631787973749},{"_id":"public/tags/Vue3/index.html","hash":"e6d45957e5a2f7de5d0bd5c9e3e6c6175f117993","modified":1631787973749},{"_id":"public/tags/博客说明/index.html","hash":"ee23246c6b59835366201c60b0e1edbc42625aac","modified":1631787973749},{"_id":"public/404.html","hash":"1f43f01371fae19de5ad301480db7f3feec215a6","modified":1631787973749},{"_id":"public/tags/index.html","hash":"9c57d491d9cda332c3ba4957ff5abe1460d0d34a","modified":1631787973749},{"_id":"public/categories/index.html","hash":"3a3780f888292d648ae3d135f1296e7e0f839102","modified":1631787973749},{"_id":"public/links/index.html","hash":"81dfcca636f5da89174aabc649de655b67b73852","modified":1631787973749},{"_id":"public/20210915/vue3文档记录/index.html","hash":"368fdce1f1465a281b4c45f0ca23569b2032aac7","modified":1631875335418},{"_id":"public/20210913/叔本华《人生的智慧》第一章节/index.html","hash":"edd2a1e4675febcef0999b4648e04b91ee53b6a1","modified":1631787973749},{"_id":"public/20210910/TypeScript中函数的理解/index.html","hash":"08ca005ab8310aca421e4771ac0aebf2f042091d","modified":1631787973749},{"_id":"public/20210906/TypeScript中类的理解/index.html","hash":"54243f68495b68879560856b9787f0d84cd7b5dd","modified":1631787973749},{"_id":"public/index.html","hash":"13db6125f3d7eb7abbdc2dc1e6e4f1c72f80c152","modified":1631787973749},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1631787973749},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1631787973749},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1631787973749},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1631787973749},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1631787973749},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1631787973749},{"_id":"public/img/user/cjl.jpeg","hash":"8965600c5e613420121715435f69547c80040033","modified":1631787973749},{"_id":"public/img/user/jianshu.jpeg","hash":"e3f77ae1071b74c68f0a7237850a3dc7a41a9936","modified":1631787973749},{"_id":"public/img/bg/zhimingyuchunjiao.jpeg","hash":"03f9c96b520c0976c03c5bc45901b0c0e64b1c4d","modified":1631787973749},{"_id":"public/img/bg/zhimingyuchunjiao2.jpeg","hash":"d69f0fad1d332cbccba580440039e91b8b694062","modified":1631787973749},{"_id":"public/img/bg/zhimingyuchunjiao4.jpeg","hash":"bfd085b6094073740fdf104d9430812949eaf4e4","modified":1631787973749},{"_id":"public/img/bg/zoo2.jpeg","hash":"554f430900e9fedc1cf0f94b4e3613a711ea127c","modified":1631787973749},{"_id":"public/img/20210911/AirPods.jpeg","hash":"8601c573436498d33b4016f948869ad8de42c543","modified":1631787973749},{"_id":"public/img/20210911/pic1.jpeg","hash":"dc36460fc6f228a5f85c9906359a3e777ec4f9ea","modified":1631787973749},{"_id":"public/img/user/user.jpg","hash":"5a1c8f2385741605649bacf36bfe84f3d0b7983a","modified":1631787973749},{"_id":"public/img/user/weChat.jpg","hash":"1c490e9ab2206003f6d84446bf8dc347b2d416ef","modified":1631787973749},{"_id":"public/img/bg/1988.jpeg","hash":"b2e716315092f447a1c56e79d9ebf102d5e19ca7","modified":1631787973749},{"_id":"public/img/bg/benjamin.jpeg","hash":"83c5636568ee5c2fe4602edf4a418414d242d155","modified":1631787973749},{"_id":"public/img/bg/feiwuhuanyouji.jpeg","hash":"05b300041712ab37f2a1f946e29455e9b9dad1ae","modified":1631787973749},{"_id":"public/img/bg/pengranxindong.jpeg","hash":"9855c234288822b61aeece0b17c4f09f3c881b62","modified":1631787973749},{"_id":"public/img/bg/tianruoyouqing.jpeg","hash":"c03c2d638c9858b48791019759e06f54c57f3730","modified":1631787973749},{"_id":"public/img/bg/tianruoyouqing2.jpeg","hash":"620243d332754c7e32e2614862b1d5ed8a7ca78b","modified":1631787973749},{"_id":"public/img/bg/zoo.jpeg","hash":"3b1b416383a1b3ddc040cabbac8dcc2793f4dacd","modified":1631787973749},{"_id":"public/img/20210911/pic2.jpeg","hash":"e66ac1c464555050a5e57d610d41df3ea2300772","modified":1631787973749},{"_id":"public/img/20210911/图片.jpeg","hash":"ce86726a54981795d8a5f6cc166af0b2ed050afb","modified":1631787973749},{"_id":"public/img/user/bilibili.jpeg","hash":"2a1493d349d20f5b682a43639104ceeda3734ba1","modified":1631787973749},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1631787973749},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1631787973749},{"_id":"public/js/color-schema.js","hash":"cc712fc71bf33d561e1ba74fe1d52d2353092171","modified":1631787973749},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1631787973749},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1631787973749},{"_id":"public/js/leancloud.js","hash":"b7985ac3cff9ee2722db43ee6b32b5484c43f5f2","modified":1631787973749},{"_id":"public/js/local-search.js","hash":"bf00f5786bb8de7241f635455b67243d26656222","modified":1631787973749},{"_id":"public/js/plugins.js","hash":"342b1fbc30d1465687ce389a4e07f967266d5d86","modified":1631787973749},{"_id":"public/js/utils.js","hash":"9d492fab9c26311ad0ab553c890e09b9575a76f2","modified":1631787973749},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1631787973749},{"_id":"public/css/main.css","hash":"be9a0652de06d61fa26f4b4128b29bcc5a4a0ad7","modified":1631787973749},{"_id":"public/img/20210913/renshengdezhihui.png","hash":"7981415b28a16c4ac3fc282c53b488c779a7eacc","modified":1631787973749},{"_id":"public/img/20210913/renshengdezhihui2.png","hash":"b217a9b7523a7300876a97bf32959f678794ed38","modified":1631787973749},{"_id":"public/img/user/webo.jpg","hash":"e13a0af612e0944a2014104058242b4fbebe8e56","modified":1631787973749}],"Category":[{"name":"技术类-TypeScript","_id":"cktmsfffp0004fkvqcg6tgo0k"},{"name":"浮生一日","_id":"cktmsfffw000bfkvqf3asbdwm"},{"name":"技术类","_id":"cktmsfffx000gfkvqbc1h6efd"},{"name":"阅读","_id":"cktmsffg1000qfkvq3pl9699s"},{"name":"技术类-Vue","_id":"cktmsffg3000tfkvqebfq0zcu"},{"name":"博客说明","_id":"cktmsffg3000wfkvqhfpadyse"}],"Data":[],"Page":[{"layout":"false","_content":"676194d86471561a70b8026338973ebc","source":"baidu_verify_code-TmkkRxX4ps.html","raw":"---\n\nlayout: false\n\n---\n676194d86471561a70b8026338973ebc","date":"2021-09-09T01:43:34.047Z","updated":"2021-09-09T01:43:34.047Z","path":"baidu_verify_code-TmkkRxX4ps.html","title":"","comments":1,"_id":"cktmsfffg0000fkvqe5ey06f6","content":"676194d86471561a70b8026338973ebc","site":{"data":{}},"excerpt":"","more":"676194d86471561a70b8026338973ebc"},{"title":"about","layout":"about","date":"2021-09-07T07:20:04.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ndate: 2021-09-07 15:20:04\n---\n","updated":"2021-09-09T01:43:34.047Z","path":"about/index.html","comments":1,"_id":"cktmsfffn0002fkvq47qdbqp8","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"tech","title":"TypeScript中类的理解","date":"2021-09-06T06:48:00.000Z","_content":"\n# 一、是什么\n\n类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础\n> ❝类是一种用户定义的引用数据类型，也称类类型❞\n\n传统的面向对象语言基本都是基于类的，`JavaScript` 基于原型的方式让开发者多了很多理解成本\n在 `ES6` 之后，`JavaScript` 拥有了 `class` 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多\n但是`JavaScript` 的`class`依然有一些特性还没有加入，比如修饰符和抽象类\n`TypeScript` 的 `class`  支持面向对象的所有特性，比如 类、接口等\n# 二、使用方式\n定义类的关键字为 `class`，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：\n\n「字段」：字段是类里面声明的变量。字段表示对象的有关数据。\n\n「构造函数」：类实例化时调用，可以为类的对象分配内存。\n\n「方法」：方法为对象要执行的操作\n如下例子：\n```typescript\nclass Car { \n    // 字段 \n    engine:string; \n \n    // 构造函数 \n    constructor(engine:string) { \n        this.engine = engine \n    }  \n \n    // 方法 \n    disp():void { \n        console.log(\"发动机为 :   \"+this.engine) \n    } \n}\n\n```\n\n## 继承\n类的继承使用过`extends`的关键字\n```typescript\nclass Animal {\n    move(distanceInMeters: number = 0) {\n        console.log(`Animal moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Dog extends Animal {\n    bark() {\n        console.log('Woof! Woof!');\n    }\n}\n\nconst dog = new Dog();\ndog.bark();\ndog.move(10);\ndog.bark();\n\n```\n\n`Dog`是一个 派生类，它派生自 `Animal` 基类，派生类通常被称作子类，基类通常被称作 **超类**。\n\n`Dog`类继承了`Animal`类，因此实例`dog`也能够使用`Animal`类`move`方法。\n同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。\n\n通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：\n```typescript\nclass PrinterClass { \n   doPrint():void {\n      console.log(\"父类的 doPrint() 方法。\") \n   } \n} \n \nclass StringPrinter extends PrinterClass { \n   doPrint():void { \n      super.doPrint() // 调用父类的函数\n      console.log(\"子类的 doPrint()方法。\")\n   } \n}\n\n```\n## 修饰符\n可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：\n\n- 公共 public：可以自由的访问类程序里定义的成员\n- 私有 private：只能够在该类的内部进行访问\n- 受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问\n\n### 私有修饰符\n只能够在该类的内部进行访问，实例对象并不能够访问\n```typescript\nclass Father{\n    private name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错，提示 \"属性name为私有属性，只能在Father类中访问\"\n```\n并且继承该类的子类并不能访问，如下图所示：\n```typescript\nclass Father{\n    private name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nclass Son extends Father{\n    say(){\n        console.log(`my name is ${this.name}`)  //会报错，提示 \"属性name为私有属性，只能在Father类中访问\"\n    }\n}\n```\n### 受保护修饰符\n跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：\n```typescript\nclass Father{\n    protected name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错，提示 \"属性name受保护，只能在类Father及其子类中访问\"\n```\n有一点不同的是 `protected` 成员在子类中仍然可以访问\n```typescript\nclass Father{\n    protected name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nclass Son extends Father{\n    say(){\n        console.log(`my name is ${this.name}`)\n    }\n}\n```\n\n### 只读修饰符\n通过`readonly`关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：\n```typescript\nclass Father{\n    readonly name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错,提示\"无法分配到name，因为它是只读属性\"\n```\n\n### 静态属性\n这些属性存在于类本身上面而不是类的实例上，通过`static`进行定义，访问这些属性需要通过 `类型.静态属性` 的这种形式访问，如下所示：\n```typescript\nclass Square {\n    static width = '100px'\n}\n\nconsole.log(Square.width) // 100px\n```\n### 抽象类\n抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节\n`abstract`关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：\n```typescript\nabstract class Animal {\n    abstract makeSound(): void;\n    move(): void {\n        console.log('roaming the earch...');\n    }\n}\n```\n这种类并不能被实例化，通常需要我们创建子类去继承，如下：\n```typescript\nclass Cat extends Animal {\n\n    makeSound() {\n        console.log('miao miao')\n    }\n}\n\nconst cat = new Cat()\n\ncat.makeSound() // miao miao\ncat.move() // roaming the earch...\n```\n# 三、应用场景\n除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在`React` 工程中是很常用的，如下：\n```typescript\nexport default class Carousel extends React.Component<Props, State> {}\n```\n由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。\n\n先声明一个类，这个类包含组件 props 所需的类型和初始值：\n```typescript\n// props的类型\nexport default class Props {\n  public children: Array<React.ReactElement<any>> | React.ReactElement<any> | never[] = []\n  public speed: number = 500\n  public height: number = 160\n  public animation: string = 'easeInOutQuad'\n  public isAuto: boolean = true\n  public autoPlayInterval: number = 4500\n  public afterChange: () => {}\n  public beforeChange: () => {}\n  public selesctedColor: string\n  public showDots: boolean = true\n}\n```\n当我们需要传入 `props` 类型的时候直接将 `Props` 作为接口传入，此时 `Props` 的作用就是接口，而当需要我们设置`defaultProps`初始值的时候，我们只需要:\n```typescript\npublic static defaultProps = new Props()\n```\n`Props` 的实例就是 `defaultProps` 的初始值，这就是 `class`作为接口的实际应用，我们用一个 `class` 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量\n\n# 参考文章\n- https://www.tslang.cn/docs/handbook/classes.html\n- https://www.runoob.com/typescript/ts-class.html","source":"_posts/2021-09-09-TypeScript中类的理解.md","raw":"---\nlayout: tech\ntitle: TypeScript中类的理解\ndate: 2021-09-06 14:48:00\ntags: TypeScript\ncategories: 技术类-TypeScript\n---\n\n# 一、是什么\n\n类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础\n> ❝类是一种用户定义的引用数据类型，也称类类型❞\n\n传统的面向对象语言基本都是基于类的，`JavaScript` 基于原型的方式让开发者多了很多理解成本\n在 `ES6` 之后，`JavaScript` 拥有了 `class` 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多\n但是`JavaScript` 的`class`依然有一些特性还没有加入，比如修饰符和抽象类\n`TypeScript` 的 `class`  支持面向对象的所有特性，比如 类、接口等\n# 二、使用方式\n定义类的关键字为 `class`，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：\n\n「字段」：字段是类里面声明的变量。字段表示对象的有关数据。\n\n「构造函数」：类实例化时调用，可以为类的对象分配内存。\n\n「方法」：方法为对象要执行的操作\n如下例子：\n```typescript\nclass Car { \n    // 字段 \n    engine:string; \n \n    // 构造函数 \n    constructor(engine:string) { \n        this.engine = engine \n    }  \n \n    // 方法 \n    disp():void { \n        console.log(\"发动机为 :   \"+this.engine) \n    } \n}\n\n```\n\n## 继承\n类的继承使用过`extends`的关键字\n```typescript\nclass Animal {\n    move(distanceInMeters: number = 0) {\n        console.log(`Animal moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Dog extends Animal {\n    bark() {\n        console.log('Woof! Woof!');\n    }\n}\n\nconst dog = new Dog();\ndog.bark();\ndog.move(10);\ndog.bark();\n\n```\n\n`Dog`是一个 派生类，它派生自 `Animal` 基类，派生类通常被称作子类，基类通常被称作 **超类**。\n\n`Dog`类继承了`Animal`类，因此实例`dog`也能够使用`Animal`类`move`方法。\n同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。\n\n通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：\n```typescript\nclass PrinterClass { \n   doPrint():void {\n      console.log(\"父类的 doPrint() 方法。\") \n   } \n} \n \nclass StringPrinter extends PrinterClass { \n   doPrint():void { \n      super.doPrint() // 调用父类的函数\n      console.log(\"子类的 doPrint()方法。\")\n   } \n}\n\n```\n## 修饰符\n可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：\n\n- 公共 public：可以自由的访问类程序里定义的成员\n- 私有 private：只能够在该类的内部进行访问\n- 受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问\n\n### 私有修饰符\n只能够在该类的内部进行访问，实例对象并不能够访问\n```typescript\nclass Father{\n    private name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错，提示 \"属性name为私有属性，只能在Father类中访问\"\n```\n并且继承该类的子类并不能访问，如下图所示：\n```typescript\nclass Father{\n    private name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nclass Son extends Father{\n    say(){\n        console.log(`my name is ${this.name}`)  //会报错，提示 \"属性name为私有属性，只能在Father类中访问\"\n    }\n}\n```\n### 受保护修饰符\n跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：\n```typescript\nclass Father{\n    protected name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错，提示 \"属性name受保护，只能在类Father及其子类中访问\"\n```\n有一点不同的是 `protected` 成员在子类中仍然可以访问\n```typescript\nclass Father{\n    protected name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nclass Son extends Father{\n    say(){\n        console.log(`my name is ${this.name}`)\n    }\n}\n```\n\n### 只读修饰符\n通过`readonly`关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：\n```typescript\nclass Father{\n    readonly name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错,提示\"无法分配到name，因为它是只读属性\"\n```\n\n### 静态属性\n这些属性存在于类本身上面而不是类的实例上，通过`static`进行定义，访问这些属性需要通过 `类型.静态属性` 的这种形式访问，如下所示：\n```typescript\nclass Square {\n    static width = '100px'\n}\n\nconsole.log(Square.width) // 100px\n```\n### 抽象类\n抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节\n`abstract`关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：\n```typescript\nabstract class Animal {\n    abstract makeSound(): void;\n    move(): void {\n        console.log('roaming the earch...');\n    }\n}\n```\n这种类并不能被实例化，通常需要我们创建子类去继承，如下：\n```typescript\nclass Cat extends Animal {\n\n    makeSound() {\n        console.log('miao miao')\n    }\n}\n\nconst cat = new Cat()\n\ncat.makeSound() // miao miao\ncat.move() // roaming the earch...\n```\n# 三、应用场景\n除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在`React` 工程中是很常用的，如下：\n```typescript\nexport default class Carousel extends React.Component<Props, State> {}\n```\n由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。\n\n先声明一个类，这个类包含组件 props 所需的类型和初始值：\n```typescript\n// props的类型\nexport default class Props {\n  public children: Array<React.ReactElement<any>> | React.ReactElement<any> | never[] = []\n  public speed: number = 500\n  public height: number = 160\n  public animation: string = 'easeInOutQuad'\n  public isAuto: boolean = true\n  public autoPlayInterval: number = 4500\n  public afterChange: () => {}\n  public beforeChange: () => {}\n  public selesctedColor: string\n  public showDots: boolean = true\n}\n```\n当我们需要传入 `props` 类型的时候直接将 `Props` 作为接口传入，此时 `Props` 的作用就是接口，而当需要我们设置`defaultProps`初始值的时候，我们只需要:\n```typescript\npublic static defaultProps = new Props()\n```\n`Props` 的实例就是 `defaultProps` 的初始值，这就是 `class`作为接口的实际应用，我们用一个 `class` 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量\n\n# 参考文章\n- https://www.tslang.cn/docs/handbook/classes.html\n- https://www.runoob.com/typescript/ts-class.html","slug":"TypeScript中类的理解","published":1,"updated":"2021-09-09T07:35:00.949Z","comments":1,"photos":[],"link":"","_id":"cktmsfffk0001fkvq8vd792a3","content":"<h1 id=\"一、是什么\"><a href=\"#一、是什么\" class=\"headerlink\" title=\"一、是什么\"></a>一、是什么</h1><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p>\n<blockquote>\n<p>❝类是一种用户定义的引用数据类型，也称类类型❞</p>\n</blockquote>\n<p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本<br>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多<br>但是<code>JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类<br><code>TypeScript</code> 的 <code>class</code>  支持面向对象的所有特性，比如 类、接口等</p>\n<h1 id=\"二、使用方式\"><a href=\"#二、使用方式\" class=\"headerlink\" title=\"二、使用方式\"></a>二、使用方式</h1><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：</p>\n<p>「字段」：字段是类里面声明的变量。字段表示对象的有关数据。</p>\n<p>「构造函数」：类实例化时调用，可以为类的对象分配内存。</p>\n<p>「方法」：方法为对象要执行的操作<br>如下例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Car</span> </span>&#123; <br>    <span class=\"hljs-comment\">// 字段 </span><br>    <span class=\"hljs-attr\">engine</span>:<span class=\"hljs-built_in\">string</span>; <br> <br>    <span class=\"hljs-comment\">// 构造函数 </span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">engine:<span class=\"hljs-built_in\">string</span></span>)</span> &#123; <br>        <span class=\"hljs-built_in\">this</span>.engine = engine <br>    &#125;  <br> <br>    <span class=\"hljs-comment\">// 方法 </span><br>    disp():<span class=\"hljs-built_in\">void</span> &#123; <br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;发动机为 :   &quot;</span>+<span class=\"hljs-built_in\">this</span>.engine) <br>    &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>类的继承使用过<code>extends</code>的关键字</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">move</span>(<span class=\"hljs-params\">distanceInMeters: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0</span></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Animal moved <span class=\"hljs-subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">bark</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Woof! Woof!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> Dog();<br>dog.bark();<br>dog.move(<span class=\"hljs-number\">10</span>);<br>dog.bark();<br><br></code></pre></td></tr></table></figure>\n\n<p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 <strong>超类</strong>。</p>\n<p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法。<br>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。</p>\n<p>通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PrinterClass</span> </span>&#123; <br>   doPrint():<span class=\"hljs-built_in\">void</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;父类的 doPrint() 方法。&quot;</span>) <br>   &#125; <br>&#125; <br> <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StringPrinter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PrinterClass</span> </span>&#123; <br>   doPrint():<span class=\"hljs-built_in\">void</span> &#123; <br>      <span class=\"hljs-built_in\">super</span>.doPrint() <span class=\"hljs-comment\">// 调用父类的函数</span><br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;子类的 doPrint()方法。&quot;</span>)<br>   &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><p>可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：</p>\n<ul>\n<li>公共 public：可以自由的访问类程序里定义的成员</li>\n<li>私有 private：只能够在该类的内部进行访问</li>\n<li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li>\n</ul>\n<h3 id=\"私有修饰符\"><a href=\"#私有修饰符\" class=\"headerlink\" title=\"私有修饰符\"></a>私有修饰符</h3><p>只能够在该类的内部进行访问，实例对象并不能够访问</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br></code></pre></td></tr></table></figure>\n<p>并且继承该类的子类并不能访问，如下图所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>`</span>)  <span class=\"hljs-comment\">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"受保护修饰符\"><a href=\"#受保护修饰符\" class=\"headerlink\" title=\"受保护修饰符\"></a>受保护修饰符</h3><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">protected</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错，提示 &quot;属性name受保护，只能在类Father及其子类中访问&quot;</span><br></code></pre></td></tr></table></figure>\n<p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">protected</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>`</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"只读修饰符\"><a href=\"#只读修饰符\" class=\"headerlink\" title=\"只读修饰符\"></a>只读修饰符</h3><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">readonly</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错,提示&quot;无法分配到name，因为它是只读属性&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h3><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 <code>类型.静态属性</code> 的这种形式访问，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Square</span> </span>&#123;<br>    <span class=\"hljs-keyword\">static</span> width = <span class=\"hljs-string\">&#x27;100px&#x27;</span><br>&#125;<br><br><span class=\"hljs-built_in\">console</span>.log(Square.width) <span class=\"hljs-comment\">// 100px</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节<br><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-keyword\">abstract</span> makeSound(): <span class=\"hljs-built_in\">void</span>;<br>    move(): <span class=\"hljs-built_in\">void</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;roaming the earch...&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Cat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">makeSound</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;miao miao&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> cat = <span class=\"hljs-keyword\">new</span> Cat()<br><br>cat.makeSound() <span class=\"hljs-comment\">// miao miao</span><br>cat.move() <span class=\"hljs-comment\">// roaming the earch...</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"三、应用场景\"><a href=\"#三、应用场景\" class=\"headerlink\" title=\"三、应用场景\"></a>三、应用场景</h1><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在<code>React</code> 工程中是很常用的，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Carousel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>, <span class=\"hljs-title\">State</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。</p>\n<p>先声明一个类，这个类包含组件 props 所需的类型和初始值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// props的类型</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Props</span> </span>&#123;<br>  <span class=\"hljs-keyword\">public</span> children: <span class=\"hljs-built_in\">Array</span>&lt;React.ReactElement&lt;<span class=\"hljs-built_in\">any</span>&gt;&gt; | React.ReactElement&lt;<span class=\"hljs-built_in\">any</span>&gt; | <span class=\"hljs-built_in\">never</span>[] = []<br>  <span class=\"hljs-keyword\">public</span> speed: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">500</span><br>  <span class=\"hljs-keyword\">public</span> height: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">160</span><br>  <span class=\"hljs-keyword\">public</span> animation: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&#x27;easeInOutQuad&#x27;</span><br>  <span class=\"hljs-keyword\">public</span> isAuto: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-keyword\">public</span> autoPlayInterval: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">4500</span><br>  <span class=\"hljs-keyword\">public</span> afterChange: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<br>  <span class=\"hljs-keyword\">public</span> beforeChange: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<br>  <span class=\"hljs-keyword\">public</span> selesctedColor: <span class=\"hljs-built_in\">string</span><br>  <span class=\"hljs-keyword\">public</span> showDots: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> defaultProps = <span class=\"hljs-keyword\">new</span> Props()<br></code></pre></td></tr></table></figure>\n<p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class</code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/classes.html\">https://www.tslang.cn/docs/handbook/classes.html</a></li>\n<li><a href=\"https://www.runoob.com/typescript/ts-class.html\">https://www.runoob.com/typescript/ts-class.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、是什么\"><a href=\"#一、是什么\" class=\"headerlink\" title=\"一、是什么\"></a>一、是什么</h1><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p>\n<blockquote>\n<p>❝类是一种用户定义的引用数据类型，也称类类型❞</p>\n</blockquote>\n<p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本<br>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多<br>但是<code>JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类<br><code>TypeScript</code> 的 <code>class</code>  支持面向对象的所有特性，比如 类、接口等</p>\n<h1 id=\"二、使用方式\"><a href=\"#二、使用方式\" class=\"headerlink\" title=\"二、使用方式\"></a>二、使用方式</h1><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：</p>\n<p>「字段」：字段是类里面声明的变量。字段表示对象的有关数据。</p>\n<p>「构造函数」：类实例化时调用，可以为类的对象分配内存。</p>\n<p>「方法」：方法为对象要执行的操作<br>如下例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Car</span> </span>&#123; <br>    <span class=\"hljs-comment\">// 字段 </span><br>    <span class=\"hljs-attr\">engine</span>:<span class=\"hljs-built_in\">string</span>; <br> <br>    <span class=\"hljs-comment\">// 构造函数 </span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">engine:<span class=\"hljs-built_in\">string</span></span>)</span> &#123; <br>        <span class=\"hljs-built_in\">this</span>.engine = engine <br>    &#125;  <br> <br>    <span class=\"hljs-comment\">// 方法 </span><br>    disp():<span class=\"hljs-built_in\">void</span> &#123; <br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;发动机为 :   &quot;</span>+<span class=\"hljs-built_in\">this</span>.engine) <br>    &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>类的继承使用过<code>extends</code>的关键字</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">move</span>(<span class=\"hljs-params\">distanceInMeters: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0</span></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Animal moved <span class=\"hljs-subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">bark</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Woof! Woof!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> Dog();<br>dog.bark();<br>dog.move(<span class=\"hljs-number\">10</span>);<br>dog.bark();<br><br></code></pre></td></tr></table></figure>\n\n<p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 <strong>超类</strong>。</p>\n<p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法。<br>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。</p>\n<p>通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PrinterClass</span> </span>&#123; <br>   doPrint():<span class=\"hljs-built_in\">void</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;父类的 doPrint() 方法。&quot;</span>) <br>   &#125; <br>&#125; <br> <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StringPrinter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PrinterClass</span> </span>&#123; <br>   doPrint():<span class=\"hljs-built_in\">void</span> &#123; <br>      <span class=\"hljs-built_in\">super</span>.doPrint() <span class=\"hljs-comment\">// 调用父类的函数</span><br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;子类的 doPrint()方法。&quot;</span>)<br>   &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><p>可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：</p>\n<ul>\n<li>公共 public：可以自由的访问类程序里定义的成员</li>\n<li>私有 private：只能够在该类的内部进行访问</li>\n<li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li>\n</ul>\n<h3 id=\"私有修饰符\"><a href=\"#私有修饰符\" class=\"headerlink\" title=\"私有修饰符\"></a>私有修饰符</h3><p>只能够在该类的内部进行访问，实例对象并不能够访问</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br></code></pre></td></tr></table></figure>\n<p>并且继承该类的子类并不能访问，如下图所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>`</span>)  <span class=\"hljs-comment\">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"受保护修饰符\"><a href=\"#受保护修饰符\" class=\"headerlink\" title=\"受保护修饰符\"></a>受保护修饰符</h3><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">protected</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错，提示 &quot;属性name受保护，只能在类Father及其子类中访问&quot;</span><br></code></pre></td></tr></table></figure>\n<p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">protected</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>`</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"只读修饰符\"><a href=\"#只读修饰符\" class=\"headerlink\" title=\"只读修饰符\"></a>只读修饰符</h3><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">readonly</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错,提示&quot;无法分配到name，因为它是只读属性&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h3><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 <code>类型.静态属性</code> 的这种形式访问，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Square</span> </span>&#123;<br>    <span class=\"hljs-keyword\">static</span> width = <span class=\"hljs-string\">&#x27;100px&#x27;</span><br>&#125;<br><br><span class=\"hljs-built_in\">console</span>.log(Square.width) <span class=\"hljs-comment\">// 100px</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节<br><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-keyword\">abstract</span> makeSound(): <span class=\"hljs-built_in\">void</span>;<br>    move(): <span class=\"hljs-built_in\">void</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;roaming the earch...&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Cat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">makeSound</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;miao miao&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> cat = <span class=\"hljs-keyword\">new</span> Cat()<br><br>cat.makeSound() <span class=\"hljs-comment\">// miao miao</span><br>cat.move() <span class=\"hljs-comment\">// roaming the earch...</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"三、应用场景\"><a href=\"#三、应用场景\" class=\"headerlink\" title=\"三、应用场景\"></a>三、应用场景</h1><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在<code>React</code> 工程中是很常用的，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Carousel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>, <span class=\"hljs-title\">State</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。</p>\n<p>先声明一个类，这个类包含组件 props 所需的类型和初始值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// props的类型</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Props</span> </span>&#123;<br>  <span class=\"hljs-keyword\">public</span> children: <span class=\"hljs-built_in\">Array</span>&lt;React.ReactElement&lt;<span class=\"hljs-built_in\">any</span>&gt;&gt; | React.ReactElement&lt;<span class=\"hljs-built_in\">any</span>&gt; | <span class=\"hljs-built_in\">never</span>[] = []<br>  <span class=\"hljs-keyword\">public</span> speed: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">500</span><br>  <span class=\"hljs-keyword\">public</span> height: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">160</span><br>  <span class=\"hljs-keyword\">public</span> animation: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&#x27;easeInOutQuad&#x27;</span><br>  <span class=\"hljs-keyword\">public</span> isAuto: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-keyword\">public</span> autoPlayInterval: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">4500</span><br>  <span class=\"hljs-keyword\">public</span> afterChange: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<br>  <span class=\"hljs-keyword\">public</span> beforeChange: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<br>  <span class=\"hljs-keyword\">public</span> selesctedColor: <span class=\"hljs-built_in\">string</span><br>  <span class=\"hljs-keyword\">public</span> showDots: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> defaultProps = <span class=\"hljs-keyword\">new</span> Props()<br></code></pre></td></tr></table></figure>\n<p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class</code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/classes.html\">https://www.tslang.cn/docs/handbook/classes.html</a></li>\n<li><a href=\"https://www.runoob.com/typescript/ts-class.html\">https://www.runoob.com/typescript/ts-class.html</a></li>\n</ul>\n"},{"title":"TypeScript中函数的理解","date":"2021-09-10T08:55:32.000Z","_content":"# 使用方式\n和JavaScript使用方式类似，可以通过`funciton`关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：\n```typescript\nconst add = (a:number,b:number)=> a+b\n```\n上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：\n![TypeScript编译器的提示](https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg)\n当鼠标放置在第三行 `add` 函数名的时候，会出现完整的函数定义类型，通过 `:` 的形式来定义参数类型，通过 `=>` 连接参数和返回值类型\n\n我们也可以显式地写上返回类型，如下：\n```typescript\nconst add = (a:number,b:number):number=> a+b\n```\n\n当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：\n```typescript\n// 方式一\ntype LongHand = {\n  (a: number): number;\n};\n\n// 方式二\ntype ShortHand = (a: number) => number;\n\n```\n当存在函数重载时，只能使用方式一的形式\n\n## 可选参数\n当函数的参数可能是不存在的，只需要在参数后面加上 `?` 代表参数可能不存在，如下：\n```typescript\nconst add = (a: number, b?: number) => a + (b ? b : 0)\n```\n这时候参数`b`可以是`number类型`或者`undefined类型`，即可以传一个`number类型`或者不传都可以\n\n## 剩余类型\n剩余参数与JavaScript的语法类似，需要用 `...` 来表示剩余参数\n\n如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：\n```typescript\nconst add = (a: number, ...rest: number[]) => rest.reduce(((a, b) => a + b), a)\n```\n\n## 函数重载\n允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力\n\n关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 `|操作符`或者`?操作符`，把所有可能的输入类型全部包含进去，用于具体实现\n\n这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并\n\n例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：\n```typescript\n// 上边是声明\nfunction add (arg1: string, arg2: string): string\nfunction add (arg1: number, arg2: number): number\n// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字\n\n// 下边是实现\nfunction add (arg1: string | number, arg2: string | number) {\n  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2\n  if (typeof arg1 === 'string' && typeof arg2 === 'string') {\n    return arg1 + arg2\n  } else if (typeof arg1 === 'number' && typeof arg2 === 'number') {\n    return arg1 + arg2\n  }\n}\n```\n# 区别\n从上面可以看到：\n\n- 从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型\n- typescript 在参数中，添加可选参数供使用者选择\n- typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型\n# 参考文章\n- https://www.tslang.cn/docs/handbook/functions.html\n- https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\n- https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD","source":"_posts/2021-09-10-TypeScript中函数的理解.md","raw":"---\ntitle: TypeScript中函数的理解\ndate: 2021-09-10 16:55:32\ntags: TypeScript\ncategories: 技术类-TypeScript\n---\n# 使用方式\n和JavaScript使用方式类似，可以通过`funciton`关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：\n```typescript\nconst add = (a:number,b:number)=> a+b\n```\n上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：\n![TypeScript编译器的提示](https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg)\n当鼠标放置在第三行 `add` 函数名的时候，会出现完整的函数定义类型，通过 `:` 的形式来定义参数类型，通过 `=>` 连接参数和返回值类型\n\n我们也可以显式地写上返回类型，如下：\n```typescript\nconst add = (a:number,b:number):number=> a+b\n```\n\n当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：\n```typescript\n// 方式一\ntype LongHand = {\n  (a: number): number;\n};\n\n// 方式二\ntype ShortHand = (a: number) => number;\n\n```\n当存在函数重载时，只能使用方式一的形式\n\n## 可选参数\n当函数的参数可能是不存在的，只需要在参数后面加上 `?` 代表参数可能不存在，如下：\n```typescript\nconst add = (a: number, b?: number) => a + (b ? b : 0)\n```\n这时候参数`b`可以是`number类型`或者`undefined类型`，即可以传一个`number类型`或者不传都可以\n\n## 剩余类型\n剩余参数与JavaScript的语法类似，需要用 `...` 来表示剩余参数\n\n如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：\n```typescript\nconst add = (a: number, ...rest: number[]) => rest.reduce(((a, b) => a + b), a)\n```\n\n## 函数重载\n允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力\n\n关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 `|操作符`或者`?操作符`，把所有可能的输入类型全部包含进去，用于具体实现\n\n这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并\n\n例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：\n```typescript\n// 上边是声明\nfunction add (arg1: string, arg2: string): string\nfunction add (arg1: number, arg2: number): number\n// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字\n\n// 下边是实现\nfunction add (arg1: string | number, arg2: string | number) {\n  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2\n  if (typeof arg1 === 'string' && typeof arg2 === 'string') {\n    return arg1 + arg2\n  } else if (typeof arg1 === 'number' && typeof arg2 === 'number') {\n    return arg1 + arg2\n  }\n}\n```\n# 区别\n从上面可以看到：\n\n- 从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型\n- typescript 在参数中，添加可选参数供使用者选择\n- typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型\n# 参考文章\n- https://www.tslang.cn/docs/handbook/functions.html\n- https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\n- https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD","slug":"TypeScript中函数的理解","published":1,"updated":"2021-09-10T09:03:27.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktmsfffn0003fkvq56qw3m2t","content":"<h1 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h1><p>和JavaScript使用方式类似，可以通过<code>funciton</code>关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a:<span class=\"hljs-built_in\">number</span>,b:<span class=\"hljs-built_in\">number</span></span>)=&gt;</span> a+b<br></code></pre></td></tr></table></figure>\n<p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：<br><img src=\"https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg\" alt=\"TypeScript编译器的提示\"><br>当鼠标放置在第三行 <code>add</code> 函数名的时候，会出现完整的函数定义类型，通过 <code>:</code> 的形式来定义参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p>\n<p>我们也可以显式地写上返回类型，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = (a:<span class=\"hljs-built_in\">number</span>,<span class=\"hljs-attr\">b</span>:<span class=\"hljs-built_in\">number</span>):<span class=\"hljs-function\"><span class=\"hljs-params\">number</span>=&gt;</span> a+b<br></code></pre></td></tr></table></figure>\n\n<p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 方式一</span><br><span class=\"hljs-keyword\">type</span> LongHand = &#123;<br>  (a: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;<br>&#125;;<br><br><span class=\"hljs-comment\">// 方式二</span><br><span class=\"hljs-keyword\">type</span> ShortHand = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span>;<br><br></code></pre></td></tr></table></figure>\n<p>当存在函数重载时，只能使用方式一的形式</p>\n<h2 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h2><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b?: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> a + (b ? b : <span class=\"hljs-number\">0</span>)<br></code></pre></td></tr></table></figure>\n<p>这时候参数<code>b</code>可以是<code>number类型</code>或者<code>undefined类型</code>，即可以传一个<code>number类型</code>或者不传都可以</p>\n<h2 id=\"剩余类型\"><a href=\"#剩余类型\" class=\"headerlink\" title=\"剩余类型\"></a>剩余类型</h2><p>剩余参数与JavaScript的语法类似，需要用 <code>...</code> 来表示剩余参数</p>\n<p>如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, ...rest: <span class=\"hljs-built_in\">number</span>[]</span>) =&gt;</span> rest.reduce((<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a + b), a)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p>\n<p>关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|操作符</code>或者<code>?操作符</code>，把所有可能的输入类型全部包含进去，用于具体实现</p>\n<p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并</p>\n<p>例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 上边是声明</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span>, arg2: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">string</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 <span class=\"hljs-title\">declare</span> 关键字</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">// 下边是实现</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>) </span>&#123;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">  <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;string&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;string&#x27;</span></span>) </span>&#123;</span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">return</span> <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span><br><span class=\"hljs-function\">  &#125; <span class=\"hljs-title\">else</span> <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;number&#x27;</span></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> arg1 + arg2<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p>从上面可以看到：</p>\n<ul>\n<li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li>\n<li>typescript 在参数中，添加可选参数供使用者选择</li>\n<li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1></li>\n<li><a href=\"https://www.tslang.cn/docs/handbook/functions.html\">https://www.tslang.cn/docs/handbook/functions.html</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\">https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD</a></li>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD\">https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h1><p>和JavaScript使用方式类似，可以通过<code>funciton</code>关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a:<span class=\"hljs-built_in\">number</span>,b:<span class=\"hljs-built_in\">number</span></span>)=&gt;</span> a+b<br></code></pre></td></tr></table></figure>\n<p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：<br><img src=\"https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg\" alt=\"TypeScript编译器的提示\"><br>当鼠标放置在第三行 <code>add</code> 函数名的时候，会出现完整的函数定义类型，通过 <code>:</code> 的形式来定义参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p>\n<p>我们也可以显式地写上返回类型，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = (a:<span class=\"hljs-built_in\">number</span>,<span class=\"hljs-attr\">b</span>:<span class=\"hljs-built_in\">number</span>):<span class=\"hljs-function\"><span class=\"hljs-params\">number</span>=&gt;</span> a+b<br></code></pre></td></tr></table></figure>\n\n<p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 方式一</span><br><span class=\"hljs-keyword\">type</span> LongHand = &#123;<br>  (a: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;<br>&#125;;<br><br><span class=\"hljs-comment\">// 方式二</span><br><span class=\"hljs-keyword\">type</span> ShortHand = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span>;<br><br></code></pre></td></tr></table></figure>\n<p>当存在函数重载时，只能使用方式一的形式</p>\n<h2 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h2><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b?: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> a + (b ? b : <span class=\"hljs-number\">0</span>)<br></code></pre></td></tr></table></figure>\n<p>这时候参数<code>b</code>可以是<code>number类型</code>或者<code>undefined类型</code>，即可以传一个<code>number类型</code>或者不传都可以</p>\n<h2 id=\"剩余类型\"><a href=\"#剩余类型\" class=\"headerlink\" title=\"剩余类型\"></a>剩余类型</h2><p>剩余参数与JavaScript的语法类似，需要用 <code>...</code> 来表示剩余参数</p>\n<p>如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, ...rest: <span class=\"hljs-built_in\">number</span>[]</span>) =&gt;</span> rest.reduce((<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a + b), a)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p>\n<p>关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|操作符</code>或者<code>?操作符</code>，把所有可能的输入类型全部包含进去，用于具体实现</p>\n<p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并</p>\n<p>例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 上边是声明</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span>, arg2: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">string</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 <span class=\"hljs-title\">declare</span> 关键字</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">// 下边是实现</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>) </span>&#123;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">  <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;string&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;string&#x27;</span></span>) </span>&#123;</span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">return</span> <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span><br><span class=\"hljs-function\">  &#125; <span class=\"hljs-title\">else</span> <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;number&#x27;</span></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> arg1 + arg2<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p>从上面可以看到：</p>\n<ul>\n<li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li>\n<li>typescript 在参数中，添加可选参数供使用者选择</li>\n<li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1></li>\n<li><a href=\"https://www.tslang.cn/docs/handbook/functions.html\">https://www.tslang.cn/docs/handbook/functions.html</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\">https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD</a></li>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD\">https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD</a></li>\n</ul>\n"},{"title":"浮生一日(20210911)","date":"2021-09-11T10:44:58.000Z","_content":"今天老妈的生日🎂\n\n猝不及防的狗粮\n\n![老妈的朋友圈](/img/20210911/pic1.jpeg)\n![老妈的朋友圈](/img/20210911/pic2.jpeg)\n\n---\n\n苹果的售后真的好，耳机检测了一下就说直接换新的\n\n![苹果售后](/img/20210911/AirPods.jpeg)\n","source":"_posts/2021-09-11-浮生一日.md","raw":"---\ntitle: 浮生一日(20210911)\ndate: 2021-09-11 18:44:58\ntags: \n  - [浮生一日]\n  - [日常]\ncategories: \n  - [浮生一日]\n---\n今天老妈的生日🎂\n\n猝不及防的狗粮\n\n![老妈的朋友圈](/img/20210911/pic1.jpeg)\n![老妈的朋友圈](/img/20210911/pic2.jpeg)\n\n---\n\n苹果的售后真的好，耳机检测了一下就说直接换新的\n\n![苹果售后](/img/20210911/AirPods.jpeg)\n","slug":"浮生一日","published":1,"updated":"2021-09-15T11:01:19.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktmsfffr0006fkvqacqsa0w8","content":"<p>今天老妈的生日🎂</p>\n<p>猝不及防的狗粮</p>\n<p><img src=\"/img/20210911/pic1.jpeg\" alt=\"老妈的朋友圈\"><br><img src=\"/img/20210911/pic2.jpeg\" alt=\"老妈的朋友圈\"></p>\n<hr>\n<p>苹果的售后真的好，耳机检测了一下就说直接换新的</p>\n<p><img src=\"/img/20210911/AirPods.jpeg\" alt=\"苹果售后\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天老妈的生日🎂</p>\n<p>猝不及防的狗粮</p>\n<p><img src=\"/img/20210911/pic1.jpeg\" alt=\"老妈的朋友圈\"><br><img src=\"/img/20210911/pic2.jpeg\" alt=\"老妈的朋友圈\"></p>\n<hr>\n<p>苹果的售后真的好，耳机检测了一下就说直接换新的</p>\n<p><img src=\"/img/20210911/AirPods.jpeg\" alt=\"苹果售后\"></p>\n"},{"layout":"zhuawa","title":"web设计模式解析与实战（一）","date":"2021-09-12T05:31:57.000Z","_content":"今天课程主要是讲前端设计模式，早上一节，晚上一节。\n\n---\n\n# 设计模式 \n有利于\n\n1. 组织模块\n\n2. 设计沟通\n\n3. 代码质量\n\n\n\n# 五大设计原则：\n\n1. 开闭原则（OCP：open close principle）\n    - 开-对拓展开放，对修改关闭\n2. 单一职责原则（SRP）\n    - 岗位职责单一，互不重叠\n3. 依赖倒置原则（DIP）\n    - 上层不应该依赖下层实现\n4. 接口隔离原则（ISP）\n    - 多个专业的接口比单个胖借口好用\n5. 里氏替换原则（LSP：the Lxxxx substitution principle）\n    - 子类能够覆盖父类\n    - 父类能够出现的地方子类就能出现\n---\n今天老师给的课后题：\n- 某个**停车场**，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开，\n- 车辆进入前，显示每层的空余车辆数量\n- 车辆进入时，摄像头可识别车牌号和时间\n- 车辆出来时，出口显示器显示车牌号和停车时长\n请设计一套系统。","source":"_posts/2021-09-12-web设计模式解析与实战.md","raw":"---\nlayout: zhuawa\ntitle: web设计模式解析与实战（一）\ndate: 2021-09-12 13:31:57\ntags: 课程\ncategories: 技术类\n---\n今天课程主要是讲前端设计模式，早上一节，晚上一节。\n\n---\n\n# 设计模式 \n有利于\n\n1. 组织模块\n\n2. 设计沟通\n\n3. 代码质量\n\n\n\n# 五大设计原则：\n\n1. 开闭原则（OCP：open close principle）\n    - 开-对拓展开放，对修改关闭\n2. 单一职责原则（SRP）\n    - 岗位职责单一，互不重叠\n3. 依赖倒置原则（DIP）\n    - 上层不应该依赖下层实现\n4. 接口隔离原则（ISP）\n    - 多个专业的接口比单个胖借口好用\n5. 里氏替换原则（LSP：the Lxxxx substitution principle）\n    - 子类能够覆盖父类\n    - 父类能够出现的地方子类就能出现\n---\n今天老师给的课后题：\n- 某个**停车场**，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开，\n- 车辆进入前，显示每层的空余车辆数量\n- 车辆进入时，摄像头可识别车牌号和时间\n- 车辆出来时，出口显示器显示车牌号和停车时长\n请设计一套系统。","slug":"web设计模式解析与实战","published":1,"updated":"2021-09-15T11:01:19.021Z","comments":1,"photos":[],"link":"","_id":"cktmsfffs0007fkvq01nxdc7i","content":"<p>今天课程主要是讲前端设计模式，早上一节，晚上一节。</p>\n<hr>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><p>有利于</p>\n<ol>\n<li><p>组织模块</p>\n</li>\n<li><p>设计沟通</p>\n</li>\n<li><p>代码质量</p>\n</li>\n</ol>\n<h1 id=\"五大设计原则：\"><a href=\"#五大设计原则：\" class=\"headerlink\" title=\"五大设计原则：\"></a>五大设计原则：</h1><ol>\n<li>开闭原则（OCP：open close principle）<ul>\n<li>开-对拓展开放，对修改关闭</li>\n</ul>\n</li>\n<li>单一职责原则（SRP）<ul>\n<li>岗位职责单一，互不重叠</li>\n</ul>\n</li>\n<li>依赖倒置原则（DIP）<ul>\n<li>上层不应该依赖下层实现</li>\n</ul>\n</li>\n<li>接口隔离原则（ISP）<ul>\n<li>多个专业的接口比单个胖借口好用</li>\n</ul>\n</li>\n<li>里氏替换原则（LSP：the Lxxxx substitution principle）<ul>\n<li>子类能够覆盖父类</li>\n<li>父类能够出现的地方子类就能出现</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>今天老师给的课后题：</p>\n<ul>\n<li>某个<strong>停车场</strong>，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开，</li>\n<li>车辆进入前，显示每层的空余车辆数量</li>\n<li>车辆进入时，摄像头可识别车牌号和时间</li>\n<li>车辆出来时，出口显示器显示车牌号和停车时长<br>请设计一套系统。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>今天课程主要是讲前端设计模式，早上一节，晚上一节。</p>\n<hr>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><p>有利于</p>\n<ol>\n<li><p>组织模块</p>\n</li>\n<li><p>设计沟通</p>\n</li>\n<li><p>代码质量</p>\n</li>\n</ol>\n<h1 id=\"五大设计原则：\"><a href=\"#五大设计原则：\" class=\"headerlink\" title=\"五大设计原则：\"></a>五大设计原则：</h1><ol>\n<li>开闭原则（OCP：open close principle）<ul>\n<li>开-对拓展开放，对修改关闭</li>\n</ul>\n</li>\n<li>单一职责原则（SRP）<ul>\n<li>岗位职责单一，互不重叠</li>\n</ul>\n</li>\n<li>依赖倒置原则（DIP）<ul>\n<li>上层不应该依赖下层实现</li>\n</ul>\n</li>\n<li>接口隔离原则（ISP）<ul>\n<li>多个专业的接口比单个胖借口好用</li>\n</ul>\n</li>\n<li>里氏替换原则（LSP：the Lxxxx substitution principle）<ul>\n<li>子类能够覆盖父类</li>\n<li>父类能够出现的地方子类就能出现</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>今天老师给的课后题：</p>\n<ul>\n<li>某个<strong>停车场</strong>，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开，</li>\n<li>车辆进入前，显示每层的空余车辆数量</li>\n<li>车辆进入时，摄像头可识别车牌号和时间</li>\n<li>车辆出来时，出口显示器显示车牌号和停车时长<br>请设计一套系统。</li>\n</ul>\n"},{"title":"叔本华《人生的智慧》第一章节","date":"2021-09-13T14:13:47.000Z","_content":"对于阅读人生哲理这一类的书，我一直坚信“尽信书则不如无书”。\n书名叫做《人生的智慧》，第一眼见到就觉得命题有点过于庞大而且作者有些自大。倘若人生的智慧真能总结在一本书中，那我想我们真的应该每个人都手捧一本，而不是什么《红宝书/圣经》。\n但是又不是每个人都爱去阅读，阅读从来都是用来克制自己的而不是去监管别人的。\n许多人把叔本华哲学归为悲观主义，但读完第一章节，他一直在指引我们如何去追求人生的乐趣。\n文章逻辑性强，有理有据，说服力强，看得出叔本华的哲学深度以及译者的功力。\n至少第一章我读下来，确实有不少启发。\n以下是部分抄录\n---\n![叔本华人生的智慧](/img/20210913/renshengdezhihui.png)\n\n---\n # 第一章 基本的划分\n\n决定凡人命运的根本差别在于三项内容：\n- 人的自身，即在最广泛意义上属于人的个性的东西。因此，它包括人的健康、力量、外貌、气质、道德品格、精神智力及其潜在发展。\n- 人所拥有的身外之物，亦即财产和其他占有物。\n- 人向其他人所显示的样子，人在其他人眼中所呈现的样子，亦即人们对他的看法。他人的看法又可分为名誉、地位和名声。\n\n---\n对于一个人的幸福，甚至对于他的整个生存的方式，最主要的明显就是这个人自身的内在素质，它直接决定了这个人是否能够得到内心的幸福，因为人的内心快乐抑或内心痛苦首先就是人的感情、意欲和思想的产物。而人自身之外的所有事物，对于人的幸福都只是间接地发挥影响。因此，同一样外在的事物和同一样的境遇，对于我们每一个人的影响都不尽相同；处在同一样的环境每一个人，都生活在不同的世界中。因为与一个人直接相关的是这一个人对事物的看法、他的感情以及他的意欲活动。外在事物只有在刺激起他的上述东西时才能发挥作用\n\n---\n> “对完全一样的客体时，不同的主体就意味着所构成的现实完全不同，反之亦然”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n注：不同的人对发生的同一件事会有不同的态度和想法\n\n---\n一个人只能直接活在自己的意识之中。因此，外在世界对他帮助不大\n\n---\n   > “对于人来说，存在和发生的一切事情总是直接存在和发生在他的意识里面，所以，很明显，人的意识的构成是首要关键”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books.\n \n注：你的下意识会对发生的事情产生看法。\n\n---\n> “尽管在人的一生中，外在变化不断发生，但人的性格却始终如一，这好比虽然有一连串的变奏，但主旋律却维持不变。无人能够脱离自身个性 ”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n---\n> “对我们的生活幸福而言，我们的自身个性才是最重要和最关键的，因为我们的个性持久不变，它在任何情况下都在发挥着作用”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n---\n>“我们唯一能够做到的就是尽可能充分地利用我们既定的个性。因此，我们应该循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。所以，我们必须选择与我们个性相配的地位、职业和生活方式。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n---\n>“人的自身比起财产和他人对自己的看法具有压倒性的优势；由此可知，注重保持身体健康和发挥个人自身才能比全力投入获得财富更为明智”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“人生最高的乐趣——精神方面的乐趣——对他们来说，是遥不可及的事情。既然如此，他们就只能忙里偷闲地寻求那些短暂的、感官的乐趣——它们费时很少，却耗钱很多。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“人的内在拥有对于人的幸福才是最关键的”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“无聊——它源自上述的精神贫乏和空虚”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“人自身内在的贫乏由此导致了外在财富的贫乏。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“彼德尼斯【3】说过：“一个人所拥有的财产决定了这个人在他人眼中的价值。”如果这句话是正确的话，那么，反过来，他人对自己的良好评价，能以各种形式帮助自己获取财产。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n![今日阅读](/img/20210913/renshengdezhihui2.png)\n","source":"_posts/2021-09-13-叔本华《人生的智慧》第一章节.md","raw":"---\ntitle: 叔本华《人生的智慧》第一章节\ndate: 2021-09-13 22:13:47\ntags: \n  - [人生的智慧]\n  - [叔本华]\n  - [哲学]\ncategories: 阅读\n---\n对于阅读人生哲理这一类的书，我一直坚信“尽信书则不如无书”。\n书名叫做《人生的智慧》，第一眼见到就觉得命题有点过于庞大而且作者有些自大。倘若人生的智慧真能总结在一本书中，那我想我们真的应该每个人都手捧一本，而不是什么《红宝书/圣经》。\n但是又不是每个人都爱去阅读，阅读从来都是用来克制自己的而不是去监管别人的。\n许多人把叔本华哲学归为悲观主义，但读完第一章节，他一直在指引我们如何去追求人生的乐趣。\n文章逻辑性强，有理有据，说服力强，看得出叔本华的哲学深度以及译者的功力。\n至少第一章我读下来，确实有不少启发。\n以下是部分抄录\n---\n![叔本华人生的智慧](/img/20210913/renshengdezhihui.png)\n\n---\n # 第一章 基本的划分\n\n决定凡人命运的根本差别在于三项内容：\n- 人的自身，即在最广泛意义上属于人的个性的东西。因此，它包括人的健康、力量、外貌、气质、道德品格、精神智力及其潜在发展。\n- 人所拥有的身外之物，亦即财产和其他占有物。\n- 人向其他人所显示的样子，人在其他人眼中所呈现的样子，亦即人们对他的看法。他人的看法又可分为名誉、地位和名声。\n\n---\n对于一个人的幸福，甚至对于他的整个生存的方式，最主要的明显就是这个人自身的内在素质，它直接决定了这个人是否能够得到内心的幸福，因为人的内心快乐抑或内心痛苦首先就是人的感情、意欲和思想的产物。而人自身之外的所有事物，对于人的幸福都只是间接地发挥影响。因此，同一样外在的事物和同一样的境遇，对于我们每一个人的影响都不尽相同；处在同一样的环境每一个人，都生活在不同的世界中。因为与一个人直接相关的是这一个人对事物的看法、他的感情以及他的意欲活动。外在事物只有在刺激起他的上述东西时才能发挥作用\n\n---\n> “对完全一样的客体时，不同的主体就意味着所构成的现实完全不同，反之亦然”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n注：不同的人对发生的同一件事会有不同的态度和想法\n\n---\n一个人只能直接活在自己的意识之中。因此，外在世界对他帮助不大\n\n---\n   > “对于人来说，存在和发生的一切事情总是直接存在和发生在他的意识里面，所以，很明显，人的意识的构成是首要关键”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books.\n \n注：你的下意识会对发生的事情产生看法。\n\n---\n> “尽管在人的一生中，外在变化不断发生，但人的性格却始终如一，这好比虽然有一连串的变奏，但主旋律却维持不变。无人能够脱离自身个性 ”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n---\n> “对我们的生活幸福而言，我们的自身个性才是最重要和最关键的，因为我们的个性持久不变，它在任何情况下都在发挥着作用”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n---\n>“我们唯一能够做到的就是尽可能充分地利用我们既定的个性。因此，我们应该循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。所以，我们必须选择与我们个性相配的地位、职业和生活方式。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n---\n>“人的自身比起财产和他人对自己的看法具有压倒性的优势；由此可知，注重保持身体健康和发挥个人自身才能比全力投入获得财富更为明智”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“人生最高的乐趣——精神方面的乐趣——对他们来说，是遥不可及的事情。既然如此，他们就只能忙里偷闲地寻求那些短暂的、感官的乐趣——它们费时很少，却耗钱很多。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“人的内在拥有对于人的幸福才是最关键的”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“无聊——它源自上述的精神贫乏和空虚”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“人自身内在的贫乏由此导致了外在财富的贫乏。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“彼德尼斯【3】说过：“一个人所拥有的财产决定了这个人在他人眼中的价值。”如果这句话是正确的话，那么，反过来，他人对自己的良好评价，能以各种形式帮助自己获取财产。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n![今日阅读](/img/20210913/renshengdezhihui2.png)\n","slug":"叔本华《人生的智慧》第一章节","published":1,"updated":"2021-09-15T11:01:19.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktmsffg0000ofkvq77idgpkm","content":"<p>对于阅读人生哲理这一类的书，我一直坚信“尽信书则不如无书”。<br>书名叫做《人生的智慧》，第一眼见到就觉得命题有点过于庞大而且作者有些自大。倘若人生的智慧真能总结在一本书中，那我想我们真的应该每个人都手捧一本，而不是什么《红宝书/圣经》。<br>但是又不是每个人都爱去阅读，阅读从来都是用来克制自己的而不是去监管别人的。<br>许多人把叔本华哲学归为悲观主义，但读完第一章节，他一直在指引我们如何去追求人生的乐趣。<br>文章逻辑性强，有理有据，说服力强，看得出叔本华的哲学深度以及译者的功力。<br>至少第一章我读下来，确实有不少启发。<br>以下是部分抄录</p>\n<hr>\n<p><img src=\"/img/20210913/renshengdezhihui.png\" alt=\"叔本华人生的智慧\"></p>\n<hr>\n<h1 id=\"第一章-基本的划分\"><a href=\"#第一章-基本的划分\" class=\"headerlink\" title=\"第一章 基本的划分\"></a>第一章 基本的划分</h1><p>决定凡人命运的根本差别在于三项内容：</p>\n<ul>\n<li>人的自身，即在最广泛意义上属于人的个性的东西。因此，它包括人的健康、力量、外貌、气质、道德品格、精神智力及其潜在发展。</li>\n<li>人所拥有的身外之物，亦即财产和其他占有物。</li>\n<li>人向其他人所显示的样子，人在其他人眼中所呈现的样子，亦即人们对他的看法。他人的看法又可分为名誉、地位和名声。</li>\n</ul>\n<hr>\n<p>对于一个人的幸福，甚至对于他的整个生存的方式，最主要的明显就是这个人自身的内在素质，它直接决定了这个人是否能够得到内心的幸福，因为人的内心快乐抑或内心痛苦首先就是人的感情、意欲和思想的产物。而人自身之外的所有事物，对于人的幸福都只是间接地发挥影响。因此，同一样外在的事物和同一样的境遇，对于我们每一个人的影响都不尽相同；处在同一样的环境每一个人，都生活在不同的世界中。因为与一个人直接相关的是这一个人对事物的看法、他的感情以及他的意欲活动。外在事物只有在刺激起他的上述东西时才能发挥作用</p>\n<hr>\n<blockquote>\n<p>“对完全一样的客体时，不同的主体就意味着所构成的现实完全不同，反之亦然”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<p>注：不同的人对发生的同一件事会有不同的态度和想法</p>\n<hr>\n<p>一个人只能直接活在自己的意识之中。因此，外在世界对他帮助不大</p>\n<hr>\n<blockquote>\n<p>“对于人来说，存在和发生的一切事情总是直接存在和发生在他的意识里面，所以，很明显，人的意识的构成是首要关键”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books.</p>\n</blockquote>\n<p>注：你的下意识会对发生的事情产生看法。</p>\n<hr>\n<blockquote>\n<p>“尽管在人的一生中，外在变化不断发生，但人的性格却始终如一，这好比虽然有一连串的变奏，但主旋律却维持不变。无人能够脱离自身个性 ”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“对我们的生活幸福而言，我们的自身个性才是最重要和最关键的，因为我们的个性持久不变，它在任何情况下都在发挥着作用”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“我们唯一能够做到的就是尽可能充分地利用我们既定的个性。因此，我们应该循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。所以，我们必须选择与我们个性相配的地位、职业和生活方式。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人的自身比起财产和他人对自己的看法具有压倒性的优势；由此可知，注重保持身体健康和发挥个人自身才能比全力投入获得财富更为明智”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人生最高的乐趣——精神方面的乐趣——对他们来说，是遥不可及的事情。既然如此，他们就只能忙里偷闲地寻求那些短暂的、感官的乐趣——它们费时很少，却耗钱很多。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人的内在拥有对于人的幸福才是最关键的”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“无聊——它源自上述的精神贫乏和空虚”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人自身内在的贫乏由此导致了外在财富的贫乏。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“彼德尼斯【3】说过：“一个人所拥有的财产决定了这个人在他人眼中的价值。”如果这句话是正确的话，那么，反过来，他人对自己的良好评价，能以各种形式帮助自己获取财产。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<p><img src=\"/img/20210913/renshengdezhihui2.png\" alt=\"今日阅读\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>对于阅读人生哲理这一类的书，我一直坚信“尽信书则不如无书”。<br>书名叫做《人生的智慧》，第一眼见到就觉得命题有点过于庞大而且作者有些自大。倘若人生的智慧真能总结在一本书中，那我想我们真的应该每个人都手捧一本，而不是什么《红宝书/圣经》。<br>但是又不是每个人都爱去阅读，阅读从来都是用来克制自己的而不是去监管别人的。<br>许多人把叔本华哲学归为悲观主义，但读完第一章节，他一直在指引我们如何去追求人生的乐趣。<br>文章逻辑性强，有理有据，说服力强，看得出叔本华的哲学深度以及译者的功力。<br>至少第一章我读下来，确实有不少启发。<br>以下是部分抄录</p>\n<hr>\n<p><img src=\"/img/20210913/renshengdezhihui.png\" alt=\"叔本华人生的智慧\"></p>\n<hr>\n<h1 id=\"第一章-基本的划分\"><a href=\"#第一章-基本的划分\" class=\"headerlink\" title=\"第一章 基本的划分\"></a>第一章 基本的划分</h1><p>决定凡人命运的根本差别在于三项内容：</p>\n<ul>\n<li>人的自身，即在最广泛意义上属于人的个性的东西。因此，它包括人的健康、力量、外貌、气质、道德品格、精神智力及其潜在发展。</li>\n<li>人所拥有的身外之物，亦即财产和其他占有物。</li>\n<li>人向其他人所显示的样子，人在其他人眼中所呈现的样子，亦即人们对他的看法。他人的看法又可分为名誉、地位和名声。</li>\n</ul>\n<hr>\n<p>对于一个人的幸福，甚至对于他的整个生存的方式，最主要的明显就是这个人自身的内在素质，它直接决定了这个人是否能够得到内心的幸福，因为人的内心快乐抑或内心痛苦首先就是人的感情、意欲和思想的产物。而人自身之外的所有事物，对于人的幸福都只是间接地发挥影响。因此，同一样外在的事物和同一样的境遇，对于我们每一个人的影响都不尽相同；处在同一样的环境每一个人，都生活在不同的世界中。因为与一个人直接相关的是这一个人对事物的看法、他的感情以及他的意欲活动。外在事物只有在刺激起他的上述东西时才能发挥作用</p>\n<hr>\n<blockquote>\n<p>“对完全一样的客体时，不同的主体就意味着所构成的现实完全不同，反之亦然”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<p>注：不同的人对发生的同一件事会有不同的态度和想法</p>\n<hr>\n<p>一个人只能直接活在自己的意识之中。因此，外在世界对他帮助不大</p>\n<hr>\n<blockquote>\n<p>“对于人来说，存在和发生的一切事情总是直接存在和发生在他的意识里面，所以，很明显，人的意识的构成是首要关键”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books.</p>\n</blockquote>\n<p>注：你的下意识会对发生的事情产生看法。</p>\n<hr>\n<blockquote>\n<p>“尽管在人的一生中，外在变化不断发生，但人的性格却始终如一，这好比虽然有一连串的变奏，但主旋律却维持不变。无人能够脱离自身个性 ”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“对我们的生活幸福而言，我们的自身个性才是最重要和最关键的，因为我们的个性持久不变，它在任何情况下都在发挥着作用”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“我们唯一能够做到的就是尽可能充分地利用我们既定的个性。因此，我们应该循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。所以，我们必须选择与我们个性相配的地位、职业和生活方式。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人的自身比起财产和他人对自己的看法具有压倒性的优势；由此可知，注重保持身体健康和发挥个人自身才能比全力投入获得财富更为明智”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人生最高的乐趣——精神方面的乐趣——对他们来说，是遥不可及的事情。既然如此，他们就只能忙里偷闲地寻求那些短暂的、感官的乐趣——它们费时很少，却耗钱很多。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人的内在拥有对于人的幸福才是最关键的”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“无聊——它源自上述的精神贫乏和空虚”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人自身内在的贫乏由此导致了外在财富的贫乏。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“彼德尼斯【3】说过：“一个人所拥有的财产决定了这个人在他人眼中的价值。”如果这句话是正确的话，那么，反过来，他人对自己的良好评价，能以各种形式帮助自己获取财产。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<p><img src=\"/img/20210913/renshengdezhihui2.png\" alt=\"今日阅读\"></p>\n"},{"title":"通读vue3文档记录","date":"2021-09-15T11:03:11.000Z","_content":"之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是`Object.defineProperty()`，vue3用的是`Proxy`。vue3还新增了`组合式API`等等。\n\n这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。\n\n持续更新ing\n\n# 应用&组件实例\n## 应用实例\n每个 Vue 应用都是通过用 createApp 函数创建一个新的**应用实例**开始的：\n\n```js\nconst app = Vue.createApp({ /* 选项 */ })\n```\n\n该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：\n```js\nconst app = Vue.createApp({})\napp.component('SearchInput', SearchInputComponent)\napp.directive('focus', FocusDirective)\napp.use(LocalePlugin)\n```\n应用实例暴露的大多数方法都会返回该同一实例，允许链式：\n```js\nVue.createApp({})\n  .component('SearchInput', SearchInputComponent)\n  .directive('focus', FocusDirective)\n  .use(LocalePlugin)\n```\n\n## 根组件实例\n传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。\n\n一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 `<div id=\"app\"></div>`，我们应该传递 `#app`：\n```js\nconst RootComponent = { /* 选项 */ }\nconst app = Vue.createApp(RootComponent)\nconst vm = app.mount('#app')\n```\n与大多数应用方法不同的是，`mount` 不返回应用本身。相反，它返回的是**根组件实例**。\n\n虽然没有完全遵循 `MVVM` 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。\n\n# 计算属性&侦听器\n## 计算属性缓存 vs 方法\n    \n你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：\n```html\n<p>{{ calculateBooksMessage() }}</p>\n```\n```js\n// 在组件中\nmethods: {\n  calculateBooksMessage() {\n    return this.author.books.length > 0 ? 'Yes' : 'No'\n  }\n}\n```\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要`author.books` 还没有发生改变，多次访问 `publishedBookMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。 \n\n这也同样意味着下面的计算属性将不再更新，因为 **Date.now () 不是响应式依赖**：\n```js\ncomputed: {\n  now() {\n    return Date.now()\n  }\n}\n```\n相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。\n\n我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 `list`，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 `list`。如果没有缓存，我们将不可避免的多次执行 `list` 的 getter！如果你不希望有缓存，请用 method 来替代\n\n---\n以下为2021.09.16更新\n---\n## 计算属性的 Setter\n计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：\n```js\n// ...\ncomputed: {\n  fullName: {\n    // getter\n    get() {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set(newValue) {\n      const names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n// ...\n```\n现在再运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应地被更新。\n\n# Class与Style绑定\n如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作：\n```js\n<div id=\"app\">\n  <my-component class=\"baz\"></my-component>\n</div>\nconst app = Vue.createApp({})\n\napp.component('my-component', {\n  template: `\n    <p :class=\"$attrs.class\">Hi!</p>\n    <span>This is a child component</span>\n  `\n})\n```\n\n# 条件渲染\n\n## `v-if` vs `v-show`\n`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n`v-if` 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好\n\n## v-if 与 v-for 一起使用\n> 提示 不推荐同时使用 v-if 和 v-for\n\n当 `v-if` 与 `v-for` 一起使用时，`v-if` 具有比 `v-for` 更高的优先级。请查阅列表渲染指南以获取详细信息。\n\n当它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量：\n```js\n<!-- This will throw an error because property \"todo\" is not defined on instance. -->\n\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n  {{ todo }}\n</li>\n```\n可以把 v-for 移动到`<template>` 标签中来修正：\n```js\n<template v-for=\"todo in todos\">\n  <li v-if=\"!todo.isComplete\">\n    {{ todo }}\n  </li>\n</template>\n```\n# 表单绑定输入\n## 基础用法\n`v-model` 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：\n\n- text 和 textarea 元素使用 value property 和 input 事件；\n- checkbox 和 radio 使用 checked property 和 change 事件；\n- select 字段将 value 作为 prop 并将 change 作为事件。\n\n# 组件基础\n## 基本实例\n这里有一个 Vue 组件的示例：\n```js\n// 创建一个Vue 应用\nconst app = Vue.createApp({})\n\n// 定义一个名为 button-counter 的新全局组件\napp.component('button-counter', {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n})\n```\n## 组件的复用\n你可以将组件进行任意次数的复用\n每个组件都会各自独立维护它的`data`。因为你每用一次组件，就会有一个它的新组件实例被创建\n\n## 在组件上使用 v-model\n自定义事件也可以用于创建支持 `v-model` 的自定义输入组件。记住：\n```js\n<input v-model=\"searchText\" />\n等价于：\n\n<input :value=\"searchText\" @input=\"searchText = $event.target.value\" />\n当用在组件上时，v-model 则会这样：\n\n<custom-input\n  :model-value=\"searchText\"\n  @update:model-value=\"searchText = $event\"\n></custom-input>\n```\n为了让它正常工作，这个组件内的 `<input>` 必须：\n\n将其 `value` attribute 绑定到一个名叫 `modelValue` 的 prop 上\n在其 `input` 事件被触发时，将新的值通过自定义的 `update:modelValue` 事件抛出\n写成代码之后是这样的：\n```js\napp.component('custom-input', {\n  props: ['modelValue'],\n  template: `\n    <input\n      :value=\"modelValue\"\n      @input=\"$emit('update:modelValue', $event.target.value)\"\n    >\n  `\n})\n```\n现在 `v-model` 就应该可以在这个组件上完美地工作起来了：\n```html\n<custom-input v-model=\"searchText\"></custom-input>\n```\n# 深入组件\n## 非 Prop 的 Attribute\n### Attribute 继承\n当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 `<date-picker>` 组件的实例中：\n```js\napp.component('date-picker', {\n  template: `\n    <div class=\"date-picker\">\n      <input type=\"datetime\" />\n    </div>\n  `\n})\n```\n如果我们需要通过 `data status` property 定义 `<date-picker>` 组件的状态，它将应用于根节点 (即 `div.date-picker`)。\n```html\n<!-- 具有非prop attribute的Date-picker组件-->\n<date-picker data-status=\"activated\"></date-picker>\n\n<!-- 渲染 date-picker 组件 -->\n<div class=\"date-picker\" data-status=\"activated\">\n  <input type=\"datetime\" />\n</div>\n```\n\n同样的规则适用于事件监听器：\n```html\n<date-picker @change=\"submitChange\"></date-picker>\n```\n```js\napp.component('date-picker', {\n  created() {\n    console.log(this.$attrs) // { onChange: () => {}  }\n  }\n})\n```\n当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。\n```js\napp.component('date-picker', {\n  template: `\n    <select>\n      <option value=\"1\">Yesterday</option>\n      <option value=\"2\">Today</option>\n      <option value=\"3\">Tomorrow</option>\n    </select>\n  `\n})\n```\n在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件：\n```html\n<div id=\"date-picker\" class=\"demo\">\n  <date-picker @change=\"showChange\"></date-picker>\n</div>\n```\n```js\nconst app = Vue.createApp({\n  methods: {\n    showChange(event) {\n      console.log(event.target.value) // 将记录所选选项的值\n    }\n  }\n})\n```\n\n### 禁用 Attribute 继承\n如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 `inheritAttrs: false`。例如：\n\n禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。\n\n通过将 `inheritAttrs` 选项设置为 `false`，你可以访问组件的 `$attrs` property，该 property 包括组件 `props` 和 `emits` property 中未包含的所有属性 (例如，`class`、`style`、`v-on` 监听器等)。\n```js\napp.component('date-picker', {\n  inheritAttrs: false,\n  template: `\n    <div class=\"date-picker\">\n      <input type=\"datetime\" v-bind=\"$attrs\" />\n    </div>\n  `\n})\n```\n有了这个新配置，`data status` attribute 将应用于 `input` 元素！\n```html\n<!-- Date-picker 组件 使用非 prop attribute -->\n<date-picker data-status=\"activated\"></date-picker>\n\n<!-- 渲染 date-picker 组件 -->\n<div class=\"date-picker\">\n  <input type=\"datetime\" data-status=\"activated\" />\n</div>\n```\n\n### 多个根节点上的 Attribute 继承\n与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。\n```html\n<custom-layout id=\"custom-layout\" @click=\"changeValue\"></custom-layout>\n```\n```js\n// 这将发出警告\napp.component('custom-layout', {\n  template: `\n    <header>...</header>\n    <main>...</main>\n    <footer>...</footer>\n  `\n})\n\n// 没有警告，$attrs被传递到<main>元素\napp.component('custom-layout', {\n  template: `\n    <header>...</header>\n    <main v-bind=\"$attrs\">...</main>\n    <footer>...</footer>\n  `\n})\n```\n## 自定义事件\n### 处理 v-model 修饰符\n在 2.x 中，我们对组件 `v-model` 上的 `.trim` 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 `v-model` 的修饰符将通过 `modelModifiers` prop 提供给组件：\n\n让我们创建一个示例自定义修饰符 `capitalize`，它将 `v-model` 绑定提供的字符串的第一个字母大写。\n\n添加到组件 `v-model` 的修饰符将通过 `modelModifiers` prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 `modelModifiers` prop。\n\n请注意，当组件的 `created` 生命周期钩子触发时，`modelModifiers` prop 包含 `capitalize`，其值为 `true`——因为它被设置在 `v-model` 绑定 `v-model.capitalize=\"bar\"`。\n```html\n<my-component v-model.capitalize=\"bar\"></my-component>\n```\n\n```js\napp.component('my-component', {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  template: `\n    <input type=\"text\" \n      :value=\"modelValue\"\n      @input=\"$emit('update:modelValue', $event.target.value)\">\n  `,\n  created() {\n    console.log(this.modelModifiers) // { capitalize: true }\n  }\n})\n```\n现在我们已经设置了 prop，我们可以检查 `modelModifiers` 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 `<input/>` 元素触发 `input` 事件时，我们都将字符串大写。\n```html\n<div id=\"app\">\n  <my-component v-model.capitalize=\"myText\"></my-component>\n  {{ myText }}\n</div>\n```\n```js\nconst app = Vue.createApp({\n  data() {\n    return {\n      myText: ''\n    }\n  }\n})\n\napp.component('my-component', {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  methods: {\n    emitValue(e) {\n      let value = e.target.value\n      if (this.modelModifiers.capitalize) {\n        value = value.charAt(0).toUpperCase() + value.slice(1)\n      }\n      this.$emit('update:modelValue', value)\n    }\n  },\n  template: `<input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"emitValue\">`\n})\n\napp.mount('#app')\n```\n对于带参数的 `v-model` 绑定，生成的 prop 名称将为 `arg + \"Modifiers\"`：\n```html\n<my-component v-model:foo.capitalize=\"bar\"></my-component>\n```\n```js\napp.component('my-component', {\n  props: ['foo', 'fooModifiers'],\n  template: `\n    <input type=\"text\" \n      :value=\"foo\"\n      @input=\"$emit('update:foo', $event.target.value)\">\n  `,\n  created() {\n    console.log(this.fooModifiers) // { capitalize: true }\n  }\n})\n```\n---\n2021.09.17更新\n---\n## 提供/注入\n通常，当我们需要将数据从父组件传递到子组件时，我们使用`props`。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。\n\n对于这种情况，我们可以使用 `provide` 和 `inject` 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 `provide` 选项来提供数据，子组件有一个 `inject` 选项来开始使用这个数据。\n\n# 可复用&组合\n## 渲染函数\n### 虚拟DOM树\nVue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：\n```js\nreturn Vue.h('h1', {}, this.blogTitle)\n```\n`h()` 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 **VNode**。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。\n\n### h()参数\nh() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：\n\n```js\nh(\n  // {String | Object | Function | null} tag\n  // 一个 HTML 标签名、一个组件、一个异步组件，或者 null。\n  // 使用 null 将会渲染一个注释。\n  //\n  // 必需的。\n  'div',\n\n  // {Object} props\n  // 与 attribute、prop 和事件相对应的对象。\n  // 我们会在模板中使用。\n  //\n  // 可选的。\n  {},\n\n  // {String | Array | Object} children\n  // 子 VNodes, 使用 `h()` 构建,\n  // 或使用字符串获取 \"文本 Vnode\" 或者\n  // 有 slot 的对象。\n  //\n  // 可选的。\n  [\n    'Some text comes first.',\n    h('h1', 'A headline'),\n    h(MyComponent, {\n      someProp: 'foobar'\n    })\n  ]\n)\n```\n\n### 完整实例\n有了这些知识，我们现在可以完成我们最开始想实现的组件：\n```js\nconst app = Vue.createApp({})\n\n/** Recursively get text from children nodes */\nfunction getChildrenTextContent(children) {\n  return children\n    .map(node => {\n      return typeof node.children === 'string'\n        ? node.children\n        : Array.isArray(node.children)\n        ? getChildrenTextContent(node.children)\n        : ''\n    })\n    .join('')\n}\n\napp.component('anchored-heading', {\n  render() {\n    // create kebab-case id from the text contents of the children\n    const headingId = getChildrenTextContent(this.$slots.default())\n      .toLowerCase()\n      .replace(/\\W+/g, '-') // replace non-word characters with dash\n      .replace(/(^-|-$)/g, '') // remove leading and trailing dashes\n\n    return Vue.h('h' + this.level, [\n      Vue.h(\n        'a',\n        {\n          name: headingId,\n          href: '#' + headingId\n        },\n        this.$slots.default()\n      )\n    ])\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```","source":"_posts/2021-09-15-vue3文档记录.md","raw":"---\ntitle: 通读vue3文档记录\ndate: 2021-09-15 19:03:11\ntags: Vue3\ncategories: 技术类-Vue\n---\n之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是`Object.defineProperty()`，vue3用的是`Proxy`。vue3还新增了`组合式API`等等。\n\n这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。\n\n持续更新ing\n\n# 应用&组件实例\n## 应用实例\n每个 Vue 应用都是通过用 createApp 函数创建一个新的**应用实例**开始的：\n\n```js\nconst app = Vue.createApp({ /* 选项 */ })\n```\n\n该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：\n```js\nconst app = Vue.createApp({})\napp.component('SearchInput', SearchInputComponent)\napp.directive('focus', FocusDirective)\napp.use(LocalePlugin)\n```\n应用实例暴露的大多数方法都会返回该同一实例，允许链式：\n```js\nVue.createApp({})\n  .component('SearchInput', SearchInputComponent)\n  .directive('focus', FocusDirective)\n  .use(LocalePlugin)\n```\n\n## 根组件实例\n传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。\n\n一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 `<div id=\"app\"></div>`，我们应该传递 `#app`：\n```js\nconst RootComponent = { /* 选项 */ }\nconst app = Vue.createApp(RootComponent)\nconst vm = app.mount('#app')\n```\n与大多数应用方法不同的是，`mount` 不返回应用本身。相反，它返回的是**根组件实例**。\n\n虽然没有完全遵循 `MVVM` 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。\n\n# 计算属性&侦听器\n## 计算属性缓存 vs 方法\n    \n你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：\n```html\n<p>{{ calculateBooksMessage() }}</p>\n```\n```js\n// 在组件中\nmethods: {\n  calculateBooksMessage() {\n    return this.author.books.length > 0 ? 'Yes' : 'No'\n  }\n}\n```\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要`author.books` 还没有发生改变，多次访问 `publishedBookMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。 \n\n这也同样意味着下面的计算属性将不再更新，因为 **Date.now () 不是响应式依赖**：\n```js\ncomputed: {\n  now() {\n    return Date.now()\n  }\n}\n```\n相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。\n\n我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 `list`，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 `list`。如果没有缓存，我们将不可避免的多次执行 `list` 的 getter！如果你不希望有缓存，请用 method 来替代\n\n---\n以下为2021.09.16更新\n---\n## 计算属性的 Setter\n计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：\n```js\n// ...\ncomputed: {\n  fullName: {\n    // getter\n    get() {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set(newValue) {\n      const names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n// ...\n```\n现在再运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应地被更新。\n\n# Class与Style绑定\n如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作：\n```js\n<div id=\"app\">\n  <my-component class=\"baz\"></my-component>\n</div>\nconst app = Vue.createApp({})\n\napp.component('my-component', {\n  template: `\n    <p :class=\"$attrs.class\">Hi!</p>\n    <span>This is a child component</span>\n  `\n})\n```\n\n# 条件渲染\n\n## `v-if` vs `v-show`\n`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n`v-if` 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好\n\n## v-if 与 v-for 一起使用\n> 提示 不推荐同时使用 v-if 和 v-for\n\n当 `v-if` 与 `v-for` 一起使用时，`v-if` 具有比 `v-for` 更高的优先级。请查阅列表渲染指南以获取详细信息。\n\n当它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量：\n```js\n<!-- This will throw an error because property \"todo\" is not defined on instance. -->\n\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n  {{ todo }}\n</li>\n```\n可以把 v-for 移动到`<template>` 标签中来修正：\n```js\n<template v-for=\"todo in todos\">\n  <li v-if=\"!todo.isComplete\">\n    {{ todo }}\n  </li>\n</template>\n```\n# 表单绑定输入\n## 基础用法\n`v-model` 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：\n\n- text 和 textarea 元素使用 value property 和 input 事件；\n- checkbox 和 radio 使用 checked property 和 change 事件；\n- select 字段将 value 作为 prop 并将 change 作为事件。\n\n# 组件基础\n## 基本实例\n这里有一个 Vue 组件的示例：\n```js\n// 创建一个Vue 应用\nconst app = Vue.createApp({})\n\n// 定义一个名为 button-counter 的新全局组件\napp.component('button-counter', {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n})\n```\n## 组件的复用\n你可以将组件进行任意次数的复用\n每个组件都会各自独立维护它的`data`。因为你每用一次组件，就会有一个它的新组件实例被创建\n\n## 在组件上使用 v-model\n自定义事件也可以用于创建支持 `v-model` 的自定义输入组件。记住：\n```js\n<input v-model=\"searchText\" />\n等价于：\n\n<input :value=\"searchText\" @input=\"searchText = $event.target.value\" />\n当用在组件上时，v-model 则会这样：\n\n<custom-input\n  :model-value=\"searchText\"\n  @update:model-value=\"searchText = $event\"\n></custom-input>\n```\n为了让它正常工作，这个组件内的 `<input>` 必须：\n\n将其 `value` attribute 绑定到一个名叫 `modelValue` 的 prop 上\n在其 `input` 事件被触发时，将新的值通过自定义的 `update:modelValue` 事件抛出\n写成代码之后是这样的：\n```js\napp.component('custom-input', {\n  props: ['modelValue'],\n  template: `\n    <input\n      :value=\"modelValue\"\n      @input=\"$emit('update:modelValue', $event.target.value)\"\n    >\n  `\n})\n```\n现在 `v-model` 就应该可以在这个组件上完美地工作起来了：\n```html\n<custom-input v-model=\"searchText\"></custom-input>\n```\n# 深入组件\n## 非 Prop 的 Attribute\n### Attribute 继承\n当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 `<date-picker>` 组件的实例中：\n```js\napp.component('date-picker', {\n  template: `\n    <div class=\"date-picker\">\n      <input type=\"datetime\" />\n    </div>\n  `\n})\n```\n如果我们需要通过 `data status` property 定义 `<date-picker>` 组件的状态，它将应用于根节点 (即 `div.date-picker`)。\n```html\n<!-- 具有非prop attribute的Date-picker组件-->\n<date-picker data-status=\"activated\"></date-picker>\n\n<!-- 渲染 date-picker 组件 -->\n<div class=\"date-picker\" data-status=\"activated\">\n  <input type=\"datetime\" />\n</div>\n```\n\n同样的规则适用于事件监听器：\n```html\n<date-picker @change=\"submitChange\"></date-picker>\n```\n```js\napp.component('date-picker', {\n  created() {\n    console.log(this.$attrs) // { onChange: () => {}  }\n  }\n})\n```\n当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。\n```js\napp.component('date-picker', {\n  template: `\n    <select>\n      <option value=\"1\">Yesterday</option>\n      <option value=\"2\">Today</option>\n      <option value=\"3\">Tomorrow</option>\n    </select>\n  `\n})\n```\n在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件：\n```html\n<div id=\"date-picker\" class=\"demo\">\n  <date-picker @change=\"showChange\"></date-picker>\n</div>\n```\n```js\nconst app = Vue.createApp({\n  methods: {\n    showChange(event) {\n      console.log(event.target.value) // 将记录所选选项的值\n    }\n  }\n})\n```\n\n### 禁用 Attribute 继承\n如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 `inheritAttrs: false`。例如：\n\n禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。\n\n通过将 `inheritAttrs` 选项设置为 `false`，你可以访问组件的 `$attrs` property，该 property 包括组件 `props` 和 `emits` property 中未包含的所有属性 (例如，`class`、`style`、`v-on` 监听器等)。\n```js\napp.component('date-picker', {\n  inheritAttrs: false,\n  template: `\n    <div class=\"date-picker\">\n      <input type=\"datetime\" v-bind=\"$attrs\" />\n    </div>\n  `\n})\n```\n有了这个新配置，`data status` attribute 将应用于 `input` 元素！\n```html\n<!-- Date-picker 组件 使用非 prop attribute -->\n<date-picker data-status=\"activated\"></date-picker>\n\n<!-- 渲染 date-picker 组件 -->\n<div class=\"date-picker\">\n  <input type=\"datetime\" data-status=\"activated\" />\n</div>\n```\n\n### 多个根节点上的 Attribute 继承\n与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。\n```html\n<custom-layout id=\"custom-layout\" @click=\"changeValue\"></custom-layout>\n```\n```js\n// 这将发出警告\napp.component('custom-layout', {\n  template: `\n    <header>...</header>\n    <main>...</main>\n    <footer>...</footer>\n  `\n})\n\n// 没有警告，$attrs被传递到<main>元素\napp.component('custom-layout', {\n  template: `\n    <header>...</header>\n    <main v-bind=\"$attrs\">...</main>\n    <footer>...</footer>\n  `\n})\n```\n## 自定义事件\n### 处理 v-model 修饰符\n在 2.x 中，我们对组件 `v-model` 上的 `.trim` 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 `v-model` 的修饰符将通过 `modelModifiers` prop 提供给组件：\n\n让我们创建一个示例自定义修饰符 `capitalize`，它将 `v-model` 绑定提供的字符串的第一个字母大写。\n\n添加到组件 `v-model` 的修饰符将通过 `modelModifiers` prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 `modelModifiers` prop。\n\n请注意，当组件的 `created` 生命周期钩子触发时，`modelModifiers` prop 包含 `capitalize`，其值为 `true`——因为它被设置在 `v-model` 绑定 `v-model.capitalize=\"bar\"`。\n```html\n<my-component v-model.capitalize=\"bar\"></my-component>\n```\n\n```js\napp.component('my-component', {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  template: `\n    <input type=\"text\" \n      :value=\"modelValue\"\n      @input=\"$emit('update:modelValue', $event.target.value)\">\n  `,\n  created() {\n    console.log(this.modelModifiers) // { capitalize: true }\n  }\n})\n```\n现在我们已经设置了 prop，我们可以检查 `modelModifiers` 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 `<input/>` 元素触发 `input` 事件时，我们都将字符串大写。\n```html\n<div id=\"app\">\n  <my-component v-model.capitalize=\"myText\"></my-component>\n  {{ myText }}\n</div>\n```\n```js\nconst app = Vue.createApp({\n  data() {\n    return {\n      myText: ''\n    }\n  }\n})\n\napp.component('my-component', {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  methods: {\n    emitValue(e) {\n      let value = e.target.value\n      if (this.modelModifiers.capitalize) {\n        value = value.charAt(0).toUpperCase() + value.slice(1)\n      }\n      this.$emit('update:modelValue', value)\n    }\n  },\n  template: `<input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"emitValue\">`\n})\n\napp.mount('#app')\n```\n对于带参数的 `v-model` 绑定，生成的 prop 名称将为 `arg + \"Modifiers\"`：\n```html\n<my-component v-model:foo.capitalize=\"bar\"></my-component>\n```\n```js\napp.component('my-component', {\n  props: ['foo', 'fooModifiers'],\n  template: `\n    <input type=\"text\" \n      :value=\"foo\"\n      @input=\"$emit('update:foo', $event.target.value)\">\n  `,\n  created() {\n    console.log(this.fooModifiers) // { capitalize: true }\n  }\n})\n```\n---\n2021.09.17更新\n---\n## 提供/注入\n通常，当我们需要将数据从父组件传递到子组件时，我们使用`props`。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。\n\n对于这种情况，我们可以使用 `provide` 和 `inject` 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 `provide` 选项来提供数据，子组件有一个 `inject` 选项来开始使用这个数据。\n\n# 可复用&组合\n## 渲染函数\n### 虚拟DOM树\nVue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：\n```js\nreturn Vue.h('h1', {}, this.blogTitle)\n```\n`h()` 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 **VNode**。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。\n\n### h()参数\nh() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：\n\n```js\nh(\n  // {String | Object | Function | null} tag\n  // 一个 HTML 标签名、一个组件、一个异步组件，或者 null。\n  // 使用 null 将会渲染一个注释。\n  //\n  // 必需的。\n  'div',\n\n  // {Object} props\n  // 与 attribute、prop 和事件相对应的对象。\n  // 我们会在模板中使用。\n  //\n  // 可选的。\n  {},\n\n  // {String | Array | Object} children\n  // 子 VNodes, 使用 `h()` 构建,\n  // 或使用字符串获取 \"文本 Vnode\" 或者\n  // 有 slot 的对象。\n  //\n  // 可选的。\n  [\n    'Some text comes first.',\n    h('h1', 'A headline'),\n    h(MyComponent, {\n      someProp: 'foobar'\n    })\n  ]\n)\n```\n\n### 完整实例\n有了这些知识，我们现在可以完成我们最开始想实现的组件：\n```js\nconst app = Vue.createApp({})\n\n/** Recursively get text from children nodes */\nfunction getChildrenTextContent(children) {\n  return children\n    .map(node => {\n      return typeof node.children === 'string'\n        ? node.children\n        : Array.isArray(node.children)\n        ? getChildrenTextContent(node.children)\n        : ''\n    })\n    .join('')\n}\n\napp.component('anchored-heading', {\n  render() {\n    // create kebab-case id from the text contents of the children\n    const headingId = getChildrenTextContent(this.$slots.default())\n      .toLowerCase()\n      .replace(/\\W+/g, '-') // replace non-word characters with dash\n      .replace(/(^-|-$)/g, '') // remove leading and trailing dashes\n\n    return Vue.h('h' + this.level, [\n      Vue.h(\n        'a',\n        {\n          name: headingId,\n          href: '#' + headingId\n        },\n        this.$slots.default()\n      )\n    ])\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```","slug":"vue3文档记录","published":1,"updated":"2021-09-17T10:41:59.128Z","_id":"cktmsffg1000pfkvq6hqseosg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是<code>Object.defineProperty()</code>，vue3用的是<code>Proxy</code>。vue3还新增了<code>组合式API</code>等等。</p>\n<p>这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。</p>\n<p>持续更新ing</p>\n<h1 id=\"应用-amp-组件实例\"><a href=\"#应用-amp-组件实例\" class=\"headerlink\" title=\"应用&amp;组件实例\"></a>应用&amp;组件实例</h1><h2 id=\"应用实例\"><a href=\"#应用实例\" class=\"headerlink\" title=\"应用实例\"></a>应用实例</h2><p>每个 Vue 应用都是通过用 createApp 函数创建一个新的<strong>应用实例</strong>开始的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123; <span class=\"hljs-comment\">/* 选项 */</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n<p>该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br>app.component(<span class=\"hljs-string\">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>app.directive(<span class=\"hljs-string\">&#x27;focus&#x27;</span>, FocusDirective)<br>app.use(LocalePlugin)<br></code></pre></td></tr></table></figure>\n<p>应用实例暴露的大多数方法都会返回该同一实例，允许链式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">Vue.createApp(&#123;&#125;)<br>  .component(<span class=\"hljs-string\">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>  .directive(<span class=\"hljs-string\">&#x27;focus&#x27;</span>, FocusDirective)<br>  .use(LocalePlugin)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"根组件实例\"><a href=\"#根组件实例\" class=\"headerlink\" title=\"根组件实例\"></a>根组件实例</h2><p>传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。</p>\n<p>一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，我们应该传递 <code>#app</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> RootComponent = &#123; <span class=\"hljs-comment\">/* 选项 */</span> &#125;<br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(RootComponent)<br><span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>与大多数应用方法不同的是，<code>mount</code> 不返回应用本身。相反，它返回的是<strong>根组件实例</strong>。</p>\n<p>虽然没有完全遵循 <code>MVVM</code> 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。</p>\n<h1 id=\"计算属性-amp-侦听器\"><a href=\"#计算属性-amp-侦听器\" class=\"headerlink\" title=\"计算属性&amp;侦听器\"></a>计算属性&amp;侦听器</h1><h2 id=\"计算属性缓存-vs-方法\"><a href=\"#计算属性缓存-vs-方法\" class=\"headerlink\" title=\"计算属性缓存 vs 方法\"></a>计算属性缓存 vs 方法</h2><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123; calculateBooksMessage() &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 在组件中</span><br><span class=\"hljs-attr\">methods</span>: &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">calculateBooksMessage</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.author.books.length &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-string\">&#x27;Yes&#x27;</span> : <span class=\"hljs-string\">&#x27;No&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要<code>author.books</code> 还没有发生改变，多次访问 <code>publishedBookMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。 </p>\n<p>这也同样意味着下面的计算属性将不再更新，因为 <strong>Date.now () 不是响应式依赖</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">computed: &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">now</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Date</span>.now()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p>\n<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <code>list</code>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <code>list</code>。如果没有缓存，我们将不可避免的多次执行 <code>list</code> 的 getter！如果你不希望有缓存，请用 method 来替代</p>\n<hr>\n<h2 id=\"以下为2021-09-16更新\"><a href=\"#以下为2021-09-16更新\" class=\"headerlink\" title=\"以下为2021.09.16更新\"></a>以下为2021.09.16更新</h2><h2 id=\"计算属性的-Setter\"><a href=\"#计算属性的-Setter\" class=\"headerlink\" title=\"计算属性的 Setter\"></a>计算属性的 Setter</h2><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// ...</span><br><span class=\"hljs-attr\">computed</span>: &#123;<br>  <span class=\"hljs-attr\">fullName</span>: &#123;<br>    <span class=\"hljs-comment\">// getter</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.firstName + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-built_in\">this</span>.lastName<br>    &#125;,<br>    <span class=\"hljs-comment\">// setter</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\">newValue</span>)</span> &#123;<br>      <span class=\"hljs-keyword\">const</span> names = newValue.split(<span class=\"hljs-string\">&#x27; &#x27;</span>)<br>      <span class=\"hljs-built_in\">this</span>.firstName = names[<span class=\"hljs-number\">0</span>]<br>      <span class=\"hljs-built_in\">this</span>.lastName = names[names.length - <span class=\"hljs-number\">1</span>]<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// ...</span><br></code></pre></td></tr></table></figure>\n<p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p>\n<h1 id=\"Class与Style绑定\"><a href=\"#Class与Style绑定\" class=\"headerlink\" title=\"Class与Style绑定\"></a>Class与Style绑定</h1><p>如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;div id=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;baz&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></span><br>&lt;/div&gt;<br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br>app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;</span><br><span class=\"hljs-string\">    &lt;span&gt;This is a child component&lt;/span&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h1><h2 id=\"v-if-vs-v-show\"><a href=\"#v-if-vs-v-show\" class=\"headerlink\" title=\"v-if vs v-show\"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>\n<p><code>v-if</code> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>\n<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>\n<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好</p>\n<h2 id=\"v-if-与-v-for-一起使用\"><a href=\"#v-if-与-v-for-一起使用\" class=\"headerlink\" title=\"v-if 与 v-for 一起使用\"></a>v-if 与 v-for 一起使用</h2><blockquote>\n<p>提示 不推荐同时使用 v-if 和 v-for</p>\n</blockquote>\n<p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-if</code> 具有比 <code>v-for</code> 更高的优先级。请查阅列表渲染指南以获取详细信息。</p>\n<p>当它们处于同一节点，<code>v-if</code> 的优先级比 <code>v-for</code> 更高，这意味着 <code>v-if</code> 将没有权限访问 <code>v-for</code> 里的变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;!-- This will <span class=\"hljs-keyword\">throw</span> an error because property <span class=\"hljs-string\">&quot;todo&quot;</span> is not defined on instance. --&gt;<br><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;todo in todos&quot;</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class=\"xml\">  &#123;&#123; todo &#125;&#125;</span><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>可以把 v-for 移动到<code>&lt;template&gt;</code> 标签中来修正：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;template v-<span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">&quot;todo in todos&quot;</span>&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class=\"xml\">    &#123;&#123; todo &#125;&#125;</span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n<h1 id=\"表单绑定输入\"><a href=\"#表单绑定输入\" class=\"headerlink\" title=\"表单绑定输入\"></a>表单绑定输入</h1><h2 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h2><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>\n<ul>\n<li>text 和 textarea 元素使用 value property 和 input 事件；</li>\n<li>checkbox 和 radio 使用 checked property 和 change 事件；</li>\n<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>\n</ul>\n<h1 id=\"组件基础\"><a href=\"#组件基础\" class=\"headerlink\" title=\"组件基础\"></a>组件基础</h1><h2 id=\"基本实例\"><a href=\"#基本实例\" class=\"headerlink\" title=\"基本实例\"></a>基本实例</h2><p>这里有一个 Vue 组件的示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 创建一个Vue 应用</span><br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class=\"hljs-comment\">// 定义一个名为 button-counter 的新全局组件</span><br>app.component(<span class=\"hljs-string\">&#x27;button-counter&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span><br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;button @click=&quot;count++&quot;&gt;</span><br><span class=\"hljs-string\">      You clicked me &#123;&#123; count &#125;&#125; times.</span><br><span class=\"hljs-string\">    &lt;/button&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<h2 id=\"组件的复用\"><a href=\"#组件的复用\" class=\"headerlink\" title=\"组件的复用\"></a>组件的复用</h2><p>你可以将组件进行任意次数的复用<br>每个组件都会各自独立维护它的<code>data</code>。因为你每用一次组件，就会有一个它的新组件实例被创建</p>\n<h2 id=\"在组件上使用-v-model\"><a href=\"#在组件上使用-v-model\" class=\"headerlink\" title=\"在组件上使用 v-model\"></a>在组件上使用 v-model</h2><p>自定义事件也可以用于创建支持 <code>v-model</code> 的自定义输入组件。记住：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;input v-model=<span class=\"hljs-string\">&quot;searchText&quot;</span> /&gt;<br>等价于：<br><br>&lt;input :value=<span class=\"hljs-string\">&quot;searchText&quot;</span> @input=<span class=\"hljs-string\">&quot;searchText = $event.target.value&quot;</span> /&gt;<br>当用在组件上时，v-model 则会这样：<br><br>&lt;custom-input<br>  :model-value=<span class=\"hljs-string\">&quot;searchText&quot;</span><br>  @update:model-value=<span class=\"hljs-string\">&quot;searchText = $event&quot;</span><br>&gt;&lt;/custom-input&gt;<br></code></pre></td></tr></table></figure>\n<p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code> 必须：</p>\n<p>将其 <code>value</code> attribute 绑定到一个名叫 <code>modelValue</code> 的 prop 上<br>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>update:modelValue</code> 事件抛出<br>写成代码之后是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;custom-input&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;modelValue&#x27;</span>],<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input</span><br><span class=\"hljs-string\">      :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span><br><span class=\"hljs-string\">    &gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>现在 <code>v-model</code> 就应该可以在这个组件上完美地工作起来了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;searchText&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-input</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"深入组件\"><a href=\"#深入组件\" class=\"headerlink\" title=\"深入组件\"></a>深入组件</h1><h2 id=\"非-Prop-的-Attribute\"><a href=\"#非-Prop-的-Attribute\" class=\"headerlink\" title=\"非 Prop 的 Attribute\"></a>非 Prop 的 Attribute</h2><h3 id=\"Attribute-继承\"><a href=\"#Attribute-继承\" class=\"headerlink\" title=\"Attribute 继承\"></a>Attribute 继承</h3><p>当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 <code>&lt;date-picker&gt;</code> 组件的实例中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class=\"hljs-string\">      &lt;input type=&quot;datetime&quot; /&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>如果我们需要通过 <code>data status</code> property 定义 <code>&lt;date-picker&gt;</code> 组件的状态，它将应用于根节点 (即 <code>div.date-picker</code>)。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 具有非prop attribute的Date-picker组件--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;datetime&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>同样的规则适用于事件监听器：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">&quot;submitChange&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.$attrs) <span class=\"hljs-comment\">// &#123; onChange: () =&gt; &#123;&#125;  &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;select&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;1&quot;&gt;Yesterday&lt;/option&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;2&quot;&gt;Today&lt;/option&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;3&quot;&gt;Tomorrow&lt;/option&gt;</span><br><span class=\"hljs-string\">    &lt;/select&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;demo&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">&quot;showChange&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">showChange</span>(<span class=\"hljs-params\">event</span>)</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(event.target.value) <span class=\"hljs-comment\">// 将记录所选选项的值</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"禁用-Attribute-继承\"><a href=\"#禁用-Attribute-继承\" class=\"headerlink\" title=\"禁用 Attribute 继承\"></a>禁用 Attribute 继承</h3><p>如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p>\n<p>禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。</p>\n<p>通过将 <code>inheritAttrs</code> 选项设置为 <code>false</code>，你可以访问组件的 <code>$attrs</code> property，该 property 包括组件 <code>props</code> 和 <code>emits</code> property 中未包含的所有属性 (例如，<code>class</code>、<code>style</code>、<code>v-on</code> 监听器等)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class=\"hljs-string\">      &lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>有了这个新配置，<code>data status</code> attribute 将应用于 <code>input</code> 元素！</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Date-picker 组件 使用非 prop attribute --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;datetime&quot;</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"多个根节点上的-Attribute-继承\"><a href=\"#多个根节点上的-Attribute-继承\" class=\"headerlink\" title=\"多个根节点上的 Attribute 继承\"></a>多个根节点上的 Attribute 继承</h3><p>与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-layout</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;custom-layout&quot;</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;changeValue&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-layout</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 这将发出警告</span><br>app.component(<span class=\"hljs-string\">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;header&gt;...&lt;/header&gt;</span><br><span class=\"hljs-string\">    &lt;main&gt;...&lt;/main&gt;</span><br><span class=\"hljs-string\">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 没有警告，$attrs被传递到&lt;main&gt;元素</span><br>app.component(<span class=\"hljs-string\">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;header&gt;...&lt;/header&gt;</span><br><span class=\"hljs-string\">    &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class=\"hljs-string\">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<h2 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h2><h3 id=\"处理-v-model-修饰符\"><a href=\"#处理-v-model-修饰符\" class=\"headerlink\" title=\"处理 v-model 修饰符\"></a>处理 v-model 修饰符</h3><p>在 2.x 中，我们对组件 <code>v-model</code> 上的 <code>.trim</code> 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件：</p>\n<p>让我们创建一个示例自定义修饰符 <code>capitalize</code>，它将 <code>v-model</code> 绑定提供的字符串的第一个字母大写。</p>\n<p>添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 <code>modelModifiers</code> prop。</p>\n<p>请注意，当组件的 <code>created</code> 生命周期钩子触发时，<code>modelModifiers</code> prop 包含 <code>capitalize</code>，其值为 <code>true</code>——因为它被设置在 <code>v-model</code> 绑定 <code>v-model.capitalize=&quot;bar&quot;</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model.capitalize</span>=<span class=\"hljs-string\">&quot;bar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">modelValue</span>: <span class=\"hljs-built_in\">String</span>,<br>    <span class=\"hljs-attr\">modelModifiers</span>: &#123;<br>      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input type=&quot;text&quot; </span><br><span class=\"hljs-string\">      :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;&gt;</span><br><span class=\"hljs-string\">  `</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.modelModifiers) <span class=\"hljs-comment\">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>现在我们已经设置了 prop，我们可以检查 <code>modelModifiers</code> 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 <code>&lt;input/&gt;</code> 元素触发 <code>input</code> 事件时，我们都将字符串大写。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model.capitalize</span>=<span class=\"hljs-string\">&quot;myText&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br>  &#123;&#123; myText &#125;&#125;<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-attr\">myText</span>: <span class=\"hljs-string\">&#x27;&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br><br>app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">modelValue</span>: <span class=\"hljs-built_in\">String</span>,<br>    <span class=\"hljs-attr\">modelModifiers</span>: &#123;<br>      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">emitValue</span>(<span class=\"hljs-params\">e</span>)</span> &#123;<br>      <span class=\"hljs-keyword\">let</span> value = e.target.value<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.modelModifiers.capitalize) &#123;<br>        value = value.charAt(<span class=\"hljs-number\">0</span>).toUpperCase() + value.slice(<span class=\"hljs-number\">1</span>)<br>      &#125;<br>      <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&#x27;update:modelValue&#x27;</span>, value)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;input</span><br><span class=\"hljs-string\">    type=&quot;text&quot;</span><br><span class=\"hljs-string\">    :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">    @input=&quot;emitValue&quot;&gt;`</span><br>&#125;)<br><br>app.mount(<span class=\"hljs-string\">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>对于带参数的 <code>v-model</code> 绑定，生成的 prop 名称将为 <code>arg + &quot;Modifiers&quot;</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model:foo.capitalize</span>=<span class=\"hljs-string\">&quot;bar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;foo&#x27;</span>, <span class=\"hljs-string\">&#x27;fooModifiers&#x27;</span>],<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input type=&quot;text&quot; </span><br><span class=\"hljs-string\">      :value=&quot;foo&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:foo&#x27;, $event.target.value)&quot;&gt;</span><br><span class=\"hljs-string\">  `</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.fooModifiers) <span class=\"hljs-comment\">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"2021-09-17更新\"><a href=\"#2021-09-17更新\" class=\"headerlink\" title=\"2021.09.17更新\"></a>2021.09.17更新</h2><h2 id=\"提供-注入\"><a href=\"#提供-注入\" class=\"headerlink\" title=\"提供/注入\"></a>提供/注入</h2><p>通常，当我们需要将数据从父组件传递到子组件时，我们使用<code>props</code>。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。</p>\n<p>对于这种情况，我们可以使用 <code>provide</code> 和 <code>inject</code> 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这个数据。</p>\n<h1 id=\"可复用-amp-组合\"><a href=\"#可复用-amp-组合\" class=\"headerlink\" title=\"可复用&amp;组合\"></a>可复用&amp;组合</h1><h2 id=\"渲染函数\"><a href=\"#渲染函数\" class=\"headerlink\" title=\"渲染函数\"></a>渲染函数</h2><h3 id=\"虚拟DOM树\"><a href=\"#虚拟DOM树\" class=\"headerlink\" title=\"虚拟DOM树\"></a>虚拟DOM树</h3><p>Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">return</span> Vue.h(<span class=\"hljs-string\">&#x27;h1&#x27;</span>, &#123;&#125;, <span class=\"hljs-built_in\">this</span>.blogTitle)<br></code></pre></td></tr></table></figure>\n<p><code>h()</code> 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 <strong>VNode</strong>。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p>\n<h3 id=\"h-参数\"><a href=\"#h-参数\" class=\"headerlink\" title=\"h()参数\"></a>h()参数</h3><p>h() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">h(<br>  <span class=\"hljs-comment\">// &#123;String | Object | Function | null&#125; tag</span><br>  <span class=\"hljs-comment\">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span><br>  <span class=\"hljs-comment\">// 使用 null 将会渲染一个注释。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 必需的。</span><br>  <span class=\"hljs-string\">&#x27;div&#x27;</span>,<br><br>  <span class=\"hljs-comment\">// &#123;Object&#125; props</span><br>  <span class=\"hljs-comment\">// 与 attribute、prop 和事件相对应的对象。</span><br>  <span class=\"hljs-comment\">// 我们会在模板中使用。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 可选的。</span><br>  &#123;&#125;,<br><br>  <span class=\"hljs-comment\">// &#123;String | Array | Object&#125; children</span><br>  <span class=\"hljs-comment\">// 子 VNodes, 使用 `h()` 构建,</span><br>  <span class=\"hljs-comment\">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span><br>  <span class=\"hljs-comment\">// 有 slot 的对象。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 可选的。</span><br>  [<br>    <span class=\"hljs-string\">&#x27;Some text comes first.&#x27;</span>,<br>    h(<span class=\"hljs-string\">&#x27;h1&#x27;</span>, <span class=\"hljs-string\">&#x27;A headline&#x27;</span>),<br>    h(MyComponent, &#123;<br>      <span class=\"hljs-attr\">someProp</span>: <span class=\"hljs-string\">&#x27;foobar&#x27;</span><br>    &#125;)<br>  ]<br>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"完整实例\"><a href=\"#完整实例\" class=\"headerlink\" title=\"完整实例\"></a>完整实例</h3><p>有了这些知识，我们现在可以完成我们最开始想实现的组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class=\"hljs-comment\">/** Recursively get text from children nodes */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getChildrenTextContent</span>(<span class=\"hljs-params\">children</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> children<br>    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">node</span> =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> node.children === <span class=\"hljs-string\">&#x27;string&#x27;</span><br>        ? node.children<br>        : <span class=\"hljs-built_in\">Array</span>.isArray(node.children)<br>        ? getChildrenTextContent(node.children)<br>        : <span class=\"hljs-string\">&#x27;&#x27;</span><br>    &#125;)<br>    .join(<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>&#125;<br><br>app.component(<span class=\"hljs-string\">&#x27;anchored-heading&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-comment\">// create kebab-case id from the text contents of the children</span><br>    <span class=\"hljs-keyword\">const</span> headingId = getChildrenTextContent(<span class=\"hljs-built_in\">this</span>.$slots.default())<br>      .toLowerCase()<br>      .replace(<span class=\"hljs-regexp\">/\\W+/g</span>, <span class=\"hljs-string\">&#x27;-&#x27;</span>) <span class=\"hljs-comment\">// replace non-word characters with dash</span><br>      .replace(<span class=\"hljs-regexp\">/(^-|-$)/g</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-comment\">// remove leading and trailing dashes</span><br><br>    <span class=\"hljs-keyword\">return</span> Vue.h(<span class=\"hljs-string\">&#x27;h&#x27;</span> + <span class=\"hljs-built_in\">this</span>.level, [<br>      Vue.h(<br>        <span class=\"hljs-string\">&#x27;a&#x27;</span>,<br>        &#123;<br>          <span class=\"hljs-attr\">name</span>: headingId,<br>          <span class=\"hljs-attr\">href</span>: <span class=\"hljs-string\">&#x27;#&#x27;</span> + headingId<br>        &#125;,<br>        <span class=\"hljs-built_in\">this</span>.$slots.default()<br>      )<br>    ])<br>  &#125;,<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">level</span>: &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,<br>      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是<code>Object.defineProperty()</code>，vue3用的是<code>Proxy</code>。vue3还新增了<code>组合式API</code>等等。</p>\n<p>这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。</p>\n<p>持续更新ing</p>\n<h1 id=\"应用-amp-组件实例\"><a href=\"#应用-amp-组件实例\" class=\"headerlink\" title=\"应用&amp;组件实例\"></a>应用&amp;组件实例</h1><h2 id=\"应用实例\"><a href=\"#应用实例\" class=\"headerlink\" title=\"应用实例\"></a>应用实例</h2><p>每个 Vue 应用都是通过用 createApp 函数创建一个新的<strong>应用实例</strong>开始的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123; <span class=\"hljs-comment\">/* 选项 */</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n<p>该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br>app.component(<span class=\"hljs-string\">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>app.directive(<span class=\"hljs-string\">&#x27;focus&#x27;</span>, FocusDirective)<br>app.use(LocalePlugin)<br></code></pre></td></tr></table></figure>\n<p>应用实例暴露的大多数方法都会返回该同一实例，允许链式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">Vue.createApp(&#123;&#125;)<br>  .component(<span class=\"hljs-string\">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>  .directive(<span class=\"hljs-string\">&#x27;focus&#x27;</span>, FocusDirective)<br>  .use(LocalePlugin)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"根组件实例\"><a href=\"#根组件实例\" class=\"headerlink\" title=\"根组件实例\"></a>根组件实例</h2><p>传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。</p>\n<p>一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，我们应该传递 <code>#app</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> RootComponent = &#123; <span class=\"hljs-comment\">/* 选项 */</span> &#125;<br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(RootComponent)<br><span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>与大多数应用方法不同的是，<code>mount</code> 不返回应用本身。相反，它返回的是<strong>根组件实例</strong>。</p>\n<p>虽然没有完全遵循 <code>MVVM</code> 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。</p>\n<h1 id=\"计算属性-amp-侦听器\"><a href=\"#计算属性-amp-侦听器\" class=\"headerlink\" title=\"计算属性&amp;侦听器\"></a>计算属性&amp;侦听器</h1><h2 id=\"计算属性缓存-vs-方法\"><a href=\"#计算属性缓存-vs-方法\" class=\"headerlink\" title=\"计算属性缓存 vs 方法\"></a>计算属性缓存 vs 方法</h2><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123; calculateBooksMessage() &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 在组件中</span><br><span class=\"hljs-attr\">methods</span>: &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">calculateBooksMessage</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.author.books.length &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-string\">&#x27;Yes&#x27;</span> : <span class=\"hljs-string\">&#x27;No&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要<code>author.books</code> 还没有发生改变，多次访问 <code>publishedBookMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。 </p>\n<p>这也同样意味着下面的计算属性将不再更新，因为 <strong>Date.now () 不是响应式依赖</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">computed: &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">now</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Date</span>.now()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p>\n<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <code>list</code>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <code>list</code>。如果没有缓存，我们将不可避免的多次执行 <code>list</code> 的 getter！如果你不希望有缓存，请用 method 来替代</p>\n<hr>\n<h2 id=\"以下为2021-09-16更新\"><a href=\"#以下为2021-09-16更新\" class=\"headerlink\" title=\"以下为2021.09.16更新\"></a>以下为2021.09.16更新</h2><h2 id=\"计算属性的-Setter\"><a href=\"#计算属性的-Setter\" class=\"headerlink\" title=\"计算属性的 Setter\"></a>计算属性的 Setter</h2><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// ...</span><br><span class=\"hljs-attr\">computed</span>: &#123;<br>  <span class=\"hljs-attr\">fullName</span>: &#123;<br>    <span class=\"hljs-comment\">// getter</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.firstName + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-built_in\">this</span>.lastName<br>    &#125;,<br>    <span class=\"hljs-comment\">// setter</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\">newValue</span>)</span> &#123;<br>      <span class=\"hljs-keyword\">const</span> names = newValue.split(<span class=\"hljs-string\">&#x27; &#x27;</span>)<br>      <span class=\"hljs-built_in\">this</span>.firstName = names[<span class=\"hljs-number\">0</span>]<br>      <span class=\"hljs-built_in\">this</span>.lastName = names[names.length - <span class=\"hljs-number\">1</span>]<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// ...</span><br></code></pre></td></tr></table></figure>\n<p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p>\n<h1 id=\"Class与Style绑定\"><a href=\"#Class与Style绑定\" class=\"headerlink\" title=\"Class与Style绑定\"></a>Class与Style绑定</h1><p>如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;div id=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;baz&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></span><br>&lt;/div&gt;<br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br>app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;</span><br><span class=\"hljs-string\">    &lt;span&gt;This is a child component&lt;/span&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h1><h2 id=\"v-if-vs-v-show\"><a href=\"#v-if-vs-v-show\" class=\"headerlink\" title=\"v-if vs v-show\"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>\n<p><code>v-if</code> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>\n<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>\n<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好</p>\n<h2 id=\"v-if-与-v-for-一起使用\"><a href=\"#v-if-与-v-for-一起使用\" class=\"headerlink\" title=\"v-if 与 v-for 一起使用\"></a>v-if 与 v-for 一起使用</h2><blockquote>\n<p>提示 不推荐同时使用 v-if 和 v-for</p>\n</blockquote>\n<p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-if</code> 具有比 <code>v-for</code> 更高的优先级。请查阅列表渲染指南以获取详细信息。</p>\n<p>当它们处于同一节点，<code>v-if</code> 的优先级比 <code>v-for</code> 更高，这意味着 <code>v-if</code> 将没有权限访问 <code>v-for</code> 里的变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;!-- This will <span class=\"hljs-keyword\">throw</span> an error because property <span class=\"hljs-string\">&quot;todo&quot;</span> is not defined on instance. --&gt;<br><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;todo in todos&quot;</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class=\"xml\">  &#123;&#123; todo &#125;&#125;</span><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>可以把 v-for 移动到<code>&lt;template&gt;</code> 标签中来修正：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;template v-<span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">&quot;todo in todos&quot;</span>&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class=\"xml\">    &#123;&#123; todo &#125;&#125;</span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n<h1 id=\"表单绑定输入\"><a href=\"#表单绑定输入\" class=\"headerlink\" title=\"表单绑定输入\"></a>表单绑定输入</h1><h2 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h2><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>\n<ul>\n<li>text 和 textarea 元素使用 value property 和 input 事件；</li>\n<li>checkbox 和 radio 使用 checked property 和 change 事件；</li>\n<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>\n</ul>\n<h1 id=\"组件基础\"><a href=\"#组件基础\" class=\"headerlink\" title=\"组件基础\"></a>组件基础</h1><h2 id=\"基本实例\"><a href=\"#基本实例\" class=\"headerlink\" title=\"基本实例\"></a>基本实例</h2><p>这里有一个 Vue 组件的示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 创建一个Vue 应用</span><br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class=\"hljs-comment\">// 定义一个名为 button-counter 的新全局组件</span><br>app.component(<span class=\"hljs-string\">&#x27;button-counter&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span><br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;button @click=&quot;count++&quot;&gt;</span><br><span class=\"hljs-string\">      You clicked me &#123;&#123; count &#125;&#125; times.</span><br><span class=\"hljs-string\">    &lt;/button&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<h2 id=\"组件的复用\"><a href=\"#组件的复用\" class=\"headerlink\" title=\"组件的复用\"></a>组件的复用</h2><p>你可以将组件进行任意次数的复用<br>每个组件都会各自独立维护它的<code>data</code>。因为你每用一次组件，就会有一个它的新组件实例被创建</p>\n<h2 id=\"在组件上使用-v-model\"><a href=\"#在组件上使用-v-model\" class=\"headerlink\" title=\"在组件上使用 v-model\"></a>在组件上使用 v-model</h2><p>自定义事件也可以用于创建支持 <code>v-model</code> 的自定义输入组件。记住：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;input v-model=<span class=\"hljs-string\">&quot;searchText&quot;</span> /&gt;<br>等价于：<br><br>&lt;input :value=<span class=\"hljs-string\">&quot;searchText&quot;</span> @input=<span class=\"hljs-string\">&quot;searchText = $event.target.value&quot;</span> /&gt;<br>当用在组件上时，v-model 则会这样：<br><br>&lt;custom-input<br>  :model-value=<span class=\"hljs-string\">&quot;searchText&quot;</span><br>  @update:model-value=<span class=\"hljs-string\">&quot;searchText = $event&quot;</span><br>&gt;&lt;/custom-input&gt;<br></code></pre></td></tr></table></figure>\n<p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code> 必须：</p>\n<p>将其 <code>value</code> attribute 绑定到一个名叫 <code>modelValue</code> 的 prop 上<br>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>update:modelValue</code> 事件抛出<br>写成代码之后是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;custom-input&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;modelValue&#x27;</span>],<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input</span><br><span class=\"hljs-string\">      :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span><br><span class=\"hljs-string\">    &gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>现在 <code>v-model</code> 就应该可以在这个组件上完美地工作起来了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;searchText&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-input</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"深入组件\"><a href=\"#深入组件\" class=\"headerlink\" title=\"深入组件\"></a>深入组件</h1><h2 id=\"非-Prop-的-Attribute\"><a href=\"#非-Prop-的-Attribute\" class=\"headerlink\" title=\"非 Prop 的 Attribute\"></a>非 Prop 的 Attribute</h2><h3 id=\"Attribute-继承\"><a href=\"#Attribute-继承\" class=\"headerlink\" title=\"Attribute 继承\"></a>Attribute 继承</h3><p>当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 <code>&lt;date-picker&gt;</code> 组件的实例中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class=\"hljs-string\">      &lt;input type=&quot;datetime&quot; /&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>如果我们需要通过 <code>data status</code> property 定义 <code>&lt;date-picker&gt;</code> 组件的状态，它将应用于根节点 (即 <code>div.date-picker</code>)。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 具有非prop attribute的Date-picker组件--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;datetime&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>同样的规则适用于事件监听器：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">&quot;submitChange&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.$attrs) <span class=\"hljs-comment\">// &#123; onChange: () =&gt; &#123;&#125;  &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;select&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;1&quot;&gt;Yesterday&lt;/option&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;2&quot;&gt;Today&lt;/option&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;3&quot;&gt;Tomorrow&lt;/option&gt;</span><br><span class=\"hljs-string\">    &lt;/select&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;demo&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">&quot;showChange&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">showChange</span>(<span class=\"hljs-params\">event</span>)</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(event.target.value) <span class=\"hljs-comment\">// 将记录所选选项的值</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"禁用-Attribute-继承\"><a href=\"#禁用-Attribute-继承\" class=\"headerlink\" title=\"禁用 Attribute 继承\"></a>禁用 Attribute 继承</h3><p>如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p>\n<p>禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。</p>\n<p>通过将 <code>inheritAttrs</code> 选项设置为 <code>false</code>，你可以访问组件的 <code>$attrs</code> property，该 property 包括组件 <code>props</code> 和 <code>emits</code> property 中未包含的所有属性 (例如，<code>class</code>、<code>style</code>、<code>v-on</code> 监听器等)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class=\"hljs-string\">      &lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>有了这个新配置，<code>data status</code> attribute 将应用于 <code>input</code> 元素！</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Date-picker 组件 使用非 prop attribute --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;datetime&quot;</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"多个根节点上的-Attribute-继承\"><a href=\"#多个根节点上的-Attribute-继承\" class=\"headerlink\" title=\"多个根节点上的 Attribute 继承\"></a>多个根节点上的 Attribute 继承</h3><p>与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-layout</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;custom-layout&quot;</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;changeValue&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-layout</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 这将发出警告</span><br>app.component(<span class=\"hljs-string\">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;header&gt;...&lt;/header&gt;</span><br><span class=\"hljs-string\">    &lt;main&gt;...&lt;/main&gt;</span><br><span class=\"hljs-string\">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 没有警告，$attrs被传递到&lt;main&gt;元素</span><br>app.component(<span class=\"hljs-string\">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;header&gt;...&lt;/header&gt;</span><br><span class=\"hljs-string\">    &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class=\"hljs-string\">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<h2 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h2><h3 id=\"处理-v-model-修饰符\"><a href=\"#处理-v-model-修饰符\" class=\"headerlink\" title=\"处理 v-model 修饰符\"></a>处理 v-model 修饰符</h3><p>在 2.x 中，我们对组件 <code>v-model</code> 上的 <code>.trim</code> 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件：</p>\n<p>让我们创建一个示例自定义修饰符 <code>capitalize</code>，它将 <code>v-model</code> 绑定提供的字符串的第一个字母大写。</p>\n<p>添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 <code>modelModifiers</code> prop。</p>\n<p>请注意，当组件的 <code>created</code> 生命周期钩子触发时，<code>modelModifiers</code> prop 包含 <code>capitalize</code>，其值为 <code>true</code>——因为它被设置在 <code>v-model</code> 绑定 <code>v-model.capitalize=&quot;bar&quot;</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model.capitalize</span>=<span class=\"hljs-string\">&quot;bar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">modelValue</span>: <span class=\"hljs-built_in\">String</span>,<br>    <span class=\"hljs-attr\">modelModifiers</span>: &#123;<br>      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input type=&quot;text&quot; </span><br><span class=\"hljs-string\">      :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;&gt;</span><br><span class=\"hljs-string\">  `</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.modelModifiers) <span class=\"hljs-comment\">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>现在我们已经设置了 prop，我们可以检查 <code>modelModifiers</code> 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 <code>&lt;input/&gt;</code> 元素触发 <code>input</code> 事件时，我们都将字符串大写。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model.capitalize</span>=<span class=\"hljs-string\">&quot;myText&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br>  &#123;&#123; myText &#125;&#125;<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-attr\">myText</span>: <span class=\"hljs-string\">&#x27;&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br><br>app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">modelValue</span>: <span class=\"hljs-built_in\">String</span>,<br>    <span class=\"hljs-attr\">modelModifiers</span>: &#123;<br>      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">emitValue</span>(<span class=\"hljs-params\">e</span>)</span> &#123;<br>      <span class=\"hljs-keyword\">let</span> value = e.target.value<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.modelModifiers.capitalize) &#123;<br>        value = value.charAt(<span class=\"hljs-number\">0</span>).toUpperCase() + value.slice(<span class=\"hljs-number\">1</span>)<br>      &#125;<br>      <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&#x27;update:modelValue&#x27;</span>, value)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;input</span><br><span class=\"hljs-string\">    type=&quot;text&quot;</span><br><span class=\"hljs-string\">    :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">    @input=&quot;emitValue&quot;&gt;`</span><br>&#125;)<br><br>app.mount(<span class=\"hljs-string\">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>对于带参数的 <code>v-model</code> 绑定，生成的 prop 名称将为 <code>arg + &quot;Modifiers&quot;</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model:foo.capitalize</span>=<span class=\"hljs-string\">&quot;bar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;foo&#x27;</span>, <span class=\"hljs-string\">&#x27;fooModifiers&#x27;</span>],<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input type=&quot;text&quot; </span><br><span class=\"hljs-string\">      :value=&quot;foo&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:foo&#x27;, $event.target.value)&quot;&gt;</span><br><span class=\"hljs-string\">  `</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.fooModifiers) <span class=\"hljs-comment\">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"2021-09-17更新\"><a href=\"#2021-09-17更新\" class=\"headerlink\" title=\"2021.09.17更新\"></a>2021.09.17更新</h2><h2 id=\"提供-注入\"><a href=\"#提供-注入\" class=\"headerlink\" title=\"提供/注入\"></a>提供/注入</h2><p>通常，当我们需要将数据从父组件传递到子组件时，我们使用<code>props</code>。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。</p>\n<p>对于这种情况，我们可以使用 <code>provide</code> 和 <code>inject</code> 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这个数据。</p>\n<h1 id=\"可复用-amp-组合\"><a href=\"#可复用-amp-组合\" class=\"headerlink\" title=\"可复用&amp;组合\"></a>可复用&amp;组合</h1><h2 id=\"渲染函数\"><a href=\"#渲染函数\" class=\"headerlink\" title=\"渲染函数\"></a>渲染函数</h2><h3 id=\"虚拟DOM树\"><a href=\"#虚拟DOM树\" class=\"headerlink\" title=\"虚拟DOM树\"></a>虚拟DOM树</h3><p>Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">return</span> Vue.h(<span class=\"hljs-string\">&#x27;h1&#x27;</span>, &#123;&#125;, <span class=\"hljs-built_in\">this</span>.blogTitle)<br></code></pre></td></tr></table></figure>\n<p><code>h()</code> 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 <strong>VNode</strong>。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p>\n<h3 id=\"h-参数\"><a href=\"#h-参数\" class=\"headerlink\" title=\"h()参数\"></a>h()参数</h3><p>h() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">h(<br>  <span class=\"hljs-comment\">// &#123;String | Object | Function | null&#125; tag</span><br>  <span class=\"hljs-comment\">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span><br>  <span class=\"hljs-comment\">// 使用 null 将会渲染一个注释。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 必需的。</span><br>  <span class=\"hljs-string\">&#x27;div&#x27;</span>,<br><br>  <span class=\"hljs-comment\">// &#123;Object&#125; props</span><br>  <span class=\"hljs-comment\">// 与 attribute、prop 和事件相对应的对象。</span><br>  <span class=\"hljs-comment\">// 我们会在模板中使用。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 可选的。</span><br>  &#123;&#125;,<br><br>  <span class=\"hljs-comment\">// &#123;String | Array | Object&#125; children</span><br>  <span class=\"hljs-comment\">// 子 VNodes, 使用 `h()` 构建,</span><br>  <span class=\"hljs-comment\">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span><br>  <span class=\"hljs-comment\">// 有 slot 的对象。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 可选的。</span><br>  [<br>    <span class=\"hljs-string\">&#x27;Some text comes first.&#x27;</span>,<br>    h(<span class=\"hljs-string\">&#x27;h1&#x27;</span>, <span class=\"hljs-string\">&#x27;A headline&#x27;</span>),<br>    h(MyComponent, &#123;<br>      <span class=\"hljs-attr\">someProp</span>: <span class=\"hljs-string\">&#x27;foobar&#x27;</span><br>    &#125;)<br>  ]<br>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"完整实例\"><a href=\"#完整实例\" class=\"headerlink\" title=\"完整实例\"></a>完整实例</h3><p>有了这些知识，我们现在可以完成我们最开始想实现的组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class=\"hljs-comment\">/** Recursively get text from children nodes */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getChildrenTextContent</span>(<span class=\"hljs-params\">children</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> children<br>    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">node</span> =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> node.children === <span class=\"hljs-string\">&#x27;string&#x27;</span><br>        ? node.children<br>        : <span class=\"hljs-built_in\">Array</span>.isArray(node.children)<br>        ? getChildrenTextContent(node.children)<br>        : <span class=\"hljs-string\">&#x27;&#x27;</span><br>    &#125;)<br>    .join(<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>&#125;<br><br>app.component(<span class=\"hljs-string\">&#x27;anchored-heading&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-comment\">// create kebab-case id from the text contents of the children</span><br>    <span class=\"hljs-keyword\">const</span> headingId = getChildrenTextContent(<span class=\"hljs-built_in\">this</span>.$slots.default())<br>      .toLowerCase()<br>      .replace(<span class=\"hljs-regexp\">/\\W+/g</span>, <span class=\"hljs-string\">&#x27;-&#x27;</span>) <span class=\"hljs-comment\">// replace non-word characters with dash</span><br>      .replace(<span class=\"hljs-regexp\">/(^-|-$)/g</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-comment\">// remove leading and trailing dashes</span><br><br>    <span class=\"hljs-keyword\">return</span> Vue.h(<span class=\"hljs-string\">&#x27;h&#x27;</span> + <span class=\"hljs-built_in\">this</span>.level, [<br>      Vue.h(<br>        <span class=\"hljs-string\">&#x27;a&#x27;</span>,<br>        &#123;<br>          <span class=\"hljs-attr\">name</span>: headingId,<br>          <span class=\"hljs-attr\">href</span>: <span class=\"hljs-string\">&#x27;#&#x27;</span> + headingId<br>        &#125;,<br>        <span class=\"hljs-built_in\">this</span>.$slots.default()<br>      )<br>    ])<br>  &#125;,<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">level</span>: &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,<br>      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>"},{"title":"本博客说明书","date":"2021-09-07T03:19:02.000Z","comments":1,"_content":"{% blockquote %}\n幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔\n{% endblockquote %}\n\n19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。\n所以我又重新搭了一个。\n后续会把写过的文档陆续上传到这边\n\n以下是功能测试：\n\n嵌入YOUTUBE视频\n{% youtube lJIrF4YjHfQ %}\n\n嵌入B站视频\n{% raw %}\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n<iframe src=\"//player.bilibili.com/player.html?aid=846655043&bvid=BV1e54y1n7XK&cid=371989206&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\"allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; Left: 0; top: 0;\"> </iframe></div>\n{% endraw %}\n\n\n嵌入图片\n![背景图](/img/bg/bg.jpg)\n![长颈鹿](/img/user/zoo.jpeg)\n\n\n代码块\n```javaScript\nconsole.log('zouHuaLu')\nhexo g\nhexo g -w\nhexo server\nhexo clean\nhexo deploy\n```\n\n如果你看到`We were unable to load Disqus. If you are a moderator please see our troubleshooting guide.`,说明本博客的评论功能有问题，后续有时间再改吧","source":"_posts/about-me.md","raw":"---\ntitle: 本博客说明书\ndate: 2021-09-07 11:19:02\ntags: 博客说明\ncategories: 博客说明\ncomments: true\n---\n{% blockquote %}\n幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔\n{% endblockquote %}\n\n19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。\n所以我又重新搭了一个。\n后续会把写过的文档陆续上传到这边\n\n以下是功能测试：\n\n嵌入YOUTUBE视频\n{% youtube lJIrF4YjHfQ %}\n\n嵌入B站视频\n{% raw %}\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n<iframe src=\"//player.bilibili.com/player.html?aid=846655043&bvid=BV1e54y1n7XK&cid=371989206&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\"allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; Left: 0; top: 0;\"> </iframe></div>\n{% endraw %}\n\n\n嵌入图片\n![背景图](/img/bg/bg.jpg)\n![长颈鹿](/img/user/zoo.jpeg)\n\n\n代码块\n```javaScript\nconsole.log('zouHuaLu')\nhexo g\nhexo g -w\nhexo server\nhexo clean\nhexo deploy\n```\n\n如果你看到`We were unable to load Disqus. If you are a moderator please see our troubleshooting guide.`,说明本博客的评论功能有问题，后续有时间再改吧","slug":"about-me","published":1,"updated":"2021-09-09T01:43:34.046Z","layout":"post","photos":[],"link":"","_id":"cktmsffg2000sfkvq0i3gbsdv","content":"<blockquote><p>幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔</p>\n</blockquote>\n\n<p>19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。<br>所以我又重新搭了一个。<br>后续会把写过的文档陆续上传到这边</p>\n<p>以下是功能测试：</p>\n<p>嵌入YOUTUBE视频</p>\n<div class=\"video-container\"><iframe src=\"https://www.youtube.com/embed/lJIrF4YjHfQ\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe></div>\n\n<p>嵌入B站视频</p>\n\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n<iframe src=\"//player.bilibili.com/player.html?aid=846655043&bvid=BV1e54y1n7XK&cid=371989206&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\"allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; Left: 0; top: 0;\"> </iframe></div>\n\n\n\n<p>嵌入图片<br><img src=\"/img/bg/bg.jpg\" alt=\"背景图\"><br><img src=\"/img/user/zoo.jpeg\" alt=\"长颈鹿\"></p>\n<p>代码块</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javaScript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>hexo g<br>hexo g -w<br>hexo server<br>hexo clean<br>hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>如果你看到<code>We were unable to load Disqus. If you are a moderator please see our troubleshooting guide.</code>,说明本博客的评论功能有问题，后续有时间再改吧</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote><p>幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔</p>\n</blockquote>\n\n<p>19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。<br>所以我又重新搭了一个。<br>后续会把写过的文档陆续上传到这边</p>\n<p>以下是功能测试：</p>\n<p>嵌入YOUTUBE视频</p>\n<div class=\"video-container\"><iframe src=\"https://www.youtube.com/embed/lJIrF4YjHfQ\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe></div>\n\n<p>嵌入B站视频</p>\n\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n<iframe src=\"//player.bilibili.com/player.html?aid=846655043&bvid=BV1e54y1n7XK&cid=371989206&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\"allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; Left: 0; top: 0;\"> </iframe></div>\n\n\n\n<p>嵌入图片<br><img src=\"/img/bg/bg.jpg\" alt=\"背景图\"><br><img src=\"/img/user/zoo.jpeg\" alt=\"长颈鹿\"></p>\n<p>代码块</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javaScript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>hexo g<br>hexo g -w<br>hexo server<br>hexo clean<br>hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>如果你看到<code>We were unable to load Disqus. If you are a moderator please see our troubleshooting guide.</code>,说明本博客的评论功能有问题，后续有时间再改吧</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cktmsfffk0001fkvq8vd792a3","category_id":"cktmsfffp0004fkvqcg6tgo0k","_id":"cktmsfffw000cfkvq80kzfv42"},{"post_id":"cktmsfffn0003fkvq56qw3m2t","category_id":"cktmsfffp0004fkvqcg6tgo0k","_id":"cktmsfffx000ffkvq7cm2a0m8"},{"post_id":"cktmsfffr0006fkvqacqsa0w8","category_id":"cktmsfffw000bfkvqf3asbdwm","_id":"cktmsfffy000jfkvqgeoofovq"},{"post_id":"cktmsfffs0007fkvq01nxdc7i","category_id":"cktmsfffx000gfkvqbc1h6efd","_id":"cktmsfffy000mfkvqclgoai0k"},{"post_id":"cktmsffg0000ofkvq77idgpkm","category_id":"cktmsffg1000qfkvq3pl9699s","_id":"cktmsffg3000vfkvqbguf80as"},{"post_id":"cktmsffg1000pfkvq6hqseosg","category_id":"cktmsffg3000tfkvqebfq0zcu","_id":"cktmsffg4000yfkvq3asv4mox"},{"post_id":"cktmsffg2000sfkvq0i3gbsdv","category_id":"cktmsffg3000wfkvqhfpadyse","_id":"cktmsffg40012fkvq0ip082k4"}],"PostTag":[{"post_id":"cktmsfffk0001fkvq8vd792a3","tag_id":"cktmsfffq0005fkvq3atw4rdp","_id":"cktmsfffv000afkvq6bdk0e94"},{"post_id":"cktmsfffn0003fkvq56qw3m2t","tag_id":"cktmsfffq0005fkvq3atw4rdp","_id":"cktmsfffx000efkvq7pszb0dn"},{"post_id":"cktmsfffr0006fkvqacqsa0w8","tag_id":"cktmsfffw000dfkvqcvxsftlw","_id":"cktmsfffy000kfkvq58sb5n7d"},{"post_id":"cktmsfffr0006fkvqacqsa0w8","tag_id":"cktmsfffx000hfkvq88nfd81m","_id":"cktmsfffy000lfkvq2mv3e460"},{"post_id":"cktmsfffs0007fkvq01nxdc7i","tag_id":"cktmsfffy000ifkvqhqcbdzd9","_id":"cktmsfffy000nfkvqcwl7ef81"},{"post_id":"cktmsffg0000ofkvq77idgpkm","tag_id":"cktmsffg2000rfkvq75p9enoe","_id":"cktmsffg40010fkvq107c536c"},{"post_id":"cktmsffg0000ofkvq77idgpkm","tag_id":"cktmsffg3000ufkvqdk3y4xx4","_id":"cktmsffg40011fkvqbnptcta6"},{"post_id":"cktmsffg0000ofkvq77idgpkm","tag_id":"cktmsffg4000xfkvq76b5eo7y","_id":"cktmsffg50014fkvq14skfns8"},{"post_id":"cktmsffg1000pfkvq6hqseosg","tag_id":"cktmsffg4000zfkvq6vpm6j64","_id":"cktmsffg50015fkvqdy4e2e6b"},{"post_id":"cktmsffg2000sfkvq0i3gbsdv","tag_id":"cktmsffg40013fkvqa3ps2zgx","_id":"cktmsffg50016fkvq9wnrejdn"}],"Tag":[{"name":"TypeScript","_id":"cktmsfffq0005fkvq3atw4rdp"},{"name":"浮生一日","_id":"cktmsfffw000dfkvqcvxsftlw"},{"name":"日常","_id":"cktmsfffx000hfkvq88nfd81m"},{"name":"课程","_id":"cktmsfffy000ifkvqhqcbdzd9"},{"name":"人生的智慧","_id":"cktmsffg2000rfkvq75p9enoe"},{"name":"叔本华","_id":"cktmsffg3000ufkvqdk3y4xx4"},{"name":"哲学","_id":"cktmsffg4000xfkvq76b5eo7y"},{"name":"Vue3","_id":"cktmsffg4000zfkvq6vpm6j64"},{"name":"博客说明","_id":"cktmsffg40013fkvqa3ps2zgx"}]}}
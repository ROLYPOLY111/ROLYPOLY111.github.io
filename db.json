{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":1,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/20210911/AirPods.jpeg","path":"img/20210911/AirPods.jpeg","modified":1,"renderable":0},{"_id":"source/img/20210911/pic2.jpeg","path":"img/20210911/pic2.jpeg","modified":1,"renderable":0},{"_id":"source/img/20210911/pic1.jpeg","path":"img/20210911/pic1.jpeg","modified":1,"renderable":0},{"_id":"source/img/20210911/图片.jpeg","path":"img/20210911/图片.jpeg","modified":1,"renderable":0},{"_id":"source/img/20210913/renshengdezhihui.png","path":"img/20210913/renshengdezhihui.png","modified":1,"renderable":0},{"_id":"source/img/20210913/renshengdezhihui2.png","path":"img/20210913/renshengdezhihui2.png","modified":1,"renderable":0},{"_id":"source/img/bg/benjamin.jpeg","path":"img/bg/benjamin.jpeg","modified":1,"renderable":0},{"_id":"source/img/bg/bg1.jpg","path":"img/bg/bg1.jpg","modified":1,"renderable":0},{"_id":"source/img/bg/bg2.jpg","path":"img/bg/bg2.jpg","modified":1,"renderable":0},{"_id":"source/img/bg/bg3.jpg","path":"img/bg/bg3.jpg","modified":1,"renderable":0},{"_id":"source/img/bg/bg4.jpg","path":"img/bg/bg4.jpg","modified":1,"renderable":0},{"_id":"source/img/bg/shashou.jpeg","path":"img/bg/shashou.jpeg","modified":1,"renderable":0},{"_id":"source/img/bg/zhimingyuchunjiao.jpeg","path":"img/bg/zhimingyuchunjiao.jpeg","modified":1,"renderable":0},{"_id":"source/img/bg/tianruoyouqing.jpeg","path":"img/bg/tianruoyouqing.jpeg","modified":1,"renderable":0},{"_id":"source/img/user/bilibili.jpeg","path":"img/user/bilibili.jpeg","modified":1,"renderable":0},{"_id":"source/img/user/jianshu.jpeg","path":"img/user/jianshu.jpeg","modified":1,"renderable":0},{"_id":"source/img/user/user.jpg","path":"img/user/user.jpg","modified":1,"renderable":0},{"_id":"source/img/user/user1.png","path":"img/user/user1.png","modified":1,"renderable":0},{"_id":"source/img/user/wazi.png","path":"img/user/wazi.png","modified":1,"renderable":0},{"_id":"source/img/user/weChat.jpg","path":"img/user/weChat.jpg","modified":1,"renderable":0},{"_id":"source/img/user/webo.jpg","path":"img/user/webo.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"61e7919ef45b0fd313fcb2de41b7021f7ccbf47b","modified":1632386175708},{"_id":"source/baidu_verify_code-TmkkRxX4ps.html","hash":"59ea65a0795dc0964e8b356cb89b666fef6e1a53","modified":1631151814047},{"_id":"source/_posts/2021-09-11-浮生一日.md","hash":"4e376a776914285e79b16f7ed280aa665bc2e399","modified":1637226056110},{"_id":"source/.DS_Store","hash":"19332cfdf39a2776f27d87208af7b99819d9425f","modified":1631151814046},{"_id":"source/_posts/2021-09-09-TypeScript中类的理解.md","hash":"e308ebb054af702062bc20534344f00c6492f4d0","modified":1631172900949},{"_id":"source/_posts/2021-09-13-叔本华《人生的智慧》第一章节.md","hash":"2ab4ea0cb8a86bfdb1f2ae7ac7438e83335452a2","modified":1634114698314},{"_id":"source/_posts/2021-09-12-web设计模式解析与实战.md","hash":"a2e136a9f1ebcf90b76fabfef8b612977643e296","modified":1633662665384},{"_id":"source/_posts/2021-09-10-TypeScript中函数的理解.md","hash":"8e9a73fcd541ec49244f4ada6837c61b75fc514c","modified":1631264607141},{"_id":"source/_posts/2021-09-23-JavaScript中的堆栈以及数据类型.md","hash":"8f11e7bca4acdf842df5e1e850dfc8214810f46f","modified":1633662715650},{"_id":"source/_posts/2021-09-23-Vue自定义全局组件.md","hash":"4698d7ba81c3877bcdb830c5c89c7f45d85dfd84","modified":1632363995030},{"_id":"source/_posts/2021-09-23-export与export-default的区别.md","hash":"68e9ae7e85c15405af92819f3a387b0151b4e744","modified":1633662682166},{"_id":"source/_posts/2021-09-23-原型与原型链与constructor.md","hash":"ddb4f9a166f6984c606ee229730e4e71737facfd","modified":1634114746967},{"_id":"source/_posts/2021-09-15-vue3文档记录.md","hash":"bac16fa39b89ee7aeec60e0af9c56918626e6973","modified":1631875319128},{"_id":"source/_posts/2021-09-25-Vue3-一.md","hash":"730ddef00fc1e6cc6e99bca9030d25606eceeae2","modified":1632622598702},{"_id":"source/_posts/2021-09-23-栈与队列的理解以及应用场景.md","hash":"d848b1932b35ea3cd6bb33ebf7aab4178591859d","modified":1633662598345},{"_id":"source/_posts/2021-09-25-浮生一日-最爱的电影.md","hash":"e612bb2181f870bfe3801fb6e7ce1311325433e5","modified":1637226036337},{"_id":"source/_posts/2021-09-23-new操作符的实现.md","hash":"b6297324ae74d5ab10044772892d13c71d2639cf","modified":1634114529247},{"_id":"source/_posts/2021-10-08-互联网是如何运作的.md","hash":"d3cf0f5d9e7b19f6424a5ae2d58fe62930e62506","modified":1634114812438},{"_id":"source/_posts/2021-10-13-深入理解javascript之typeof和instanceof.md","hash":"044e49afac8ab1c0408c33fdf18b66ffb095017c","modified":1634114593089},{"_id":"source/_posts/2021-10-20-Array数组的一些发现.md","hash":"4d6c682e18cf90e29724fdbc3904eb72b8864c6d","modified":1634710421777},{"_id":"source/_posts/2021-10-21-call-apply和bind.md","hash":"e7fcd5d36896e1689ba0aaacf7c04e0b031b3f56","modified":1634787472895},{"_id":"source/_posts/2021-11-18-最近在忙什么.md","hash":"f2eef784f860ee06371961c94dc59c550645d7d4","modified":1637226366763},{"_id":"source/_posts/2021-11-29-create-react-app-搭建项目踩坑记录.md","hash":"d44bce72342515a1ee7b5476592a9e631dc661ad","modified":1638326737400},{"_id":"source/_posts/2021-12-02-git-rebase-用法.md","hash":"41d820f62201b49008674d250cec0215f4b329a7","modified":1639026421370},{"_id":"source/about/index.md","hash":"07cec388cba95d1c06886b4d9f31a15821ca8e65","modified":1632383928894},{"_id":"source/_posts/2021-09-27-leetcode每日算法（2021-09-27）.md","hash":"f7e14949d403275c20510271dd8a66b2c215de62","modified":1632795852490},{"_id":"source/_posts/2021-10-14-JavaScript事件循环.md","hash":"70be1cfb50b0216a0bc5034b61a9e4b749f1ecf1","modified":1634183479548},{"_id":"source/_posts/2021-10-31-Node-js学习记录.md","hash":"ef65dde4546b50f7196578120a0a201163488b77","modified":1635739270333},{"_id":"source/_posts/about-me.md","hash":"7ce3bdd9978dd3a10d5d307770cc91ced5b41502","modified":1632622881380},{"_id":"source/img/.DS_Store","hash":"9ce77c9f9c098f72174548c7e3ec2e4a75e20803","modified":1631703679023},{"_id":"source/img/user/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1631703679061},{"_id":"source/img/bg/zhimingyuchunjiao.jpeg","hash":"03f9c96b520c0976c03c5bc45901b0c0e64b1c4d","modified":1631703679058},{"_id":"source/img/user/jianshu.jpeg","hash":"e3f77ae1071b74c68f0a7237850a3dc7a41a9936","modified":1631012709659},{"_id":"source/img/user/wazi.png","hash":"a6489d50d8b4fa846cbfd4ae094897586f5b5d76","modified":1636023241685},{"_id":"source/img/20210911/AirPods.jpeg","hash":"8601c573436498d33b4016f948869ad8de42c543","modified":1631703679024},{"_id":"source/img/20210911/pic1.jpeg","hash":"dc36460fc6f228a5f85c9906359a3e777ec4f9ea","modified":1631703679026},{"_id":"source/img/bg/benjamin.jpeg","hash":"83c5636568ee5c2fe4602edf4a418414d242d155","modified":1631703679054},{"_id":"source/img/bg/bg4.jpg","hash":"e766eb50706a9f2a10fc25ba479bfb7944cfb9dc","modified":1636078507472},{"_id":"source/img/bg/bg1.jpg","hash":"026a9e6ef05b063cf0c62142634d092b5e7015db","modified":1636078423569},{"_id":"source/img/bg/tianruoyouqing.jpeg","hash":"c03c2d638c9858b48791019759e06f54c57f3730","modified":1631703679057},{"_id":"source/img/user/weChat.jpg","hash":"1c490e9ab2206003f6d84446bf8dc347b2d416ef","modified":1631012709662},{"_id":"source/img/20210911/pic2.jpeg","hash":"e66ac1c464555050a5e57d610d41df3ea2300772","modified":1631703679028},{"_id":"source/img/20210911/图片.jpeg","hash":"ce86726a54981795d8a5f6cc166af0b2ed050afb","modified":1631703679030},{"_id":"source/img/bg/bg2.jpg","hash":"4df0a1e43accbb1a2c5fa6e2c26e324d7c280499","modified":1636078502399},{"_id":"source/img/user/bilibili.jpeg","hash":"2a1493d349d20f5b682a43639104ceeda3734ba1","modified":1631012709659},{"_id":"source/img/bg/bg3.jpg","hash":"43ea9f0ae1c75b0edf7623cb0ff57fbc545fe3c5","modified":1636078505270},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"dac9d10d95b9e179e8cd7c439300b450db51f0c2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"76c2cf56f16dccb2fc057977f9dd7b39800a5cb4","modified":1630999001319},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"6cbd88a2ef9dd2198d72ccc1899c4966ac5f49f9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"a154785aef120988d29409847977f24069d3a3d5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"9d6ff8772bf54d7458ae4e846e5a2d1f2921b8a7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"19c6db0ccebc8f59fa4ef9567a066b33223eccd6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/gulpfile.js","hash":"a7c87a83becf7080bddd14e81a6f09ce8c3df109","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"523b9db3801ca892124502c17d72864457cc4b21","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/lint.yaml","hash":"64d521c9c5b61d3a4852c74894fb574082dc7009","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"8723aa57f61134a2c1dc84cc7ea88ea366f4fda3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"6ec30a9dd56341590af07f4227324f619025c109","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"cdcb607f1104543a42beda647f3c9cf0f3d11623","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"9328ebe2abbe00f82cd6f701230e80e04618ade0","modified":1631093425550},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"39e63b3e1502803c9e8ea0c44ea662a7bbe15744","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"245f49aad0e4124b52aa82d981281ad9c871f1f8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"3e0fa1731b6e54dbcf52ccf8e200e83dc4549bfa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"b3d93135d9ae74f006da31ec54343308bbd77cb5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"606131cb807846bf43776a9073fcc1473d359ec9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"cc712fc71bf33d561e1ba74fe1d52d2353092171","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"b7985ac3cff9ee2722db43ee6b32b5484c43f5f2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"725a1fe23c672fca87edc57739b748c3adf705da","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"fb4502fc9204284f8b4e8dabde8477d478e826e5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"ffe08e76c9ebd4fc27715b8a60f385b3f10d0348","modified":1631097677877},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"9238063c5e2928bb6fce2b99cd25ad85e78c4d1c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"5b61661fbc65752f54f99402077dbb03044149a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"ab71df2e56b60e8e193ff827e81704e5b358a977","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"deed966f38cf0c8dee3f72e5b1f2e878510db0e1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"a2d08e3b9f98b6371b2e64d664f079c99571494b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"342b1fbc30d1465687ce389a4e07f967266d5d86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"9d492fab9c26311ad0ab553c890e09b9575a76f2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"26d29403d8ecb0b533e63bde3ca73b2c91f171ff","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"bf00f5786bb8de7241f635455b67243d26656222","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"dabd87267d60240c0daea0f35a46f30ee1b2337a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"32fb938d72b2d86159cb315a98b086bd17fa4415","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"ad7dcc8a060d94d3c44ca5e0788a24ca38be0f79","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"3a6b4f8a29648d9d2c1e99b52a7b42df3f15cf62","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"4c6fffc6d4a3b8830931800ee7da99dccf1be36e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"461d609a802a4f9aa9f492411ed8074813a956b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"source/img/user/user.jpg","hash":"5a1c8f2385741605649bacf36bfe84f3d0b7983a","modified":1631012709660},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"35539a1ce8476e75515015a06d01ec66e4af6834","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"766fcf017deb4c8b0c260ac4c8d2e3489407ad89","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":499162500000},{"_id":"source/img/20210913/renshengdezhihui.png","hash":"7981415b28a16c4ac3fc282c53b488c779a7eacc","modified":1631703679039},{"_id":"source/img/20210913/renshengdezhihui2.png","hash":"b217a9b7523a7300876a97bf32959f678794ed38","modified":1631703679053},{"_id":"source/img/user/user1.png","hash":"de768c0d778b4ce91d17a4fa6643fcdaecc0d960","modified":1633664711410},{"_id":"source/img/user/webo.jpg","hash":"e13a0af612e0944a2014104058242b4fbebe8e56","modified":1631012709670},{"_id":"source/img/bg/shashou.jpeg","hash":"b6fccd7c1c535c73c3f374583d0bd26daa84874a","modified":1632362634037},{"_id":"public/baidu_verify_code-TmkkRxX4ps.html","hash":"e38c85c4546a055dfa8e38926f8b25a657ab1c3d","modified":1639026456064},{"_id":"public/baidu_urls.txt","hash":"5cbee089033964b3cdfb92b6121b45a3aa8b5f89","modified":1639026456064},{"_id":"public/baidusitemap.xml","hash":"0ea7aab0083543ced07ebc43bf7b8512ec104c2d","modified":1639026456064},{"_id":"public/content.json","hash":"49dc99ec80c871af260188355048df17effb4627","modified":1639026456064},{"_id":"public/sitemap.xml","hash":"a9aae4d16303e9f806c89aca74c10d6224bffff0","modified":1639026456064},{"_id":"public/local-search.xml","hash":"e8645e5e55bf71e39409cdfc59f05a4946285c9e","modified":1639026456064},{"_id":"public/about/index.html","hash":"7db9c420dcef45af411e11fd28ccfb3f8786b340","modified":1639026456064},{"_id":"public/20211118/最近在忙什么/index.html","hash":"6dedd6e406577d7a69659a507be053a2654be6fa","modified":1639026456064},{"_id":"public/20210925/浮生一日-最爱的电影/index.html","hash":"c329557a7b7ad0dd852ca99c0fc83d241d416bc2","modified":1639026456064},{"_id":"public/20210916/Vue3-一/index.html","hash":"64d4d85e56dab685e0cac96ab63aca5c2836cf8b","modified":1639026456064},{"_id":"public/20210912/web设计模式解析与实战/index.html","hash":"6a8e3a9bbb29bb760e509cc6e46e68e85b2aed65","modified":1639026456064},{"_id":"public/20210911/浮生一日/index.html","hash":"53e6d7f8757392d8318f8f7c60a96193dc33e1c0","modified":1639026456064},{"_id":"public/20210907/about-me/index.html","hash":"b287d32332d9e53a37f56a5ce2036d610d9d46cf","modified":1639026456064},{"_id":"public/archives/index.html","hash":"55be164f16c89579ec57b318759a38ec9175c602","modified":1639026456064},{"_id":"public/archives/page/2/index.html","hash":"83ecf4b92586563725a6165905a9c9f3eee5537c","modified":1639026456064},{"_id":"public/archives/page/3/index.html","hash":"220d944f687544a905bcdb871225d3a57812ec8e","modified":1639026456064},{"_id":"public/archives/2021/index.html","hash":"1565412b0af94e57919688409614042c88367639","modified":1639026456064},{"_id":"public/archives/2021/page/2/index.html","hash":"b0117047e17544b2d6e0d0469d1452001aee57d6","modified":1639026456064},{"_id":"public/archives/2021/page/3/index.html","hash":"18ec4f79e3bcb2b92725797c3661611a3fced237","modified":1639026456064},{"_id":"public/archives/2021/06/index.html","hash":"428fc11ec1416d2e9b99e37ca0fb1127f377797a","modified":1639026456064},{"_id":"public/archives/2021/07/index.html","hash":"e49354cb2fba39195d9cad2fc9407590dc6a4aca","modified":1639026456064},{"_id":"public/archives/2021/09/index.html","hash":"19e8a9d4c017affc47b597d887795fdd40e910b4","modified":1639026456064},{"_id":"public/archives/2021/09/page/2/index.html","hash":"2a53fb47441b62b3a486cce1e8e6055b365a868d","modified":1639026456064},{"_id":"public/archives/2021/10/index.html","hash":"7cc32a10781218d9a883eabf95252fe9741aad92","modified":1639026456064},{"_id":"public/archives/2021/11/index.html","hash":"98be57df7deaadb7b1942bdb85fde64a20bfebbd","modified":1639026456064},{"_id":"public/archives/2021/12/index.html","hash":"88916a8ca6c6275d0107c99ec27580763f4771a2","modified":1639026456064},{"_id":"public/categories/技术类-TypeScript/index.html","hash":"9f3038af951c0178bd6d4c9910615e5fcc120c39","modified":1639026456064},{"_id":"public/categories/日常/index.html","hash":"3883110171fd067463ce4d449c24c0a4358caeb5","modified":1639026456064},{"_id":"public/categories/技术类-前端/index.html","hash":"7b995faf322a0e2c82997d8b92b202d39cd70ad2","modified":1639026456064},{"_id":"public/categories/阅读/index.html","hash":"8318877e93894e734a9ddcf66c56e20514128399","modified":1639026456064},{"_id":"public/categories/技术类-Vue/index.html","hash":"55603c750778fbb888024fd574d08135ef1b6e2b","modified":1639026456064},{"_id":"public/categories/计算机基础/index.html","hash":"caf4e05b6d8e03c2c798a51c95dbd6bb9df69adf","modified":1639026456064},{"_id":"public/categories/算法类/index.html","hash":"47382251992d3a1001e9c63588811f2a8b4b8eb4","modified":1639026456064},{"_id":"public/categories/技术类-后端/index.html","hash":"dc9c9819cff6383a3f26e1f60bb508665cb1a70d","modified":1639026456064},{"_id":"public/categories/技术类-React/index.html","hash":"07ccc6a0038662a46a82a389d16dbbb60d7bbaef","modified":1639026456064},{"_id":"public/categories/博客说明/index.html","hash":"39831222a883c6a2527658e70520f0b5d064146c","modified":1639026456064},{"_id":"public/tags/TypeScript/index.html","hash":"0fa9068918a35733f59698c758509b25751a13e3","modified":1639026456064},{"_id":"public/tags/日常/index.html","hash":"8493db900ffbb0e6a7e17a8c0e43960f02eeca3c","modified":1639026456064},{"_id":"public/tags/课程/index.html","hash":"dadaf7092ea60622dd90d5f7d74822b657c0f686","modified":1639026456064},{"_id":"public/tags/阅读/index.html","hash":"c1e0e98d2ea931c0527b4ef70d2cf6c6680b6b1b","modified":1639026456064},{"_id":"public/tags/Vue3/index.html","hash":"c9bc9ef8b24065375660f5ee539029b107ed7705","modified":1639026456064},{"_id":"public/tags/JavaScript/index.html","hash":"99770344e39e661b0744fa93de19b171238dbce7","modified":1639026456064},{"_id":"public/tags/ES6/index.html","hash":"32e894d44860a3512e10afa7ff16d32a285905b1","modified":1639026456064},{"_id":"public/tags/面试/index.html","hash":"59f8db0315bdf5111f548735da3a6c19a166391f","modified":1639026456064},{"_id":"public/tags/计算机基础/index.html","hash":"9725cd0246224c16282b814d090d54366665e615","modified":1639026456064},{"_id":"public/tags/算法/index.html","hash":"7d414992caf76c014878b916087d12a1a3ff854b","modified":1639026456064},{"_id":"public/tags/leetcode/index.html","hash":"deb4fa8a2d286626e1626967a7a7e7e33f5e5271","modified":1639026456064},{"_id":"public/tags/Node-js/index.html","hash":"d8824febc3efad4c5c595599ee0bf0f688772f20","modified":1639026456064},{"_id":"public/tags/React/index.html","hash":"cb9101f048c5a8ce3037ca1ba8db9ac981dda744","modified":1639026456064},{"_id":"public/tags/博客说明/index.html","hash":"6b7f050a07b5873e743de0911ace767a3b814809","modified":1639026456064},{"_id":"public/404.html","hash":"5a9d9f98645aa083f3075314c14085f3f3f106f1","modified":1639026456064},{"_id":"public/tags/index.html","hash":"51a9daba4cf18486170bc0a7f1d83b9bc1e4ca67","modified":1639026456064},{"_id":"public/links/index.html","hash":"ea60677aa62da8c8c3a02b814968fe1a11972568","modified":1639026456064},{"_id":"public/20211202/git-rebase-用法/index.html","hash":"d3b06a80c9375587e63cea88d1b7404d486a700e","modified":1639026456064},{"_id":"public/20211129/create-react-app-搭建项目踩坑记录/index.html","hash":"b64f7a08efcce481deae3ceacfa037025dd24e23","modified":1639026456064},{"_id":"public/20211031/Node-js学习记录/index.html","hash":"7ec02924f37cdccb4a99d95dcfda3d47447de3ac","modified":1639026456064},{"_id":"public/20211021/call-apply和bind/index.html","hash":"b2959305a5073b1ea9ef126cfb99377a204e86f3","modified":1639026456064},{"_id":"public/20211020/Array数组的一些发现/index.html","hash":"8f6123e9df45ea8dbf41871073a27733c344e965","modified":1639026456064},{"_id":"public/20211014/JavaScript事件循环/index.html","hash":"dc77c1bdd69980f19486ba29b9fcbacb305e98ad","modified":1639026456064},{"_id":"public/20211013/深入理解javascript之typeof和instanceof/index.html","hash":"43b14eb88b8a9955ff86f7828e6a61e28287ecb7","modified":1639026456064},{"_id":"public/20211007/互联网是如何运作的/index.html","hash":"ac7ac7abf037779b296b22b45ea27f203d2304ef","modified":1639026456064},{"_id":"public/20210927/leetcode每日算法（2021-09-27）/index.html","hash":"390eec82526f7a1abf691417359dc77fd2793ca9","modified":1639026456064},{"_id":"public/20210923/栈与队列的理解以及应用场景/index.html","hash":"1d4c7732ba6d47c62b3441565544ba41ac8023f6","modified":1639026456064},{"_id":"public/20210915/vue3文档记录/index.html","hash":"ebc6f831664cb3b42a55562fc31f41818ffbb880","modified":1639026456064},{"_id":"public/20210913/叔本华《人生的智慧》第一章节/index.html","hash":"8d6c1d7ae1b9713831f6ea1399b31db266eb84bc","modified":1639026456064},{"_id":"public/20210910/TypeScript中函数的理解/index.html","hash":"3a45d2db89d4152082b90ff10e1b85f0c6c10627","modified":1639026456064},{"_id":"public/20210906/TypeScript中类的理解/index.html","hash":"04a2ea8a401cf6b8b4e5ca4847850cc9d4766b4d","modified":1639026456064},{"_id":"public/20210701/export与export-default的区别/index.html","hash":"0bfa5e56d2f98133f3bb9c3f8af296a02f41513e","modified":1639026456064},{"_id":"public/20210619/new操作符的实现/index.html","hash":"bac7c306d32d28f7538ee90450adb2f12a90c59f","modified":1639026456064},{"_id":"public/20210618/原型与原型链与constructor/index.html","hash":"7459ecb441b534f9375493a753a6115aafe236cf","modified":1639026456064},{"_id":"public/20210618/Vue自定义全局组件/index.html","hash":"714d4734a655b3ed5e8c246dd1ebc9fc0a32a3ac","modified":1639026456064},{"_id":"public/20210617/JavaScript中的堆栈以及数据类型/index.html","hash":"9fa6c127be6041881275855499feae4b036df48d","modified":1639026456064},{"_id":"public/index.html","hash":"0b251a0c0e6a4ecc6e1a7e6651edbf7241d4bc7d","modified":1639026456064},{"_id":"public/page/2/index.html","hash":"8249b3b936b9ac1bfdf1196decb294699f8bd376","modified":1639026456064},{"_id":"public/page/3/index.html","hash":"726846a6ab3154f62e7daaee2d36363c39e7d26d","modified":1639026456064},{"_id":"public/categories/index.html","hash":"d239c79afe4fe908fc689f2b829dc3818816bdc0","modified":1639026456064},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1639026456064},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1639026456064},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1639026456064},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1639026456064},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1639026456064},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1639026456064},{"_id":"public/CNAME","hash":"61e7919ef45b0fd313fcb2de41b7021f7ccbf47b","modified":1639026456064},{"_id":"public/img/bg/zhimingyuchunjiao.jpeg","hash":"03f9c96b520c0976c03c5bc45901b0c0e64b1c4d","modified":1639026456064},{"_id":"public/img/user/jianshu.jpeg","hash":"e3f77ae1071b74c68f0a7237850a3dc7a41a9936","modified":1639026456064},{"_id":"public/img/user/wazi.png","hash":"a6489d50d8b4fa846cbfd4ae094897586f5b5d76","modified":1639026456064},{"_id":"public/img/20210911/AirPods.jpeg","hash":"8601c573436498d33b4016f948869ad8de42c543","modified":1639026456064},{"_id":"public/img/20210911/pic1.jpeg","hash":"dc36460fc6f228a5f85c9906359a3e777ec4f9ea","modified":1639026456064},{"_id":"public/img/bg/benjamin.jpeg","hash":"83c5636568ee5c2fe4602edf4a418414d242d155","modified":1639026456064},{"_id":"public/img/bg/bg1.jpg","hash":"026a9e6ef05b063cf0c62142634d092b5e7015db","modified":1639026456064},{"_id":"public/img/bg/bg4.jpg","hash":"e766eb50706a9f2a10fc25ba479bfb7944cfb9dc","modified":1639026456064},{"_id":"public/img/bg/tianruoyouqing.jpeg","hash":"c03c2d638c9858b48791019759e06f54c57f3730","modified":1639026456064},{"_id":"public/img/user/user.jpg","hash":"5a1c8f2385741605649bacf36bfe84f3d0b7983a","modified":1639026456064},{"_id":"public/img/user/weChat.jpg","hash":"1c490e9ab2206003f6d84446bf8dc347b2d416ef","modified":1639026456064},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1639026456064},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1639026456064},{"_id":"public/js/color-schema.js","hash":"cc712fc71bf33d561e1ba74fe1d52d2353092171","modified":1639026456064},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1639026456064},{"_id":"public/js/leancloud.js","hash":"b7985ac3cff9ee2722db43ee6b32b5484c43f5f2","modified":1639026456064},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1639026456064},{"_id":"public/js/local-search.js","hash":"bf00f5786bb8de7241f635455b67243d26656222","modified":1639026456064},{"_id":"public/js/plugins.js","hash":"342b1fbc30d1465687ce389a4e07f967266d5d86","modified":1639026456064},{"_id":"public/js/utils.js","hash":"9d492fab9c26311ad0ab553c890e09b9575a76f2","modified":1639026456064},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1639026456064},{"_id":"public/css/main.css","hash":"be9a0652de06d61fa26f4b4128b29bcc5a4a0ad7","modified":1639026456064},{"_id":"public/img/20210911/pic2.jpeg","hash":"e66ac1c464555050a5e57d610d41df3ea2300772","modified":1639026456064},{"_id":"public/img/20210911/图片.jpeg","hash":"ce86726a54981795d8a5f6cc166af0b2ed050afb","modified":1639026456064},{"_id":"public/img/bg/bg2.jpg","hash":"4df0a1e43accbb1a2c5fa6e2c26e324d7c280499","modified":1639026456064},{"_id":"public/img/user/bilibili.jpeg","hash":"2a1493d349d20f5b682a43639104ceeda3734ba1","modified":1639026456064},{"_id":"public/img/bg/bg3.jpg","hash":"43ea9f0ae1c75b0edf7623cb0ff57fbc545fe3c5","modified":1639026456064},{"_id":"public/img/20210913/renshengdezhihui.png","hash":"7981415b28a16c4ac3fc282c53b488c779a7eacc","modified":1639026456064},{"_id":"public/img/user/user1.png","hash":"de768c0d778b4ce91d17a4fa6643fcdaecc0d960","modified":1639026456064},{"_id":"public/img/20210913/renshengdezhihui2.png","hash":"b217a9b7523a7300876a97bf32959f678794ed38","modified":1639026456064},{"_id":"public/img/user/webo.jpg","hash":"e13a0af612e0944a2014104058242b4fbebe8e56","modified":1639026456064},{"_id":"public/img/bg/shashou.jpeg","hash":"b6fccd7c1c535c73c3f374583d0bd26daa84874a","modified":1639026456064}],"Category":[{"name":"技术类-TypeScript","_id":"ckwyi189z0004cco94lns2k9t"},{"name":"日常","_id":"ckwyi18a8000ecco96nwngfxi"},{"name":"技术类-前端","_id":"ckwyi18aa000lcco96qn98lrd"},{"name":"阅读","_id":"ckwyi18ad000qcco90inga8h8"},{"name":"技术类-Vue","_id":"ckwyi18af000xcco95ai2hg2p"},{"name":"计算机基础","_id":"ckwyi18ar001scco91rbj3ave"},{"name":"算法类","_id":"ckwyi18av0025cco90xx2a7tv"},{"name":"技术类-后端","_id":"ckwyi18ax002fcco922081s15"},{"name":"技术类-React","_id":"ckwyi18ay002kcco945902y8p"},{"name":"博客说明","_id":"ckwyi18az002pcco9dlti1ibl"}],"Data":[],"Page":[{"layout":"false","_content":"676194d86471561a70b8026338973ebc","source":"baidu_verify_code-TmkkRxX4ps.html","raw":"---\n\nlayout: false\n\n---\n676194d86471561a70b8026338973ebc","date":"2021-09-09T01:43:34.047Z","updated":"2021-09-09T01:43:34.047Z","path":"baidu_verify_code-TmkkRxX4ps.html","title":"","comments":1,"_id":"ckwyi189r0000cco989im6sv6","content":"676194d86471561a70b8026338973ebc","site":{"data":{}},"excerpt":"","more":"676194d86471561a70b8026338973ebc"},{"title":"about","layout":"about","comment":"utterances","date":"2021-09-07T07:20:04.000Z","_content":"网速足够快或者翻墙的话会使本网站打开的更快一些，网站有缓存，第一次打开可能会比较慢，后面就好了。\n谢谢关注，请一键三连！！！","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ncomment: utterances\ndate: 2021-09-07 15:20:04\n---\n网速足够快或者翻墙的话会使本网站打开的更快一些，网站有缓存，第一次打开可能会比较慢，后面就好了。\n谢谢关注，请一键三连！！！","updated":"2021-09-23T07:58:48.894Z","path":"about/index.html","comments":1,"_id":"ckwyi189x0002cco9ad161ta5","content":"<p>网速足够快或者翻墙的话会使本网站打开的更快一些，网站有缓存，第一次打开可能会比较慢，后面就好了。<br>谢谢关注，请一键三连！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>网速足够快或者翻墙的话会使本网站打开的更快一些，网站有缓存，第一次打开可能会比较慢，后面就好了。<br>谢谢关注，请一键三连！！！</p>\n"}],"Post":[{"layout":"tech","title":"TypeScript中类的理解","date":"2021-09-06T06:48:00.000Z","_content":"\n# 一、是什么\n\n类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础\n> ❝类是一种用户定义的引用数据类型，也称类类型❞\n\n传统的面向对象语言基本都是基于类的，`JavaScript` 基于原型的方式让开发者多了很多理解成本\n在 `ES6` 之后，`JavaScript` 拥有了 `class` 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多\n但是`JavaScript` 的`class`依然有一些特性还没有加入，比如修饰符和抽象类\n`TypeScript` 的 `class`  支持面向对象的所有特性，比如 类、接口等\n# 二、使用方式\n定义类的关键字为 `class`，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：\n\n「字段」：字段是类里面声明的变量。字段表示对象的有关数据。\n\n「构造函数」：类实例化时调用，可以为类的对象分配内存。\n\n「方法」：方法为对象要执行的操作\n如下例子：\n```typescript\nclass Car { \n    // 字段 \n    engine:string; \n \n    // 构造函数 \n    constructor(engine:string) { \n        this.engine = engine \n    }  \n \n    // 方法 \n    disp():void { \n        console.log(\"发动机为 :   \"+this.engine) \n    } \n}\n\n```\n\n## 继承\n类的继承使用过`extends`的关键字\n```typescript\nclass Animal {\n    move(distanceInMeters: number = 0) {\n        console.log(`Animal moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Dog extends Animal {\n    bark() {\n        console.log('Woof! Woof!');\n    }\n}\n\nconst dog = new Dog();\ndog.bark();\ndog.move(10);\ndog.bark();\n\n```\n\n`Dog`是一个 派生类，它派生自 `Animal` 基类，派生类通常被称作子类，基类通常被称作 **超类**。\n\n`Dog`类继承了`Animal`类，因此实例`dog`也能够使用`Animal`类`move`方法。\n同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。\n\n通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：\n```typescript\nclass PrinterClass { \n   doPrint():void {\n      console.log(\"父类的 doPrint() 方法。\") \n   } \n} \n \nclass StringPrinter extends PrinterClass { \n   doPrint():void { \n      super.doPrint() // 调用父类的函数\n      console.log(\"子类的 doPrint()方法。\")\n   } \n}\n\n```\n## 修饰符\n可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：\n\n- 公共 public：可以自由的访问类程序里定义的成员\n- 私有 private：只能够在该类的内部进行访问\n- 受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问\n\n### 私有修饰符\n只能够在该类的内部进行访问，实例对象并不能够访问\n```typescript\nclass Father{\n    private name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错，提示 \"属性name为私有属性，只能在Father类中访问\"\n```\n并且继承该类的子类并不能访问，如下图所示：\n```typescript\nclass Father{\n    private name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nclass Son extends Father{\n    say(){\n        console.log(`my name is ${this.name}`)  //会报错，提示 \"属性name为私有属性，只能在Father类中访问\"\n    }\n}\n```\n### 受保护修饰符\n跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：\n```typescript\nclass Father{\n    protected name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错，提示 \"属性name受保护，只能在类Father及其子类中访问\"\n```\n有一点不同的是 `protected` 成员在子类中仍然可以访问\n```typescript\nclass Father{\n    protected name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nclass Son extends Father{\n    say(){\n        console.log(`my name is ${this.name}`)\n    }\n}\n```\n\n### 只读修饰符\n通过`readonly`关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：\n```typescript\nclass Father{\n    readonly name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错,提示\"无法分配到name，因为它是只读属性\"\n```\n\n### 静态属性\n这些属性存在于类本身上面而不是类的实例上，通过`static`进行定义，访问这些属性需要通过 `类型.静态属性` 的这种形式访问，如下所示：\n```typescript\nclass Square {\n    static width = '100px'\n}\n\nconsole.log(Square.width) // 100px\n```\n### 抽象类\n抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节\n`abstract`关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：\n```typescript\nabstract class Animal {\n    abstract makeSound(): void;\n    move(): void {\n        console.log('roaming the earch...');\n    }\n}\n```\n这种类并不能被实例化，通常需要我们创建子类去继承，如下：\n```typescript\nclass Cat extends Animal {\n\n    makeSound() {\n        console.log('miao miao')\n    }\n}\n\nconst cat = new Cat()\n\ncat.makeSound() // miao miao\ncat.move() // roaming the earch...\n```\n# 三、应用场景\n除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在`React` 工程中是很常用的，如下：\n```typescript\nexport default class Carousel extends React.Component<Props, State> {}\n```\n由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。\n\n先声明一个类，这个类包含组件 props 所需的类型和初始值：\n```typescript\n// props的类型\nexport default class Props {\n  public children: Array<React.ReactElement<any>> | React.ReactElement<any> | never[] = []\n  public speed: number = 500\n  public height: number = 160\n  public animation: string = 'easeInOutQuad'\n  public isAuto: boolean = true\n  public autoPlayInterval: number = 4500\n  public afterChange: () => {}\n  public beforeChange: () => {}\n  public selesctedColor: string\n  public showDots: boolean = true\n}\n```\n当我们需要传入 `props` 类型的时候直接将 `Props` 作为接口传入，此时 `Props` 的作用就是接口，而当需要我们设置`defaultProps`初始值的时候，我们只需要:\n```typescript\npublic static defaultProps = new Props()\n```\n`Props` 的实例就是 `defaultProps` 的初始值，这就是 `class`作为接口的实际应用，我们用一个 `class` 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量\n\n# 参考文章\n- https://www.tslang.cn/docs/handbook/classes.html\n- https://www.runoob.com/typescript/ts-class.html","source":"_posts/2021-09-09-TypeScript中类的理解.md","raw":"---\nlayout: tech\ntitle: TypeScript中类的理解\ndate: 2021-09-06 14:48:00\ntags: TypeScript\ncategories: 技术类-TypeScript\n---\n\n# 一、是什么\n\n类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础\n> ❝类是一种用户定义的引用数据类型，也称类类型❞\n\n传统的面向对象语言基本都是基于类的，`JavaScript` 基于原型的方式让开发者多了很多理解成本\n在 `ES6` 之后，`JavaScript` 拥有了 `class` 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多\n但是`JavaScript` 的`class`依然有一些特性还没有加入，比如修饰符和抽象类\n`TypeScript` 的 `class`  支持面向对象的所有特性，比如 类、接口等\n# 二、使用方式\n定义类的关键字为 `class`，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：\n\n「字段」：字段是类里面声明的变量。字段表示对象的有关数据。\n\n「构造函数」：类实例化时调用，可以为类的对象分配内存。\n\n「方法」：方法为对象要执行的操作\n如下例子：\n```typescript\nclass Car { \n    // 字段 \n    engine:string; \n \n    // 构造函数 \n    constructor(engine:string) { \n        this.engine = engine \n    }  \n \n    // 方法 \n    disp():void { \n        console.log(\"发动机为 :   \"+this.engine) \n    } \n}\n\n```\n\n## 继承\n类的继承使用过`extends`的关键字\n```typescript\nclass Animal {\n    move(distanceInMeters: number = 0) {\n        console.log(`Animal moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Dog extends Animal {\n    bark() {\n        console.log('Woof! Woof!');\n    }\n}\n\nconst dog = new Dog();\ndog.bark();\ndog.move(10);\ndog.bark();\n\n```\n\n`Dog`是一个 派生类，它派生自 `Animal` 基类，派生类通常被称作子类，基类通常被称作 **超类**。\n\n`Dog`类继承了`Animal`类，因此实例`dog`也能够使用`Animal`类`move`方法。\n同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。\n\n通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：\n```typescript\nclass PrinterClass { \n   doPrint():void {\n      console.log(\"父类的 doPrint() 方法。\") \n   } \n} \n \nclass StringPrinter extends PrinterClass { \n   doPrint():void { \n      super.doPrint() // 调用父类的函数\n      console.log(\"子类的 doPrint()方法。\")\n   } \n}\n\n```\n## 修饰符\n可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：\n\n- 公共 public：可以自由的访问类程序里定义的成员\n- 私有 private：只能够在该类的内部进行访问\n- 受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问\n\n### 私有修饰符\n只能够在该类的内部进行访问，实例对象并不能够访问\n```typescript\nclass Father{\n    private name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错，提示 \"属性name为私有属性，只能在Father类中访问\"\n```\n并且继承该类的子类并不能访问，如下图所示：\n```typescript\nclass Father{\n    private name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nclass Son extends Father{\n    say(){\n        console.log(`my name is ${this.name}`)  //会报错，提示 \"属性name为私有属性，只能在Father类中访问\"\n    }\n}\n```\n### 受保护修饰符\n跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：\n```typescript\nclass Father{\n    protected name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错，提示 \"属性name受保护，只能在类Father及其子类中访问\"\n```\n有一点不同的是 `protected` 成员在子类中仍然可以访问\n```typescript\nclass Father{\n    protected name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nclass Son extends Father{\n    say(){\n        console.log(`my name is ${this.name}`)\n    }\n}\n```\n\n### 只读修饰符\n通过`readonly`关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：\n```typescript\nclass Father{\n    readonly name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错,提示\"无法分配到name，因为它是只读属性\"\n```\n\n### 静态属性\n这些属性存在于类本身上面而不是类的实例上，通过`static`进行定义，访问这些属性需要通过 `类型.静态属性` 的这种形式访问，如下所示：\n```typescript\nclass Square {\n    static width = '100px'\n}\n\nconsole.log(Square.width) // 100px\n```\n### 抽象类\n抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节\n`abstract`关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：\n```typescript\nabstract class Animal {\n    abstract makeSound(): void;\n    move(): void {\n        console.log('roaming the earch...');\n    }\n}\n```\n这种类并不能被实例化，通常需要我们创建子类去继承，如下：\n```typescript\nclass Cat extends Animal {\n\n    makeSound() {\n        console.log('miao miao')\n    }\n}\n\nconst cat = new Cat()\n\ncat.makeSound() // miao miao\ncat.move() // roaming the earch...\n```\n# 三、应用场景\n除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在`React` 工程中是很常用的，如下：\n```typescript\nexport default class Carousel extends React.Component<Props, State> {}\n```\n由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。\n\n先声明一个类，这个类包含组件 props 所需的类型和初始值：\n```typescript\n// props的类型\nexport default class Props {\n  public children: Array<React.ReactElement<any>> | React.ReactElement<any> | never[] = []\n  public speed: number = 500\n  public height: number = 160\n  public animation: string = 'easeInOutQuad'\n  public isAuto: boolean = true\n  public autoPlayInterval: number = 4500\n  public afterChange: () => {}\n  public beforeChange: () => {}\n  public selesctedColor: string\n  public showDots: boolean = true\n}\n```\n当我们需要传入 `props` 类型的时候直接将 `Props` 作为接口传入，此时 `Props` 的作用就是接口，而当需要我们设置`defaultProps`初始值的时候，我们只需要:\n```typescript\npublic static defaultProps = new Props()\n```\n`Props` 的实例就是 `defaultProps` 的初始值，这就是 `class`作为接口的实际应用，我们用一个 `class` 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量\n\n# 参考文章\n- https://www.tslang.cn/docs/handbook/classes.html\n- https://www.runoob.com/typescript/ts-class.html","slug":"TypeScript中类的理解","published":1,"updated":"2021-09-09T07:35:00.949Z","comments":1,"photos":[],"link":"","_id":"ckwyi189u0001cco93scza3x6","content":"<h1 id=\"一、是什么\"><a href=\"#一、是什么\" class=\"headerlink\" title=\"一、是什么\"></a>一、是什么</h1><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p>\n<blockquote>\n<p>❝类是一种用户定义的引用数据类型，也称类类型❞</p>\n</blockquote>\n<p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本<br>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多<br>但是<code>JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类<br><code>TypeScript</code> 的 <code>class</code>  支持面向对象的所有特性，比如 类、接口等</p>\n<h1 id=\"二、使用方式\"><a href=\"#二、使用方式\" class=\"headerlink\" title=\"二、使用方式\"></a>二、使用方式</h1><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：</p>\n<p>「字段」：字段是类里面声明的变量。字段表示对象的有关数据。</p>\n<p>「构造函数」：类实例化时调用，可以为类的对象分配内存。</p>\n<p>「方法」：方法为对象要执行的操作<br>如下例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Car</span> </span>&#123; <br>    <span class=\"hljs-comment\">// 字段 </span><br>    <span class=\"hljs-attr\">engine</span>:<span class=\"hljs-built_in\">string</span>; <br> <br>    <span class=\"hljs-comment\">// 构造函数 </span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">engine:<span class=\"hljs-built_in\">string</span></span>)</span> &#123; <br>        <span class=\"hljs-built_in\">this</span>.engine = engine <br>    &#125;  <br> <br>    <span class=\"hljs-comment\">// 方法 </span><br>    disp():<span class=\"hljs-built_in\">void</span> &#123; <br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;发动机为 :   &quot;</span>+<span class=\"hljs-built_in\">this</span>.engine) <br>    &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>类的继承使用过<code>extends</code>的关键字</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">move</span>(<span class=\"hljs-params\">distanceInMeters: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0</span></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Animal moved <span class=\"hljs-subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">bark</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Woof! Woof!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> Dog();<br>dog.bark();<br>dog.move(<span class=\"hljs-number\">10</span>);<br>dog.bark();<br><br></code></pre></td></tr></table></figure>\n\n<p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 <strong>超类</strong>。</p>\n<p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法。<br>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。</p>\n<p>通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PrinterClass</span> </span>&#123; <br>   doPrint():<span class=\"hljs-built_in\">void</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;父类的 doPrint() 方法。&quot;</span>) <br>   &#125; <br>&#125; <br> <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StringPrinter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PrinterClass</span> </span>&#123; <br>   doPrint():<span class=\"hljs-built_in\">void</span> &#123; <br>      <span class=\"hljs-built_in\">super</span>.doPrint() <span class=\"hljs-comment\">// 调用父类的函数</span><br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;子类的 doPrint()方法。&quot;</span>)<br>   &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><p>可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：</p>\n<ul>\n<li>公共 public：可以自由的访问类程序里定义的成员</li>\n<li>私有 private：只能够在该类的内部进行访问</li>\n<li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li>\n</ul>\n<h3 id=\"私有修饰符\"><a href=\"#私有修饰符\" class=\"headerlink\" title=\"私有修饰符\"></a>私有修饰符</h3><p>只能够在该类的内部进行访问，实例对象并不能够访问</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br></code></pre></td></tr></table></figure>\n<p>并且继承该类的子类并不能访问，如下图所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>`</span>)  <span class=\"hljs-comment\">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"受保护修饰符\"><a href=\"#受保护修饰符\" class=\"headerlink\" title=\"受保护修饰符\"></a>受保护修饰符</h3><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">protected</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错，提示 &quot;属性name受保护，只能在类Father及其子类中访问&quot;</span><br></code></pre></td></tr></table></figure>\n<p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">protected</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>`</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"只读修饰符\"><a href=\"#只读修饰符\" class=\"headerlink\" title=\"只读修饰符\"></a>只读修饰符</h3><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">readonly</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错,提示&quot;无法分配到name，因为它是只读属性&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h3><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 <code>类型.静态属性</code> 的这种形式访问，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Square</span> </span>&#123;<br>    <span class=\"hljs-keyword\">static</span> width = <span class=\"hljs-string\">&#x27;100px&#x27;</span><br>&#125;<br><br><span class=\"hljs-built_in\">console</span>.log(Square.width) <span class=\"hljs-comment\">// 100px</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节<br><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-keyword\">abstract</span> makeSound(): <span class=\"hljs-built_in\">void</span>;<br>    move(): <span class=\"hljs-built_in\">void</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;roaming the earch...&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Cat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">makeSound</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;miao miao&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> cat = <span class=\"hljs-keyword\">new</span> Cat()<br><br>cat.makeSound() <span class=\"hljs-comment\">// miao miao</span><br>cat.move() <span class=\"hljs-comment\">// roaming the earch...</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"三、应用场景\"><a href=\"#三、应用场景\" class=\"headerlink\" title=\"三、应用场景\"></a>三、应用场景</h1><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在<code>React</code> 工程中是很常用的，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Carousel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>, <span class=\"hljs-title\">State</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。</p>\n<p>先声明一个类，这个类包含组件 props 所需的类型和初始值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// props的类型</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Props</span> </span>&#123;<br>  <span class=\"hljs-keyword\">public</span> children: <span class=\"hljs-built_in\">Array</span>&lt;React.ReactElement&lt;<span class=\"hljs-built_in\">any</span>&gt;&gt; | React.ReactElement&lt;<span class=\"hljs-built_in\">any</span>&gt; | <span class=\"hljs-built_in\">never</span>[] = []<br>  <span class=\"hljs-keyword\">public</span> speed: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">500</span><br>  <span class=\"hljs-keyword\">public</span> height: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">160</span><br>  <span class=\"hljs-keyword\">public</span> animation: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&#x27;easeInOutQuad&#x27;</span><br>  <span class=\"hljs-keyword\">public</span> isAuto: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-keyword\">public</span> autoPlayInterval: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">4500</span><br>  <span class=\"hljs-keyword\">public</span> afterChange: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<br>  <span class=\"hljs-keyword\">public</span> beforeChange: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<br>  <span class=\"hljs-keyword\">public</span> selesctedColor: <span class=\"hljs-built_in\">string</span><br>  <span class=\"hljs-keyword\">public</span> showDots: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> defaultProps = <span class=\"hljs-keyword\">new</span> Props()<br></code></pre></td></tr></table></figure>\n<p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class</code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/classes.html\">https://www.tslang.cn/docs/handbook/classes.html</a></li>\n<li><a href=\"https://www.runoob.com/typescript/ts-class.html\">https://www.runoob.com/typescript/ts-class.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、是什么\"><a href=\"#一、是什么\" class=\"headerlink\" title=\"一、是什么\"></a>一、是什么</h1><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p>\n<blockquote>\n<p>❝类是一种用户定义的引用数据类型，也称类类型❞</p>\n</blockquote>\n<p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本<br>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多<br>但是<code>JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类<br><code>TypeScript</code> 的 <code>class</code>  支持面向对象的所有特性，比如 类、接口等</p>\n<h1 id=\"二、使用方式\"><a href=\"#二、使用方式\" class=\"headerlink\" title=\"二、使用方式\"></a>二、使用方式</h1><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：</p>\n<p>「字段」：字段是类里面声明的变量。字段表示对象的有关数据。</p>\n<p>「构造函数」：类实例化时调用，可以为类的对象分配内存。</p>\n<p>「方法」：方法为对象要执行的操作<br>如下例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Car</span> </span>&#123; <br>    <span class=\"hljs-comment\">// 字段 </span><br>    <span class=\"hljs-attr\">engine</span>:<span class=\"hljs-built_in\">string</span>; <br> <br>    <span class=\"hljs-comment\">// 构造函数 </span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">engine:<span class=\"hljs-built_in\">string</span></span>)</span> &#123; <br>        <span class=\"hljs-built_in\">this</span>.engine = engine <br>    &#125;  <br> <br>    <span class=\"hljs-comment\">// 方法 </span><br>    disp():<span class=\"hljs-built_in\">void</span> &#123; <br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;发动机为 :   &quot;</span>+<span class=\"hljs-built_in\">this</span>.engine) <br>    &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>类的继承使用过<code>extends</code>的关键字</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">move</span>(<span class=\"hljs-params\">distanceInMeters: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0</span></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Animal moved <span class=\"hljs-subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">bark</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Woof! Woof!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> Dog();<br>dog.bark();<br>dog.move(<span class=\"hljs-number\">10</span>);<br>dog.bark();<br><br></code></pre></td></tr></table></figure>\n\n<p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 <strong>超类</strong>。</p>\n<p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法。<br>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。</p>\n<p>通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PrinterClass</span> </span>&#123; <br>   doPrint():<span class=\"hljs-built_in\">void</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;父类的 doPrint() 方法。&quot;</span>) <br>   &#125; <br>&#125; <br> <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StringPrinter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PrinterClass</span> </span>&#123; <br>   doPrint():<span class=\"hljs-built_in\">void</span> &#123; <br>      <span class=\"hljs-built_in\">super</span>.doPrint() <span class=\"hljs-comment\">// 调用父类的函数</span><br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;子类的 doPrint()方法。&quot;</span>)<br>   &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><p>可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：</p>\n<ul>\n<li>公共 public：可以自由的访问类程序里定义的成员</li>\n<li>私有 private：只能够在该类的内部进行访问</li>\n<li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li>\n</ul>\n<h3 id=\"私有修饰符\"><a href=\"#私有修饰符\" class=\"headerlink\" title=\"私有修饰符\"></a>私有修饰符</h3><p>只能够在该类的内部进行访问，实例对象并不能够访问</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br></code></pre></td></tr></table></figure>\n<p>并且继承该类的子类并不能访问，如下图所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>`</span>)  <span class=\"hljs-comment\">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"受保护修饰符\"><a href=\"#受保护修饰符\" class=\"headerlink\" title=\"受保护修饰符\"></a>受保护修饰符</h3><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">protected</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错，提示 &quot;属性name受保护，只能在类Father及其子类中访问&quot;</span><br></code></pre></td></tr></table></figure>\n<p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">protected</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>`</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"只读修饰符\"><a href=\"#只读修饰符\" class=\"headerlink\" title=\"只读修饰符\"></a>只读修饰符</h3><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">readonly</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错,提示&quot;无法分配到name，因为它是只读属性&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h3><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 <code>类型.静态属性</code> 的这种形式访问，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Square</span> </span>&#123;<br>    <span class=\"hljs-keyword\">static</span> width = <span class=\"hljs-string\">&#x27;100px&#x27;</span><br>&#125;<br><br><span class=\"hljs-built_in\">console</span>.log(Square.width) <span class=\"hljs-comment\">// 100px</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节<br><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-keyword\">abstract</span> makeSound(): <span class=\"hljs-built_in\">void</span>;<br>    move(): <span class=\"hljs-built_in\">void</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;roaming the earch...&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Cat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">makeSound</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;miao miao&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> cat = <span class=\"hljs-keyword\">new</span> Cat()<br><br>cat.makeSound() <span class=\"hljs-comment\">// miao miao</span><br>cat.move() <span class=\"hljs-comment\">// roaming the earch...</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"三、应用场景\"><a href=\"#三、应用场景\" class=\"headerlink\" title=\"三、应用场景\"></a>三、应用场景</h1><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在<code>React</code> 工程中是很常用的，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Carousel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>, <span class=\"hljs-title\">State</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。</p>\n<p>先声明一个类，这个类包含组件 props 所需的类型和初始值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// props的类型</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Props</span> </span>&#123;<br>  <span class=\"hljs-keyword\">public</span> children: <span class=\"hljs-built_in\">Array</span>&lt;React.ReactElement&lt;<span class=\"hljs-built_in\">any</span>&gt;&gt; | React.ReactElement&lt;<span class=\"hljs-built_in\">any</span>&gt; | <span class=\"hljs-built_in\">never</span>[] = []<br>  <span class=\"hljs-keyword\">public</span> speed: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">500</span><br>  <span class=\"hljs-keyword\">public</span> height: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">160</span><br>  <span class=\"hljs-keyword\">public</span> animation: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&#x27;easeInOutQuad&#x27;</span><br>  <span class=\"hljs-keyword\">public</span> isAuto: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-keyword\">public</span> autoPlayInterval: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">4500</span><br>  <span class=\"hljs-keyword\">public</span> afterChange: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<br>  <span class=\"hljs-keyword\">public</span> beforeChange: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<br>  <span class=\"hljs-keyword\">public</span> selesctedColor: <span class=\"hljs-built_in\">string</span><br>  <span class=\"hljs-keyword\">public</span> showDots: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> defaultProps = <span class=\"hljs-keyword\">new</span> Props()<br></code></pre></td></tr></table></figure>\n<p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class</code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/classes.html\">https://www.tslang.cn/docs/handbook/classes.html</a></li>\n<li><a href=\"https://www.runoob.com/typescript/ts-class.html\">https://www.runoob.com/typescript/ts-class.html</a></li>\n</ul>\n"},{"title":"TypeScript中函数的理解","date":"2021-09-10T08:55:32.000Z","_content":"# 使用方式\n和JavaScript使用方式类似，可以通过`funciton`关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：\n```typescript\nconst add = (a:number,b:number)=> a+b\n```\n上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：\n![TypeScript编译器的提示](https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg)\n当鼠标放置在第三行 `add` 函数名的时候，会出现完整的函数定义类型，通过 `:` 的形式来定义参数类型，通过 `=>` 连接参数和返回值类型\n\n我们也可以显式地写上返回类型，如下：\n```typescript\nconst add = (a:number,b:number):number=> a+b\n```\n\n当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：\n```typescript\n// 方式一\ntype LongHand = {\n  (a: number): number;\n};\n\n// 方式二\ntype ShortHand = (a: number) => number;\n\n```\n当存在函数重载时，只能使用方式一的形式\n\n## 可选参数\n当函数的参数可能是不存在的，只需要在参数后面加上 `?` 代表参数可能不存在，如下：\n```typescript\nconst add = (a: number, b?: number) => a + (b ? b : 0)\n```\n这时候参数`b`可以是`number类型`或者`undefined类型`，即可以传一个`number类型`或者不传都可以\n\n## 剩余类型\n剩余参数与JavaScript的语法类似，需要用 `...` 来表示剩余参数\n\n如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：\n```typescript\nconst add = (a: number, ...rest: number[]) => rest.reduce(((a, b) => a + b), a)\n```\n\n## 函数重载\n允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力\n\n关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 `|操作符`或者`?操作符`，把所有可能的输入类型全部包含进去，用于具体实现\n\n这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并\n\n例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：\n```typescript\n// 上边是声明\nfunction add (arg1: string, arg2: string): string\nfunction add (arg1: number, arg2: number): number\n// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字\n\n// 下边是实现\nfunction add (arg1: string | number, arg2: string | number) {\n  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2\n  if (typeof arg1 === 'string' && typeof arg2 === 'string') {\n    return arg1 + arg2\n  } else if (typeof arg1 === 'number' && typeof arg2 === 'number') {\n    return arg1 + arg2\n  }\n}\n```\n# 区别\n从上面可以看到：\n\n- 从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型\n- typescript 在参数中，添加可选参数供使用者选择\n- typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型\n# 参考文章\n- https://www.tslang.cn/docs/handbook/functions.html\n- https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\n- https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD","source":"_posts/2021-09-10-TypeScript中函数的理解.md","raw":"---\ntitle: TypeScript中函数的理解\ndate: 2021-09-10 16:55:32\ntags: TypeScript\ncategories: 技术类-TypeScript\n---\n# 使用方式\n和JavaScript使用方式类似，可以通过`funciton`关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：\n```typescript\nconst add = (a:number,b:number)=> a+b\n```\n上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：\n![TypeScript编译器的提示](https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg)\n当鼠标放置在第三行 `add` 函数名的时候，会出现完整的函数定义类型，通过 `:` 的形式来定义参数类型，通过 `=>` 连接参数和返回值类型\n\n我们也可以显式地写上返回类型，如下：\n```typescript\nconst add = (a:number,b:number):number=> a+b\n```\n\n当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：\n```typescript\n// 方式一\ntype LongHand = {\n  (a: number): number;\n};\n\n// 方式二\ntype ShortHand = (a: number) => number;\n\n```\n当存在函数重载时，只能使用方式一的形式\n\n## 可选参数\n当函数的参数可能是不存在的，只需要在参数后面加上 `?` 代表参数可能不存在，如下：\n```typescript\nconst add = (a: number, b?: number) => a + (b ? b : 0)\n```\n这时候参数`b`可以是`number类型`或者`undefined类型`，即可以传一个`number类型`或者不传都可以\n\n## 剩余类型\n剩余参数与JavaScript的语法类似，需要用 `...` 来表示剩余参数\n\n如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：\n```typescript\nconst add = (a: number, ...rest: number[]) => rest.reduce(((a, b) => a + b), a)\n```\n\n## 函数重载\n允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力\n\n关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 `|操作符`或者`?操作符`，把所有可能的输入类型全部包含进去，用于具体实现\n\n这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并\n\n例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：\n```typescript\n// 上边是声明\nfunction add (arg1: string, arg2: string): string\nfunction add (arg1: number, arg2: number): number\n// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字\n\n// 下边是实现\nfunction add (arg1: string | number, arg2: string | number) {\n  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2\n  if (typeof arg1 === 'string' && typeof arg2 === 'string') {\n    return arg1 + arg2\n  } else if (typeof arg1 === 'number' && typeof arg2 === 'number') {\n    return arg1 + arg2\n  }\n}\n```\n# 区别\n从上面可以看到：\n\n- 从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型\n- typescript 在参数中，添加可选参数供使用者选择\n- typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型\n# 参考文章\n- https://www.tslang.cn/docs/handbook/functions.html\n- https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\n- https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD","slug":"TypeScript中函数的理解","published":1,"updated":"2021-09-10T09:03:27.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi189x0003cco923593e7i","content":"<h1 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h1><p>和JavaScript使用方式类似，可以通过<code>funciton</code>关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a:<span class=\"hljs-built_in\">number</span>,b:<span class=\"hljs-built_in\">number</span></span>)=&gt;</span> a+b<br></code></pre></td></tr></table></figure>\n<p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：<br><img src=\"https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg\" alt=\"TypeScript编译器的提示\"><br>当鼠标放置在第三行 <code>add</code> 函数名的时候，会出现完整的函数定义类型，通过 <code>:</code> 的形式来定义参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p>\n<p>我们也可以显式地写上返回类型，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = (a:<span class=\"hljs-built_in\">number</span>,<span class=\"hljs-attr\">b</span>:<span class=\"hljs-built_in\">number</span>):<span class=\"hljs-function\"><span class=\"hljs-params\">number</span>=&gt;</span> a+b<br></code></pre></td></tr></table></figure>\n\n<p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 方式一</span><br><span class=\"hljs-keyword\">type</span> LongHand = &#123;<br>  (a: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;<br>&#125;;<br><br><span class=\"hljs-comment\">// 方式二</span><br><span class=\"hljs-keyword\">type</span> ShortHand = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span>;<br><br></code></pre></td></tr></table></figure>\n<p>当存在函数重载时，只能使用方式一的形式</p>\n<h2 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h2><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b?: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> a + (b ? b : <span class=\"hljs-number\">0</span>)<br></code></pre></td></tr></table></figure>\n<p>这时候参数<code>b</code>可以是<code>number类型</code>或者<code>undefined类型</code>，即可以传一个<code>number类型</code>或者不传都可以</p>\n<h2 id=\"剩余类型\"><a href=\"#剩余类型\" class=\"headerlink\" title=\"剩余类型\"></a>剩余类型</h2><p>剩余参数与JavaScript的语法类似，需要用 <code>...</code> 来表示剩余参数</p>\n<p>如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, ...rest: <span class=\"hljs-built_in\">number</span>[]</span>) =&gt;</span> rest.reduce((<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a + b), a)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p>\n<p>关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|操作符</code>或者<code>?操作符</code>，把所有可能的输入类型全部包含进去，用于具体实现</p>\n<p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并</p>\n<p>例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 上边是声明</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span>, arg2: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">string</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 <span class=\"hljs-title\">declare</span> 关键字</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">// 下边是实现</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>) </span>&#123;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">  <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;string&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;string&#x27;</span></span>) </span>&#123;</span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">return</span> <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span><br><span class=\"hljs-function\">  &#125; <span class=\"hljs-title\">else</span> <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;number&#x27;</span></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> arg1 + arg2<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p>从上面可以看到：</p>\n<ul>\n<li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li>\n<li>typescript 在参数中，添加可选参数供使用者选择</li>\n<li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1></li>\n<li><a href=\"https://www.tslang.cn/docs/handbook/functions.html\">https://www.tslang.cn/docs/handbook/functions.html</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\">https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD</a></li>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD\">https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h1><p>和JavaScript使用方式类似，可以通过<code>funciton</code>关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a:<span class=\"hljs-built_in\">number</span>,b:<span class=\"hljs-built_in\">number</span></span>)=&gt;</span> a+b<br></code></pre></td></tr></table></figure>\n<p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：<br><img src=\"https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg\" alt=\"TypeScript编译器的提示\"><br>当鼠标放置在第三行 <code>add</code> 函数名的时候，会出现完整的函数定义类型，通过 <code>:</code> 的形式来定义参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p>\n<p>我们也可以显式地写上返回类型，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = (a:<span class=\"hljs-built_in\">number</span>,<span class=\"hljs-attr\">b</span>:<span class=\"hljs-built_in\">number</span>):<span class=\"hljs-function\"><span class=\"hljs-params\">number</span>=&gt;</span> a+b<br></code></pre></td></tr></table></figure>\n\n<p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 方式一</span><br><span class=\"hljs-keyword\">type</span> LongHand = &#123;<br>  (a: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;<br>&#125;;<br><br><span class=\"hljs-comment\">// 方式二</span><br><span class=\"hljs-keyword\">type</span> ShortHand = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span>;<br><br></code></pre></td></tr></table></figure>\n<p>当存在函数重载时，只能使用方式一的形式</p>\n<h2 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h2><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b?: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> a + (b ? b : <span class=\"hljs-number\">0</span>)<br></code></pre></td></tr></table></figure>\n<p>这时候参数<code>b</code>可以是<code>number类型</code>或者<code>undefined类型</code>，即可以传一个<code>number类型</code>或者不传都可以</p>\n<h2 id=\"剩余类型\"><a href=\"#剩余类型\" class=\"headerlink\" title=\"剩余类型\"></a>剩余类型</h2><p>剩余参数与JavaScript的语法类似，需要用 <code>...</code> 来表示剩余参数</p>\n<p>如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, ...rest: <span class=\"hljs-built_in\">number</span>[]</span>) =&gt;</span> rest.reduce((<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a + b), a)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p>\n<p>关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|操作符</code>或者<code>?操作符</code>，把所有可能的输入类型全部包含进去，用于具体实现</p>\n<p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并</p>\n<p>例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 上边是声明</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span>, arg2: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">string</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 <span class=\"hljs-title\">declare</span> 关键字</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">// 下边是实现</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>) </span>&#123;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">  <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;string&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;string&#x27;</span></span>) </span>&#123;</span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">return</span> <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span><br><span class=\"hljs-function\">  &#125; <span class=\"hljs-title\">else</span> <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;number&#x27;</span></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> arg1 + arg2<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p>从上面可以看到：</p>\n<ul>\n<li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li>\n<li>typescript 在参数中，添加可选参数供使用者选择</li>\n<li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1></li>\n<li><a href=\"https://www.tslang.cn/docs/handbook/functions.html\">https://www.tslang.cn/docs/handbook/functions.html</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\">https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD</a></li>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD\">https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD</a></li>\n</ul>\n"},{"title":"浮生一日(20210911)","date":"2021-09-11T10:44:58.000Z","_content":"今天老妈的生日🎂\n\n猝不及防的狗粮\n\n![老妈的朋友圈](/img/20210911/pic1.jpeg)\n![老妈的朋友圈](/img/20210911/pic2.jpeg)\n\n---\n\n苹果的售后真的好，耳机检测了一下就说直接换新的\n\n![苹果售后](/img/20210911/AirPods.jpeg)\n","source":"_posts/2021-09-11-浮生一日.md","raw":"---\ntitle: 浮生一日(20210911)\ndate: 2021-09-11 18:44:58\ntags: \n  - [日常]\ncategories: \n  - [日常]\n---\n今天老妈的生日🎂\n\n猝不及防的狗粮\n\n![老妈的朋友圈](/img/20210911/pic1.jpeg)\n![老妈的朋友圈](/img/20210911/pic2.jpeg)\n\n---\n\n苹果的售后真的好，耳机检测了一下就说直接换新的\n\n![苹果售后](/img/20210911/AirPods.jpeg)\n","slug":"浮生一日","published":1,"updated":"2021-11-18T09:00:56.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18a10006cco90b766yaz","content":"<p>今天老妈的生日🎂</p>\n<p>猝不及防的狗粮</p>\n<p><img src=\"/img/20210911/pic1.jpeg\" alt=\"老妈的朋友圈\"><br><img src=\"/img/20210911/pic2.jpeg\" alt=\"老妈的朋友圈\"></p>\n<hr>\n<p>苹果的售后真的好，耳机检测了一下就说直接换新的</p>\n<p><img src=\"/img/20210911/AirPods.jpeg\" alt=\"苹果售后\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天老妈的生日🎂</p>\n<p>猝不及防的狗粮</p>\n<p><img src=\"/img/20210911/pic1.jpeg\" alt=\"老妈的朋友圈\"><br><img src=\"/img/20210911/pic2.jpeg\" alt=\"老妈的朋友圈\"></p>\n<hr>\n<p>苹果的售后真的好，耳机检测了一下就说直接换新的</p>\n<p><img src=\"/img/20210911/AirPods.jpeg\" alt=\"苹果售后\"></p>\n"},{"layout":"zhuawa","title":"web设计模式解析与实战（一）","date":"2021-09-12T05:31:57.000Z","_content":"今天课程主要是讲前端设计模式，早上一节，晚上一节。\n\n---\n\n# 设计模式 \n有利于\n\n1. 组织模块\n\n2. 设计沟通\n\n3. 代码质量\n\n\n\n# 五大设计原则：\n\n1. 开闭原则（OCP：open close principle）\n    - 开-对拓展开放，对修改关闭\n2. 单一职责原则（SRP）\n    - 岗位职责单一，互不重叠\n3. 依赖倒置原则（DIP）\n    - 上层不应该依赖下层实现\n4. 接口隔离原则（ISP）\n    - 多个专业的接口比单个胖借口好用\n5. 里氏替换原则（LSP：the Lxxxx substitution principle）\n    - 子类能够覆盖父类\n    - 父类能够出现的地方子类就能出现\n---\n今天老师给的课后题：\n- 某个**停车场**，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开，\n- 车辆进入前，显示每层的空余车辆数量\n- 车辆进入时，摄像头可识别车牌号和时间\n- 车辆出来时，出口显示器显示车牌号和停车时长\n请设计一套系统。","source":"_posts/2021-09-12-web设计模式解析与实战.md","raw":"---\nlayout: zhuawa\ntitle: web设计模式解析与实战（一）\ndate: 2021-09-12 13:31:57\ntags: 课程\ncategories: 技术类-前端\n---\n今天课程主要是讲前端设计模式，早上一节，晚上一节。\n\n---\n\n# 设计模式 \n有利于\n\n1. 组织模块\n\n2. 设计沟通\n\n3. 代码质量\n\n\n\n# 五大设计原则：\n\n1. 开闭原则（OCP：open close principle）\n    - 开-对拓展开放，对修改关闭\n2. 单一职责原则（SRP）\n    - 岗位职责单一，互不重叠\n3. 依赖倒置原则（DIP）\n    - 上层不应该依赖下层实现\n4. 接口隔离原则（ISP）\n    - 多个专业的接口比单个胖借口好用\n5. 里氏替换原则（LSP：the Lxxxx substitution principle）\n    - 子类能够覆盖父类\n    - 父类能够出现的地方子类就能出现\n---\n今天老师给的课后题：\n- 某个**停车场**，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开，\n- 车辆进入前，显示每层的空余车辆数量\n- 车辆进入时，摄像头可识别车牌号和时间\n- 车辆出来时，出口显示器显示车牌号和停车时长\n请设计一套系统。","slug":"web设计模式解析与实战","published":1,"updated":"2021-10-08T03:11:05.384Z","comments":1,"photos":[],"link":"","_id":"ckwyi18a20007cco9cmmreqv1","content":"<p>今天课程主要是讲前端设计模式，早上一节，晚上一节。</p>\n<hr>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><p>有利于</p>\n<ol>\n<li><p>组织模块</p>\n</li>\n<li><p>设计沟通</p>\n</li>\n<li><p>代码质量</p>\n</li>\n</ol>\n<h1 id=\"五大设计原则：\"><a href=\"#五大设计原则：\" class=\"headerlink\" title=\"五大设计原则：\"></a>五大设计原则：</h1><ol>\n<li>开闭原则（OCP：open close principle）<ul>\n<li>开-对拓展开放，对修改关闭</li>\n</ul>\n</li>\n<li>单一职责原则（SRP）<ul>\n<li>岗位职责单一，互不重叠</li>\n</ul>\n</li>\n<li>依赖倒置原则（DIP）<ul>\n<li>上层不应该依赖下层实现</li>\n</ul>\n</li>\n<li>接口隔离原则（ISP）<ul>\n<li>多个专业的接口比单个胖借口好用</li>\n</ul>\n</li>\n<li>里氏替换原则（LSP：the Lxxxx substitution principle）<ul>\n<li>子类能够覆盖父类</li>\n<li>父类能够出现的地方子类就能出现</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>今天老师给的课后题：</p>\n<ul>\n<li>某个<strong>停车场</strong>，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开，</li>\n<li>车辆进入前，显示每层的空余车辆数量</li>\n<li>车辆进入时，摄像头可识别车牌号和时间</li>\n<li>车辆出来时，出口显示器显示车牌号和停车时长<br>请设计一套系统。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>今天课程主要是讲前端设计模式，早上一节，晚上一节。</p>\n<hr>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><p>有利于</p>\n<ol>\n<li><p>组织模块</p>\n</li>\n<li><p>设计沟通</p>\n</li>\n<li><p>代码质量</p>\n</li>\n</ol>\n<h1 id=\"五大设计原则：\"><a href=\"#五大设计原则：\" class=\"headerlink\" title=\"五大设计原则：\"></a>五大设计原则：</h1><ol>\n<li>开闭原则（OCP：open close principle）<ul>\n<li>开-对拓展开放，对修改关闭</li>\n</ul>\n</li>\n<li>单一职责原则（SRP）<ul>\n<li>岗位职责单一，互不重叠</li>\n</ul>\n</li>\n<li>依赖倒置原则（DIP）<ul>\n<li>上层不应该依赖下层实现</li>\n</ul>\n</li>\n<li>接口隔离原则（ISP）<ul>\n<li>多个专业的接口比单个胖借口好用</li>\n</ul>\n</li>\n<li>里氏替换原则（LSP：the Lxxxx substitution principle）<ul>\n<li>子类能够覆盖父类</li>\n<li>父类能够出现的地方子类就能出现</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>今天老师给的课后题：</p>\n<ul>\n<li>某个<strong>停车场</strong>，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开，</li>\n<li>车辆进入前，显示每层的空余车辆数量</li>\n<li>车辆进入时，摄像头可识别车牌号和时间</li>\n<li>车辆出来时，出口显示器显示车牌号和停车时长<br>请设计一套系统。</li>\n</ul>\n"},{"title":"叔本华《人生的智慧》第一章节","date":"2021-09-13T14:13:47.000Z","_content":"对于阅读人生哲理这一类的书，我一直坚信“尽信书则不如无书”。\n书名叫做《人生的智慧》，第一眼见到就觉得命题有点过于庞大而且作者有些自大。倘若人生的智慧真能总结在一本书中，那我想我们真的应该每个人都手捧一本，而不是什么《红宝书/圣经》。\n但是又不是每个人都爱去阅读，阅读从来都是用来克制自己的而不是去监管别人的。\n许多人把叔本华哲学归为悲观主义，但读完第一章节，他一直在指引我们如何去追求人生的乐趣。\n文章逻辑性强，有理有据，说服力强，看得出叔本华的哲学深度以及译者的功力。\n至少第一章我读下来，确实有不少启发。\n以下是部分抄录\n---\n![叔本华人生的智慧](/img/20210913/renshengdezhihui.png)\n\n---\n # 第一章 基本的划分\n\n决定凡人命运的根本差别在于三项内容：\n- 人的自身，即在最广泛意义上属于人的个性的东西。因此，它包括人的健康、力量、外貌、气质、道德品格、精神智力及其潜在发展。\n- 人所拥有的身外之物，亦即财产和其他占有物。\n- 人向其他人所显示的样子，人在其他人眼中所呈现的样子，亦即人们对他的看法。他人的看法又可分为名誉、地位和名声。\n\n---\n对于一个人的幸福，甚至对于他的整个生存的方式，最主要的明显就是这个人自身的内在素质，它直接决定了这个人是否能够得到内心的幸福，因为人的内心快乐抑或内心痛苦首先就是人的感情、意欲和思想的产物。而人自身之外的所有事物，对于人的幸福都只是间接地发挥影响。因此，同一样外在的事物和同一样的境遇，对于我们每一个人的影响都不尽相同；处在同一样的环境每一个人，都生活在不同的世界中。因为与一个人直接相关的是这一个人对事物的看法、他的感情以及他的意欲活动。外在事物只有在刺激起他的上述东西时才能发挥作用\n\n---\n> “对完全一样的客体时，不同的主体就意味着所构成的现实完全不同，反之亦然”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n注：不同的人对发生的同一件事会有不同的态度和想法\n\n---\n一个人只能直接活在自己的意识之中。因此，外在世界对他帮助不大\n\n---\n   > “对于人来说，存在和发生的一切事情总是直接存在和发生在他的意识里面，所以，很明显，人的意识的构成是首要关键”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books.\n \n注：你的下意识会对发生的事情产生看法。\n\n---\n> “尽管在人的一生中，外在变化不断发生，但人的性格却始终如一，这好比虽然有一连串的变奏，但主旋律却维持不变。无人能够脱离自身个性 ”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n---\n> “对我们的生活幸福而言，我们的自身个性才是最重要和最关键的，因为我们的个性持久不变，它在任何情况下都在发挥着作用”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n---\n>“我们唯一能够做到的就是尽可能充分地利用我们既定的个性。因此，我们应该循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。所以，我们必须选择与我们个性相配的地位、职业和生活方式。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n---\n>“人的自身比起财产和他人对自己的看法具有压倒性的优势；由此可知，注重保持身体健康和发挥个人自身才能比全力投入获得财富更为明智”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“人生最高的乐趣——精神方面的乐趣——对他们来说，是遥不可及的事情。既然如此，他们就只能忙里偷闲地寻求那些短暂的、感官的乐趣——它们费时很少，却耗钱很多。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“人的内在拥有对于人的幸福才是最关键的”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“无聊——它源自上述的精神贫乏和空虚”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“人自身内在的贫乏由此导致了外在财富的贫乏。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“彼德尼斯【3】说过：“一个人所拥有的财产决定了这个人在他人眼中的价值。”如果这句话是正确的话，那么，反过来，他人对自己的良好评价，能以各种形式帮助自己获取财产。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n![今日阅读](/img/20210913/renshengdezhihui2.png)\n","source":"_posts/2021-09-13-叔本华《人生的智慧》第一章节.md","raw":"---\ntitle: 叔本华《人生的智慧》第一章节\ndate: 2021-09-13 22:13:47\ntags: 阅读\ncategories: 阅读\n---\n对于阅读人生哲理这一类的书，我一直坚信“尽信书则不如无书”。\n书名叫做《人生的智慧》，第一眼见到就觉得命题有点过于庞大而且作者有些自大。倘若人生的智慧真能总结在一本书中，那我想我们真的应该每个人都手捧一本，而不是什么《红宝书/圣经》。\n但是又不是每个人都爱去阅读，阅读从来都是用来克制自己的而不是去监管别人的。\n许多人把叔本华哲学归为悲观主义，但读完第一章节，他一直在指引我们如何去追求人生的乐趣。\n文章逻辑性强，有理有据，说服力强，看得出叔本华的哲学深度以及译者的功力。\n至少第一章我读下来，确实有不少启发。\n以下是部分抄录\n---\n![叔本华人生的智慧](/img/20210913/renshengdezhihui.png)\n\n---\n # 第一章 基本的划分\n\n决定凡人命运的根本差别在于三项内容：\n- 人的自身，即在最广泛意义上属于人的个性的东西。因此，它包括人的健康、力量、外貌、气质、道德品格、精神智力及其潜在发展。\n- 人所拥有的身外之物，亦即财产和其他占有物。\n- 人向其他人所显示的样子，人在其他人眼中所呈现的样子，亦即人们对他的看法。他人的看法又可分为名誉、地位和名声。\n\n---\n对于一个人的幸福，甚至对于他的整个生存的方式，最主要的明显就是这个人自身的内在素质，它直接决定了这个人是否能够得到内心的幸福，因为人的内心快乐抑或内心痛苦首先就是人的感情、意欲和思想的产物。而人自身之外的所有事物，对于人的幸福都只是间接地发挥影响。因此，同一样外在的事物和同一样的境遇，对于我们每一个人的影响都不尽相同；处在同一样的环境每一个人，都生活在不同的世界中。因为与一个人直接相关的是这一个人对事物的看法、他的感情以及他的意欲活动。外在事物只有在刺激起他的上述东西时才能发挥作用\n\n---\n> “对完全一样的客体时，不同的主体就意味着所构成的现实完全不同，反之亦然”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n注：不同的人对发生的同一件事会有不同的态度和想法\n\n---\n一个人只能直接活在自己的意识之中。因此，外在世界对他帮助不大\n\n---\n   > “对于人来说，存在和发生的一切事情总是直接存在和发生在他的意识里面，所以，很明显，人的意识的构成是首要关键”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books.\n \n注：你的下意识会对发生的事情产生看法。\n\n---\n> “尽管在人的一生中，外在变化不断发生，但人的性格却始终如一，这好比虽然有一连串的变奏，但主旋律却维持不变。无人能够脱离自身个性 ”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n---\n> “对我们的生活幸福而言，我们的自身个性才是最重要和最关键的，因为我们的个性持久不变，它在任何情况下都在发挥着作用”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n---\n>“我们唯一能够做到的就是尽可能充分地利用我们既定的个性。因此，我们应该循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。所以，我们必须选择与我们个性相配的地位、职业和生活方式。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n\n---\n>“人的自身比起财产和他人对自己的看法具有压倒性的优势；由此可知，注重保持身体健康和发挥个人自身才能比全力投入获得财富更为明智”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“人生最高的乐趣——精神方面的乐趣——对他们来说，是遥不可及的事情。既然如此，他们就只能忙里偷闲地寻求那些短暂的、感官的乐趣——它们费时很少，却耗钱很多。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“人的内在拥有对于人的幸福才是最关键的”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“无聊——它源自上述的精神贫乏和空虚”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“人自身内在的贫乏由此导致了外在财富的贫乏。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n>“彼德尼斯【3】说过：“一个人所拥有的财产决定了这个人在他人眼中的价值。”如果这句话是正确的话，那么，反过来，他人对自己的良好评价，能以各种形式帮助自己获取财产。”\n摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. \n---\n![今日阅读](/img/20210913/renshengdezhihui2.png)\n","slug":"叔本华《人生的智慧》第一章节","published":1,"updated":"2021-10-13T08:44:58.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18a30008cco915lpbzn8","content":"<p>对于阅读人生哲理这一类的书，我一直坚信“尽信书则不如无书”。<br>书名叫做《人生的智慧》，第一眼见到就觉得命题有点过于庞大而且作者有些自大。倘若人生的智慧真能总结在一本书中，那我想我们真的应该每个人都手捧一本，而不是什么《红宝书/圣经》。<br>但是又不是每个人都爱去阅读，阅读从来都是用来克制自己的而不是去监管别人的。<br>许多人把叔本华哲学归为悲观主义，但读完第一章节，他一直在指引我们如何去追求人生的乐趣。<br>文章逻辑性强，有理有据，说服力强，看得出叔本华的哲学深度以及译者的功力。<br>至少第一章我读下来，确实有不少启发。<br>以下是部分抄录</p>\n<hr>\n<p><img src=\"/img/20210913/renshengdezhihui.png\" alt=\"叔本华人生的智慧\"></p>\n<hr>\n<h1 id=\"第一章-基本的划分\"><a href=\"#第一章-基本的划分\" class=\"headerlink\" title=\"第一章 基本的划分\"></a>第一章 基本的划分</h1><p>决定凡人命运的根本差别在于三项内容：</p>\n<ul>\n<li>人的自身，即在最广泛意义上属于人的个性的东西。因此，它包括人的健康、力量、外貌、气质、道德品格、精神智力及其潜在发展。</li>\n<li>人所拥有的身外之物，亦即财产和其他占有物。</li>\n<li>人向其他人所显示的样子，人在其他人眼中所呈现的样子，亦即人们对他的看法。他人的看法又可分为名誉、地位和名声。</li>\n</ul>\n<hr>\n<p>对于一个人的幸福，甚至对于他的整个生存的方式，最主要的明显就是这个人自身的内在素质，它直接决定了这个人是否能够得到内心的幸福，因为人的内心快乐抑或内心痛苦首先就是人的感情、意欲和思想的产物。而人自身之外的所有事物，对于人的幸福都只是间接地发挥影响。因此，同一样外在的事物和同一样的境遇，对于我们每一个人的影响都不尽相同；处在同一样的环境每一个人，都生活在不同的世界中。因为与一个人直接相关的是这一个人对事物的看法、他的感情以及他的意欲活动。外在事物只有在刺激起他的上述东西时才能发挥作用</p>\n<hr>\n<blockquote>\n<p>“对完全一样的客体时，不同的主体就意味着所构成的现实完全不同，反之亦然”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<p>注：不同的人对发生的同一件事会有不同的态度和想法</p>\n<hr>\n<p>一个人只能直接活在自己的意识之中。因此，外在世界对他帮助不大</p>\n<hr>\n<blockquote>\n<p>“对于人来说，存在和发生的一切事情总是直接存在和发生在他的意识里面，所以，很明显，人的意识的构成是首要关键”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books.</p>\n</blockquote>\n<p>注：你的下意识会对发生的事情产生看法。</p>\n<hr>\n<blockquote>\n<p>“尽管在人的一生中，外在变化不断发生，但人的性格却始终如一，这好比虽然有一连串的变奏，但主旋律却维持不变。无人能够脱离自身个性 ”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“对我们的生活幸福而言，我们的自身个性才是最重要和最关键的，因为我们的个性持久不变，它在任何情况下都在发挥着作用”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“我们唯一能够做到的就是尽可能充分地利用我们既定的个性。因此，我们应该循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。所以，我们必须选择与我们个性相配的地位、职业和生活方式。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人的自身比起财产和他人对自己的看法具有压倒性的优势；由此可知，注重保持身体健康和发挥个人自身才能比全力投入获得财富更为明智”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人生最高的乐趣——精神方面的乐趣——对他们来说，是遥不可及的事情。既然如此，他们就只能忙里偷闲地寻求那些短暂的、感官的乐趣——它们费时很少，却耗钱很多。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人的内在拥有对于人的幸福才是最关键的”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“无聊——它源自上述的精神贫乏和空虚”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人自身内在的贫乏由此导致了外在财富的贫乏。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“彼德尼斯【3】说过：“一个人所拥有的财产决定了这个人在他人眼中的价值。”如果这句话是正确的话，那么，反过来，他人对自己的良好评价，能以各种形式帮助自己获取财产。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<p><img src=\"/img/20210913/renshengdezhihui2.png\" alt=\"今日阅读\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>对于阅读人生哲理这一类的书，我一直坚信“尽信书则不如无书”。<br>书名叫做《人生的智慧》，第一眼见到就觉得命题有点过于庞大而且作者有些自大。倘若人生的智慧真能总结在一本书中，那我想我们真的应该每个人都手捧一本，而不是什么《红宝书/圣经》。<br>但是又不是每个人都爱去阅读，阅读从来都是用来克制自己的而不是去监管别人的。<br>许多人把叔本华哲学归为悲观主义，但读完第一章节，他一直在指引我们如何去追求人生的乐趣。<br>文章逻辑性强，有理有据，说服力强，看得出叔本华的哲学深度以及译者的功力。<br>至少第一章我读下来，确实有不少启发。<br>以下是部分抄录</p>\n<hr>\n<p><img src=\"/img/20210913/renshengdezhihui.png\" alt=\"叔本华人生的智慧\"></p>\n<hr>\n<h1 id=\"第一章-基本的划分\"><a href=\"#第一章-基本的划分\" class=\"headerlink\" title=\"第一章 基本的划分\"></a>第一章 基本的划分</h1><p>决定凡人命运的根本差别在于三项内容：</p>\n<ul>\n<li>人的自身，即在最广泛意义上属于人的个性的东西。因此，它包括人的健康、力量、外貌、气质、道德品格、精神智力及其潜在发展。</li>\n<li>人所拥有的身外之物，亦即财产和其他占有物。</li>\n<li>人向其他人所显示的样子，人在其他人眼中所呈现的样子，亦即人们对他的看法。他人的看法又可分为名誉、地位和名声。</li>\n</ul>\n<hr>\n<p>对于一个人的幸福，甚至对于他的整个生存的方式，最主要的明显就是这个人自身的内在素质，它直接决定了这个人是否能够得到内心的幸福，因为人的内心快乐抑或内心痛苦首先就是人的感情、意欲和思想的产物。而人自身之外的所有事物，对于人的幸福都只是间接地发挥影响。因此，同一样外在的事物和同一样的境遇，对于我们每一个人的影响都不尽相同；处在同一样的环境每一个人，都生活在不同的世界中。因为与一个人直接相关的是这一个人对事物的看法、他的感情以及他的意欲活动。外在事物只有在刺激起他的上述东西时才能发挥作用</p>\n<hr>\n<blockquote>\n<p>“对完全一样的客体时，不同的主体就意味着所构成的现实完全不同，反之亦然”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<p>注：不同的人对发生的同一件事会有不同的态度和想法</p>\n<hr>\n<p>一个人只能直接活在自己的意识之中。因此，外在世界对他帮助不大</p>\n<hr>\n<blockquote>\n<p>“对于人来说，存在和发生的一切事情总是直接存在和发生在他的意识里面，所以，很明显，人的意识的构成是首要关键”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books.</p>\n</blockquote>\n<p>注：你的下意识会对发生的事情产生看法。</p>\n<hr>\n<blockquote>\n<p>“尽管在人的一生中，外在变化不断发生，但人的性格却始终如一，这好比虽然有一连串的变奏，但主旋律却维持不变。无人能够脱离自身个性 ”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“对我们的生活幸福而言，我们的自身个性才是最重要和最关键的，因为我们的个性持久不变，它在任何情况下都在发挥着作用”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“我们唯一能够做到的就是尽可能充分地利用我们既定的个性。因此，我们应该循着符合我们个性的方向，努力争取适合个性的发展，除此之外则一概避免。所以，我们必须选择与我们个性相配的地位、职业和生活方式。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人的自身比起财产和他人对自己的看法具有压倒性的优势；由此可知，注重保持身体健康和发挥个人自身才能比全力投入获得财富更为明智”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人生最高的乐趣——精神方面的乐趣——对他们来说，是遥不可及的事情。既然如此，他们就只能忙里偷闲地寻求那些短暂的、感官的乐趣——它们费时很少，却耗钱很多。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人的内在拥有对于人的幸福才是最关键的”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“无聊——它源自上述的精神贫乏和空虚”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“人自身内在的贫乏由此导致了外在财富的贫乏。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>“彼德尼斯【3】说过：“一个人所拥有的财产决定了这个人在他人眼中的价值。”如果这句话是正确的话，那么，反过来，他人对自己的良好评价，能以各种形式帮助自己获取财产。”<br>摘录来自: 叔本华(Arthur Schopenhauer). “人生的智慧。” Apple Books. </p>\n</blockquote>\n<hr>\n<p><img src=\"/img/20210913/renshengdezhihui2.png\" alt=\"今日阅读\"></p>\n"},{"title":"通读vue3文档记录","date":"2021-09-15T11:03:11.000Z","_content":"之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是`Object.defineProperty()`，vue3用的是`Proxy`。vue3还新增了`组合式API`等等。\n\n这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。\n\n持续更新ing\n\n# 应用&组件实例\n## 应用实例\n每个 Vue 应用都是通过用 createApp 函数创建一个新的**应用实例**开始的：\n\n```js\nconst app = Vue.createApp({ /* 选项 */ })\n```\n\n该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：\n```js\nconst app = Vue.createApp({})\napp.component('SearchInput', SearchInputComponent)\napp.directive('focus', FocusDirective)\napp.use(LocalePlugin)\n```\n应用实例暴露的大多数方法都会返回该同一实例，允许链式：\n```js\nVue.createApp({})\n  .component('SearchInput', SearchInputComponent)\n  .directive('focus', FocusDirective)\n  .use(LocalePlugin)\n```\n\n## 根组件实例\n传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。\n\n一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 `<div id=\"app\"></div>`，我们应该传递 `#app`：\n```js\nconst RootComponent = { /* 选项 */ }\nconst app = Vue.createApp(RootComponent)\nconst vm = app.mount('#app')\n```\n与大多数应用方法不同的是，`mount` 不返回应用本身。相反，它返回的是**根组件实例**。\n\n虽然没有完全遵循 `MVVM` 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。\n\n# 计算属性&侦听器\n## 计算属性缓存 vs 方法\n    \n你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：\n```html\n<p>{{ calculateBooksMessage() }}</p>\n```\n```js\n// 在组件中\nmethods: {\n  calculateBooksMessage() {\n    return this.author.books.length > 0 ? 'Yes' : 'No'\n  }\n}\n```\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要`author.books` 还没有发生改变，多次访问 `publishedBookMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。 \n\n这也同样意味着下面的计算属性将不再更新，因为 **Date.now () 不是响应式依赖**：\n```js\ncomputed: {\n  now() {\n    return Date.now()\n  }\n}\n```\n相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。\n\n我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 `list`，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 `list`。如果没有缓存，我们将不可避免的多次执行 `list` 的 getter！如果你不希望有缓存，请用 method 来替代\n\n---\n以下为2021.09.16更新\n---\n## 计算属性的 Setter\n计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：\n```js\n// ...\ncomputed: {\n  fullName: {\n    // getter\n    get() {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set(newValue) {\n      const names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n// ...\n```\n现在再运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应地被更新。\n\n# Class与Style绑定\n如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作：\n```js\n<div id=\"app\">\n  <my-component class=\"baz\"></my-component>\n</div>\nconst app = Vue.createApp({})\n\napp.component('my-component', {\n  template: `\n    <p :class=\"$attrs.class\">Hi!</p>\n    <span>This is a child component</span>\n  `\n})\n```\n\n# 条件渲染\n\n## `v-if` vs `v-show`\n`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n`v-if` 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好\n\n## v-if 与 v-for 一起使用\n> 提示 不推荐同时使用 v-if 和 v-for\n\n当 `v-if` 与 `v-for` 一起使用时，`v-if` 具有比 `v-for` 更高的优先级。请查阅列表渲染指南以获取详细信息。\n\n当它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量：\n```js\n<!-- This will throw an error because property \"todo\" is not defined on instance. -->\n\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n  {{ todo }}\n</li>\n```\n可以把 v-for 移动到`<template>` 标签中来修正：\n```js\n<template v-for=\"todo in todos\">\n  <li v-if=\"!todo.isComplete\">\n    {{ todo }}\n  </li>\n</template>\n```\n# 表单绑定输入\n## 基础用法\n`v-model` 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：\n\n- text 和 textarea 元素使用 value property 和 input 事件；\n- checkbox 和 radio 使用 checked property 和 change 事件；\n- select 字段将 value 作为 prop 并将 change 作为事件。\n\n# 组件基础\n## 基本实例\n这里有一个 Vue 组件的示例：\n```js\n// 创建一个Vue 应用\nconst app = Vue.createApp({})\n\n// 定义一个名为 button-counter 的新全局组件\napp.component('button-counter', {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n})\n```\n## 组件的复用\n你可以将组件进行任意次数的复用\n每个组件都会各自独立维护它的`data`。因为你每用一次组件，就会有一个它的新组件实例被创建\n\n## 在组件上使用 v-model\n自定义事件也可以用于创建支持 `v-model` 的自定义输入组件。记住：\n```js\n<input v-model=\"searchText\" />\n等价于：\n\n<input :value=\"searchText\" @input=\"searchText = $event.target.value\" />\n当用在组件上时，v-model 则会这样：\n\n<custom-input\n  :model-value=\"searchText\"\n  @update:model-value=\"searchText = $event\"\n></custom-input>\n```\n为了让它正常工作，这个组件内的 `<input>` 必须：\n\n将其 `value` attribute 绑定到一个名叫 `modelValue` 的 prop 上\n在其 `input` 事件被触发时，将新的值通过自定义的 `update:modelValue` 事件抛出\n写成代码之后是这样的：\n```js\napp.component('custom-input', {\n  props: ['modelValue'],\n  template: `\n    <input\n      :value=\"modelValue\"\n      @input=\"$emit('update:modelValue', $event.target.value)\"\n    >\n  `\n})\n```\n现在 `v-model` 就应该可以在这个组件上完美地工作起来了：\n```html\n<custom-input v-model=\"searchText\"></custom-input>\n```\n# 深入组件\n## 非 Prop 的 Attribute\n### Attribute 继承\n当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 `<date-picker>` 组件的实例中：\n```js\napp.component('date-picker', {\n  template: `\n    <div class=\"date-picker\">\n      <input type=\"datetime\" />\n    </div>\n  `\n})\n```\n如果我们需要通过 `data status` property 定义 `<date-picker>` 组件的状态，它将应用于根节点 (即 `div.date-picker`)。\n```html\n<!-- 具有非prop attribute的Date-picker组件-->\n<date-picker data-status=\"activated\"></date-picker>\n\n<!-- 渲染 date-picker 组件 -->\n<div class=\"date-picker\" data-status=\"activated\">\n  <input type=\"datetime\" />\n</div>\n```\n\n同样的规则适用于事件监听器：\n```html\n<date-picker @change=\"submitChange\"></date-picker>\n```\n```js\napp.component('date-picker', {\n  created() {\n    console.log(this.$attrs) // { onChange: () => {}  }\n  }\n})\n```\n当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。\n```js\napp.component('date-picker', {\n  template: `\n    <select>\n      <option value=\"1\">Yesterday</option>\n      <option value=\"2\">Today</option>\n      <option value=\"3\">Tomorrow</option>\n    </select>\n  `\n})\n```\n在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件：\n```html\n<div id=\"date-picker\" class=\"demo\">\n  <date-picker @change=\"showChange\"></date-picker>\n</div>\n```\n```js\nconst app = Vue.createApp({\n  methods: {\n    showChange(event) {\n      console.log(event.target.value) // 将记录所选选项的值\n    }\n  }\n})\n```\n\n### 禁用 Attribute 继承\n如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 `inheritAttrs: false`。例如：\n\n禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。\n\n通过将 `inheritAttrs` 选项设置为 `false`，你可以访问组件的 `$attrs` property，该 property 包括组件 `props` 和 `emits` property 中未包含的所有属性 (例如，`class`、`style`、`v-on` 监听器等)。\n```js\napp.component('date-picker', {\n  inheritAttrs: false,\n  template: `\n    <div class=\"date-picker\">\n      <input type=\"datetime\" v-bind=\"$attrs\" />\n    </div>\n  `\n})\n```\n有了这个新配置，`data status` attribute 将应用于 `input` 元素！\n```html\n<!-- Date-picker 组件 使用非 prop attribute -->\n<date-picker data-status=\"activated\"></date-picker>\n\n<!-- 渲染 date-picker 组件 -->\n<div class=\"date-picker\">\n  <input type=\"datetime\" data-status=\"activated\" />\n</div>\n```\n\n### 多个根节点上的 Attribute 继承\n与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。\n```html\n<custom-layout id=\"custom-layout\" @click=\"changeValue\"></custom-layout>\n```\n```js\n// 这将发出警告\napp.component('custom-layout', {\n  template: `\n    <header>...</header>\n    <main>...</main>\n    <footer>...</footer>\n  `\n})\n\n// 没有警告，$attrs被传递到<main>元素\napp.component('custom-layout', {\n  template: `\n    <header>...</header>\n    <main v-bind=\"$attrs\">...</main>\n    <footer>...</footer>\n  `\n})\n```\n## 自定义事件\n### 处理 v-model 修饰符\n在 2.x 中，我们对组件 `v-model` 上的 `.trim` 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 `v-model` 的修饰符将通过 `modelModifiers` prop 提供给组件：\n\n让我们创建一个示例自定义修饰符 `capitalize`，它将 `v-model` 绑定提供的字符串的第一个字母大写。\n\n添加到组件 `v-model` 的修饰符将通过 `modelModifiers` prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 `modelModifiers` prop。\n\n请注意，当组件的 `created` 生命周期钩子触发时，`modelModifiers` prop 包含 `capitalize`，其值为 `true`——因为它被设置在 `v-model` 绑定 `v-model.capitalize=\"bar\"`。\n```html\n<my-component v-model.capitalize=\"bar\"></my-component>\n```\n\n```js\napp.component('my-component', {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  template: `\n    <input type=\"text\" \n      :value=\"modelValue\"\n      @input=\"$emit('update:modelValue', $event.target.value)\">\n  `,\n  created() {\n    console.log(this.modelModifiers) // { capitalize: true }\n  }\n})\n```\n现在我们已经设置了 prop，我们可以检查 `modelModifiers` 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 `<input/>` 元素触发 `input` 事件时，我们都将字符串大写。\n```html\n<div id=\"app\">\n  <my-component v-model.capitalize=\"myText\"></my-component>\n  {{ myText }}\n</div>\n```\n```js\nconst app = Vue.createApp({\n  data() {\n    return {\n      myText: ''\n    }\n  }\n})\n\napp.component('my-component', {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  methods: {\n    emitValue(e) {\n      let value = e.target.value\n      if (this.modelModifiers.capitalize) {\n        value = value.charAt(0).toUpperCase() + value.slice(1)\n      }\n      this.$emit('update:modelValue', value)\n    }\n  },\n  template: `<input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"emitValue\">`\n})\n\napp.mount('#app')\n```\n对于带参数的 `v-model` 绑定，生成的 prop 名称将为 `arg + \"Modifiers\"`：\n```html\n<my-component v-model:foo.capitalize=\"bar\"></my-component>\n```\n```js\napp.component('my-component', {\n  props: ['foo', 'fooModifiers'],\n  template: `\n    <input type=\"text\" \n      :value=\"foo\"\n      @input=\"$emit('update:foo', $event.target.value)\">\n  `,\n  created() {\n    console.log(this.fooModifiers) // { capitalize: true }\n  }\n})\n```\n---\n2021.09.17更新\n---\n## 提供/注入\n通常，当我们需要将数据从父组件传递到子组件时，我们使用`props`。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。\n\n对于这种情况，我们可以使用 `provide` 和 `inject` 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 `provide` 选项来提供数据，子组件有一个 `inject` 选项来开始使用这个数据。\n\n# 可复用&组合\n## 渲染函数\n### 虚拟DOM树\nVue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：\n```js\nreturn Vue.h('h1', {}, this.blogTitle)\n```\n`h()` 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 **VNode**。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。\n\n### h()参数\nh() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：\n\n```js\nh(\n  // {String | Object | Function | null} tag\n  // 一个 HTML 标签名、一个组件、一个异步组件，或者 null。\n  // 使用 null 将会渲染一个注释。\n  //\n  // 必需的。\n  'div',\n\n  // {Object} props\n  // 与 attribute、prop 和事件相对应的对象。\n  // 我们会在模板中使用。\n  //\n  // 可选的。\n  {},\n\n  // {String | Array | Object} children\n  // 子 VNodes, 使用 `h()` 构建,\n  // 或使用字符串获取 \"文本 Vnode\" 或者\n  // 有 slot 的对象。\n  //\n  // 可选的。\n  [\n    'Some text comes first.',\n    h('h1', 'A headline'),\n    h(MyComponent, {\n      someProp: 'foobar'\n    })\n  ]\n)\n```\n\n### 完整实例\n有了这些知识，我们现在可以完成我们最开始想实现的组件：\n```js\nconst app = Vue.createApp({})\n\n/** Recursively get text from children nodes */\nfunction getChildrenTextContent(children) {\n  return children\n    .map(node => {\n      return typeof node.children === 'string'\n        ? node.children\n        : Array.isArray(node.children)\n        ? getChildrenTextContent(node.children)\n        : ''\n    })\n    .join('')\n}\n\napp.component('anchored-heading', {\n  render() {\n    // create kebab-case id from the text contents of the children\n    const headingId = getChildrenTextContent(this.$slots.default())\n      .toLowerCase()\n      .replace(/\\W+/g, '-') // replace non-word characters with dash\n      .replace(/(^-|-$)/g, '') // remove leading and trailing dashes\n\n    return Vue.h('h' + this.level, [\n      Vue.h(\n        'a',\n        {\n          name: headingId,\n          href: '#' + headingId\n        },\n        this.$slots.default()\n      )\n    ])\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```","source":"_posts/2021-09-15-vue3文档记录.md","raw":"---\ntitle: 通读vue3文档记录\ndate: 2021-09-15 19:03:11\ntags: Vue3\ncategories: 技术类-Vue\n---\n之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是`Object.defineProperty()`，vue3用的是`Proxy`。vue3还新增了`组合式API`等等。\n\n这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。\n\n持续更新ing\n\n# 应用&组件实例\n## 应用实例\n每个 Vue 应用都是通过用 createApp 函数创建一个新的**应用实例**开始的：\n\n```js\nconst app = Vue.createApp({ /* 选项 */ })\n```\n\n该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：\n```js\nconst app = Vue.createApp({})\napp.component('SearchInput', SearchInputComponent)\napp.directive('focus', FocusDirective)\napp.use(LocalePlugin)\n```\n应用实例暴露的大多数方法都会返回该同一实例，允许链式：\n```js\nVue.createApp({})\n  .component('SearchInput', SearchInputComponent)\n  .directive('focus', FocusDirective)\n  .use(LocalePlugin)\n```\n\n## 根组件实例\n传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。\n\n一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 `<div id=\"app\"></div>`，我们应该传递 `#app`：\n```js\nconst RootComponent = { /* 选项 */ }\nconst app = Vue.createApp(RootComponent)\nconst vm = app.mount('#app')\n```\n与大多数应用方法不同的是，`mount` 不返回应用本身。相反，它返回的是**根组件实例**。\n\n虽然没有完全遵循 `MVVM` 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。\n\n# 计算属性&侦听器\n## 计算属性缓存 vs 方法\n    \n你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：\n```html\n<p>{{ calculateBooksMessage() }}</p>\n```\n```js\n// 在组件中\nmethods: {\n  calculateBooksMessage() {\n    return this.author.books.length > 0 ? 'Yes' : 'No'\n  }\n}\n```\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要`author.books` 还没有发生改变，多次访问 `publishedBookMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。 \n\n这也同样意味着下面的计算属性将不再更新，因为 **Date.now () 不是响应式依赖**：\n```js\ncomputed: {\n  now() {\n    return Date.now()\n  }\n}\n```\n相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。\n\n我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 `list`，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 `list`。如果没有缓存，我们将不可避免的多次执行 `list` 的 getter！如果你不希望有缓存，请用 method 来替代\n\n---\n以下为2021.09.16更新\n---\n## 计算属性的 Setter\n计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：\n```js\n// ...\ncomputed: {\n  fullName: {\n    // getter\n    get() {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set(newValue) {\n      const names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n// ...\n```\n现在再运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应地被更新。\n\n# Class与Style绑定\n如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作：\n```js\n<div id=\"app\">\n  <my-component class=\"baz\"></my-component>\n</div>\nconst app = Vue.createApp({})\n\napp.component('my-component', {\n  template: `\n    <p :class=\"$attrs.class\">Hi!</p>\n    <span>This is a child component</span>\n  `\n})\n```\n\n# 条件渲染\n\n## `v-if` vs `v-show`\n`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n`v-if` 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好\n\n## v-if 与 v-for 一起使用\n> 提示 不推荐同时使用 v-if 和 v-for\n\n当 `v-if` 与 `v-for` 一起使用时，`v-if` 具有比 `v-for` 更高的优先级。请查阅列表渲染指南以获取详细信息。\n\n当它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量：\n```js\n<!-- This will throw an error because property \"todo\" is not defined on instance. -->\n\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n  {{ todo }}\n</li>\n```\n可以把 v-for 移动到`<template>` 标签中来修正：\n```js\n<template v-for=\"todo in todos\">\n  <li v-if=\"!todo.isComplete\">\n    {{ todo }}\n  </li>\n</template>\n```\n# 表单绑定输入\n## 基础用法\n`v-model` 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：\n\n- text 和 textarea 元素使用 value property 和 input 事件；\n- checkbox 和 radio 使用 checked property 和 change 事件；\n- select 字段将 value 作为 prop 并将 change 作为事件。\n\n# 组件基础\n## 基本实例\n这里有一个 Vue 组件的示例：\n```js\n// 创建一个Vue 应用\nconst app = Vue.createApp({})\n\n// 定义一个名为 button-counter 的新全局组件\napp.component('button-counter', {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n})\n```\n## 组件的复用\n你可以将组件进行任意次数的复用\n每个组件都会各自独立维护它的`data`。因为你每用一次组件，就会有一个它的新组件实例被创建\n\n## 在组件上使用 v-model\n自定义事件也可以用于创建支持 `v-model` 的自定义输入组件。记住：\n```js\n<input v-model=\"searchText\" />\n等价于：\n\n<input :value=\"searchText\" @input=\"searchText = $event.target.value\" />\n当用在组件上时，v-model 则会这样：\n\n<custom-input\n  :model-value=\"searchText\"\n  @update:model-value=\"searchText = $event\"\n></custom-input>\n```\n为了让它正常工作，这个组件内的 `<input>` 必须：\n\n将其 `value` attribute 绑定到一个名叫 `modelValue` 的 prop 上\n在其 `input` 事件被触发时，将新的值通过自定义的 `update:modelValue` 事件抛出\n写成代码之后是这样的：\n```js\napp.component('custom-input', {\n  props: ['modelValue'],\n  template: `\n    <input\n      :value=\"modelValue\"\n      @input=\"$emit('update:modelValue', $event.target.value)\"\n    >\n  `\n})\n```\n现在 `v-model` 就应该可以在这个组件上完美地工作起来了：\n```html\n<custom-input v-model=\"searchText\"></custom-input>\n```\n# 深入组件\n## 非 Prop 的 Attribute\n### Attribute 继承\n当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 `<date-picker>` 组件的实例中：\n```js\napp.component('date-picker', {\n  template: `\n    <div class=\"date-picker\">\n      <input type=\"datetime\" />\n    </div>\n  `\n})\n```\n如果我们需要通过 `data status` property 定义 `<date-picker>` 组件的状态，它将应用于根节点 (即 `div.date-picker`)。\n```html\n<!-- 具有非prop attribute的Date-picker组件-->\n<date-picker data-status=\"activated\"></date-picker>\n\n<!-- 渲染 date-picker 组件 -->\n<div class=\"date-picker\" data-status=\"activated\">\n  <input type=\"datetime\" />\n</div>\n```\n\n同样的规则适用于事件监听器：\n```html\n<date-picker @change=\"submitChange\"></date-picker>\n```\n```js\napp.component('date-picker', {\n  created() {\n    console.log(this.$attrs) // { onChange: () => {}  }\n  }\n})\n```\n当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。\n```js\napp.component('date-picker', {\n  template: `\n    <select>\n      <option value=\"1\">Yesterday</option>\n      <option value=\"2\">Today</option>\n      <option value=\"3\">Tomorrow</option>\n    </select>\n  `\n})\n```\n在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件：\n```html\n<div id=\"date-picker\" class=\"demo\">\n  <date-picker @change=\"showChange\"></date-picker>\n</div>\n```\n```js\nconst app = Vue.createApp({\n  methods: {\n    showChange(event) {\n      console.log(event.target.value) // 将记录所选选项的值\n    }\n  }\n})\n```\n\n### 禁用 Attribute 继承\n如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 `inheritAttrs: false`。例如：\n\n禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。\n\n通过将 `inheritAttrs` 选项设置为 `false`，你可以访问组件的 `$attrs` property，该 property 包括组件 `props` 和 `emits` property 中未包含的所有属性 (例如，`class`、`style`、`v-on` 监听器等)。\n```js\napp.component('date-picker', {\n  inheritAttrs: false,\n  template: `\n    <div class=\"date-picker\">\n      <input type=\"datetime\" v-bind=\"$attrs\" />\n    </div>\n  `\n})\n```\n有了这个新配置，`data status` attribute 将应用于 `input` 元素！\n```html\n<!-- Date-picker 组件 使用非 prop attribute -->\n<date-picker data-status=\"activated\"></date-picker>\n\n<!-- 渲染 date-picker 组件 -->\n<div class=\"date-picker\">\n  <input type=\"datetime\" data-status=\"activated\" />\n</div>\n```\n\n### 多个根节点上的 Attribute 继承\n与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。\n```html\n<custom-layout id=\"custom-layout\" @click=\"changeValue\"></custom-layout>\n```\n```js\n// 这将发出警告\napp.component('custom-layout', {\n  template: `\n    <header>...</header>\n    <main>...</main>\n    <footer>...</footer>\n  `\n})\n\n// 没有警告，$attrs被传递到<main>元素\napp.component('custom-layout', {\n  template: `\n    <header>...</header>\n    <main v-bind=\"$attrs\">...</main>\n    <footer>...</footer>\n  `\n})\n```\n## 自定义事件\n### 处理 v-model 修饰符\n在 2.x 中，我们对组件 `v-model` 上的 `.trim` 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 `v-model` 的修饰符将通过 `modelModifiers` prop 提供给组件：\n\n让我们创建一个示例自定义修饰符 `capitalize`，它将 `v-model` 绑定提供的字符串的第一个字母大写。\n\n添加到组件 `v-model` 的修饰符将通过 `modelModifiers` prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 `modelModifiers` prop。\n\n请注意，当组件的 `created` 生命周期钩子触发时，`modelModifiers` prop 包含 `capitalize`，其值为 `true`——因为它被设置在 `v-model` 绑定 `v-model.capitalize=\"bar\"`。\n```html\n<my-component v-model.capitalize=\"bar\"></my-component>\n```\n\n```js\napp.component('my-component', {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  template: `\n    <input type=\"text\" \n      :value=\"modelValue\"\n      @input=\"$emit('update:modelValue', $event.target.value)\">\n  `,\n  created() {\n    console.log(this.modelModifiers) // { capitalize: true }\n  }\n})\n```\n现在我们已经设置了 prop，我们可以检查 `modelModifiers` 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 `<input/>` 元素触发 `input` 事件时，我们都将字符串大写。\n```html\n<div id=\"app\">\n  <my-component v-model.capitalize=\"myText\"></my-component>\n  {{ myText }}\n</div>\n```\n```js\nconst app = Vue.createApp({\n  data() {\n    return {\n      myText: ''\n    }\n  }\n})\n\napp.component('my-component', {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  methods: {\n    emitValue(e) {\n      let value = e.target.value\n      if (this.modelModifiers.capitalize) {\n        value = value.charAt(0).toUpperCase() + value.slice(1)\n      }\n      this.$emit('update:modelValue', value)\n    }\n  },\n  template: `<input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"emitValue\">`\n})\n\napp.mount('#app')\n```\n对于带参数的 `v-model` 绑定，生成的 prop 名称将为 `arg + \"Modifiers\"`：\n```html\n<my-component v-model:foo.capitalize=\"bar\"></my-component>\n```\n```js\napp.component('my-component', {\n  props: ['foo', 'fooModifiers'],\n  template: `\n    <input type=\"text\" \n      :value=\"foo\"\n      @input=\"$emit('update:foo', $event.target.value)\">\n  `,\n  created() {\n    console.log(this.fooModifiers) // { capitalize: true }\n  }\n})\n```\n---\n2021.09.17更新\n---\n## 提供/注入\n通常，当我们需要将数据从父组件传递到子组件时，我们使用`props`。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。\n\n对于这种情况，我们可以使用 `provide` 和 `inject` 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 `provide` 选项来提供数据，子组件有一个 `inject` 选项来开始使用这个数据。\n\n# 可复用&组合\n## 渲染函数\n### 虚拟DOM树\nVue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：\n```js\nreturn Vue.h('h1', {}, this.blogTitle)\n```\n`h()` 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 **VNode**。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。\n\n### h()参数\nh() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：\n\n```js\nh(\n  // {String | Object | Function | null} tag\n  // 一个 HTML 标签名、一个组件、一个异步组件，或者 null。\n  // 使用 null 将会渲染一个注释。\n  //\n  // 必需的。\n  'div',\n\n  // {Object} props\n  // 与 attribute、prop 和事件相对应的对象。\n  // 我们会在模板中使用。\n  //\n  // 可选的。\n  {},\n\n  // {String | Array | Object} children\n  // 子 VNodes, 使用 `h()` 构建,\n  // 或使用字符串获取 \"文本 Vnode\" 或者\n  // 有 slot 的对象。\n  //\n  // 可选的。\n  [\n    'Some text comes first.',\n    h('h1', 'A headline'),\n    h(MyComponent, {\n      someProp: 'foobar'\n    })\n  ]\n)\n```\n\n### 完整实例\n有了这些知识，我们现在可以完成我们最开始想实现的组件：\n```js\nconst app = Vue.createApp({})\n\n/** Recursively get text from children nodes */\nfunction getChildrenTextContent(children) {\n  return children\n    .map(node => {\n      return typeof node.children === 'string'\n        ? node.children\n        : Array.isArray(node.children)\n        ? getChildrenTextContent(node.children)\n        : ''\n    })\n    .join('')\n}\n\napp.component('anchored-heading', {\n  render() {\n    // create kebab-case id from the text contents of the children\n    const headingId = getChildrenTextContent(this.$slots.default())\n      .toLowerCase()\n      .replace(/\\W+/g, '-') // replace non-word characters with dash\n      .replace(/(^-|-$)/g, '') // remove leading and trailing dashes\n\n    return Vue.h('h' + this.level, [\n      Vue.h(\n        'a',\n        {\n          name: headingId,\n          href: '#' + headingId\n        },\n        this.$slots.default()\n      )\n    ])\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```","slug":"vue3文档记录","published":1,"updated":"2021-09-17T10:41:59.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18a6000ccco9dqjugx7a","content":"<p>之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是<code>Object.defineProperty()</code>，vue3用的是<code>Proxy</code>。vue3还新增了<code>组合式API</code>等等。</p>\n<p>这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。</p>\n<p>持续更新ing</p>\n<h1 id=\"应用-amp-组件实例\"><a href=\"#应用-amp-组件实例\" class=\"headerlink\" title=\"应用&amp;组件实例\"></a>应用&amp;组件实例</h1><h2 id=\"应用实例\"><a href=\"#应用实例\" class=\"headerlink\" title=\"应用实例\"></a>应用实例</h2><p>每个 Vue 应用都是通过用 createApp 函数创建一个新的<strong>应用实例</strong>开始的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123; <span class=\"hljs-comment\">/* 选项 */</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n<p>该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br>app.component(<span class=\"hljs-string\">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>app.directive(<span class=\"hljs-string\">&#x27;focus&#x27;</span>, FocusDirective)<br>app.use(LocalePlugin)<br></code></pre></td></tr></table></figure>\n<p>应用实例暴露的大多数方法都会返回该同一实例，允许链式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">Vue.createApp(&#123;&#125;)<br>  .component(<span class=\"hljs-string\">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>  .directive(<span class=\"hljs-string\">&#x27;focus&#x27;</span>, FocusDirective)<br>  .use(LocalePlugin)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"根组件实例\"><a href=\"#根组件实例\" class=\"headerlink\" title=\"根组件实例\"></a>根组件实例</h2><p>传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。</p>\n<p>一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，我们应该传递 <code>#app</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> RootComponent = &#123; <span class=\"hljs-comment\">/* 选项 */</span> &#125;<br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(RootComponent)<br><span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>与大多数应用方法不同的是，<code>mount</code> 不返回应用本身。相反，它返回的是<strong>根组件实例</strong>。</p>\n<p>虽然没有完全遵循 <code>MVVM</code> 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。</p>\n<h1 id=\"计算属性-amp-侦听器\"><a href=\"#计算属性-amp-侦听器\" class=\"headerlink\" title=\"计算属性&amp;侦听器\"></a>计算属性&amp;侦听器</h1><h2 id=\"计算属性缓存-vs-方法\"><a href=\"#计算属性缓存-vs-方法\" class=\"headerlink\" title=\"计算属性缓存 vs 方法\"></a>计算属性缓存 vs 方法</h2><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123; calculateBooksMessage() &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 在组件中</span><br><span class=\"hljs-attr\">methods</span>: &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">calculateBooksMessage</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.author.books.length &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-string\">&#x27;Yes&#x27;</span> : <span class=\"hljs-string\">&#x27;No&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要<code>author.books</code> 还没有发生改变，多次访问 <code>publishedBookMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。 </p>\n<p>这也同样意味着下面的计算属性将不再更新，因为 <strong>Date.now () 不是响应式依赖</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">computed: &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">now</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Date</span>.now()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p>\n<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <code>list</code>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <code>list</code>。如果没有缓存，我们将不可避免的多次执行 <code>list</code> 的 getter！如果你不希望有缓存，请用 method 来替代</p>\n<hr>\n<h2 id=\"以下为2021-09-16更新\"><a href=\"#以下为2021-09-16更新\" class=\"headerlink\" title=\"以下为2021.09.16更新\"></a>以下为2021.09.16更新</h2><h2 id=\"计算属性的-Setter\"><a href=\"#计算属性的-Setter\" class=\"headerlink\" title=\"计算属性的 Setter\"></a>计算属性的 Setter</h2><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// ...</span><br><span class=\"hljs-attr\">computed</span>: &#123;<br>  <span class=\"hljs-attr\">fullName</span>: &#123;<br>    <span class=\"hljs-comment\">// getter</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.firstName + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-built_in\">this</span>.lastName<br>    &#125;,<br>    <span class=\"hljs-comment\">// setter</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\">newValue</span>)</span> &#123;<br>      <span class=\"hljs-keyword\">const</span> names = newValue.split(<span class=\"hljs-string\">&#x27; &#x27;</span>)<br>      <span class=\"hljs-built_in\">this</span>.firstName = names[<span class=\"hljs-number\">0</span>]<br>      <span class=\"hljs-built_in\">this</span>.lastName = names[names.length - <span class=\"hljs-number\">1</span>]<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// ...</span><br></code></pre></td></tr></table></figure>\n<p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p>\n<h1 id=\"Class与Style绑定\"><a href=\"#Class与Style绑定\" class=\"headerlink\" title=\"Class与Style绑定\"></a>Class与Style绑定</h1><p>如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;div id=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;baz&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></span><br>&lt;/div&gt;<br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br>app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;</span><br><span class=\"hljs-string\">    &lt;span&gt;This is a child component&lt;/span&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h1><h2 id=\"v-if-vs-v-show\"><a href=\"#v-if-vs-v-show\" class=\"headerlink\" title=\"v-if vs v-show\"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>\n<p><code>v-if</code> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>\n<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>\n<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好</p>\n<h2 id=\"v-if-与-v-for-一起使用\"><a href=\"#v-if-与-v-for-一起使用\" class=\"headerlink\" title=\"v-if 与 v-for 一起使用\"></a>v-if 与 v-for 一起使用</h2><blockquote>\n<p>提示 不推荐同时使用 v-if 和 v-for</p>\n</blockquote>\n<p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-if</code> 具有比 <code>v-for</code> 更高的优先级。请查阅列表渲染指南以获取详细信息。</p>\n<p>当它们处于同一节点，<code>v-if</code> 的优先级比 <code>v-for</code> 更高，这意味着 <code>v-if</code> 将没有权限访问 <code>v-for</code> 里的变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;!-- This will <span class=\"hljs-keyword\">throw</span> an error because property <span class=\"hljs-string\">&quot;todo&quot;</span> is not defined on instance. --&gt;<br><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;todo in todos&quot;</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class=\"xml\">  &#123;&#123; todo &#125;&#125;</span><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>可以把 v-for 移动到<code>&lt;template&gt;</code> 标签中来修正：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;template v-<span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">&quot;todo in todos&quot;</span>&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class=\"xml\">    &#123;&#123; todo &#125;&#125;</span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n<h1 id=\"表单绑定输入\"><a href=\"#表单绑定输入\" class=\"headerlink\" title=\"表单绑定输入\"></a>表单绑定输入</h1><h2 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h2><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>\n<ul>\n<li>text 和 textarea 元素使用 value property 和 input 事件；</li>\n<li>checkbox 和 radio 使用 checked property 和 change 事件；</li>\n<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>\n</ul>\n<h1 id=\"组件基础\"><a href=\"#组件基础\" class=\"headerlink\" title=\"组件基础\"></a>组件基础</h1><h2 id=\"基本实例\"><a href=\"#基本实例\" class=\"headerlink\" title=\"基本实例\"></a>基本实例</h2><p>这里有一个 Vue 组件的示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 创建一个Vue 应用</span><br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class=\"hljs-comment\">// 定义一个名为 button-counter 的新全局组件</span><br>app.component(<span class=\"hljs-string\">&#x27;button-counter&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span><br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;button @click=&quot;count++&quot;&gt;</span><br><span class=\"hljs-string\">      You clicked me &#123;&#123; count &#125;&#125; times.</span><br><span class=\"hljs-string\">    &lt;/button&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<h2 id=\"组件的复用\"><a href=\"#组件的复用\" class=\"headerlink\" title=\"组件的复用\"></a>组件的复用</h2><p>你可以将组件进行任意次数的复用<br>每个组件都会各自独立维护它的<code>data</code>。因为你每用一次组件，就会有一个它的新组件实例被创建</p>\n<h2 id=\"在组件上使用-v-model\"><a href=\"#在组件上使用-v-model\" class=\"headerlink\" title=\"在组件上使用 v-model\"></a>在组件上使用 v-model</h2><p>自定义事件也可以用于创建支持 <code>v-model</code> 的自定义输入组件。记住：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;input v-model=<span class=\"hljs-string\">&quot;searchText&quot;</span> /&gt;<br>等价于：<br><br>&lt;input :value=<span class=\"hljs-string\">&quot;searchText&quot;</span> @input=<span class=\"hljs-string\">&quot;searchText = $event.target.value&quot;</span> /&gt;<br>当用在组件上时，v-model 则会这样：<br><br>&lt;custom-input<br>  :model-value=<span class=\"hljs-string\">&quot;searchText&quot;</span><br>  @update:model-value=<span class=\"hljs-string\">&quot;searchText = $event&quot;</span><br>&gt;&lt;/custom-input&gt;<br></code></pre></td></tr></table></figure>\n<p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code> 必须：</p>\n<p>将其 <code>value</code> attribute 绑定到一个名叫 <code>modelValue</code> 的 prop 上<br>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>update:modelValue</code> 事件抛出<br>写成代码之后是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;custom-input&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;modelValue&#x27;</span>],<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input</span><br><span class=\"hljs-string\">      :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span><br><span class=\"hljs-string\">    &gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>现在 <code>v-model</code> 就应该可以在这个组件上完美地工作起来了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;searchText&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-input</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"深入组件\"><a href=\"#深入组件\" class=\"headerlink\" title=\"深入组件\"></a>深入组件</h1><h2 id=\"非-Prop-的-Attribute\"><a href=\"#非-Prop-的-Attribute\" class=\"headerlink\" title=\"非 Prop 的 Attribute\"></a>非 Prop 的 Attribute</h2><h3 id=\"Attribute-继承\"><a href=\"#Attribute-继承\" class=\"headerlink\" title=\"Attribute 继承\"></a>Attribute 继承</h3><p>当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 <code>&lt;date-picker&gt;</code> 组件的实例中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class=\"hljs-string\">      &lt;input type=&quot;datetime&quot; /&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>如果我们需要通过 <code>data status</code> property 定义 <code>&lt;date-picker&gt;</code> 组件的状态，它将应用于根节点 (即 <code>div.date-picker</code>)。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 具有非prop attribute的Date-picker组件--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;datetime&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>同样的规则适用于事件监听器：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">&quot;submitChange&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.$attrs) <span class=\"hljs-comment\">// &#123; onChange: () =&gt; &#123;&#125;  &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;select&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;1&quot;&gt;Yesterday&lt;/option&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;2&quot;&gt;Today&lt;/option&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;3&quot;&gt;Tomorrow&lt;/option&gt;</span><br><span class=\"hljs-string\">    &lt;/select&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;demo&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">&quot;showChange&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">showChange</span>(<span class=\"hljs-params\">event</span>)</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(event.target.value) <span class=\"hljs-comment\">// 将记录所选选项的值</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"禁用-Attribute-继承\"><a href=\"#禁用-Attribute-继承\" class=\"headerlink\" title=\"禁用 Attribute 继承\"></a>禁用 Attribute 继承</h3><p>如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p>\n<p>禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。</p>\n<p>通过将 <code>inheritAttrs</code> 选项设置为 <code>false</code>，你可以访问组件的 <code>$attrs</code> property，该 property 包括组件 <code>props</code> 和 <code>emits</code> property 中未包含的所有属性 (例如，<code>class</code>、<code>style</code>、<code>v-on</code> 监听器等)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class=\"hljs-string\">      &lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>有了这个新配置，<code>data status</code> attribute 将应用于 <code>input</code> 元素！</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Date-picker 组件 使用非 prop attribute --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;datetime&quot;</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"多个根节点上的-Attribute-继承\"><a href=\"#多个根节点上的-Attribute-继承\" class=\"headerlink\" title=\"多个根节点上的 Attribute 继承\"></a>多个根节点上的 Attribute 继承</h3><p>与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-layout</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;custom-layout&quot;</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;changeValue&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-layout</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 这将发出警告</span><br>app.component(<span class=\"hljs-string\">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;header&gt;...&lt;/header&gt;</span><br><span class=\"hljs-string\">    &lt;main&gt;...&lt;/main&gt;</span><br><span class=\"hljs-string\">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 没有警告，$attrs被传递到&lt;main&gt;元素</span><br>app.component(<span class=\"hljs-string\">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;header&gt;...&lt;/header&gt;</span><br><span class=\"hljs-string\">    &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class=\"hljs-string\">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<h2 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h2><h3 id=\"处理-v-model-修饰符\"><a href=\"#处理-v-model-修饰符\" class=\"headerlink\" title=\"处理 v-model 修饰符\"></a>处理 v-model 修饰符</h3><p>在 2.x 中，我们对组件 <code>v-model</code> 上的 <code>.trim</code> 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件：</p>\n<p>让我们创建一个示例自定义修饰符 <code>capitalize</code>，它将 <code>v-model</code> 绑定提供的字符串的第一个字母大写。</p>\n<p>添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 <code>modelModifiers</code> prop。</p>\n<p>请注意，当组件的 <code>created</code> 生命周期钩子触发时，<code>modelModifiers</code> prop 包含 <code>capitalize</code>，其值为 <code>true</code>——因为它被设置在 <code>v-model</code> 绑定 <code>v-model.capitalize=&quot;bar&quot;</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model.capitalize</span>=<span class=\"hljs-string\">&quot;bar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">modelValue</span>: <span class=\"hljs-built_in\">String</span>,<br>    <span class=\"hljs-attr\">modelModifiers</span>: &#123;<br>      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input type=&quot;text&quot; </span><br><span class=\"hljs-string\">      :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;&gt;</span><br><span class=\"hljs-string\">  `</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.modelModifiers) <span class=\"hljs-comment\">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>现在我们已经设置了 prop，我们可以检查 <code>modelModifiers</code> 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 <code>&lt;input/&gt;</code> 元素触发 <code>input</code> 事件时，我们都将字符串大写。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model.capitalize</span>=<span class=\"hljs-string\">&quot;myText&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br>  &#123;&#123; myText &#125;&#125;<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-attr\">myText</span>: <span class=\"hljs-string\">&#x27;&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br><br>app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">modelValue</span>: <span class=\"hljs-built_in\">String</span>,<br>    <span class=\"hljs-attr\">modelModifiers</span>: &#123;<br>      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">emitValue</span>(<span class=\"hljs-params\">e</span>)</span> &#123;<br>      <span class=\"hljs-keyword\">let</span> value = e.target.value<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.modelModifiers.capitalize) &#123;<br>        value = value.charAt(<span class=\"hljs-number\">0</span>).toUpperCase() + value.slice(<span class=\"hljs-number\">1</span>)<br>      &#125;<br>      <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&#x27;update:modelValue&#x27;</span>, value)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;input</span><br><span class=\"hljs-string\">    type=&quot;text&quot;</span><br><span class=\"hljs-string\">    :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">    @input=&quot;emitValue&quot;&gt;`</span><br>&#125;)<br><br>app.mount(<span class=\"hljs-string\">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>对于带参数的 <code>v-model</code> 绑定，生成的 prop 名称将为 <code>arg + &quot;Modifiers&quot;</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model:foo.capitalize</span>=<span class=\"hljs-string\">&quot;bar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;foo&#x27;</span>, <span class=\"hljs-string\">&#x27;fooModifiers&#x27;</span>],<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input type=&quot;text&quot; </span><br><span class=\"hljs-string\">      :value=&quot;foo&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:foo&#x27;, $event.target.value)&quot;&gt;</span><br><span class=\"hljs-string\">  `</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.fooModifiers) <span class=\"hljs-comment\">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"2021-09-17更新\"><a href=\"#2021-09-17更新\" class=\"headerlink\" title=\"2021.09.17更新\"></a>2021.09.17更新</h2><h2 id=\"提供-注入\"><a href=\"#提供-注入\" class=\"headerlink\" title=\"提供/注入\"></a>提供/注入</h2><p>通常，当我们需要将数据从父组件传递到子组件时，我们使用<code>props</code>。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。</p>\n<p>对于这种情况，我们可以使用 <code>provide</code> 和 <code>inject</code> 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这个数据。</p>\n<h1 id=\"可复用-amp-组合\"><a href=\"#可复用-amp-组合\" class=\"headerlink\" title=\"可复用&amp;组合\"></a>可复用&amp;组合</h1><h2 id=\"渲染函数\"><a href=\"#渲染函数\" class=\"headerlink\" title=\"渲染函数\"></a>渲染函数</h2><h3 id=\"虚拟DOM树\"><a href=\"#虚拟DOM树\" class=\"headerlink\" title=\"虚拟DOM树\"></a>虚拟DOM树</h3><p>Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">return</span> Vue.h(<span class=\"hljs-string\">&#x27;h1&#x27;</span>, &#123;&#125;, <span class=\"hljs-built_in\">this</span>.blogTitle)<br></code></pre></td></tr></table></figure>\n<p><code>h()</code> 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 <strong>VNode</strong>。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p>\n<h3 id=\"h-参数\"><a href=\"#h-参数\" class=\"headerlink\" title=\"h()参数\"></a>h()参数</h3><p>h() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">h(<br>  <span class=\"hljs-comment\">// &#123;String | Object | Function | null&#125; tag</span><br>  <span class=\"hljs-comment\">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span><br>  <span class=\"hljs-comment\">// 使用 null 将会渲染一个注释。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 必需的。</span><br>  <span class=\"hljs-string\">&#x27;div&#x27;</span>,<br><br>  <span class=\"hljs-comment\">// &#123;Object&#125; props</span><br>  <span class=\"hljs-comment\">// 与 attribute、prop 和事件相对应的对象。</span><br>  <span class=\"hljs-comment\">// 我们会在模板中使用。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 可选的。</span><br>  &#123;&#125;,<br><br>  <span class=\"hljs-comment\">// &#123;String | Array | Object&#125; children</span><br>  <span class=\"hljs-comment\">// 子 VNodes, 使用 `h()` 构建,</span><br>  <span class=\"hljs-comment\">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span><br>  <span class=\"hljs-comment\">// 有 slot 的对象。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 可选的。</span><br>  [<br>    <span class=\"hljs-string\">&#x27;Some text comes first.&#x27;</span>,<br>    h(<span class=\"hljs-string\">&#x27;h1&#x27;</span>, <span class=\"hljs-string\">&#x27;A headline&#x27;</span>),<br>    h(MyComponent, &#123;<br>      <span class=\"hljs-attr\">someProp</span>: <span class=\"hljs-string\">&#x27;foobar&#x27;</span><br>    &#125;)<br>  ]<br>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"完整实例\"><a href=\"#完整实例\" class=\"headerlink\" title=\"完整实例\"></a>完整实例</h3><p>有了这些知识，我们现在可以完成我们最开始想实现的组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class=\"hljs-comment\">/** Recursively get text from children nodes */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getChildrenTextContent</span>(<span class=\"hljs-params\">children</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> children<br>    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">node</span> =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> node.children === <span class=\"hljs-string\">&#x27;string&#x27;</span><br>        ? node.children<br>        : <span class=\"hljs-built_in\">Array</span>.isArray(node.children)<br>        ? getChildrenTextContent(node.children)<br>        : <span class=\"hljs-string\">&#x27;&#x27;</span><br>    &#125;)<br>    .join(<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>&#125;<br><br>app.component(<span class=\"hljs-string\">&#x27;anchored-heading&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-comment\">// create kebab-case id from the text contents of the children</span><br>    <span class=\"hljs-keyword\">const</span> headingId = getChildrenTextContent(<span class=\"hljs-built_in\">this</span>.$slots.default())<br>      .toLowerCase()<br>      .replace(<span class=\"hljs-regexp\">/\\W+/g</span>, <span class=\"hljs-string\">&#x27;-&#x27;</span>) <span class=\"hljs-comment\">// replace non-word characters with dash</span><br>      .replace(<span class=\"hljs-regexp\">/(^-|-$)/g</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-comment\">// remove leading and trailing dashes</span><br><br>    <span class=\"hljs-keyword\">return</span> Vue.h(<span class=\"hljs-string\">&#x27;h&#x27;</span> + <span class=\"hljs-built_in\">this</span>.level, [<br>      Vue.h(<br>        <span class=\"hljs-string\">&#x27;a&#x27;</span>,<br>        &#123;<br>          <span class=\"hljs-attr\">name</span>: headingId,<br>          <span class=\"hljs-attr\">href</span>: <span class=\"hljs-string\">&#x27;#&#x27;</span> + headingId<br>        &#125;,<br>        <span class=\"hljs-built_in\">this</span>.$slots.default()<br>      )<br>    ])<br>  &#125;,<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">level</span>: &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,<br>      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是<code>Object.defineProperty()</code>，vue3用的是<code>Proxy</code>。vue3还新增了<code>组合式API</code>等等。</p>\n<p>这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。</p>\n<p>持续更新ing</p>\n<h1 id=\"应用-amp-组件实例\"><a href=\"#应用-amp-组件实例\" class=\"headerlink\" title=\"应用&amp;组件实例\"></a>应用&amp;组件实例</h1><h2 id=\"应用实例\"><a href=\"#应用实例\" class=\"headerlink\" title=\"应用实例\"></a>应用实例</h2><p>每个 Vue 应用都是通过用 createApp 函数创建一个新的<strong>应用实例</strong>开始的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123; <span class=\"hljs-comment\">/* 选项 */</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n<p>该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br>app.component(<span class=\"hljs-string\">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>app.directive(<span class=\"hljs-string\">&#x27;focus&#x27;</span>, FocusDirective)<br>app.use(LocalePlugin)<br></code></pre></td></tr></table></figure>\n<p>应用实例暴露的大多数方法都会返回该同一实例，允许链式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">Vue.createApp(&#123;&#125;)<br>  .component(<span class=\"hljs-string\">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>  .directive(<span class=\"hljs-string\">&#x27;focus&#x27;</span>, FocusDirective)<br>  .use(LocalePlugin)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"根组件实例\"><a href=\"#根组件实例\" class=\"headerlink\" title=\"根组件实例\"></a>根组件实例</h2><p>传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。</p>\n<p>一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，我们应该传递 <code>#app</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> RootComponent = &#123; <span class=\"hljs-comment\">/* 选项 */</span> &#125;<br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(RootComponent)<br><span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>与大多数应用方法不同的是，<code>mount</code> 不返回应用本身。相反，它返回的是<strong>根组件实例</strong>。</p>\n<p>虽然没有完全遵循 <code>MVVM</code> 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。</p>\n<h1 id=\"计算属性-amp-侦听器\"><a href=\"#计算属性-amp-侦听器\" class=\"headerlink\" title=\"计算属性&amp;侦听器\"></a>计算属性&amp;侦听器</h1><h2 id=\"计算属性缓存-vs-方法\"><a href=\"#计算属性缓存-vs-方法\" class=\"headerlink\" title=\"计算属性缓存 vs 方法\"></a>计算属性缓存 vs 方法</h2><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123; calculateBooksMessage() &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 在组件中</span><br><span class=\"hljs-attr\">methods</span>: &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">calculateBooksMessage</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.author.books.length &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-string\">&#x27;Yes&#x27;</span> : <span class=\"hljs-string\">&#x27;No&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要<code>author.books</code> 还没有发生改变，多次访问 <code>publishedBookMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。 </p>\n<p>这也同样意味着下面的计算属性将不再更新，因为 <strong>Date.now () 不是响应式依赖</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">computed: &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">now</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Date</span>.now()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p>\n<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <code>list</code>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <code>list</code>。如果没有缓存，我们将不可避免的多次执行 <code>list</code> 的 getter！如果你不希望有缓存，请用 method 来替代</p>\n<hr>\n<h2 id=\"以下为2021-09-16更新\"><a href=\"#以下为2021-09-16更新\" class=\"headerlink\" title=\"以下为2021.09.16更新\"></a>以下为2021.09.16更新</h2><h2 id=\"计算属性的-Setter\"><a href=\"#计算属性的-Setter\" class=\"headerlink\" title=\"计算属性的 Setter\"></a>计算属性的 Setter</h2><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// ...</span><br><span class=\"hljs-attr\">computed</span>: &#123;<br>  <span class=\"hljs-attr\">fullName</span>: &#123;<br>    <span class=\"hljs-comment\">// getter</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.firstName + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-built_in\">this</span>.lastName<br>    &#125;,<br>    <span class=\"hljs-comment\">// setter</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\">newValue</span>)</span> &#123;<br>      <span class=\"hljs-keyword\">const</span> names = newValue.split(<span class=\"hljs-string\">&#x27; &#x27;</span>)<br>      <span class=\"hljs-built_in\">this</span>.firstName = names[<span class=\"hljs-number\">0</span>]<br>      <span class=\"hljs-built_in\">this</span>.lastName = names[names.length - <span class=\"hljs-number\">1</span>]<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// ...</span><br></code></pre></td></tr></table></figure>\n<p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p>\n<h1 id=\"Class与Style绑定\"><a href=\"#Class与Style绑定\" class=\"headerlink\" title=\"Class与Style绑定\"></a>Class与Style绑定</h1><p>如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;div id=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;baz&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></span><br>&lt;/div&gt;<br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br>app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;</span><br><span class=\"hljs-string\">    &lt;span&gt;This is a child component&lt;/span&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h1><h2 id=\"v-if-vs-v-show\"><a href=\"#v-if-vs-v-show\" class=\"headerlink\" title=\"v-if vs v-show\"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>\n<p><code>v-if</code> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>\n<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>\n<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好</p>\n<h2 id=\"v-if-与-v-for-一起使用\"><a href=\"#v-if-与-v-for-一起使用\" class=\"headerlink\" title=\"v-if 与 v-for 一起使用\"></a>v-if 与 v-for 一起使用</h2><blockquote>\n<p>提示 不推荐同时使用 v-if 和 v-for</p>\n</blockquote>\n<p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-if</code> 具有比 <code>v-for</code> 更高的优先级。请查阅列表渲染指南以获取详细信息。</p>\n<p>当它们处于同一节点，<code>v-if</code> 的优先级比 <code>v-for</code> 更高，这意味着 <code>v-if</code> 将没有权限访问 <code>v-for</code> 里的变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;!-- This will <span class=\"hljs-keyword\">throw</span> an error because property <span class=\"hljs-string\">&quot;todo&quot;</span> is not defined on instance. --&gt;<br><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;todo in todos&quot;</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class=\"xml\">  &#123;&#123; todo &#125;&#125;</span><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>可以把 v-for 移动到<code>&lt;template&gt;</code> 标签中来修正：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;template v-<span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">&quot;todo in todos&quot;</span>&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class=\"xml\">    &#123;&#123; todo &#125;&#125;</span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n<h1 id=\"表单绑定输入\"><a href=\"#表单绑定输入\" class=\"headerlink\" title=\"表单绑定输入\"></a>表单绑定输入</h1><h2 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h2><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>\n<ul>\n<li>text 和 textarea 元素使用 value property 和 input 事件；</li>\n<li>checkbox 和 radio 使用 checked property 和 change 事件；</li>\n<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>\n</ul>\n<h1 id=\"组件基础\"><a href=\"#组件基础\" class=\"headerlink\" title=\"组件基础\"></a>组件基础</h1><h2 id=\"基本实例\"><a href=\"#基本实例\" class=\"headerlink\" title=\"基本实例\"></a>基本实例</h2><p>这里有一个 Vue 组件的示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 创建一个Vue 应用</span><br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class=\"hljs-comment\">// 定义一个名为 button-counter 的新全局组件</span><br>app.component(<span class=\"hljs-string\">&#x27;button-counter&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span><br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;button @click=&quot;count++&quot;&gt;</span><br><span class=\"hljs-string\">      You clicked me &#123;&#123; count &#125;&#125; times.</span><br><span class=\"hljs-string\">    &lt;/button&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<h2 id=\"组件的复用\"><a href=\"#组件的复用\" class=\"headerlink\" title=\"组件的复用\"></a>组件的复用</h2><p>你可以将组件进行任意次数的复用<br>每个组件都会各自独立维护它的<code>data</code>。因为你每用一次组件，就会有一个它的新组件实例被创建</p>\n<h2 id=\"在组件上使用-v-model\"><a href=\"#在组件上使用-v-model\" class=\"headerlink\" title=\"在组件上使用 v-model\"></a>在组件上使用 v-model</h2><p>自定义事件也可以用于创建支持 <code>v-model</code> 的自定义输入组件。记住：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;input v-model=<span class=\"hljs-string\">&quot;searchText&quot;</span> /&gt;<br>等价于：<br><br>&lt;input :value=<span class=\"hljs-string\">&quot;searchText&quot;</span> @input=<span class=\"hljs-string\">&quot;searchText = $event.target.value&quot;</span> /&gt;<br>当用在组件上时，v-model 则会这样：<br><br>&lt;custom-input<br>  :model-value=<span class=\"hljs-string\">&quot;searchText&quot;</span><br>  @update:model-value=<span class=\"hljs-string\">&quot;searchText = $event&quot;</span><br>&gt;&lt;/custom-input&gt;<br></code></pre></td></tr></table></figure>\n<p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code> 必须：</p>\n<p>将其 <code>value</code> attribute 绑定到一个名叫 <code>modelValue</code> 的 prop 上<br>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>update:modelValue</code> 事件抛出<br>写成代码之后是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;custom-input&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;modelValue&#x27;</span>],<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input</span><br><span class=\"hljs-string\">      :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span><br><span class=\"hljs-string\">    &gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>现在 <code>v-model</code> 就应该可以在这个组件上完美地工作起来了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;searchText&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-input</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"深入组件\"><a href=\"#深入组件\" class=\"headerlink\" title=\"深入组件\"></a>深入组件</h1><h2 id=\"非-Prop-的-Attribute\"><a href=\"#非-Prop-的-Attribute\" class=\"headerlink\" title=\"非 Prop 的 Attribute\"></a>非 Prop 的 Attribute</h2><h3 id=\"Attribute-继承\"><a href=\"#Attribute-继承\" class=\"headerlink\" title=\"Attribute 继承\"></a>Attribute 继承</h3><p>当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 <code>&lt;date-picker&gt;</code> 组件的实例中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class=\"hljs-string\">      &lt;input type=&quot;datetime&quot; /&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>如果我们需要通过 <code>data status</code> property 定义 <code>&lt;date-picker&gt;</code> 组件的状态，它将应用于根节点 (即 <code>div.date-picker</code>)。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 具有非prop attribute的Date-picker组件--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;datetime&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>同样的规则适用于事件监听器：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">&quot;submitChange&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.$attrs) <span class=\"hljs-comment\">// &#123; onChange: () =&gt; &#123;&#125;  &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;select&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;1&quot;&gt;Yesterday&lt;/option&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;2&quot;&gt;Today&lt;/option&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;3&quot;&gt;Tomorrow&lt;/option&gt;</span><br><span class=\"hljs-string\">    &lt;/select&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;demo&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">&quot;showChange&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">showChange</span>(<span class=\"hljs-params\">event</span>)</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(event.target.value) <span class=\"hljs-comment\">// 将记录所选选项的值</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"禁用-Attribute-继承\"><a href=\"#禁用-Attribute-继承\" class=\"headerlink\" title=\"禁用 Attribute 继承\"></a>禁用 Attribute 继承</h3><p>如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p>\n<p>禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。</p>\n<p>通过将 <code>inheritAttrs</code> 选项设置为 <code>false</code>，你可以访问组件的 <code>$attrs</code> property，该 property 包括组件 <code>props</code> 和 <code>emits</code> property 中未包含的所有属性 (例如，<code>class</code>、<code>style</code>、<code>v-on</code> 监听器等)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class=\"hljs-string\">      &lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>有了这个新配置，<code>data status</code> attribute 将应用于 <code>input</code> 元素！</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Date-picker 组件 使用非 prop attribute --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;datetime&quot;</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"多个根节点上的-Attribute-继承\"><a href=\"#多个根节点上的-Attribute-继承\" class=\"headerlink\" title=\"多个根节点上的 Attribute 继承\"></a>多个根节点上的 Attribute 继承</h3><p>与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-layout</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;custom-layout&quot;</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;changeValue&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-layout</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 这将发出警告</span><br>app.component(<span class=\"hljs-string\">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;header&gt;...&lt;/header&gt;</span><br><span class=\"hljs-string\">    &lt;main&gt;...&lt;/main&gt;</span><br><span class=\"hljs-string\">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 没有警告，$attrs被传递到&lt;main&gt;元素</span><br>app.component(<span class=\"hljs-string\">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;header&gt;...&lt;/header&gt;</span><br><span class=\"hljs-string\">    &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class=\"hljs-string\">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<h2 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h2><h3 id=\"处理-v-model-修饰符\"><a href=\"#处理-v-model-修饰符\" class=\"headerlink\" title=\"处理 v-model 修饰符\"></a>处理 v-model 修饰符</h3><p>在 2.x 中，我们对组件 <code>v-model</code> 上的 <code>.trim</code> 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件：</p>\n<p>让我们创建一个示例自定义修饰符 <code>capitalize</code>，它将 <code>v-model</code> 绑定提供的字符串的第一个字母大写。</p>\n<p>添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 <code>modelModifiers</code> prop。</p>\n<p>请注意，当组件的 <code>created</code> 生命周期钩子触发时，<code>modelModifiers</code> prop 包含 <code>capitalize</code>，其值为 <code>true</code>——因为它被设置在 <code>v-model</code> 绑定 <code>v-model.capitalize=&quot;bar&quot;</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model.capitalize</span>=<span class=\"hljs-string\">&quot;bar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">modelValue</span>: <span class=\"hljs-built_in\">String</span>,<br>    <span class=\"hljs-attr\">modelModifiers</span>: &#123;<br>      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input type=&quot;text&quot; </span><br><span class=\"hljs-string\">      :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;&gt;</span><br><span class=\"hljs-string\">  `</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.modelModifiers) <span class=\"hljs-comment\">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>现在我们已经设置了 prop，我们可以检查 <code>modelModifiers</code> 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 <code>&lt;input/&gt;</code> 元素触发 <code>input</code> 事件时，我们都将字符串大写。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model.capitalize</span>=<span class=\"hljs-string\">&quot;myText&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br>  &#123;&#123; myText &#125;&#125;<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-attr\">myText</span>: <span class=\"hljs-string\">&#x27;&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br><br>app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">modelValue</span>: <span class=\"hljs-built_in\">String</span>,<br>    <span class=\"hljs-attr\">modelModifiers</span>: &#123;<br>      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">emitValue</span>(<span class=\"hljs-params\">e</span>)</span> &#123;<br>      <span class=\"hljs-keyword\">let</span> value = e.target.value<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.modelModifiers.capitalize) &#123;<br>        value = value.charAt(<span class=\"hljs-number\">0</span>).toUpperCase() + value.slice(<span class=\"hljs-number\">1</span>)<br>      &#125;<br>      <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&#x27;update:modelValue&#x27;</span>, value)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;input</span><br><span class=\"hljs-string\">    type=&quot;text&quot;</span><br><span class=\"hljs-string\">    :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">    @input=&quot;emitValue&quot;&gt;`</span><br>&#125;)<br><br>app.mount(<span class=\"hljs-string\">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>对于带参数的 <code>v-model</code> 绑定，生成的 prop 名称将为 <code>arg + &quot;Modifiers&quot;</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model:foo.capitalize</span>=<span class=\"hljs-string\">&quot;bar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;foo&#x27;</span>, <span class=\"hljs-string\">&#x27;fooModifiers&#x27;</span>],<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input type=&quot;text&quot; </span><br><span class=\"hljs-string\">      :value=&quot;foo&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:foo&#x27;, $event.target.value)&quot;&gt;</span><br><span class=\"hljs-string\">  `</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.fooModifiers) <span class=\"hljs-comment\">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"2021-09-17更新\"><a href=\"#2021-09-17更新\" class=\"headerlink\" title=\"2021.09.17更新\"></a>2021.09.17更新</h2><h2 id=\"提供-注入\"><a href=\"#提供-注入\" class=\"headerlink\" title=\"提供/注入\"></a>提供/注入</h2><p>通常，当我们需要将数据从父组件传递到子组件时，我们使用<code>props</code>。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。</p>\n<p>对于这种情况，我们可以使用 <code>provide</code> 和 <code>inject</code> 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这个数据。</p>\n<h1 id=\"可复用-amp-组合\"><a href=\"#可复用-amp-组合\" class=\"headerlink\" title=\"可复用&amp;组合\"></a>可复用&amp;组合</h1><h2 id=\"渲染函数\"><a href=\"#渲染函数\" class=\"headerlink\" title=\"渲染函数\"></a>渲染函数</h2><h3 id=\"虚拟DOM树\"><a href=\"#虚拟DOM树\" class=\"headerlink\" title=\"虚拟DOM树\"></a>虚拟DOM树</h3><p>Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">return</span> Vue.h(<span class=\"hljs-string\">&#x27;h1&#x27;</span>, &#123;&#125;, <span class=\"hljs-built_in\">this</span>.blogTitle)<br></code></pre></td></tr></table></figure>\n<p><code>h()</code> 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 <strong>VNode</strong>。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p>\n<h3 id=\"h-参数\"><a href=\"#h-参数\" class=\"headerlink\" title=\"h()参数\"></a>h()参数</h3><p>h() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">h(<br>  <span class=\"hljs-comment\">// &#123;String | Object | Function | null&#125; tag</span><br>  <span class=\"hljs-comment\">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span><br>  <span class=\"hljs-comment\">// 使用 null 将会渲染一个注释。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 必需的。</span><br>  <span class=\"hljs-string\">&#x27;div&#x27;</span>,<br><br>  <span class=\"hljs-comment\">// &#123;Object&#125; props</span><br>  <span class=\"hljs-comment\">// 与 attribute、prop 和事件相对应的对象。</span><br>  <span class=\"hljs-comment\">// 我们会在模板中使用。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 可选的。</span><br>  &#123;&#125;,<br><br>  <span class=\"hljs-comment\">// &#123;String | Array | Object&#125; children</span><br>  <span class=\"hljs-comment\">// 子 VNodes, 使用 `h()` 构建,</span><br>  <span class=\"hljs-comment\">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span><br>  <span class=\"hljs-comment\">// 有 slot 的对象。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 可选的。</span><br>  [<br>    <span class=\"hljs-string\">&#x27;Some text comes first.&#x27;</span>,<br>    h(<span class=\"hljs-string\">&#x27;h1&#x27;</span>, <span class=\"hljs-string\">&#x27;A headline&#x27;</span>),<br>    h(MyComponent, &#123;<br>      <span class=\"hljs-attr\">someProp</span>: <span class=\"hljs-string\">&#x27;foobar&#x27;</span><br>    &#125;)<br>  ]<br>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"完整实例\"><a href=\"#完整实例\" class=\"headerlink\" title=\"完整实例\"></a>完整实例</h3><p>有了这些知识，我们现在可以完成我们最开始想实现的组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class=\"hljs-comment\">/** Recursively get text from children nodes */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getChildrenTextContent</span>(<span class=\"hljs-params\">children</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> children<br>    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">node</span> =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> node.children === <span class=\"hljs-string\">&#x27;string&#x27;</span><br>        ? node.children<br>        : <span class=\"hljs-built_in\">Array</span>.isArray(node.children)<br>        ? getChildrenTextContent(node.children)<br>        : <span class=\"hljs-string\">&#x27;&#x27;</span><br>    &#125;)<br>    .join(<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>&#125;<br><br>app.component(<span class=\"hljs-string\">&#x27;anchored-heading&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-comment\">// create kebab-case id from the text contents of the children</span><br>    <span class=\"hljs-keyword\">const</span> headingId = getChildrenTextContent(<span class=\"hljs-built_in\">this</span>.$slots.default())<br>      .toLowerCase()<br>      .replace(<span class=\"hljs-regexp\">/\\W+/g</span>, <span class=\"hljs-string\">&#x27;-&#x27;</span>) <span class=\"hljs-comment\">// replace non-word characters with dash</span><br>      .replace(<span class=\"hljs-regexp\">/(^-|-$)/g</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-comment\">// remove leading and trailing dashes</span><br><br>    <span class=\"hljs-keyword\">return</span> Vue.h(<span class=\"hljs-string\">&#x27;h&#x27;</span> + <span class=\"hljs-built_in\">this</span>.level, [<br>      Vue.h(<br>        <span class=\"hljs-string\">&#x27;a&#x27;</span>,<br>        &#123;<br>          <span class=\"hljs-attr\">name</span>: headingId,<br>          <span class=\"hljs-attr\">href</span>: <span class=\"hljs-string\">&#x27;#&#x27;</span> + headingId<br>        &#125;,<br>        <span class=\"hljs-built_in\">this</span>.$slots.default()<br>      )<br>    ])<br>  &#125;,<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">level</span>: &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,<br>      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>"},{"title":"JavaScript中的堆栈以及数据类型","date":"2021-06-17T07:08:21.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# JavaScript的堆栈以及数据类型\n\n[本文参考此链接](https://www.jianshu.com/p/5e0e8d183102)\n\n**堆** 是堆内存的简称。**堆**是动态分配内存，内存大小不一，也不会自动释放。 \n**栈** 是栈内存的简称。**栈**是自动分配相对固定大小的内存空间，并由系统自动释放。**后进先出**\n\n### 基本数据类型\n\n`javascript`的**基本类型**就5种:`Undefined`、`Null`、`Boolean`、`Number`和`String`，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是**确定**的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。\n\n### 引用数据类型\n\n`javascript`中其他类型的数据被称为**引用类型**的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和new出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。\n\n### 传值与传址\n\n```javascript\nvar arr1 = [1,2,5,8]; \nvar arr2 = arr1 ; \nvar str1 = arr1[2]; \nconsole.log(arr2);//1,2,5,8\nconsole.log(str1);//5\narr2[4] = 99; \nstr1 = 6; \nconsole.log(arr1);//1,2,5,8,99\nconsole.log(arr1[2]);//5\n```\n\n当我改变arr2中的数据时，arr1中数据也发生了变化，当改变str1的数据值时，arr1却没有发生改变。为什么？这就是**传值与传址**的区别。\n\n因为arr1是数组，属于引用类型，所以它赋予给arr2的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1得到的是一个基本类型的赋值，因此，str1仅仅是从arr1堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2都指向同一块堆内存，arr2修改的堆内存的时候，也就会影响到arr1，str1是直接在栈中修改，并且不能影响到arr1堆内存中的数据。\n\n\n\n![img](https://images2018.cnblogs.com/blog/1402663/201808/1402663-20180802132101478-2092833591.png)\n\n### 深拷贝和浅拷贝\n\n上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将arr1的每个基本类型的数据都遍历一遍，依次的赋值给arr2的对应字段。避免产生因为地址引用带来的问题。\n\n```javascript\nvar arr1 = [1,2,5,8]; \nvar arr2 = []; \nfor(var i=0;i<arr1.length;i++){\n   arr2[i]=arr1[i];\n};\nconsole.log(arr2)//1,2,5,8\narr2[4]=99;\nconsole.log(arr2)//1,2,5,8,99\nconsole.log(arr1)//1,2,5,8\n```\n\njavascript面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。\n\n# 完~\n\n","source":"_posts/2021-09-23-JavaScript中的堆栈以及数据类型.md","raw":"---\ntitle: JavaScript中的堆栈以及数据类型\ndate: 2021-06-17 15:08:21\ntags: JavaScript\ncategories: 技术类-前端\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# JavaScript的堆栈以及数据类型\n\n[本文参考此链接](https://www.jianshu.com/p/5e0e8d183102)\n\n**堆** 是堆内存的简称。**堆**是动态分配内存，内存大小不一，也不会自动释放。 \n**栈** 是栈内存的简称。**栈**是自动分配相对固定大小的内存空间，并由系统自动释放。**后进先出**\n\n### 基本数据类型\n\n`javascript`的**基本类型**就5种:`Undefined`、`Null`、`Boolean`、`Number`和`String`，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是**确定**的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。\n\n### 引用数据类型\n\n`javascript`中其他类型的数据被称为**引用类型**的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和new出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。\n\n### 传值与传址\n\n```javascript\nvar arr1 = [1,2,5,8]; \nvar arr2 = arr1 ; \nvar str1 = arr1[2]; \nconsole.log(arr2);//1,2,5,8\nconsole.log(str1);//5\narr2[4] = 99; \nstr1 = 6; \nconsole.log(arr1);//1,2,5,8,99\nconsole.log(arr1[2]);//5\n```\n\n当我改变arr2中的数据时，arr1中数据也发生了变化，当改变str1的数据值时，arr1却没有发生改变。为什么？这就是**传值与传址**的区别。\n\n因为arr1是数组，属于引用类型，所以它赋予给arr2的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1得到的是一个基本类型的赋值，因此，str1仅仅是从arr1堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2都指向同一块堆内存，arr2修改的堆内存的时候，也就会影响到arr1，str1是直接在栈中修改，并且不能影响到arr1堆内存中的数据。\n\n\n\n![img](https://images2018.cnblogs.com/blog/1402663/201808/1402663-20180802132101478-2092833591.png)\n\n### 深拷贝和浅拷贝\n\n上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将arr1的每个基本类型的数据都遍历一遍，依次的赋值给arr2的对应字段。避免产生因为地址引用带来的问题。\n\n```javascript\nvar arr1 = [1,2,5,8]; \nvar arr2 = []; \nfor(var i=0;i<arr1.length;i++){\n   arr2[i]=arr1[i];\n};\nconsole.log(arr2)//1,2,5,8\narr2[4]=99;\nconsole.log(arr2)//1,2,5,8,99\nconsole.log(arr1)//1,2,5,8\n```\n\njavascript面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。\n\n# 完~\n\n","slug":"JavaScript中的堆栈以及数据类型","published":1,"updated":"2021-10-08T03:11:55.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18a7000dcco9b0exde1p","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"JavaScript的堆栈以及数据类型\"><a href=\"#JavaScript的堆栈以及数据类型\" class=\"headerlink\" title=\"JavaScript的堆栈以及数据类型\"></a>JavaScript的堆栈以及数据类型</h1><p><a href=\"https://www.jianshu.com/p/5e0e8d183102\">本文参考此链接</a></p>\n<p><strong>堆</strong> 是堆内存的简称。<strong>堆</strong>是动态分配内存，内存大小不一，也不会自动释放。<br><strong>栈</strong> 是栈内存的简称。<strong>栈</strong>是自动分配相对固定大小的内存空间，并由系统自动释放。<strong>后进先出</strong></p>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p><code>javascript</code>的<strong>基本类型</strong>就5种:<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是<strong>确定</strong>的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。</p>\n<h3 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h3><p><code>javascript</code>中其他类型的数据被称为<strong>引用类型</strong>的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和new出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。</p>\n<h3 id=\"传值与传址\"><a href=\"#传值与传址\" class=\"headerlink\" title=\"传值与传址\"></a>传值与传址</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">8</span>]; <br><span class=\"hljs-keyword\">var</span> arr2 = arr1 ; <br><span class=\"hljs-keyword\">var</span> str1 = arr1[<span class=\"hljs-number\">2</span>]; <br><span class=\"hljs-built_in\">console</span>.log(arr2);<span class=\"hljs-comment\">//1,2,5,8</span><br><span class=\"hljs-built_in\">console</span>.log(str1);<span class=\"hljs-comment\">//5</span><br>arr2[<span class=\"hljs-number\">4</span>] = <span class=\"hljs-number\">99</span>; <br>str1 = <span class=\"hljs-number\">6</span>; <br><span class=\"hljs-built_in\">console</span>.log(arr1);<span class=\"hljs-comment\">//1,2,5,8,99</span><br><span class=\"hljs-built_in\">console</span>.log(arr1[<span class=\"hljs-number\">2</span>]);<span class=\"hljs-comment\">//5</span><br></code></pre></td></tr></table></figure>\n\n<p>当我改变arr2中的数据时，arr1中数据也发生了变化，当改变str1的数据值时，arr1却没有发生改变。为什么？这就是<strong>传值与传址</strong>的区别。</p>\n<p>因为arr1是数组，属于引用类型，所以它赋予给arr2的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1得到的是一个基本类型的赋值，因此，str1仅仅是从arr1堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2都指向同一块堆内存，arr2修改的堆内存的时候，也就会影响到arr1，str1是直接在栈中修改，并且不能影响到arr1堆内存中的数据。</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/1402663/201808/1402663-20180802132101478-2092833591.png\" alt=\"img\"></p>\n<h3 id=\"深拷贝和浅拷贝\"><a href=\"#深拷贝和浅拷贝\" class=\"headerlink\" title=\"深拷贝和浅拷贝\"></a>深拷贝和浅拷贝</h3><p>上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将arr1的每个基本类型的数据都遍历一遍，依次的赋值给arr2的对应字段。避免产生因为地址引用带来的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">8</span>]; <br><span class=\"hljs-keyword\">var</span> arr2 = []; <br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr1.length;i++)&#123;<br>   arr2[i]=arr1[i];<br>&#125;;<br><span class=\"hljs-built_in\">console</span>.log(arr2)<span class=\"hljs-comment\">//1,2,5,8</span><br>arr2[<span class=\"hljs-number\">4</span>]=<span class=\"hljs-number\">99</span>;<br><span class=\"hljs-built_in\">console</span>.log(arr2)<span class=\"hljs-comment\">//1,2,5,8,99</span><br><span class=\"hljs-built_in\">console</span>.log(arr1)<span class=\"hljs-comment\">//1,2,5,8</span><br></code></pre></td></tr></table></figure>\n\n<p>javascript面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。</p>\n<h1 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完~\"></a>完~</h1>","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"JavaScript的堆栈以及数据类型\"><a href=\"#JavaScript的堆栈以及数据类型\" class=\"headerlink\" title=\"JavaScript的堆栈以及数据类型\"></a>JavaScript的堆栈以及数据类型</h1><p><a href=\"https://www.jianshu.com/p/5e0e8d183102\">本文参考此链接</a></p>\n<p><strong>堆</strong> 是堆内存的简称。<strong>堆</strong>是动态分配内存，内存大小不一，也不会自动释放。<br><strong>栈</strong> 是栈内存的简称。<strong>栈</strong>是自动分配相对固定大小的内存空间，并由系统自动释放。<strong>后进先出</strong></p>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p><code>javascript</code>的<strong>基本类型</strong>就5种:<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是<strong>确定</strong>的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。</p>\n<h3 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h3><p><code>javascript</code>中其他类型的数据被称为<strong>引用类型</strong>的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和new出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。</p>\n<h3 id=\"传值与传址\"><a href=\"#传值与传址\" class=\"headerlink\" title=\"传值与传址\"></a>传值与传址</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">8</span>]; <br><span class=\"hljs-keyword\">var</span> arr2 = arr1 ; <br><span class=\"hljs-keyword\">var</span> str1 = arr1[<span class=\"hljs-number\">2</span>]; <br><span class=\"hljs-built_in\">console</span>.log(arr2);<span class=\"hljs-comment\">//1,2,5,8</span><br><span class=\"hljs-built_in\">console</span>.log(str1);<span class=\"hljs-comment\">//5</span><br>arr2[<span class=\"hljs-number\">4</span>] = <span class=\"hljs-number\">99</span>; <br>str1 = <span class=\"hljs-number\">6</span>; <br><span class=\"hljs-built_in\">console</span>.log(arr1);<span class=\"hljs-comment\">//1,2,5,8,99</span><br><span class=\"hljs-built_in\">console</span>.log(arr1[<span class=\"hljs-number\">2</span>]);<span class=\"hljs-comment\">//5</span><br></code></pre></td></tr></table></figure>\n\n<p>当我改变arr2中的数据时，arr1中数据也发生了变化，当改变str1的数据值时，arr1却没有发生改变。为什么？这就是<strong>传值与传址</strong>的区别。</p>\n<p>因为arr1是数组，属于引用类型，所以它赋予给arr2的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1得到的是一个基本类型的赋值，因此，str1仅仅是从arr1堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2都指向同一块堆内存，arr2修改的堆内存的时候，也就会影响到arr1，str1是直接在栈中修改，并且不能影响到arr1堆内存中的数据。</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/1402663/201808/1402663-20180802132101478-2092833591.png\" alt=\"img\"></p>\n<h3 id=\"深拷贝和浅拷贝\"><a href=\"#深拷贝和浅拷贝\" class=\"headerlink\" title=\"深拷贝和浅拷贝\"></a>深拷贝和浅拷贝</h3><p>上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将arr1的每个基本类型的数据都遍历一遍，依次的赋值给arr2的对应字段。避免产生因为地址引用带来的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">8</span>]; <br><span class=\"hljs-keyword\">var</span> arr2 = []; <br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr1.length;i++)&#123;<br>   arr2[i]=arr1[i];<br>&#125;;<br><span class=\"hljs-built_in\">console</span>.log(arr2)<span class=\"hljs-comment\">//1,2,5,8</span><br>arr2[<span class=\"hljs-number\">4</span>]=<span class=\"hljs-number\">99</span>;<br><span class=\"hljs-built_in\">console</span>.log(arr2)<span class=\"hljs-comment\">//1,2,5,8,99</span><br><span class=\"hljs-built_in\">console</span>.log(arr1)<span class=\"hljs-comment\">//1,2,5,8</span><br></code></pre></td></tr></table></figure>\n\n<p>javascript面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。</p>\n<h1 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完~\"></a>完~</h1>"},{"title":"Vue自定义全局组件","date":"2021-06-18T07:15:40.000Z","_content":"# vue自定义全局弹框组件\n\n1. 在components文件夹下新增一个组件文件夹Dialog，新建一个模板组件Dialog.vue\n\n   ```vue\n   <template>\n     <div class=\"u_dialog_panel\" @touchmove.stop=\"noop\">\n       <div class=\"mask\" v-if=\"visible\" @click=\"handleClose\"></div>\n       <transition name=\"open\">\n         <div v-if=\"visible\" class=\"dialog_body\">\n           <slot></slot>\n           <div class=\"btns\" v-if=\"confirmText || cancleText\">\n             <div class=\"cancle btn\" v-if=\"cancleText\" @click=\"handleCancle\">{{cancleText}}</div>\n             <div class=\"confirm btn\" :style=\"confirmStyle\" v-if=\"confirmText\" @click=\"handleConfirm\">{{confirmText}}</div>\n           </div>\n         </div>\n       </transition>\n     </div>\n   </template>\n   <script>\n   export default {\n     name: 'UDialog',\n     props: {\n       visible: { type: Boolean, default: false, required: true },\n       // 确定按钮的文案\n       confirmText: { type: String, default: '确定' },\n       confirmStyle: { type: String, default: '' },\n       // 取消按钮的文案\n       cancleText: { type: String, default: '取消' },\n       cancleStyle: { type: String, default: '' },\n     },\n     created () {\n       this.$nextTick(() => {\n         document.body.insertBefore(this.$el, document.body.lastChild)\n       })\n     },\n     beforeDestroy () {\n       document.body.removeChild(this.$el)\n     },\n     methods: {\n       // 关闭弹窗\n       handleClose () { this.$emit('close') },\n       // 确定按钮\n       handleConfirm () { this.$emit('confirm') },\n       // 取消按钮\n       handleCancle () { this.$emit('cancle') },\n       noop () {}\n     }\n   }\n   </script>\n   \n   <style lang=\"less\" scoped>\n   .u_dialog_panel {\n     .mask {\n       width: 100vw;\n       height: 100vh;\n       background-color: rgba(0, 0, 0, 0.5);\n       position: fixed;\n       left: 0;\n       top: 0;\n       z-index: 100;\n       backdrop-filter: blur(5px);\n     }\n     .dialog_body{\n       width: 80vw;\n       background-color: #fff;\n       position: fixed;\n       left: 50vw;\n       top: 50vh;\n       z-index: 100;\n       transform: translate(-50%, -50%);\n       transform-origin: 0 0;\n       border-radius: .875rem;\n       &.open-enter {\n         opacity: 0;\n         transform: scale(0.7) translate(-50%, -50%);\n         transition: all 0.3s;\n       }\n       &.open-enter-to {\n         opacity: 1;\n         transform: scale(1) translate(-50%, -50%);\n         transition: all 0.3s;\n       }\n       .btns {\n         display: flex;\n         justify-content: space-between;\n         align-items: center;\n         .btn {\n           display: flex;\n           justify-content: center;\n           align-items: center;\n           flex-grow: 1;\n           width: 50%;\n           height: 2.875rem;\n           border-top: 1px solid #ddd;\n           box-sizing: border-box;\n           display: flex;\n           justify-content: center;\n           align-items: center;\n           font-size: .875rem;\n           & + .btn {\n             border-left: 1px solid #ddd;\n           }\n           &.cancle {\n             color: #666666;\n           }\n           &.confirm {\n             color: #FF5883;\n           }\n         }\n       }\n     }\n   }\n   </style>\n   \n   ```\n\n2. 在此文件夹再新建一个index.js\n\n   ```vue\n   import Dialog from './Dialog'\n   \n   Dialog.install = function (Vue, options) {\n     Vue.component(`${Dialog.name}`, Dialog)\n   }\n   \n   export default Dialog\n   \n   ```\n\n3. 最后再main.js里注册为全局组件\n\n   ```vue\n   import Dialog from './components/Dialog/index.js'\n   \n   Vue.use(Dialog)\n   ```\n\n\n\n## 这样就可以在其他组件里无需声明而使用此组件\n\n\n\n","source":"_posts/2021-09-23-Vue自定义全局组件.md","raw":"---\ntitle: Vue自定义全局组件\ndate: 2021-06-18 15:15:40\ntags: Vue3\ncategories: 技术类-Vue\n---\n# vue自定义全局弹框组件\n\n1. 在components文件夹下新增一个组件文件夹Dialog，新建一个模板组件Dialog.vue\n\n   ```vue\n   <template>\n     <div class=\"u_dialog_panel\" @touchmove.stop=\"noop\">\n       <div class=\"mask\" v-if=\"visible\" @click=\"handleClose\"></div>\n       <transition name=\"open\">\n         <div v-if=\"visible\" class=\"dialog_body\">\n           <slot></slot>\n           <div class=\"btns\" v-if=\"confirmText || cancleText\">\n             <div class=\"cancle btn\" v-if=\"cancleText\" @click=\"handleCancle\">{{cancleText}}</div>\n             <div class=\"confirm btn\" :style=\"confirmStyle\" v-if=\"confirmText\" @click=\"handleConfirm\">{{confirmText}}</div>\n           </div>\n         </div>\n       </transition>\n     </div>\n   </template>\n   <script>\n   export default {\n     name: 'UDialog',\n     props: {\n       visible: { type: Boolean, default: false, required: true },\n       // 确定按钮的文案\n       confirmText: { type: String, default: '确定' },\n       confirmStyle: { type: String, default: '' },\n       // 取消按钮的文案\n       cancleText: { type: String, default: '取消' },\n       cancleStyle: { type: String, default: '' },\n     },\n     created () {\n       this.$nextTick(() => {\n         document.body.insertBefore(this.$el, document.body.lastChild)\n       })\n     },\n     beforeDestroy () {\n       document.body.removeChild(this.$el)\n     },\n     methods: {\n       // 关闭弹窗\n       handleClose () { this.$emit('close') },\n       // 确定按钮\n       handleConfirm () { this.$emit('confirm') },\n       // 取消按钮\n       handleCancle () { this.$emit('cancle') },\n       noop () {}\n     }\n   }\n   </script>\n   \n   <style lang=\"less\" scoped>\n   .u_dialog_panel {\n     .mask {\n       width: 100vw;\n       height: 100vh;\n       background-color: rgba(0, 0, 0, 0.5);\n       position: fixed;\n       left: 0;\n       top: 0;\n       z-index: 100;\n       backdrop-filter: blur(5px);\n     }\n     .dialog_body{\n       width: 80vw;\n       background-color: #fff;\n       position: fixed;\n       left: 50vw;\n       top: 50vh;\n       z-index: 100;\n       transform: translate(-50%, -50%);\n       transform-origin: 0 0;\n       border-radius: .875rem;\n       &.open-enter {\n         opacity: 0;\n         transform: scale(0.7) translate(-50%, -50%);\n         transition: all 0.3s;\n       }\n       &.open-enter-to {\n         opacity: 1;\n         transform: scale(1) translate(-50%, -50%);\n         transition: all 0.3s;\n       }\n       .btns {\n         display: flex;\n         justify-content: space-between;\n         align-items: center;\n         .btn {\n           display: flex;\n           justify-content: center;\n           align-items: center;\n           flex-grow: 1;\n           width: 50%;\n           height: 2.875rem;\n           border-top: 1px solid #ddd;\n           box-sizing: border-box;\n           display: flex;\n           justify-content: center;\n           align-items: center;\n           font-size: .875rem;\n           & + .btn {\n             border-left: 1px solid #ddd;\n           }\n           &.cancle {\n             color: #666666;\n           }\n           &.confirm {\n             color: #FF5883;\n           }\n         }\n       }\n     }\n   }\n   </style>\n   \n   ```\n\n2. 在此文件夹再新建一个index.js\n\n   ```vue\n   import Dialog from './Dialog'\n   \n   Dialog.install = function (Vue, options) {\n     Vue.component(`${Dialog.name}`, Dialog)\n   }\n   \n   export default Dialog\n   \n   ```\n\n3. 最后再main.js里注册为全局组件\n\n   ```vue\n   import Dialog from './components/Dialog/index.js'\n   \n   Vue.use(Dialog)\n   ```\n\n\n\n## 这样就可以在其他组件里无需声明而使用此组件\n\n\n\n","slug":"Vue自定义全局组件","published":1,"updated":"2021-09-23T02:26:35.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18a8000icco9guboe1lw","content":"<h1 id=\"vue自定义全局弹框组件\"><a href=\"#vue自定义全局弹框组件\" class=\"headerlink\" title=\"vue自定义全局弹框组件\"></a>vue自定义全局弹框组件</h1><ol>\n<li><p>在components文件夹下新增一个组件文件夹Dialog，新建一个模板组件Dialog.vue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;template&gt;<br>  &lt;div class=&quot;u_dialog_panel&quot; @touchmove.stop=&quot;noop&quot;&gt;<br>    &lt;div class=&quot;mask&quot; v-if=&quot;visible&quot; @click=&quot;handleClose&quot;&gt;&lt;/div&gt;<br>    &lt;transition name=&quot;open&quot;&gt;<br>      &lt;div v-if=&quot;visible&quot; class=&quot;dialog_body&quot;&gt;<br>        &lt;slot&gt;&lt;/slot&gt;<br>        &lt;div class=&quot;btns&quot; v-if=&quot;confirmText || cancleText&quot;&gt;<br>          &lt;div class=&quot;cancle btn&quot; v-if=&quot;cancleText&quot; @click=&quot;handleCancle&quot;&gt;&#123;&#123;cancleText&#125;&#125;&lt;/div&gt;<br>          &lt;div class=&quot;confirm btn&quot; :style=&quot;confirmStyle&quot; v-if=&quot;confirmText&quot; @click=&quot;handleConfirm&quot;&gt;&#123;&#123;confirmText&#125;&#125;&lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/transition&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  name: &#x27;UDialog&#x27;,<br>  props: &#123;<br>    visible: &#123; type: Boolean, default: false, required: true &#125;,<br>    // 确定按钮的文案<br>    confirmText: &#123; type: String, default: &#x27;确定&#x27; &#125;,<br>    confirmStyle: &#123; type: String, default: &#x27;&#x27; &#125;,<br>    // 取消按钮的文案<br>    cancleText: &#123; type: String, default: &#x27;取消&#x27; &#125;,<br>    cancleStyle: &#123; type: String, default: &#x27;&#x27; &#125;,<br>  &#125;,<br>  created () &#123;<br>    this.$nextTick(() =&gt; &#123;<br>      document.body.insertBefore(this.$el, document.body.lastChild)<br>    &#125;)<br>  &#125;,<br>  beforeDestroy () &#123;<br>    document.body.removeChild(this.$el)<br>  &#125;,<br>  methods: &#123;<br>    // 关闭弹窗<br>    handleClose () &#123; this.$emit(&#x27;close&#x27;) &#125;,<br>    // 确定按钮<br>    handleConfirm () &#123; this.$emit(&#x27;confirm&#x27;) &#125;,<br>    // 取消按钮<br>    handleCancle () &#123; this.$emit(&#x27;cancle&#x27;) &#125;,<br>    noop () &#123;&#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;<br>.u_dialog_panel &#123;<br>  .mask &#123;<br>    width: 100vw;<br>    height: 100vh;<br>    background-color: rgba(0, 0, 0, 0.5);<br>    position: fixed;<br>    left: 0;<br>    top: 0;<br>    z-index: 100;<br>    backdrop-filter: blur(5px);<br>  &#125;<br>  .dialog_body&#123;<br>    width: 80vw;<br>    background-color: #fff;<br>    position: fixed;<br>    left: 50vw;<br>    top: 50vh;<br>    z-index: 100;<br>    transform: translate(-50%, -50%);<br>    transform-origin: 0 0;<br>    border-radius: .875rem;<br>    &amp;.open-enter &#123;<br>      opacity: 0;<br>      transform: scale(0.7) translate(-50%, -50%);<br>      transition: all 0.3s;<br>    &#125;<br>    &amp;.open-enter-to &#123;<br>      opacity: 1;<br>      transform: scale(1) translate(-50%, -50%);<br>      transition: all 0.3s;<br>    &#125;<br>    .btns &#123;<br>      display: flex;<br>      justify-content: space-between;<br>      align-items: center;<br>      .btn &#123;<br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br>        flex-grow: 1;<br>        width: 50%;<br>        height: 2.875rem;<br>        border-top: 1px solid #ddd;<br>        box-sizing: border-box;<br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br>        font-size: .875rem;<br>        &amp; + .btn &#123;<br>          border-left: 1px solid #ddd;<br>        &#125;<br>        &amp;.cancle &#123;<br>          color: #666666;<br>        &#125;<br>        &amp;.confirm &#123;<br>          color: #FF5883;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure></li>\n<li><p>在此文件夹再新建一个index.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">import Dialog from &#x27;./Dialog&#x27;<br><br>Dialog.install = function (Vue, options) &#123;<br>  Vue.component(`$&#123;Dialog.name&#125;`, Dialog)<br>&#125;<br><br>export default Dialog<br><br></code></pre></td></tr></table></figure></li>\n<li><p>最后再main.js里注册为全局组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">import Dialog from &#x27;./components/Dialog/index.js&#x27;<br><br>Vue.use(Dialog)<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"这样就可以在其他组件里无需声明而使用此组件\"><a href=\"#这样就可以在其他组件里无需声明而使用此组件\" class=\"headerlink\" title=\"这样就可以在其他组件里无需声明而使用此组件\"></a>这样就可以在其他组件里无需声明而使用此组件</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"vue自定义全局弹框组件\"><a href=\"#vue自定义全局弹框组件\" class=\"headerlink\" title=\"vue自定义全局弹框组件\"></a>vue自定义全局弹框组件</h1><ol>\n<li><p>在components文件夹下新增一个组件文件夹Dialog，新建一个模板组件Dialog.vue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;template&gt;<br>  &lt;div class=&quot;u_dialog_panel&quot; @touchmove.stop=&quot;noop&quot;&gt;<br>    &lt;div class=&quot;mask&quot; v-if=&quot;visible&quot; @click=&quot;handleClose&quot;&gt;&lt;/div&gt;<br>    &lt;transition name=&quot;open&quot;&gt;<br>      &lt;div v-if=&quot;visible&quot; class=&quot;dialog_body&quot;&gt;<br>        &lt;slot&gt;&lt;/slot&gt;<br>        &lt;div class=&quot;btns&quot; v-if=&quot;confirmText || cancleText&quot;&gt;<br>          &lt;div class=&quot;cancle btn&quot; v-if=&quot;cancleText&quot; @click=&quot;handleCancle&quot;&gt;&#123;&#123;cancleText&#125;&#125;&lt;/div&gt;<br>          &lt;div class=&quot;confirm btn&quot; :style=&quot;confirmStyle&quot; v-if=&quot;confirmText&quot; @click=&quot;handleConfirm&quot;&gt;&#123;&#123;confirmText&#125;&#125;&lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/transition&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  name: &#x27;UDialog&#x27;,<br>  props: &#123;<br>    visible: &#123; type: Boolean, default: false, required: true &#125;,<br>    // 确定按钮的文案<br>    confirmText: &#123; type: String, default: &#x27;确定&#x27; &#125;,<br>    confirmStyle: &#123; type: String, default: &#x27;&#x27; &#125;,<br>    // 取消按钮的文案<br>    cancleText: &#123; type: String, default: &#x27;取消&#x27; &#125;,<br>    cancleStyle: &#123; type: String, default: &#x27;&#x27; &#125;,<br>  &#125;,<br>  created () &#123;<br>    this.$nextTick(() =&gt; &#123;<br>      document.body.insertBefore(this.$el, document.body.lastChild)<br>    &#125;)<br>  &#125;,<br>  beforeDestroy () &#123;<br>    document.body.removeChild(this.$el)<br>  &#125;,<br>  methods: &#123;<br>    // 关闭弹窗<br>    handleClose () &#123; this.$emit(&#x27;close&#x27;) &#125;,<br>    // 确定按钮<br>    handleConfirm () &#123; this.$emit(&#x27;confirm&#x27;) &#125;,<br>    // 取消按钮<br>    handleCancle () &#123; this.$emit(&#x27;cancle&#x27;) &#125;,<br>    noop () &#123;&#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;<br>.u_dialog_panel &#123;<br>  .mask &#123;<br>    width: 100vw;<br>    height: 100vh;<br>    background-color: rgba(0, 0, 0, 0.5);<br>    position: fixed;<br>    left: 0;<br>    top: 0;<br>    z-index: 100;<br>    backdrop-filter: blur(5px);<br>  &#125;<br>  .dialog_body&#123;<br>    width: 80vw;<br>    background-color: #fff;<br>    position: fixed;<br>    left: 50vw;<br>    top: 50vh;<br>    z-index: 100;<br>    transform: translate(-50%, -50%);<br>    transform-origin: 0 0;<br>    border-radius: .875rem;<br>    &amp;.open-enter &#123;<br>      opacity: 0;<br>      transform: scale(0.7) translate(-50%, -50%);<br>      transition: all 0.3s;<br>    &#125;<br>    &amp;.open-enter-to &#123;<br>      opacity: 1;<br>      transform: scale(1) translate(-50%, -50%);<br>      transition: all 0.3s;<br>    &#125;<br>    .btns &#123;<br>      display: flex;<br>      justify-content: space-between;<br>      align-items: center;<br>      .btn &#123;<br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br>        flex-grow: 1;<br>        width: 50%;<br>        height: 2.875rem;<br>        border-top: 1px solid #ddd;<br>        box-sizing: border-box;<br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br>        font-size: .875rem;<br>        &amp; + .btn &#123;<br>          border-left: 1px solid #ddd;<br>        &#125;<br>        &amp;.cancle &#123;<br>          color: #666666;<br>        &#125;<br>        &amp;.confirm &#123;<br>          color: #FF5883;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure></li>\n<li><p>在此文件夹再新建一个index.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">import Dialog from &#x27;./Dialog&#x27;<br><br>Dialog.install = function (Vue, options) &#123;<br>  Vue.component(`$&#123;Dialog.name&#125;`, Dialog)<br>&#125;<br><br>export default Dialog<br><br></code></pre></td></tr></table></figure></li>\n<li><p>最后再main.js里注册为全局组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">import Dialog from &#x27;./components/Dialog/index.js&#x27;<br><br>Vue.use(Dialog)<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"这样就可以在其他组件里无需声明而使用此组件\"><a href=\"#这样就可以在其他组件里无需声明而使用此组件\" class=\"headerlink\" title=\"这样就可以在其他组件里无需声明而使用此组件\"></a>这样就可以在其他组件里无需声明而使用此组件</h2>"},{"title":"export与export default的区别","date":"2021-07-01T06:21:44.000Z","_content":"\nnode中导入模块：var 名称 = require('模块标识符')\n\nnode中向外暴露成员的形式：module.exports = {}\n\n在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块\n\nES6中导入模块，使用 import 模块名称 from '模块标识符'    import '表示路径'\n\nimport * from * 是ES6中导入模块的方式\n\n### 在ES6中，使用export default 和 export 向外暴露成员\n\n例如：\n\n```javascript\n// test.js\nexport default {\n    name: 'zs',\n    age: 20\n}\n```\n\n或是\n\n```javascript\n// test.js\nvar info = {\n    name: 'zs',\n    age: 20\n}\nexport default info\n```\n\n在main.js中接收，test.js使用export default 向外暴露的成员\n\n```javascript\nimport person from './test.js'\nconsole.log(person);\n```\n\n### 注意：\n\n1、export default 向外暴露的成员，可以使用任意变量来接收\n\n2、在一个模块中，export default 只允许向外暴露一次\n\n3、在一个模块中，可以同时使用export default 和export 向外暴露成员\n\n4、使用export向外暴露的成员，只能使用{  }的形式来接收，这种形式，叫做【按需导出】\n\n5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义\n\n6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收\n\n7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名\n\n例如：\n\n```javascript\n// test.js\nvar info = {\n    name: 'zs',\n    age: 20\n}\nexport default info\n\nexport var title = '小星星'\n\nexport var content = '哈哈哈'\n```\n\n在main.js中接收，test.js使用export default 和 export 向外暴露的成员\n\n```javascript\nimport person, {title, content as content1} from './test.js'\nconsole.log(person);\nconsole.log(title + '=======' + content1);\n```\n\n","source":"_posts/2021-09-23-export与export-default的区别.md","raw":"---\ntitle: export与export default的区别\ndate: 2021-07-1 14:21:44\ntags: \n    - [JavaScript]\n    - [ES6]\ncategories: 技术类-前端\n---\n\nnode中导入模块：var 名称 = require('模块标识符')\n\nnode中向外暴露成员的形式：module.exports = {}\n\n在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块\n\nES6中导入模块，使用 import 模块名称 from '模块标识符'    import '表示路径'\n\nimport * from * 是ES6中导入模块的方式\n\n### 在ES6中，使用export default 和 export 向外暴露成员\n\n例如：\n\n```javascript\n// test.js\nexport default {\n    name: 'zs',\n    age: 20\n}\n```\n\n或是\n\n```javascript\n// test.js\nvar info = {\n    name: 'zs',\n    age: 20\n}\nexport default info\n```\n\n在main.js中接收，test.js使用export default 向外暴露的成员\n\n```javascript\nimport person from './test.js'\nconsole.log(person);\n```\n\n### 注意：\n\n1、export default 向外暴露的成员，可以使用任意变量来接收\n\n2、在一个模块中，export default 只允许向外暴露一次\n\n3、在一个模块中，可以同时使用export default 和export 向外暴露成员\n\n4、使用export向外暴露的成员，只能使用{  }的形式来接收，这种形式，叫做【按需导出】\n\n5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义\n\n6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收\n\n7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名\n\n例如：\n\n```javascript\n// test.js\nvar info = {\n    name: 'zs',\n    age: 20\n}\nexport default info\n\nexport var title = '小星星'\n\nexport var content = '哈哈哈'\n```\n\n在main.js中接收，test.js使用export default 和 export 向外暴露的成员\n\n```javascript\nimport person, {title, content as content1} from './test.js'\nconsole.log(person);\nconsole.log(title + '=======' + content1);\n```\n\n","slug":"export与export-default的区别","published":1,"updated":"2021-10-08T03:11:22.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18a9000jcco90hyi0lsv","content":"<p>node中导入模块：var 名称 = require(‘模块标识符’)</p>\n<p>node中向外暴露成员的形式：module.exports = {}</p>\n<p>在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块</p>\n<p>ES6中导入模块，使用 import 模块名称 from ‘模块标识符’    import ‘表示路径’</p>\n<p>import * from * 是ES6中导入模块的方式</p>\n<h3 id=\"在ES6中，使用export-default-和-export-向外暴露成员\"><a href=\"#在ES6中，使用export-default-和-export-向外暴露成员\" class=\"headerlink\" title=\"在ES6中，使用export default 和 export 向外暴露成员\"></a>在ES6中，使用export default 和 export 向外暴露成员</h3><p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zs&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>或是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span><br><span class=\"hljs-keyword\">var</span> info = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zs&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span><br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> info<br></code></pre></td></tr></table></figure>\n\n<p>在main.js中接收，test.js使用export default 向外暴露的成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> person <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./test.js&#x27;</span><br><span class=\"hljs-built_in\">console</span>.log(person);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>1、export default 向外暴露的成员，可以使用任意变量来接收</p>\n<p>2、在一个模块中，export default 只允许向外暴露一次</p>\n<p>3、在一个模块中，可以同时使用export default 和export 向外暴露成员</p>\n<p>4、使用export向外暴露的成员，只能使用{  }的形式来接收，这种形式，叫做【按需导出】</p>\n<p>5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义</p>\n<p>6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收</p>\n<p>7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名</p>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span><br><span class=\"hljs-keyword\">var</span> info = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zs&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span><br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> info<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> title = <span class=\"hljs-string\">&#x27;小星星&#x27;</span><br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> content = <span class=\"hljs-string\">&#x27;哈哈哈&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>在main.js中接收，test.js使用export default 和 export 向外暴露的成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> person, &#123;title, content <span class=\"hljs-keyword\">as</span> content1&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./test.js&#x27;</span><br><span class=\"hljs-built_in\">console</span>.log(person);<br><span class=\"hljs-built_in\">console</span>.log(title + <span class=\"hljs-string\">&#x27;=======&#x27;</span> + content1);<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>node中导入模块：var 名称 = require(‘模块标识符’)</p>\n<p>node中向外暴露成员的形式：module.exports = {}</p>\n<p>在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块</p>\n<p>ES6中导入模块，使用 import 模块名称 from ‘模块标识符’    import ‘表示路径’</p>\n<p>import * from * 是ES6中导入模块的方式</p>\n<h3 id=\"在ES6中，使用export-default-和-export-向外暴露成员\"><a href=\"#在ES6中，使用export-default-和-export-向外暴露成员\" class=\"headerlink\" title=\"在ES6中，使用export default 和 export 向外暴露成员\"></a>在ES6中，使用export default 和 export 向外暴露成员</h3><p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zs&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>或是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span><br><span class=\"hljs-keyword\">var</span> info = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zs&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span><br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> info<br></code></pre></td></tr></table></figure>\n\n<p>在main.js中接收，test.js使用export default 向外暴露的成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> person <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./test.js&#x27;</span><br><span class=\"hljs-built_in\">console</span>.log(person);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>1、export default 向外暴露的成员，可以使用任意变量来接收</p>\n<p>2、在一个模块中，export default 只允许向外暴露一次</p>\n<p>3、在一个模块中，可以同时使用export default 和export 向外暴露成员</p>\n<p>4、使用export向外暴露的成员，只能使用{  }的形式来接收，这种形式，叫做【按需导出】</p>\n<p>5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义</p>\n<p>6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收</p>\n<p>7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名</p>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span><br><span class=\"hljs-keyword\">var</span> info = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zs&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span><br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> info<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> title = <span class=\"hljs-string\">&#x27;小星星&#x27;</span><br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> content = <span class=\"hljs-string\">&#x27;哈哈哈&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>在main.js中接收，test.js使用export default 和 export 向外暴露的成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> person, &#123;title, content <span class=\"hljs-keyword\">as</span> content1&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./test.js&#x27;</span><br><span class=\"hljs-built_in\">console</span>.log(person);<br><span class=\"hljs-built_in\">console</span>.log(title + <span class=\"hljs-string\">&#x27;=======&#x27;</span> + content1);<br></code></pre></td></tr></table></figure>\n\n"},{"title":"new操作符的实现","date":"2021-06-18T21:23:44.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# JavaScript中的new操作符的原理\n\n## 例子\n\n```\nfunction Person (name, age) {\n this.name = name\n this.age = age\n}\nconst person1 = new Person('走花路的长颈鹿', 26)\nconsole.log(person1) //Person{name:'走花路的长颈鹿',age:26}\n```\n\n先定义了一个构造函数`Person`，然后通过`new`操作符生成Person构造函数的一个实例并将其引用赋值给变量`person1`。然后控制台打印出`person1`的内容，可以看到该实例对象具有`name`和`age`属性，它们的值就是我们在调用构造函数时传入的值。\n\n## new关键字进行的操作\n\n1.  先创建一个空对象`obj={}`\n\n2.  将obj的`__proto__`原型指向构造函数Person的`prototype`原型对象，即`obj.__proto__ = Person.prototype`\n\n3.  将构造函数Person内部的this指向obj，然后执行构造函数`Person()`（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象`obj`而已，就好像执行`obj.Person()`一样）\n\n4.  若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象`obj`（默认会添加`return this`）。否则，返回引用类型的值。\n\n![new操作符的执行过程](https://upload-images.jianshu.io/upload_images/13931286-2638e8196f6e699b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n## 自己实现一个new操作符\n\n```\nfunction myNew (constr, ...args) {\n // 1,2 创建一个对象obj，将obj的__proto__属性指向构造函数的原型对象\n // 即实现：obj.__proto__ === constructor.prototype\n var obj = Object.create(constr.prototype)\n // 3.将constrc内部的this（即执行上下文）指向obj，并执行\n var result = constr.apply(obj, args)\n // 4\\. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象\n return result instanceof Object ? result : obj\n}\n\n// 使用的例子：\nfunction Person(name, age){\n this.name = name;\n this.age = age;\n}\nconst person1 = myNew(Person, 'Tom', 20)\nconsole.log(person1)  // Person {name: \"Tom\", age: 20}\n```\n\n## 关键点\n\n1.  将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。\n\n2.  将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。\n\n<hr>\n\n## 2021年7月1日补充\n\n看一个例子\n```\nfunction Player(color) {\n  this.color = color\n}\nPlayer.prototype.start = function() {}\n\nconst white = new Player('white')\nconst black = new Player('black')\n\nconsole.log(black.__proto__)  // start()\nconsole.log(Object.getPrototypeOf(black)) // start()\nconsole.log(Player.prototype) // start()\nconsole.log(Player.__proto__) // {}\n```\n根据反推可以写一下思路\n1. 一个继承自`Player.prototype`的新对象 p1/p2被创建\n2. `p1.__proto__ === Player.prototype`，`p1.__proto__`指向`Player.prototype`\n3. 将this指向新创建的对象p1/p2\n4. 返回一个新对象：\n    1. 如果构造函数没有显示的返回值，那么返回this\n    2. 如果有显式的返回值，是基本类型，那么还是返回this\n    3. 如果构造函数有显式的返回值，是对象类型，比如是{a:1}，那么就返回{a:1}\n现在我们再来实现一个new指令的功能\n```\nfunction Player(name){\n  this.name = name\n}\n\nfunction objectFactory() {\n  let o = new Object()\n  let FunctionConstructor = [].shift.call(arguments)\n  o.__proto__ = FunctionConstructor.prototype\n  let resultObj = FunctionConstructor.apply(o, arguments) \n  return typeof resultObj === 'object' ? resultObj : o\n}\nconst p1 = objectFactory(Player, '花鹿')\nconsole.log(p1) // 花鹿\n``` \n## 完~\n","source":"_posts/2021-09-23-new操作符的实现.md","raw":"---\ntitle: new操作符的实现\ndate: 2021-06-19 05:23:44\ntags: [JavaScript,面试]\ncategories: 技术类-前端\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# JavaScript中的new操作符的原理\n\n## 例子\n\n```\nfunction Person (name, age) {\n this.name = name\n this.age = age\n}\nconst person1 = new Person('走花路的长颈鹿', 26)\nconsole.log(person1) //Person{name:'走花路的长颈鹿',age:26}\n```\n\n先定义了一个构造函数`Person`，然后通过`new`操作符生成Person构造函数的一个实例并将其引用赋值给变量`person1`。然后控制台打印出`person1`的内容，可以看到该实例对象具有`name`和`age`属性，它们的值就是我们在调用构造函数时传入的值。\n\n## new关键字进行的操作\n\n1.  先创建一个空对象`obj={}`\n\n2.  将obj的`__proto__`原型指向构造函数Person的`prototype`原型对象，即`obj.__proto__ = Person.prototype`\n\n3.  将构造函数Person内部的this指向obj，然后执行构造函数`Person()`（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象`obj`而已，就好像执行`obj.Person()`一样）\n\n4.  若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象`obj`（默认会添加`return this`）。否则，返回引用类型的值。\n\n![new操作符的执行过程](https://upload-images.jianshu.io/upload_images/13931286-2638e8196f6e699b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n## 自己实现一个new操作符\n\n```\nfunction myNew (constr, ...args) {\n // 1,2 创建一个对象obj，将obj的__proto__属性指向构造函数的原型对象\n // 即实现：obj.__proto__ === constructor.prototype\n var obj = Object.create(constr.prototype)\n // 3.将constrc内部的this（即执行上下文）指向obj，并执行\n var result = constr.apply(obj, args)\n // 4\\. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象\n return result instanceof Object ? result : obj\n}\n\n// 使用的例子：\nfunction Person(name, age){\n this.name = name;\n this.age = age;\n}\nconst person1 = myNew(Person, 'Tom', 20)\nconsole.log(person1)  // Person {name: \"Tom\", age: 20}\n```\n\n## 关键点\n\n1.  将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。\n\n2.  将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。\n\n<hr>\n\n## 2021年7月1日补充\n\n看一个例子\n```\nfunction Player(color) {\n  this.color = color\n}\nPlayer.prototype.start = function() {}\n\nconst white = new Player('white')\nconst black = new Player('black')\n\nconsole.log(black.__proto__)  // start()\nconsole.log(Object.getPrototypeOf(black)) // start()\nconsole.log(Player.prototype) // start()\nconsole.log(Player.__proto__) // {}\n```\n根据反推可以写一下思路\n1. 一个继承自`Player.prototype`的新对象 p1/p2被创建\n2. `p1.__proto__ === Player.prototype`，`p1.__proto__`指向`Player.prototype`\n3. 将this指向新创建的对象p1/p2\n4. 返回一个新对象：\n    1. 如果构造函数没有显示的返回值，那么返回this\n    2. 如果有显式的返回值，是基本类型，那么还是返回this\n    3. 如果构造函数有显式的返回值，是对象类型，比如是{a:1}，那么就返回{a:1}\n现在我们再来实现一个new指令的功能\n```\nfunction Player(name){\n  this.name = name\n}\n\nfunction objectFactory() {\n  let o = new Object()\n  let FunctionConstructor = [].shift.call(arguments)\n  o.__proto__ = FunctionConstructor.prototype\n  let resultObj = FunctionConstructor.apply(o, arguments) \n  return typeof resultObj === 'object' ? resultObj : o\n}\nconst p1 = objectFactory(Player, '花鹿')\nconsole.log(p1) // 花鹿\n``` \n## 完~\n","slug":"new操作符的实现","published":1,"updated":"2021-10-13T08:42:09.247Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18aa000ncco9e65dchue","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"JavaScript中的new操作符的原理\"><a href=\"#JavaScript中的new操作符的原理\" class=\"headerlink\" title=\"JavaScript中的new操作符的原理\"></a>JavaScript中的new操作符的原理</h1><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span> (<span class=\"hljs-params\">name, age</span>) </span>&#123;<br> <span class=\"hljs-built_in\">this</span>.name = name<br> <span class=\"hljs-built_in\">this</span>.age = age<br>&#125;<br><span class=\"hljs-keyword\">const</span> person1 = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">&#x27;走花路的长颈鹿&#x27;</span>, <span class=\"hljs-number\">26</span>)<br><span class=\"hljs-built_in\">console</span>.log(person1) <span class=\"hljs-comment\">//Person&#123;name:&#x27;走花路的长颈鹿&#x27;,age:26&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>先定义了一个构造函数<code>Person</code>，然后通过<code>new</code>操作符生成Person构造函数的一个实例并将其引用赋值给变量<code>person1</code>。然后控制台打印出<code>person1</code>的内容，可以看到该实例对象具有<code>name</code>和<code>age</code>属性，它们的值就是我们在调用构造函数时传入的值。</p>\n<h2 id=\"new关键字进行的操作\"><a href=\"#new关键字进行的操作\" class=\"headerlink\" title=\"new关键字进行的操作\"></a>new关键字进行的操作</h2><ol>\n<li><p> 先创建一个空对象<code>obj=&#123;&#125;</code></p>\n</li>\n<li><p> 将obj的<code>__proto__</code>原型指向构造函数Person的<code>prototype</code>原型对象，即<code>obj.__proto__ = Person.prototype</code></p>\n</li>\n<li><p> 将构造函数Person内部的this指向obj，然后执行构造函数<code>Person()</code>（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象<code>obj</code>而已，就好像执行<code>obj.Person()</code>一样）</p>\n</li>\n<li><p> 若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象<code>obj</code>（默认会添加<code>return this</code>）。否则，返回引用类型的值。</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-2638e8196f6e699b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"new操作符的执行过程\"> </p>\n<h2 id=\"自己实现一个new操作符\"><a href=\"#自己实现一个new操作符\" class=\"headerlink\" title=\"自己实现一个new操作符\"></a>自己实现一个new操作符</h2><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myNew</span> <span class=\"hljs-params\">(constr, <span class=\"hljs-rest_arg\">...args</span>)</span> </span>&#123;<br> <span class=\"hljs-comment\">// 1,2 创建一个对象obj，将obj的__proto__属性指向构造函数的原型对象</span><br> <span class=\"hljs-comment\">// 即实现：obj.__proto__ === constructor.prototype</span><br> <span class=\"hljs-keyword\">var</span> obj = Object.create(constr.prototype)<br> <span class=\"hljs-comment\">// 3.将constrc内部的this（即执行上下文）指向obj，并执行</span><br> <span class=\"hljs-keyword\">var</span> result = constr.apply(obj, args)<br> <span class=\"hljs-comment\">// 4\\. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象</span><br> <span class=\"hljs-keyword\">return</span> result <span class=\"hljs-keyword\">instanceof</span> Object ? result : obj<br>&#125;<br><br><span class=\"hljs-comment\">// 使用的例子：</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">(name, age)</span></span>&#123;<br> <span class=\"hljs-keyword\">this</span>.name = name;<br> <span class=\"hljs-keyword\">this</span>.age = age;<br>&#125;<br><span class=\"hljs-keyword\">const</span> person1 = myNew(Person, <span class=\"hljs-string\">&#x27;Tom&#x27;</span>, <span class=\"hljs-number\">20</span>)<br>console.log(person1)  <span class=\"hljs-comment\">// Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h2><ol>\n<li><p> 将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。</p>\n</li>\n<li><p> 将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。</p>\n</li>\n</ol>\n<hr>\n\n<h2 id=\"2021年7月1日补充\"><a href=\"#2021年7月1日补充\" class=\"headerlink\" title=\"2021年7月1日补充\"></a>2021年7月1日补充</h2><p>看一个例子</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-constructor\">Player(<span class=\"hljs-params\">color</span>)</span> &#123;<br>  this.color = color<br>&#125;<br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Player</span>.</span></span>prototype.start = <span class=\"hljs-keyword\">function</span><span class=\"hljs-literal\">()</span> &#123;&#125;<br><br>const white = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Player(&#x27;<span class=\"hljs-params\">white</span>&#x27;)</span><br>const black = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Player(&#x27;<span class=\"hljs-params\">black</span>&#x27;)</span><br><br>console.log(black.__proto__)  <span class=\"hljs-comment\">// start()</span><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>get<span class=\"hljs-constructor\">PrototypeOf(<span class=\"hljs-params\">black</span>)</span>) <span class=\"hljs-comment\">// start()</span><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Player</span>.</span></span>prototype) <span class=\"hljs-comment\">// start()</span><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Player</span>.</span><span class=\"hljs-module\"><span class=\"hljs-identifier\">__proto__</span>)</span></span> <span class=\"hljs-comment\">// &#123;&#125;</span><br></code></pre></td></tr></table></figure>\n<p>根据反推可以写一下思路</p>\n<ol>\n<li>一个继承自<code>Player.prototype</code>的新对象 p1/p2被创建</li>\n<li><code>p1.__proto__ === Player.prototype</code>，<code>p1.__proto__</code>指向<code>Player.prototype</code></li>\n<li>将this指向新创建的对象p1/p2</li>\n<li>返回一个新对象：<ol>\n<li>如果构造函数没有显示的返回值，那么返回this</li>\n<li>如果有显式的返回值，是基本类型，那么还是返回this</li>\n<li>如果构造函数有显式的返回值，是对象类型，比如是{a:1}，那么就返回{a:1}<br>现在我们再来实现一个new指令的功能<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Player</span>(<span class=\"hljs-params\">name</span>)</span>&#123;<br>  <span class=\"hljs-built_in\">this</span>.name = name<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">objectFactory</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> o = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>()<br>  <span class=\"hljs-keyword\">let</span> FunctionConstructor = [].shift.call(<span class=\"hljs-built_in\">arguments</span>)<br>  o.__proto__ = FunctionConstructor.prototype<br>  <span class=\"hljs-keyword\">let</span> resultObj = FunctionConstructor.apply(o, <span class=\"hljs-built_in\">arguments</span>) <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> resultObj === <span class=\"hljs-string\">&#x27;object&#x27;</span> ? resultObj : o<br>&#125;<br><span class=\"hljs-keyword\">const</span> p1 = objectFactory(Player, <span class=\"hljs-string\">&#x27;花鹿&#x27;</span>)<br><span class=\"hljs-built_in\">console</span>.log(p1) <span class=\"hljs-comment\">// 花鹿</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完~\"></a>完~</h2></li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"JavaScript中的new操作符的原理\"><a href=\"#JavaScript中的new操作符的原理\" class=\"headerlink\" title=\"JavaScript中的new操作符的原理\"></a>JavaScript中的new操作符的原理</h1><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span> (<span class=\"hljs-params\">name, age</span>) </span>&#123;<br> <span class=\"hljs-built_in\">this</span>.name = name<br> <span class=\"hljs-built_in\">this</span>.age = age<br>&#125;<br><span class=\"hljs-keyword\">const</span> person1 = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">&#x27;走花路的长颈鹿&#x27;</span>, <span class=\"hljs-number\">26</span>)<br><span class=\"hljs-built_in\">console</span>.log(person1) <span class=\"hljs-comment\">//Person&#123;name:&#x27;走花路的长颈鹿&#x27;,age:26&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>先定义了一个构造函数<code>Person</code>，然后通过<code>new</code>操作符生成Person构造函数的一个实例并将其引用赋值给变量<code>person1</code>。然后控制台打印出<code>person1</code>的内容，可以看到该实例对象具有<code>name</code>和<code>age</code>属性，它们的值就是我们在调用构造函数时传入的值。</p>\n<h2 id=\"new关键字进行的操作\"><a href=\"#new关键字进行的操作\" class=\"headerlink\" title=\"new关键字进行的操作\"></a>new关键字进行的操作</h2><ol>\n<li><p> 先创建一个空对象<code>obj=&#123;&#125;</code></p>\n</li>\n<li><p> 将obj的<code>__proto__</code>原型指向构造函数Person的<code>prototype</code>原型对象，即<code>obj.__proto__ = Person.prototype</code></p>\n</li>\n<li><p> 将构造函数Person内部的this指向obj，然后执行构造函数<code>Person()</code>（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象<code>obj</code>而已，就好像执行<code>obj.Person()</code>一样）</p>\n</li>\n<li><p> 若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象<code>obj</code>（默认会添加<code>return this</code>）。否则，返回引用类型的值。</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-2638e8196f6e699b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"new操作符的执行过程\"> </p>\n<h2 id=\"自己实现一个new操作符\"><a href=\"#自己实现一个new操作符\" class=\"headerlink\" title=\"自己实现一个new操作符\"></a>自己实现一个new操作符</h2><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myNew</span> <span class=\"hljs-params\">(constr, <span class=\"hljs-rest_arg\">...args</span>)</span> </span>&#123;<br> <span class=\"hljs-comment\">// 1,2 创建一个对象obj，将obj的__proto__属性指向构造函数的原型对象</span><br> <span class=\"hljs-comment\">// 即实现：obj.__proto__ === constructor.prototype</span><br> <span class=\"hljs-keyword\">var</span> obj = Object.create(constr.prototype)<br> <span class=\"hljs-comment\">// 3.将constrc内部的this（即执行上下文）指向obj，并执行</span><br> <span class=\"hljs-keyword\">var</span> result = constr.apply(obj, args)<br> <span class=\"hljs-comment\">// 4\\. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象</span><br> <span class=\"hljs-keyword\">return</span> result <span class=\"hljs-keyword\">instanceof</span> Object ? result : obj<br>&#125;<br><br><span class=\"hljs-comment\">// 使用的例子：</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">(name, age)</span></span>&#123;<br> <span class=\"hljs-keyword\">this</span>.name = name;<br> <span class=\"hljs-keyword\">this</span>.age = age;<br>&#125;<br><span class=\"hljs-keyword\">const</span> person1 = myNew(Person, <span class=\"hljs-string\">&#x27;Tom&#x27;</span>, <span class=\"hljs-number\">20</span>)<br>console.log(person1)  <span class=\"hljs-comment\">// Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h2><ol>\n<li><p> 将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。</p>\n</li>\n<li><p> 将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。</p>\n</li>\n</ol>\n<hr>\n\n<h2 id=\"2021年7月1日补充\"><a href=\"#2021年7月1日补充\" class=\"headerlink\" title=\"2021年7月1日补充\"></a>2021年7月1日补充</h2><p>看一个例子</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-constructor\">Player(<span class=\"hljs-params\">color</span>)</span> &#123;<br>  this.color = color<br>&#125;<br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Player</span>.</span></span>prototype.start = <span class=\"hljs-keyword\">function</span><span class=\"hljs-literal\">()</span> &#123;&#125;<br><br>const white = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Player(&#x27;<span class=\"hljs-params\">white</span>&#x27;)</span><br>const black = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Player(&#x27;<span class=\"hljs-params\">black</span>&#x27;)</span><br><br>console.log(black.__proto__)  <span class=\"hljs-comment\">// start()</span><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>get<span class=\"hljs-constructor\">PrototypeOf(<span class=\"hljs-params\">black</span>)</span>) <span class=\"hljs-comment\">// start()</span><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Player</span>.</span></span>prototype) <span class=\"hljs-comment\">// start()</span><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Player</span>.</span><span class=\"hljs-module\"><span class=\"hljs-identifier\">__proto__</span>)</span></span> <span class=\"hljs-comment\">// &#123;&#125;</span><br></code></pre></td></tr></table></figure>\n<p>根据反推可以写一下思路</p>\n<ol>\n<li>一个继承自<code>Player.prototype</code>的新对象 p1/p2被创建</li>\n<li><code>p1.__proto__ === Player.prototype</code>，<code>p1.__proto__</code>指向<code>Player.prototype</code></li>\n<li>将this指向新创建的对象p1/p2</li>\n<li>返回一个新对象：<ol>\n<li>如果构造函数没有显示的返回值，那么返回this</li>\n<li>如果有显式的返回值，是基本类型，那么还是返回this</li>\n<li>如果构造函数有显式的返回值，是对象类型，比如是{a:1}，那么就返回{a:1}<br>现在我们再来实现一个new指令的功能<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Player</span>(<span class=\"hljs-params\">name</span>)</span>&#123;<br>  <span class=\"hljs-built_in\">this</span>.name = name<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">objectFactory</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> o = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>()<br>  <span class=\"hljs-keyword\">let</span> FunctionConstructor = [].shift.call(<span class=\"hljs-built_in\">arguments</span>)<br>  o.__proto__ = FunctionConstructor.prototype<br>  <span class=\"hljs-keyword\">let</span> resultObj = FunctionConstructor.apply(o, <span class=\"hljs-built_in\">arguments</span>) <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> resultObj === <span class=\"hljs-string\">&#x27;object&#x27;</span> ? resultObj : o<br>&#125;<br><span class=\"hljs-keyword\">const</span> p1 = objectFactory(Player, <span class=\"hljs-string\">&#x27;花鹿&#x27;</span>)<br><span class=\"hljs-built_in\">console</span>.log(p1) <span class=\"hljs-comment\">// 花鹿</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完~\"></a>完~</h2></li>\n</ol>\n</li>\n</ol>\n"},{"title":"原型与原型链与constructor","date":"2021-06-18T07:16:53.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 原型与原型链与constructor\n\n本文参考自：[https://blog.csdn.net/cc18868876837/article/details/81211729](https://blog.csdn.net/cc18868876837/article/details/81211729)\n\n## 先来个总结：\n\n1.  我们需要牢记两点：①`__proto__`和`constructor`属性是对象所独有的；② `prototype`属性是函数所独有的，因为函数也是一种对象，所以函数也拥有`__proto__`和`constructor`属性。\n\n2.  __`proto__`属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的`__proto__`属性所指向的那个对象（父对象）里找，一直找，直到`__proto__`属性的终点null，再往上找就相当于在null上取值，会报错。通过`__proto__`属性将对象连接起来的这条链路即我们所谓的原型链。\n\n3.  `prototype`属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即`f1.__proto__ === Foo.prototype`。\n\n4.  `constructor`属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向`Function`。\n\n![整体的联系](https://upload-images.jianshu.io/upload_images/13931286-5467dbdb42fd91ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n## 基础知识\n\n`__proto__`翻译为**原型**，多个`__proto__`串连起来的叫做**原型链**。\n\n`prototype`翻译为**原型对象**。\n\n## Object.getPrototypeOf()\n\n`Object.getPrototypeOf()` 方法返回指定对象的原型（内部`[[Prototype]]`属性的值）。\n\n### 示例\n```\nconst prototype1 = {};\nconst object1 = Object.create(prototype1);\n\nconsole.log(Object.getPrototypeOf(object1) === prototype1);\n// expected output: true\nObject.getPrototypeOf(object1) === object1.__proto__\n```\n\n## 正式开始\n\n```\nfunction Foo() {...};\nlet f1 = new Foo();\n```\n\n以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：**函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。**\n\n## `__proto__`属性\n\n首先要记住两点：\n\n1.  `__proto__`和`constructor`是对象才有的属性，在JavaScript中函数也是一种对象。\n\n2.  `prototype`是函数才有的属性。\n\n![__proto__](https://upload-images.jianshu.io/upload_images/13931286-9355e730b53d1879?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n这里我们仅留下 `__proto__` 属性，它是对象所独有的，可以看到`__proto__`属性都是由**一个对象指向一个对象**，即指向它们构造函数的**原型对象**（也可以理解为父对象），那么这个属性的作用是什么呢？它的**作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的`__proto__`属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的`__proto__`属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点）**，由以上这种通过`__proto__`属性来连接对象直到null的一条链即为我们所谓的原型链。    其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠`__proto__`继承而来的。\n\n## `prototype`属性\n\n![prototype属性](https://upload-images.jianshu.io/upload_images/13931286-a68d7e7851adf580?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n`prototype`属性是函数独有的。他是从一个函数指向一个对象，他的含义是函数的原型对象\n\n`f1.__proto__ === Foo.prototype`，它们两个完全一样。那prototype属性的作用又是什么呢？**它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。**任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。\n\n## constructor属性\n\n![constructor属性](https://upload-images.jianshu.io/upload_images/13931286-8de481f4fbc04fee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n`constructor`属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合`__proto__`属性查看会更清楚点，如下图所示），从上图中可以看出`Function`这个对象比较特殊，它的构造函数就是它自己（因为`Function`可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由`Function`构造函数得来，所以`constructor`属性的终点就是`Function`这个函数。\n\n`函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身`\n\n## 完~\n\n","source":"_posts/2021-09-23-原型与原型链与constructor.md","raw":"---\ntitle: 原型与原型链与constructor\ndate: 2021-06-18 15:16:53\ntags: \n    - [JavaScript]\n    - [面试]\ncategories: 技术类-前端\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 原型与原型链与constructor\n\n本文参考自：[https://blog.csdn.net/cc18868876837/article/details/81211729](https://blog.csdn.net/cc18868876837/article/details/81211729)\n\n## 先来个总结：\n\n1.  我们需要牢记两点：①`__proto__`和`constructor`属性是对象所独有的；② `prototype`属性是函数所独有的，因为函数也是一种对象，所以函数也拥有`__proto__`和`constructor`属性。\n\n2.  __`proto__`属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的`__proto__`属性所指向的那个对象（父对象）里找，一直找，直到`__proto__`属性的终点null，再往上找就相当于在null上取值，会报错。通过`__proto__`属性将对象连接起来的这条链路即我们所谓的原型链。\n\n3.  `prototype`属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即`f1.__proto__ === Foo.prototype`。\n\n4.  `constructor`属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向`Function`。\n\n![整体的联系](https://upload-images.jianshu.io/upload_images/13931286-5467dbdb42fd91ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n## 基础知识\n\n`__proto__`翻译为**原型**，多个`__proto__`串连起来的叫做**原型链**。\n\n`prototype`翻译为**原型对象**。\n\n## Object.getPrototypeOf()\n\n`Object.getPrototypeOf()` 方法返回指定对象的原型（内部`[[Prototype]]`属性的值）。\n\n### 示例\n```\nconst prototype1 = {};\nconst object1 = Object.create(prototype1);\n\nconsole.log(Object.getPrototypeOf(object1) === prototype1);\n// expected output: true\nObject.getPrototypeOf(object1) === object1.__proto__\n```\n\n## 正式开始\n\n```\nfunction Foo() {...};\nlet f1 = new Foo();\n```\n\n以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：**函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。**\n\n## `__proto__`属性\n\n首先要记住两点：\n\n1.  `__proto__`和`constructor`是对象才有的属性，在JavaScript中函数也是一种对象。\n\n2.  `prototype`是函数才有的属性。\n\n![__proto__](https://upload-images.jianshu.io/upload_images/13931286-9355e730b53d1879?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n这里我们仅留下 `__proto__` 属性，它是对象所独有的，可以看到`__proto__`属性都是由**一个对象指向一个对象**，即指向它们构造函数的**原型对象**（也可以理解为父对象），那么这个属性的作用是什么呢？它的**作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的`__proto__`属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的`__proto__`属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点）**，由以上这种通过`__proto__`属性来连接对象直到null的一条链即为我们所谓的原型链。    其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠`__proto__`继承而来的。\n\n## `prototype`属性\n\n![prototype属性](https://upload-images.jianshu.io/upload_images/13931286-a68d7e7851adf580?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n`prototype`属性是函数独有的。他是从一个函数指向一个对象，他的含义是函数的原型对象\n\n`f1.__proto__ === Foo.prototype`，它们两个完全一样。那prototype属性的作用又是什么呢？**它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。**任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。\n\n## constructor属性\n\n![constructor属性](https://upload-images.jianshu.io/upload_images/13931286-8de481f4fbc04fee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n`constructor`属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合`__proto__`属性查看会更清楚点，如下图所示），从上图中可以看出`Function`这个对象比较特殊，它的构造函数就是它自己（因为`Function`可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由`Function`构造函数得来，所以`constructor`属性的终点就是`Function`这个函数。\n\n`函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身`\n\n## 完~\n\n","slug":"原型与原型链与constructor","published":1,"updated":"2021-10-13T08:45:46.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18ab000pcco9eyj40fqc","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"原型与原型链与constructor\"><a href=\"#原型与原型链与constructor\" class=\"headerlink\" title=\"原型与原型链与constructor\"></a>原型与原型链与constructor</h1><p>本文参考自：<a href=\"https://blog.csdn.net/cc18868876837/article/details/81211729\">https://blog.csdn.net/cc18868876837/article/details/81211729</a></p>\n<h2 id=\"先来个总结：\"><a href=\"#先来个总结：\" class=\"headerlink\" title=\"先来个总结：\"></a>先来个总结：</h2><ol>\n<li><p> 我们需要牢记两点：①<code>__proto__</code>和<code>constructor</code>属性是对象所独有的；② <code>prototype</code>属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性。</p>\n</li>\n<li><p> __<code>proto__</code>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（父对象）里找，一直找，直到<code>__proto__</code>属性的终点null，再往上找就相当于在null上取值，会报错。通过<code>__proto__</code>属性将对象连接起来的这条链路即我们所谓的原型链。</p>\n</li>\n<li><p> <code>prototype</code>属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即<code>f1.__proto__ === Foo.prototype</code>。</p>\n</li>\n<li><p> <code>constructor</code>属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向<code>Function</code>。</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-5467dbdb42fd91ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"整体的联系\"> </p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p><code>__proto__</code>翻译为<strong>原型</strong>，多个<code>__proto__</code>串连起来的叫做<strong>原型链</strong>。</p>\n<p><code>prototype</code>翻译为<strong>原型对象</strong>。</p>\n<h2 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf()\"></a>Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf()</code> 方法返回指定对象的原型（内部<code>[[Prototype]]</code>属性的值）。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">const prototype1 = &#123;&#125;;<br>const object1 = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>create(prototype1);<br><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>get<span class=\"hljs-constructor\">PrototypeOf(<span class=\"hljs-params\">object1</span>)</span><span class=\"hljs-operator\"> === </span>prototype1);<br><span class=\"hljs-comment\">// expected output: true</span><br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>get<span class=\"hljs-constructor\">PrototypeOf(<span class=\"hljs-params\">object1</span>)</span><span class=\"hljs-operator\"> === </span>object1.__proto__<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"正式开始\"><a href=\"#正式开始\" class=\"headerlink\" title=\"正式开始\"></a>正式开始</h2><figure class=\"highlight nim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nim\">function <span class=\"hljs-type\">Foo</span>() <span class=\"hljs-meta\">&#123;...&#125;</span>;<br><span class=\"hljs-keyword\">let</span> f1 = new <span class=\"hljs-type\">Foo</span>();<br></code></pre></td></tr></table></figure>\n\n<p>以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：<strong>函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。</strong></p>\n<h2 id=\"proto-属性\"><a href=\"#proto-属性\" class=\"headerlink\" title=\"__proto__属性\"></a><code>__proto__</code>属性</h2><p>首先要记住两点：</p>\n<ol>\n<li><p> <code>__proto__</code>和<code>constructor</code>是对象才有的属性，在JavaScript中函数也是一种对象。</p>\n</li>\n<li><p> <code>prototype</code>是函数才有的属性。</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-9355e730b53d1879?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"__proto__\"> </p>\n<p>这里我们仅留下 <code>__proto__</code> 属性，它是对象所独有的，可以看到<code>__proto__</code>属性都是由<strong>一个对象指向一个对象</strong>，即指向它们构造函数的<strong>原型对象</strong>（也可以理解为父对象），那么这个属性的作用是什么呢？它的<strong>作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的<code>__proto__</code>属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点）</strong>，由以上这种通过<code>__proto__</code>属性来连接对象直到null的一条链即为我们所谓的原型链。    其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠<code>__proto__</code>继承而来的。</p>\n<h2 id=\"prototype属性\"><a href=\"#prototype属性\" class=\"headerlink\" title=\"prototype属性\"></a><code>prototype</code>属性</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-a68d7e7851adf580?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"prototype属性\"> </p>\n<p><code>prototype</code>属性是函数独有的。他是从一个函数指向一个对象，他的含义是函数的原型对象</p>\n<p><code>f1.__proto__ === Foo.prototype</code>，它们两个完全一样。那prototype属性的作用又是什么呢？<strong>它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。</strong>任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。</p>\n<h2 id=\"constructor属性\"><a href=\"#constructor属性\" class=\"headerlink\" title=\"constructor属性\"></a>constructor属性</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-8de481f4fbc04fee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"constructor属性\"> </p>\n<p><code>constructor</code>属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合<code>__proto__</code>属性查看会更清楚点，如下图所示），从上图中可以看出<code>Function</code>这个对象比较特殊，它的构造函数就是它自己（因为<code>Function</code>可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由<code>Function</code>构造函数得来，所以<code>constructor</code>属性的终点就是<code>Function</code>这个函数。</p>\n<p><code>函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身</code></p>\n<h2 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完~\"></a>完~</h2>","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"原型与原型链与constructor\"><a href=\"#原型与原型链与constructor\" class=\"headerlink\" title=\"原型与原型链与constructor\"></a>原型与原型链与constructor</h1><p>本文参考自：<a href=\"https://blog.csdn.net/cc18868876837/article/details/81211729\">https://blog.csdn.net/cc18868876837/article/details/81211729</a></p>\n<h2 id=\"先来个总结：\"><a href=\"#先来个总结：\" class=\"headerlink\" title=\"先来个总结：\"></a>先来个总结：</h2><ol>\n<li><p> 我们需要牢记两点：①<code>__proto__</code>和<code>constructor</code>属性是对象所独有的；② <code>prototype</code>属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性。</p>\n</li>\n<li><p> __<code>proto__</code>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（父对象）里找，一直找，直到<code>__proto__</code>属性的终点null，再往上找就相当于在null上取值，会报错。通过<code>__proto__</code>属性将对象连接起来的这条链路即我们所谓的原型链。</p>\n</li>\n<li><p> <code>prototype</code>属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即<code>f1.__proto__ === Foo.prototype</code>。</p>\n</li>\n<li><p> <code>constructor</code>属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向<code>Function</code>。</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-5467dbdb42fd91ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"整体的联系\"> </p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p><code>__proto__</code>翻译为<strong>原型</strong>，多个<code>__proto__</code>串连起来的叫做<strong>原型链</strong>。</p>\n<p><code>prototype</code>翻译为<strong>原型对象</strong>。</p>\n<h2 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf()\"></a>Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf()</code> 方法返回指定对象的原型（内部<code>[[Prototype]]</code>属性的值）。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">const prototype1 = &#123;&#125;;<br>const object1 = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>create(prototype1);<br><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>get<span class=\"hljs-constructor\">PrototypeOf(<span class=\"hljs-params\">object1</span>)</span><span class=\"hljs-operator\"> === </span>prototype1);<br><span class=\"hljs-comment\">// expected output: true</span><br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>get<span class=\"hljs-constructor\">PrototypeOf(<span class=\"hljs-params\">object1</span>)</span><span class=\"hljs-operator\"> === </span>object1.__proto__<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"正式开始\"><a href=\"#正式开始\" class=\"headerlink\" title=\"正式开始\"></a>正式开始</h2><figure class=\"highlight nim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nim\">function <span class=\"hljs-type\">Foo</span>() <span class=\"hljs-meta\">&#123;...&#125;</span>;<br><span class=\"hljs-keyword\">let</span> f1 = new <span class=\"hljs-type\">Foo</span>();<br></code></pre></td></tr></table></figure>\n\n<p>以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：<strong>函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。</strong></p>\n<h2 id=\"proto-属性\"><a href=\"#proto-属性\" class=\"headerlink\" title=\"__proto__属性\"></a><code>__proto__</code>属性</h2><p>首先要记住两点：</p>\n<ol>\n<li><p> <code>__proto__</code>和<code>constructor</code>是对象才有的属性，在JavaScript中函数也是一种对象。</p>\n</li>\n<li><p> <code>prototype</code>是函数才有的属性。</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-9355e730b53d1879?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"__proto__\"> </p>\n<p>这里我们仅留下 <code>__proto__</code> 属性，它是对象所独有的，可以看到<code>__proto__</code>属性都是由<strong>一个对象指向一个对象</strong>，即指向它们构造函数的<strong>原型对象</strong>（也可以理解为父对象），那么这个属性的作用是什么呢？它的<strong>作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的<code>__proto__</code>属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点）</strong>，由以上这种通过<code>__proto__</code>属性来连接对象直到null的一条链即为我们所谓的原型链。    其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠<code>__proto__</code>继承而来的。</p>\n<h2 id=\"prototype属性\"><a href=\"#prototype属性\" class=\"headerlink\" title=\"prototype属性\"></a><code>prototype</code>属性</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-a68d7e7851adf580?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"prototype属性\"> </p>\n<p><code>prototype</code>属性是函数独有的。他是从一个函数指向一个对象，他的含义是函数的原型对象</p>\n<p><code>f1.__proto__ === Foo.prototype</code>，它们两个完全一样。那prototype属性的作用又是什么呢？<strong>它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。</strong>任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。</p>\n<h2 id=\"constructor属性\"><a href=\"#constructor属性\" class=\"headerlink\" title=\"constructor属性\"></a>constructor属性</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-8de481f4fbc04fee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"constructor属性\"> </p>\n<p><code>constructor</code>属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合<code>__proto__</code>属性查看会更清楚点，如下图所示），从上图中可以看出<code>Function</code>这个对象比较特殊，它的构造函数就是它自己（因为<code>Function</code>可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由<code>Function</code>构造函数得来，所以<code>constructor</code>属性的终点就是<code>Function</code>这个函数。</p>\n<p><code>函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身</code></p>\n<h2 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完~\"></a>完~</h2>"},{"title":"栈与队列的理解以及应用场景","date":"2021-09-23T06:00:28.000Z","_content":"# 1.栈\n**栈（stack）**又名堆栈，它是一种运算受限的线性表，**限定仅在表尾进行插入和删除操作的线性表**。\n\n表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈\n\n所以其按照**先进后出**的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用\n\n实现一个栈：\n```js\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n\n  /**\n   * 添加一个（或几个）新元素到栈顶\n   * @param {*} element 新元素\n   */\n  push(element) {\n    this.items.push(element)\n  }\n\n  /**\n   * 移除栈顶的元素，同时返回被移除的元素\n   */\n  pop() {\n    return this.items.pop()\n  }\n\n  /**\n   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）\n   */\n  peek() {\n    return this.items[this.items.length - 1]\n  }\n\n  /**\n   * 如果栈里没有任何元素就返回true,否则返回false\n   */\n  isEmpty() {\n    return this.items.length === 0\n  }\n\n  /**\n   * 移除栈里的所有元素\n   */\n  clear() {\n    this.items = []\n  }\n\n  /**\n   * 返回栈里的元素个数。这个方法和数组的length属性很类似\n   */\n  size() {\n    return this.items.length\n  }\n}\n```\n关于栈的操作主要的方法如下：\n- push：入栈操作\n- pop：出栈操作\n\n# 二.队列\n跟栈十分相似，队列是一种特殊的线性表，特殊之处在于**它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作**。\n\n进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列\n\n在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为**先进先出**\n\n简单实现一个队列，如下：\n```js\nclass Queue {\n    constructor() {\n        this.list = []\n        this.frontIndex = 0\n        this.tailIndex = 0\n    }\n    enqueue(item) {\n        this.list[this.tailIndex++] = item\n    }\n    unqueue() {\n        const item  = this.list[this.frontIndex]\n        this.frontIndex++        \n        return item\n    }\n}\n```\n# 三.应用场景\n## 栈\n借助栈的先进后出的特性，可以简单实现一个逆序输出的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出\n\n包括编译器的在对输入的语法进行分析的时候，例如\"()\"、\"{}\"、\"[]\"这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错\n\n包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值\n\n生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型\n\n## 队列\n当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题\n\n队列的使用广泛应用在广度优先搜索中，例如层次遍历一个二叉树的节点值\n\n生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型\n\n参考文献\n- https://baike.baidu.com/item/%E6%A0%88/12808149\n- https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481\n","source":"_posts/2021-09-23-栈与队列的理解以及应用场景.md","raw":"---\ntitle: 栈与队列的理解以及应用场景\ndate: 2021-09-23 14:00:28\ntags: 计算机基础\ncategories: 计算机基础\n---\n# 1.栈\n**栈（stack）**又名堆栈，它是一种运算受限的线性表，**限定仅在表尾进行插入和删除操作的线性表**。\n\n表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈\n\n所以其按照**先进后出**的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用\n\n实现一个栈：\n```js\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n\n  /**\n   * 添加一个（或几个）新元素到栈顶\n   * @param {*} element 新元素\n   */\n  push(element) {\n    this.items.push(element)\n  }\n\n  /**\n   * 移除栈顶的元素，同时返回被移除的元素\n   */\n  pop() {\n    return this.items.pop()\n  }\n\n  /**\n   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）\n   */\n  peek() {\n    return this.items[this.items.length - 1]\n  }\n\n  /**\n   * 如果栈里没有任何元素就返回true,否则返回false\n   */\n  isEmpty() {\n    return this.items.length === 0\n  }\n\n  /**\n   * 移除栈里的所有元素\n   */\n  clear() {\n    this.items = []\n  }\n\n  /**\n   * 返回栈里的元素个数。这个方法和数组的length属性很类似\n   */\n  size() {\n    return this.items.length\n  }\n}\n```\n关于栈的操作主要的方法如下：\n- push：入栈操作\n- pop：出栈操作\n\n# 二.队列\n跟栈十分相似，队列是一种特殊的线性表，特殊之处在于**它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作**。\n\n进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列\n\n在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为**先进先出**\n\n简单实现一个队列，如下：\n```js\nclass Queue {\n    constructor() {\n        this.list = []\n        this.frontIndex = 0\n        this.tailIndex = 0\n    }\n    enqueue(item) {\n        this.list[this.tailIndex++] = item\n    }\n    unqueue() {\n        const item  = this.list[this.frontIndex]\n        this.frontIndex++        \n        return item\n    }\n}\n```\n# 三.应用场景\n## 栈\n借助栈的先进后出的特性，可以简单实现一个逆序输出的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出\n\n包括编译器的在对输入的语法进行分析的时候，例如\"()\"、\"{}\"、\"[]\"这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错\n\n包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值\n\n生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型\n\n## 队列\n当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题\n\n队列的使用广泛应用在广度优先搜索中，例如层次遍历一个二叉树的节点值\n\n生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型\n\n参考文献\n- https://baike.baidu.com/item/%E6%A0%88/12808149\n- https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481\n","slug":"栈与队列的理解以及应用场景","published":1,"updated":"2021-10-08T03:09:58.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18ad000scco91hty5onj","content":"<h1 id=\"1-栈\"><a href=\"#1-栈\" class=\"headerlink\" title=\"1.栈\"></a>1.栈</h1><p><strong>栈（stack）</strong>又名堆栈，它是一种运算受限的线性表，<strong>限定仅在表尾进行插入和删除操作的线性表</strong>。</p>\n<p>表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈</p>\n<p>所以其按照<strong>先进后出</strong>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用</p>\n<p>实现一个栈：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Stack</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.items = [];<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 添加一个（或几个）新元素到栈顶</span><br><span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;*&#125;</span> </span>element 新元素</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">push</span>(<span class=\"hljs-params\">element</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.items.push(element)<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 移除栈顶的元素，同时返回被移除的元素</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">pop</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items.pop()<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">peek</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items[<span class=\"hljs-built_in\">this</span>.items.length - <span class=\"hljs-number\">1</span>]<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 如果栈里没有任何元素就返回true,否则返回false</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">isEmpty</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items.length === <span class=\"hljs-number\">0</span><br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 移除栈里的所有元素</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">clear</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.items = []<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 返回栈里的元素个数。这个方法和数组的length属性很类似</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">size</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items.length<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>关于栈的操作主要的方法如下：</p>\n<ul>\n<li>push：入栈操作</li>\n<li>pop：出栈操作</li>\n</ul>\n<h1 id=\"二-队列\"><a href=\"#二-队列\" class=\"headerlink\" title=\"二.队列\"></a>二.队列</h1><p>跟栈十分相似，队列是一种特殊的线性表，特殊之处在于<strong>它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</strong>。</p>\n<p>进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列</p>\n<p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为<strong>先进先出</strong></p>\n<p>简单实现一个队列，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Queue</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.list = []<br>        <span class=\"hljs-built_in\">this</span>.frontIndex = <span class=\"hljs-number\">0</span><br>        <span class=\"hljs-built_in\">this</span>.tailIndex = <span class=\"hljs-number\">0</span><br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">enqueue</span>(<span class=\"hljs-params\">item</span>)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.list[<span class=\"hljs-built_in\">this</span>.tailIndex++] = item<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">unqueue</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-keyword\">const</span> item  = <span class=\"hljs-built_in\">this</span>.list[<span class=\"hljs-built_in\">this</span>.frontIndex]<br>        <span class=\"hljs-built_in\">this</span>.frontIndex++        <br>        <span class=\"hljs-keyword\">return</span> item<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"三-应用场景\"><a href=\"#三-应用场景\" class=\"headerlink\" title=\"三.应用场景\"></a>三.应用场景</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>借助栈的先进后出的特性，可以简单实现一个逆序输出的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出</p>\n<p>包括编译器的在对输入的语法进行分析的时候，例如”()”、”{}”、”[]”这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p>\n<p>包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值</p>\n<p>生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题</p>\n<p>队列的使用广泛应用在广度优先搜索中，例如层次遍历一个二叉树的节点值</p>\n<p>生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型</p>\n<p>参考文献</p>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E6%A0%88/12808149\">https://baike.baidu.com/item/%E6%A0%88/12808149</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481\">https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-栈\"><a href=\"#1-栈\" class=\"headerlink\" title=\"1.栈\"></a>1.栈</h1><p><strong>栈（stack）</strong>又名堆栈，它是一种运算受限的线性表，<strong>限定仅在表尾进行插入和删除操作的线性表</strong>。</p>\n<p>表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈</p>\n<p>所以其按照<strong>先进后出</strong>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用</p>\n<p>实现一个栈：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Stack</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.items = [];<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 添加一个（或几个）新元素到栈顶</span><br><span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;*&#125;</span> </span>element 新元素</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">push</span>(<span class=\"hljs-params\">element</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.items.push(element)<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 移除栈顶的元素，同时返回被移除的元素</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">pop</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items.pop()<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">peek</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items[<span class=\"hljs-built_in\">this</span>.items.length - <span class=\"hljs-number\">1</span>]<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 如果栈里没有任何元素就返回true,否则返回false</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">isEmpty</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items.length === <span class=\"hljs-number\">0</span><br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 移除栈里的所有元素</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">clear</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.items = []<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 返回栈里的元素个数。这个方法和数组的length属性很类似</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">size</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items.length<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>关于栈的操作主要的方法如下：</p>\n<ul>\n<li>push：入栈操作</li>\n<li>pop：出栈操作</li>\n</ul>\n<h1 id=\"二-队列\"><a href=\"#二-队列\" class=\"headerlink\" title=\"二.队列\"></a>二.队列</h1><p>跟栈十分相似，队列是一种特殊的线性表，特殊之处在于<strong>它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</strong>。</p>\n<p>进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列</p>\n<p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为<strong>先进先出</strong></p>\n<p>简单实现一个队列，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Queue</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.list = []<br>        <span class=\"hljs-built_in\">this</span>.frontIndex = <span class=\"hljs-number\">0</span><br>        <span class=\"hljs-built_in\">this</span>.tailIndex = <span class=\"hljs-number\">0</span><br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">enqueue</span>(<span class=\"hljs-params\">item</span>)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.list[<span class=\"hljs-built_in\">this</span>.tailIndex++] = item<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">unqueue</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-keyword\">const</span> item  = <span class=\"hljs-built_in\">this</span>.list[<span class=\"hljs-built_in\">this</span>.frontIndex]<br>        <span class=\"hljs-built_in\">this</span>.frontIndex++        <br>        <span class=\"hljs-keyword\">return</span> item<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"三-应用场景\"><a href=\"#三-应用场景\" class=\"headerlink\" title=\"三.应用场景\"></a>三.应用场景</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>借助栈的先进后出的特性，可以简单实现一个逆序输出的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出</p>\n<p>包括编译器的在对输入的语法进行分析的时候，例如”()”、”{}”、”[]”这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p>\n<p>包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值</p>\n<p>生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题</p>\n<p>队列的使用广泛应用在广度优先搜索中，例如层次遍历一个二叉树的节点值</p>\n<p>生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型</p>\n<p>参考文献</p>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E6%A0%88/12808149\">https://baike.baidu.com/item/%E6%A0%88/12808149</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481\">https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481</a></li>\n</ul>\n"},{"title":"Vue3(一)","date":"2021-09-16T09:39:17.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n今天上课内容是 vue 3,共有两节课，一节讲基础，一节讲原理。\n\n以下是课堂笔记：\n\n![上课笔记](https://upload-images.jianshu.io/upload_images/13931286-4c145b32d10b1824.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n![上课笔记](https://upload-images.jianshu.io/upload_images/13931286-3e37e261f17cbf13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n![上课笔记](https://upload-images.jianshu.io/upload_images/13931286-673deca33d797bcb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ","source":"_posts/2021-09-25-Vue3-一.md","raw":"---\ntitle: Vue3(一)\ndate: 2021-09-16 17:39:17\ntags: Vue3\ncategories: 技术类-Vue\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n今天上课内容是 vue 3,共有两节课，一节讲基础，一节讲原理。\n\n以下是课堂笔记：\n\n![上课笔记](https://upload-images.jianshu.io/upload_images/13931286-4c145b32d10b1824.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n![上课笔记](https://upload-images.jianshu.io/upload_images/13931286-3e37e261f17cbf13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n![上课笔记](https://upload-images.jianshu.io/upload_images/13931286-673deca33d797bcb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ","slug":"Vue3-一","published":1,"updated":"2021-09-26T02:16:38.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18ae000vcco9dgjf77md","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p>今天上课内容是 vue 3,共有两节课，一节讲基础，一节讲原理。</p>\n<p>以下是课堂笔记：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-4c145b32d10b1824.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"上课笔记\"> </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-3e37e261f17cbf13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"上课笔记\"> </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-673deca33d797bcb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"上课笔记\"> </p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p>今天上课内容是 vue 3,共有两节课，一节讲基础，一节讲原理。</p>\n<p>以下是课堂笔记：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-4c145b32d10b1824.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"上课笔记\"> </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-3e37e261f17cbf13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"上课笔记\"> </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-673deca33d797bcb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"上课笔记\"> </p>\n"},{"title":"日常-最爱的电影","date":"2021-09-25T10:07:53.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n![第六感海报](https://img9.doubanio.com/view/photo/l/public/p2220184425.webp)\n今天重温了电影《第六感》，一部披着灵异外皮的心灵治愈电影。\n\n有些电影无论第几遍看还是让人感动\n![第六感剧照](https://img2.doubanio.com/view/photo/l/public/p2351243392.webp)\n![第六感剧照](https://img1.doubanio.com/view/photo/l/public/p2356175109.webp)\n","source":"_posts/2021-09-25-浮生一日-最爱的电影.md","raw":"---\ntitle: 日常-最爱的电影\ndate: 2021-09-25 18:07:53\ntags: \n  - [日常]\ncategories: \n  - [日常]\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n![第六感海报](https://img9.doubanio.com/view/photo/l/public/p2220184425.webp)\n今天重温了电影《第六感》，一部披着灵异外皮的心灵治愈电影。\n\n有些电影无论第几遍看还是让人感动\n![第六感剧照](https://img2.doubanio.com/view/photo/l/public/p2351243392.webp)\n![第六感剧照](https://img1.doubanio.com/view/photo/l/public/p2356175109.webp)\n","slug":"浮生一日-最爱的电影","published":1,"updated":"2021-11-18T09:00:36.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18af000zcco9736fedpt","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p><img src=\"https://img9.doubanio.com/view/photo/l/public/p2220184425.webp\" alt=\"第六感海报\"><br>今天重温了电影《第六感》，一部披着灵异外皮的心灵治愈电影。</p>\n<p>有些电影无论第几遍看还是让人感动<br><img src=\"https://img2.doubanio.com/view/photo/l/public/p2351243392.webp\" alt=\"第六感剧照\"><br><img src=\"https://img1.doubanio.com/view/photo/l/public/p2356175109.webp\" alt=\"第六感剧照\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p><img src=\"https://img9.doubanio.com/view/photo/l/public/p2220184425.webp\" alt=\"第六感海报\"><br>今天重温了电影《第六感》，一部披着灵异外皮的心灵治愈电影。</p>\n<p>有些电影无论第几遍看还是让人感动<br><img src=\"https://img2.doubanio.com/view/photo/l/public/p2351243392.webp\" alt=\"第六感剧照\"><br><img src=\"https://img1.doubanio.com/view/photo/l/public/p2356175109.webp\" alt=\"第六感剧照\"></p>\n"},{"title":"leetcode每日算法（2021-09-27）","date":"2021-09-27T03:06:43.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 1.两数之和\n![两数之和](https://upload-images.jianshu.io/upload_images/13931286-470a4c38230853eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 解题\n我首先想到的是暴力解法，就是对数组嵌套循环（时间复杂度是 O(n²)）：\n![我首先想到的方法](https://upload-images.jianshu.io/upload_images/13931286-efa42480453cddb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n肯定有更好的办法\n看到评论区有人说用逆向解法，用target减去数组中的一个数，然后判断得到的结果是否在数组中\n```js\nvar twoSum = function(nums, target) {\n    map = new Map()\n    for(let i = 0; i < nums.length; i++) {\n        x = target - nums[i]\n        if(map.has(x)) {\n            return [map.get(x),i]\n        }\n        map.set(nums[i],i)\n    }\n};\n```\n```js\nvar twoSum = function (nums, target) {\n  let hash = {};\n  for (let i = 0; i < nums.length; i++) {\n    if (hash[target - nums[i]] !== undefined) {\n      return [i, hash[target - nums[i]]];\n    }\n    hash[nums[i]] = i;\n  }\n  return [];\n};\n```\n\n\n","source":"_posts/2021-09-27-leetcode每日算法（2021-09-27）.md","raw":"---\ntitle: leetcode每日算法（2021-09-27）\ndate: 2021-09-27 11:06:43\ntags: [算法,leetcode]\ncategories: 算法类\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 1.两数之和\n![两数之和](https://upload-images.jianshu.io/upload_images/13931286-470a4c38230853eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 解题\n我首先想到的是暴力解法，就是对数组嵌套循环（时间复杂度是 O(n²)）：\n![我首先想到的方法](https://upload-images.jianshu.io/upload_images/13931286-efa42480453cddb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n肯定有更好的办法\n看到评论区有人说用逆向解法，用target减去数组中的一个数，然后判断得到的结果是否在数组中\n```js\nvar twoSum = function(nums, target) {\n    map = new Map()\n    for(let i = 0; i < nums.length; i++) {\n        x = target - nums[i]\n        if(map.has(x)) {\n            return [map.get(x),i]\n        }\n        map.set(nums[i],i)\n    }\n};\n```\n```js\nvar twoSum = function (nums, target) {\n  let hash = {};\n  for (let i = 0; i < nums.length; i++) {\n    if (hash[target - nums[i]] !== undefined) {\n      return [i, hash[target - nums[i]]];\n    }\n    hash[nums[i]] = i;\n  }\n  return [];\n};\n```\n\n\n","slug":"leetcode每日算法（2021-09-27）","published":1,"updated":"2021-09-28T02:24:12.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18ag0012cco98yop5uz3","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1.两数之和\"></a>1.两数之和</h1><p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-470a4c38230853eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"两数之和\"></p>\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><p>我首先想到的是暴力解法，就是对数组嵌套循环（时间复杂度是 O(n²)）：<br><img src=\"https://upload-images.jianshu.io/upload_images/13931286-efa42480453cddb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"我首先想到的方法\"><br>肯定有更好的办法<br>看到评论区有人说用逆向解法，用target减去数组中的一个数，然后判断得到的结果是否在数组中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> twoSum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums, target</span>) </span>&#123;<br>    map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.length; i++) &#123;<br>        x = target - nums[i]<br>        <span class=\"hljs-keyword\">if</span>(map.has(x)) &#123;<br>            <span class=\"hljs-keyword\">return</span> [map.get(x),i]<br>        &#125;<br>        map.set(nums[i],i)<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> twoSum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums, target</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> hash = &#123;&#125;;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class=\"hljs-keyword\">if</span> (hash[target - nums[i]] !== <span class=\"hljs-literal\">undefined</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> [i, hash[target - nums[i]]];<br>    &#125;<br>    hash[nums[i]] = i;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> [];<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1.两数之和\"></a>1.两数之和</h1><p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-470a4c38230853eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"两数之和\"></p>\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><p>我首先想到的是暴力解法，就是对数组嵌套循环（时间复杂度是 O(n²)）：<br><img src=\"https://upload-images.jianshu.io/upload_images/13931286-efa42480453cddb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"我首先想到的方法\"><br>肯定有更好的办法<br>看到评论区有人说用逆向解法，用target减去数组中的一个数，然后判断得到的结果是否在数组中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> twoSum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums, target</span>) </span>&#123;<br>    map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.length; i++) &#123;<br>        x = target - nums[i]<br>        <span class=\"hljs-keyword\">if</span>(map.has(x)) &#123;<br>            <span class=\"hljs-keyword\">return</span> [map.get(x),i]<br>        &#125;<br>        map.set(nums[i],i)<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> twoSum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums, target</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> hash = &#123;&#125;;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class=\"hljs-keyword\">if</span> (hash[target - nums[i]] !== <span class=\"hljs-literal\">undefined</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> [i, hash[target - nums[i]]];<br>    &#125;<br>    hash[nums[i]] = i;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> [];<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n\n"},{"title":"互联网是如何运作的","date":"2021-10-07T03:04:56.000Z","_content":"原文：[互联网是如何运作的](https://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm)\n\n以下是我的总结,更好的学习建议阅读原文。\n# 介绍\n\n互联网所有的传输都通过TCP/IP协议族来传输，TCP/IP是**面向连接**的**可靠**字节流服务协议\n\n# TCP/IP协议栈\n您的计算机已连接到 Internet 并具有唯一的地址。它如何与连接到 Internet 的其他计算机“交谈”？\n\n这里应该有一个例子：假设您的 IP 地址是 1.2.3.4，并且您想向计算机 5.6.7.8 发送一条消息。您要发送的消息是“Hello computer 5.6.7.8!”。显然，消息必须通过将您的计算机连接到 Internet 的任何类型的线路传输。假设您已从家里拨入您的 ISP，并且消息必须通过电话线传输。必须将消息从字母文本翻译成电子信号，通过互联网传输，然后再翻译回字母文本。 这是如何实现的？\n**通过使用协议栈**。每台计算机都需要一台在 Internet 上进行通信，它通常内置于计算机的操作系统（即 Windows、Unix 等）中。由于使用了两种主要的通信协议，Internet 上使用的协议栈被称为 **TCP/IP 协议栈**。TCP/IP 堆栈如下所示：\n- 应用层：提供特定于应用程序的协议  HTTP   FTP   IMAP(邮件)\n- 网络控制层(TCP)：发送数据包到计算机上使用特定的端口号的应用程序\n- 网络层(IP)：使用IP地址将数据包发送到特定的计算\n- 链路层：将二进制数据包与网络信号相互之间转换（例如以太网网卡、电话线调制解调器等）\n\n# HTTP\nHTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中 TCP 层的顶部，并被特定应用程序用于相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。\n\nHTTP是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送对 Web 元素（例如网页和图像）的请求。请求被服务器服务后，客户端和服务器之间通过 Internet 的连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端发出 HTTP 请求之前，必须建立到服务器的新连接。\n\n当您在 Web 浏览器中键入 URL 时，会发生以下情况：\n\n1. 如果 URL 包含域名，则浏览器首先连接到域名服务器并为 Web 服务器检索相应的 IP 地址。\n2. Web 浏览器连接到 Web 服务器并为所需的网页发送 HTTP 请求（通过协议栈）。\n3. Web 服务器接收请求并检查所需页面。如果页面存在，则 Web 服务器发送它。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。（404 的意思是“找不到页面”，任何浏览过网络的人都可能知道。）\n4. Web 浏览器接收回页面并关闭连接。\n4. 然后浏览器解析页面并查找完成网页所需的其他页面元素。这些通常包括图像、小程序等。\n6. 对于每个需要的元素，浏览器会为每个元素向服务器发出额外的连接和 HTTP 请求。\n7. 当浏览器加载完所有图像、小程序等后，页面将完全加载到浏览器窗口中。\n\n# TCP（传输控制协议）\n在协议栈的应用层之下是TCP层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）会沿堆栈向下传递到 TCP 层。**TCP 负责将应用程序协议路由到目标计算机上的正确应用程序。** 为此，使用端口号。端口可以​​被认为是每台计算机上的独立通道。例如，您可以在阅读电子邮件时上网。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上时，TCP 层根据端口号决定哪个应用程序接收数据包。\nTCP 是这样工作的：\n\n- 当 TCP 层从上面接收到应用层协议数据时，它会将其分段为可管理的“块”，然后将带有特定 TCP 信息的 TCP 标头添加到每个“块”。TCP 头中包含的信息包括数据需要发送到的应用程序的端口号。\n- 当 TCP 层接收到来自其下方 IP 层的数据包时，TCP 层会从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。\n\n这就是 TCP 将通过协议栈移动的数据路由到正确应用程序的方式。\n\nTCP 不是文本协议。**TCP 是面向连接的、可靠的字节流服务。**面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于收到的每个数据包，都会向发送方发送确认以确认交付。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。\ntcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功\n\n# IP（互联网协议）\n与 TCP 不同，**IP 是一种不可靠的无连接协议。**IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 IP 的工作也是将数据包发送和路由到其他计算机。IP 数据包是独立的实体，可能无序到达或根本没有到达。TCP 的工作是确保数据包到达并以正确的顺序。IP 与 TCP 的唯一共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据。\n\nIP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP\n\nIp是一种协议  有两种标准  IPv4 2^32次方和IPv6  2^128\n\n# TCP传输的质量和顺序\n\n当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送\n\n#网络传输\n\n1. 个人电脑\n2. 猫（调制解调器）\n3. local ISP   互联网服务提供商\n4. regional ISP   经过多个主干网络\n5. NSP   网络服务提供商  大型网络  卖带宽给ISP\n6. NAP   每个NSP连接到至少三个网络访问点\n7. ISP  NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。\n\n# DNS服务\n\n存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系","source":"_posts/2021-10-08-互联网是如何运作的.md","raw":"---\ntitle: 互联网是如何运作的\ndate: 2021-10-07 11:04:56\ntags: [计算机基础]\ncategories: 计算机基础\n---\n原文：[互联网是如何运作的](https://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm)\n\n以下是我的总结,更好的学习建议阅读原文。\n# 介绍\n\n互联网所有的传输都通过TCP/IP协议族来传输，TCP/IP是**面向连接**的**可靠**字节流服务协议\n\n# TCP/IP协议栈\n您的计算机已连接到 Internet 并具有唯一的地址。它如何与连接到 Internet 的其他计算机“交谈”？\n\n这里应该有一个例子：假设您的 IP 地址是 1.2.3.4，并且您想向计算机 5.6.7.8 发送一条消息。您要发送的消息是“Hello computer 5.6.7.8!”。显然，消息必须通过将您的计算机连接到 Internet 的任何类型的线路传输。假设您已从家里拨入您的 ISP，并且消息必须通过电话线传输。必须将消息从字母文本翻译成电子信号，通过互联网传输，然后再翻译回字母文本。 这是如何实现的？\n**通过使用协议栈**。每台计算机都需要一台在 Internet 上进行通信，它通常内置于计算机的操作系统（即 Windows、Unix 等）中。由于使用了两种主要的通信协议，Internet 上使用的协议栈被称为 **TCP/IP 协议栈**。TCP/IP 堆栈如下所示：\n- 应用层：提供特定于应用程序的协议  HTTP   FTP   IMAP(邮件)\n- 网络控制层(TCP)：发送数据包到计算机上使用特定的端口号的应用程序\n- 网络层(IP)：使用IP地址将数据包发送到特定的计算\n- 链路层：将二进制数据包与网络信号相互之间转换（例如以太网网卡、电话线调制解调器等）\n\n# HTTP\nHTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中 TCP 层的顶部，并被特定应用程序用于相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。\n\nHTTP是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送对 Web 元素（例如网页和图像）的请求。请求被服务器服务后，客户端和服务器之间通过 Internet 的连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端发出 HTTP 请求之前，必须建立到服务器的新连接。\n\n当您在 Web 浏览器中键入 URL 时，会发生以下情况：\n\n1. 如果 URL 包含域名，则浏览器首先连接到域名服务器并为 Web 服务器检索相应的 IP 地址。\n2. Web 浏览器连接到 Web 服务器并为所需的网页发送 HTTP 请求（通过协议栈）。\n3. Web 服务器接收请求并检查所需页面。如果页面存在，则 Web 服务器发送它。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。（404 的意思是“找不到页面”，任何浏览过网络的人都可能知道。）\n4. Web 浏览器接收回页面并关闭连接。\n4. 然后浏览器解析页面并查找完成网页所需的其他页面元素。这些通常包括图像、小程序等。\n6. 对于每个需要的元素，浏览器会为每个元素向服务器发出额外的连接和 HTTP 请求。\n7. 当浏览器加载完所有图像、小程序等后，页面将完全加载到浏览器窗口中。\n\n# TCP（传输控制协议）\n在协议栈的应用层之下是TCP层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）会沿堆栈向下传递到 TCP 层。**TCP 负责将应用程序协议路由到目标计算机上的正确应用程序。** 为此，使用端口号。端口可以​​被认为是每台计算机上的独立通道。例如，您可以在阅读电子邮件时上网。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上时，TCP 层根据端口号决定哪个应用程序接收数据包。\nTCP 是这样工作的：\n\n- 当 TCP 层从上面接收到应用层协议数据时，它会将其分段为可管理的“块”，然后将带有特定 TCP 信息的 TCP 标头添加到每个“块”。TCP 头中包含的信息包括数据需要发送到的应用程序的端口号。\n- 当 TCP 层接收到来自其下方 IP 层的数据包时，TCP 层会从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。\n\n这就是 TCP 将通过协议栈移动的数据路由到正确应用程序的方式。\n\nTCP 不是文本协议。**TCP 是面向连接的、可靠的字节流服务。**面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于收到的每个数据包，都会向发送方发送确认以确认交付。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。\ntcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功\n\n# IP（互联网协议）\n与 TCP 不同，**IP 是一种不可靠的无连接协议。**IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 IP 的工作也是将数据包发送和路由到其他计算机。IP 数据包是独立的实体，可能无序到达或根本没有到达。TCP 的工作是确保数据包到达并以正确的顺序。IP 与 TCP 的唯一共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据。\n\nIP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP\n\nIp是一种协议  有两种标准  IPv4 2^32次方和IPv6  2^128\n\n# TCP传输的质量和顺序\n\n当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送\n\n#网络传输\n\n1. 个人电脑\n2. 猫（调制解调器）\n3. local ISP   互联网服务提供商\n4. regional ISP   经过多个主干网络\n5. NSP   网络服务提供商  大型网络  卖带宽给ISP\n6. NAP   每个NSP连接到至少三个网络访问点\n7. ISP  NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。\n\n# DNS服务\n\n存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系","slug":"互联网是如何运作的","published":1,"updated":"2021-10-13T08:46:52.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18ah0015cco9285bb692","content":"<p>原文：<a href=\"https://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm\">互联网是如何运作的</a></p>\n<p>以下是我的总结,更好的学习建议阅读原文。</p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>互联网所有的传输都通过TCP/IP协议族来传输，TCP/IP是<strong>面向连接</strong>的<strong>可靠</strong>字节流服务协议</p>\n<h1 id=\"TCP-IP协议栈\"><a href=\"#TCP-IP协议栈\" class=\"headerlink\" title=\"TCP/IP协议栈\"></a>TCP/IP协议栈</h1><p>您的计算机已连接到 Internet 并具有唯一的地址。它如何与连接到 Internet 的其他计算机“交谈”？</p>\n<p>这里应该有一个例子：假设您的 IP 地址是 1.2.3.4，并且您想向计算机 5.6.7.8 发送一条消息。您要发送的消息是“Hello computer 5.6.7.8!”。显然，消息必须通过将您的计算机连接到 Internet 的任何类型的线路传输。假设您已从家里拨入您的 ISP，并且消息必须通过电话线传输。必须将消息从字母文本翻译成电子信号，通过互联网传输，然后再翻译回字母文本。 这是如何实现的？<br><strong>通过使用协议栈</strong>。每台计算机都需要一台在 Internet 上进行通信，它通常内置于计算机的操作系统（即 Windows、Unix 等）中。由于使用了两种主要的通信协议，Internet 上使用的协议栈被称为 <strong>TCP/IP 协议栈</strong>。TCP/IP 堆栈如下所示：</p>\n<ul>\n<li>应用层：提供特定于应用程序的协议  HTTP   FTP   IMAP(邮件)</li>\n<li>网络控制层(TCP)：发送数据包到计算机上使用特定的端口号的应用程序</li>\n<li>网络层(IP)：使用IP地址将数据包发送到特定的计算</li>\n<li>链路层：将二进制数据包与网络信号相互之间转换（例如以太网网卡、电话线调制解调器等）</li>\n</ul>\n<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><p>HTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中 TCP 层的顶部，并被特定应用程序用于相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。</p>\n<p>HTTP是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送对 Web 元素（例如网页和图像）的请求。请求被服务器服务后，客户端和服务器之间通过 Internet 的连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端发出 HTTP 请求之前，必须建立到服务器的新连接。</p>\n<p>当您在 Web 浏览器中键入 URL 时，会发生以下情况：</p>\n<ol>\n<li>如果 URL 包含域名，则浏览器首先连接到域名服务器并为 Web 服务器检索相应的 IP 地址。</li>\n<li>Web 浏览器连接到 Web 服务器并为所需的网页发送 HTTP 请求（通过协议栈）。</li>\n<li>Web 服务器接收请求并检查所需页面。如果页面存在，则 Web 服务器发送它。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。（404 的意思是“找不到页面”，任何浏览过网络的人都可能知道。）</li>\n<li>Web 浏览器接收回页面并关闭连接。</li>\n<li>然后浏览器解析页面并查找完成网页所需的其他页面元素。这些通常包括图像、小程序等。</li>\n<li>对于每个需要的元素，浏览器会为每个元素向服务器发出额外的连接和 HTTP 请求。</li>\n<li>当浏览器加载完所有图像、小程序等后，页面将完全加载到浏览器窗口中。</li>\n</ol>\n<h1 id=\"TCP（传输控制协议）\"><a href=\"#TCP（传输控制协议）\" class=\"headerlink\" title=\"TCP（传输控制协议）\"></a>TCP（传输控制协议）</h1><p>在协议栈的应用层之下是TCP层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）会沿堆栈向下传递到 TCP 层。<strong>TCP 负责将应用程序协议路由到目标计算机上的正确应用程序。</strong> 为此，使用端口号。端口可以​​被认为是每台计算机上的独立通道。例如，您可以在阅读电子邮件时上网。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上时，TCP 层根据端口号决定哪个应用程序接收数据包。<br>TCP 是这样工作的：</p>\n<ul>\n<li>当 TCP 层从上面接收到应用层协议数据时，它会将其分段为可管理的“块”，然后将带有特定 TCP 信息的 TCP 标头添加到每个“块”。TCP 头中包含的信息包括数据需要发送到的应用程序的端口号。</li>\n<li>当 TCP 层接收到来自其下方 IP 层的数据包时，TCP 层会从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。</li>\n</ul>\n<p>这就是 TCP 将通过协议栈移动的数据路由到正确应用程序的方式。</p>\n<p>TCP 不是文本协议。<strong>TCP 是面向连接的、可靠的字节流服务。</strong>面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于收到的每个数据包，都会向发送方发送确认以确认交付。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。<br>tcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功</p>\n<h1 id=\"IP（互联网协议）\"><a href=\"#IP（互联网协议）\" class=\"headerlink\" title=\"IP（互联网协议）\"></a>IP（互联网协议）</h1><p>与 TCP 不同，<strong>IP 是一种不可靠的无连接协议。</strong>IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 IP 的工作也是将数据包发送和路由到其他计算机。IP 数据包是独立的实体，可能无序到达或根本没有到达。TCP 的工作是确保数据包到达并以正确的顺序。IP 与 TCP 的唯一共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据。</p>\n<p>IP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP</p>\n<p>Ip是一种协议  有两种标准  IPv4 2^32次方和IPv6  2^128</p>\n<h1 id=\"TCP传输的质量和顺序\"><a href=\"#TCP传输的质量和顺序\" class=\"headerlink\" title=\"TCP传输的质量和顺序\"></a>TCP传输的质量和顺序</h1><p>当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送</p>\n<p>#网络传输</p>\n<ol>\n<li>个人电脑</li>\n<li>猫（调制解调器）</li>\n<li>local ISP   互联网服务提供商</li>\n<li>regional ISP   经过多个主干网络</li>\n<li>NSP   网络服务提供商  大型网络  卖带宽给ISP</li>\n<li>NAP   每个NSP连接到至少三个网络访问点</li>\n<li>ISP  NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。</li>\n</ol>\n<h1 id=\"DNS服务\"><a href=\"#DNS服务\" class=\"headerlink\" title=\"DNS服务\"></a>DNS服务</h1><p>存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系</p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文：<a href=\"https://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm\">互联网是如何运作的</a></p>\n<p>以下是我的总结,更好的学习建议阅读原文。</p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>互联网所有的传输都通过TCP/IP协议族来传输，TCP/IP是<strong>面向连接</strong>的<strong>可靠</strong>字节流服务协议</p>\n<h1 id=\"TCP-IP协议栈\"><a href=\"#TCP-IP协议栈\" class=\"headerlink\" title=\"TCP/IP协议栈\"></a>TCP/IP协议栈</h1><p>您的计算机已连接到 Internet 并具有唯一的地址。它如何与连接到 Internet 的其他计算机“交谈”？</p>\n<p>这里应该有一个例子：假设您的 IP 地址是 1.2.3.4，并且您想向计算机 5.6.7.8 发送一条消息。您要发送的消息是“Hello computer 5.6.7.8!”。显然，消息必须通过将您的计算机连接到 Internet 的任何类型的线路传输。假设您已从家里拨入您的 ISP，并且消息必须通过电话线传输。必须将消息从字母文本翻译成电子信号，通过互联网传输，然后再翻译回字母文本。 这是如何实现的？<br><strong>通过使用协议栈</strong>。每台计算机都需要一台在 Internet 上进行通信，它通常内置于计算机的操作系统（即 Windows、Unix 等）中。由于使用了两种主要的通信协议，Internet 上使用的协议栈被称为 <strong>TCP/IP 协议栈</strong>。TCP/IP 堆栈如下所示：</p>\n<ul>\n<li>应用层：提供特定于应用程序的协议  HTTP   FTP   IMAP(邮件)</li>\n<li>网络控制层(TCP)：发送数据包到计算机上使用特定的端口号的应用程序</li>\n<li>网络层(IP)：使用IP地址将数据包发送到特定的计算</li>\n<li>链路层：将二进制数据包与网络信号相互之间转换（例如以太网网卡、电话线调制解调器等）</li>\n</ul>\n<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><p>HTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中 TCP 层的顶部，并被特定应用程序用于相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。</p>\n<p>HTTP是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送对 Web 元素（例如网页和图像）的请求。请求被服务器服务后，客户端和服务器之间通过 Internet 的连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端发出 HTTP 请求之前，必须建立到服务器的新连接。</p>\n<p>当您在 Web 浏览器中键入 URL 时，会发生以下情况：</p>\n<ol>\n<li>如果 URL 包含域名，则浏览器首先连接到域名服务器并为 Web 服务器检索相应的 IP 地址。</li>\n<li>Web 浏览器连接到 Web 服务器并为所需的网页发送 HTTP 请求（通过协议栈）。</li>\n<li>Web 服务器接收请求并检查所需页面。如果页面存在，则 Web 服务器发送它。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。（404 的意思是“找不到页面”，任何浏览过网络的人都可能知道。）</li>\n<li>Web 浏览器接收回页面并关闭连接。</li>\n<li>然后浏览器解析页面并查找完成网页所需的其他页面元素。这些通常包括图像、小程序等。</li>\n<li>对于每个需要的元素，浏览器会为每个元素向服务器发出额外的连接和 HTTP 请求。</li>\n<li>当浏览器加载完所有图像、小程序等后，页面将完全加载到浏览器窗口中。</li>\n</ol>\n<h1 id=\"TCP（传输控制协议）\"><a href=\"#TCP（传输控制协议）\" class=\"headerlink\" title=\"TCP（传输控制协议）\"></a>TCP（传输控制协议）</h1><p>在协议栈的应用层之下是TCP层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）会沿堆栈向下传递到 TCP 层。<strong>TCP 负责将应用程序协议路由到目标计算机上的正确应用程序。</strong> 为此，使用端口号。端口可以​​被认为是每台计算机上的独立通道。例如，您可以在阅读电子邮件时上网。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上时，TCP 层根据端口号决定哪个应用程序接收数据包。<br>TCP 是这样工作的：</p>\n<ul>\n<li>当 TCP 层从上面接收到应用层协议数据时，它会将其分段为可管理的“块”，然后将带有特定 TCP 信息的 TCP 标头添加到每个“块”。TCP 头中包含的信息包括数据需要发送到的应用程序的端口号。</li>\n<li>当 TCP 层接收到来自其下方 IP 层的数据包时，TCP 层会从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。</li>\n</ul>\n<p>这就是 TCP 将通过协议栈移动的数据路由到正确应用程序的方式。</p>\n<p>TCP 不是文本协议。<strong>TCP 是面向连接的、可靠的字节流服务。</strong>面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于收到的每个数据包，都会向发送方发送确认以确认交付。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。<br>tcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功</p>\n<h1 id=\"IP（互联网协议）\"><a href=\"#IP（互联网协议）\" class=\"headerlink\" title=\"IP（互联网协议）\"></a>IP（互联网协议）</h1><p>与 TCP 不同，<strong>IP 是一种不可靠的无连接协议。</strong>IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 IP 的工作也是将数据包发送和路由到其他计算机。IP 数据包是独立的实体，可能无序到达或根本没有到达。TCP 的工作是确保数据包到达并以正确的顺序。IP 与 TCP 的唯一共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据。</p>\n<p>IP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP</p>\n<p>Ip是一种协议  有两种标准  IPv4 2^32次方和IPv6  2^128</p>\n<h1 id=\"TCP传输的质量和顺序\"><a href=\"#TCP传输的质量和顺序\" class=\"headerlink\" title=\"TCP传输的质量和顺序\"></a>TCP传输的质量和顺序</h1><p>当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送</p>\n<p>#网络传输</p>\n<ol>\n<li>个人电脑</li>\n<li>猫（调制解调器）</li>\n<li>local ISP   互联网服务提供商</li>\n<li>regional ISP   经过多个主干网络</li>\n<li>NSP   网络服务提供商  大型网络  卖带宽给ISP</li>\n<li>NAP   每个NSP连接到至少三个网络访问点</li>\n<li>ISP  NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。</li>\n</ol>\n<h1 id=\"DNS服务\"><a href=\"#DNS服务\" class=\"headerlink\" title=\"DNS服务\"></a>DNS服务</h1><p>存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系</p>\n"},{"title":"深入理解javascript之typeof和instanceof","date":"2021-10-13T08:41:28.000Z","_content":"\n# typeof\n\ntypeof方法**返回一个字符串**，来表示**数据的类型**。\n\n各个数据类型对应typeof的值：\n\n| **数据类型**                       | **Type**                 |\n| ---------------------------------- | ------------------------ |\n| Undefined                          | “undefined”              |\n| Null                               | \"object\"                 |\n| Boolean                            | “boolean”                |\n| Number                             | \"number\"                 |\n| String                             | \"string\"                 |\n| Symbol                             | \"symbol\"                 |\n| 宿主对象(JS环境提供的，比如浏览器) | Implementation-dependent |\n| 函数对象Function                   | \"function\"               |\n| 任何其他对象Object                 | \"object\"                 |\n\n下面是代码示例：\n\n```js\n// Numbers\ntypeof 37 === 'number';\ntypeof 3.14 === 'number';\ntypeof Math.LN2 === 'number';\ntypeof Infinity === 'number';\ntypeof NaN === 'number'; // 尽管NaN是\"Not-A-Number\"的缩写,意思是\"不是一个数字\"\ntypeof Number(1) === 'number'; // 不要这样使用!\n\n// Strings\ntypeof \"\" === 'string';\ntypeof \"bla\" === 'string';\ntypeof (typeof 1) === 'string'; // typeof返回的肯定是一个字符串\ntypeof String(\"abc\") === 'string'; // 不要这样使用!\n\n// Booleans\ntypeof true === 'boolean';\ntypeof false === 'boolean';\ntypeof Boolean(true) === 'boolean'; // 不要这样使用!\n\n// Symbols\ntypeof Symbol() === 'symbol';\ntypeof Symbol('foo') === 'symbol';\ntypeof Symbol.iterator === 'symbol';\n\n// Undefined\ntypeof undefined === 'undefined';\ntypeof blabla === 'undefined'; // 一个未定义的变量,或者一个定义了却未赋初值的变量\n\n// Objects\ntypeof {a:1} === 'object';\n\n// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型\ntypeof [1, 2, 4] === 'object';\n\ntypeof new Date() === 'object';\n\n// 下面的容易令人迷惑，不要这样使用！\ntypeof new Boolean(true) === 'object';\ntypeof new Number(1) ==== 'object';\ntypeof new String(\"abc\") === 'object';\n\n// 函数\ntypeof function(){} === 'function';\ntypeof Math.sin === 'function';\n```\n\n发现typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象hj的typeof返回值都是object\n\n# instanceof\n\ninstanceof运算符可以用来判断某个构造函数的prototype属性**是否存在于另外一个**要检测对象**的原型链上**。\n\n```js\n// 定义构造函数\nfunction C(){} \nfunction D(){} \n\nvar o = new C();\n\n// true，因为 Object.getPrototypeOf(o) === C.prototype\no instanceof C; \n\n// false，因为 D.prototype不在o的原型链上\no instanceof D; \n\no instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回true\nC.prototype instanceof Object // true,同上\n\nC.prototype = {};\nvar o2 = new C();\n\no2 instanceof C; // true\n\no instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.\n\nD.prototype = new C(); // 继承\nvar o3 = new D();\no3 instanceof D; // true\no3 instanceof C; // true\n```\n\n\n","source":"_posts/2021-10-13-深入理解javascript之typeof和instanceof.md","raw":"---\ntitle: 深入理解javascript之typeof和instanceof\ndate: 2021-10-13 16:41:28\ntags: [JavaScript,面试]\ncategories: 技术类-前端\n---\n\n# typeof\n\ntypeof方法**返回一个字符串**，来表示**数据的类型**。\n\n各个数据类型对应typeof的值：\n\n| **数据类型**                       | **Type**                 |\n| ---------------------------------- | ------------------------ |\n| Undefined                          | “undefined”              |\n| Null                               | \"object\"                 |\n| Boolean                            | “boolean”                |\n| Number                             | \"number\"                 |\n| String                             | \"string\"                 |\n| Symbol                             | \"symbol\"                 |\n| 宿主对象(JS环境提供的，比如浏览器) | Implementation-dependent |\n| 函数对象Function                   | \"function\"               |\n| 任何其他对象Object                 | \"object\"                 |\n\n下面是代码示例：\n\n```js\n// Numbers\ntypeof 37 === 'number';\ntypeof 3.14 === 'number';\ntypeof Math.LN2 === 'number';\ntypeof Infinity === 'number';\ntypeof NaN === 'number'; // 尽管NaN是\"Not-A-Number\"的缩写,意思是\"不是一个数字\"\ntypeof Number(1) === 'number'; // 不要这样使用!\n\n// Strings\ntypeof \"\" === 'string';\ntypeof \"bla\" === 'string';\ntypeof (typeof 1) === 'string'; // typeof返回的肯定是一个字符串\ntypeof String(\"abc\") === 'string'; // 不要这样使用!\n\n// Booleans\ntypeof true === 'boolean';\ntypeof false === 'boolean';\ntypeof Boolean(true) === 'boolean'; // 不要这样使用!\n\n// Symbols\ntypeof Symbol() === 'symbol';\ntypeof Symbol('foo') === 'symbol';\ntypeof Symbol.iterator === 'symbol';\n\n// Undefined\ntypeof undefined === 'undefined';\ntypeof blabla === 'undefined'; // 一个未定义的变量,或者一个定义了却未赋初值的变量\n\n// Objects\ntypeof {a:1} === 'object';\n\n// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型\ntypeof [1, 2, 4] === 'object';\n\ntypeof new Date() === 'object';\n\n// 下面的容易令人迷惑，不要这样使用！\ntypeof new Boolean(true) === 'object';\ntypeof new Number(1) ==== 'object';\ntypeof new String(\"abc\") === 'object';\n\n// 函数\ntypeof function(){} === 'function';\ntypeof Math.sin === 'function';\n```\n\n发现typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象hj的typeof返回值都是object\n\n# instanceof\n\ninstanceof运算符可以用来判断某个构造函数的prototype属性**是否存在于另外一个**要检测对象**的原型链上**。\n\n```js\n// 定义构造函数\nfunction C(){} \nfunction D(){} \n\nvar o = new C();\n\n// true，因为 Object.getPrototypeOf(o) === C.prototype\no instanceof C; \n\n// false，因为 D.prototype不在o的原型链上\no instanceof D; \n\no instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回true\nC.prototype instanceof Object // true,同上\n\nC.prototype = {};\nvar o2 = new C();\n\no2 instanceof C; // true\n\no instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.\n\nD.prototype = new C(); // 继承\nvar o3 = new D();\no3 instanceof D; // true\no3 instanceof C; // true\n```\n\n\n","slug":"深入理解javascript之typeof和instanceof","published":1,"updated":"2021-10-13T08:43:13.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18aj001acco91u309k4e","content":"<h1 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h1><p>typeof方法<strong>返回一个字符串</strong>，来表示<strong>数据的类型</strong>。</p>\n<p>各个数据类型对应typeof的值：</p>\n<table>\n<thead>\n<tr>\n<th><strong>数据类型</strong></th>\n<th><strong>Type</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Undefined</td>\n<td>“undefined”</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>“object”</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>“boolean”</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>“number”</td>\n</tr>\n<tr>\n<td>String</td>\n<td>“string”</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>“symbol”</td>\n</tr>\n<tr>\n<td>宿主对象(JS环境提供的，比如浏览器)</td>\n<td>Implementation-dependent</td>\n</tr>\n<tr>\n<td>函数对象Function</td>\n<td>“function”</td>\n</tr>\n<tr>\n<td>任何其他对象Object</td>\n<td>“object”</td>\n</tr>\n</tbody></table>\n<p>下面是代码示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Numbers</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">37</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">3.14</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Math</span>.LN2 === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">Infinity</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">NaN</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>; <span class=\"hljs-comment\">// 尽管NaN是&quot;Not-A-Number&quot;的缩写,意思是&quot;不是一个数字&quot;</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-number\">1</span>) === <span class=\"hljs-string\">&#x27;number&#x27;</span>; <span class=\"hljs-comment\">// 不要这样使用!</span><br><br><span class=\"hljs-comment\">// Strings</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-string\">&quot;&quot;</span> === <span class=\"hljs-string\">&#x27;string&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-string\">&quot;bla&quot;</span> === <span class=\"hljs-string\">&#x27;string&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">1</span>) === <span class=\"hljs-string\">&#x27;string&#x27;</span>; <span class=\"hljs-comment\">// typeof返回的肯定是一个字符串</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>) === <span class=\"hljs-string\">&#x27;string&#x27;</span>; <span class=\"hljs-comment\">// 不要这样使用!</span><br><br><span class=\"hljs-comment\">// Booleans</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">true</span> === <span class=\"hljs-string\">&#x27;boolean&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">false</span> === <span class=\"hljs-string\">&#x27;boolean&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Boolean</span>(<span class=\"hljs-literal\">true</span>) === <span class=\"hljs-string\">&#x27;boolean&#x27;</span>; <span class=\"hljs-comment\">// 不要这样使用!</span><br><br><span class=\"hljs-comment\">// Symbols</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span>() === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>) === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span>.iterator === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>;<br><br><span class=\"hljs-comment\">// Undefined</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">undefined</span> === <span class=\"hljs-string\">&#x27;undefined&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> blabla === <span class=\"hljs-string\">&#x27;undefined&#x27;</span>; <span class=\"hljs-comment\">// 一个未定义的变量,或者一个定义了却未赋初值的变量</span><br><br><span class=\"hljs-comment\">// Objects</span><br><span class=\"hljs-keyword\">typeof</span> &#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>&#125; === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-comment\">// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型</span><br><span class=\"hljs-keyword\">typeof</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>] === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>() === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-comment\">// 下面的容易令人迷惑，不要这样使用！</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Boolean</span>(<span class=\"hljs-literal\">true</span>) === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-number\">1</span>) ==== <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>) === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-comment\">// 函数</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125; === <span class=\"hljs-string\">&#x27;function&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Math</span>.sin === <span class=\"hljs-string\">&#x27;function&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>发现typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象hj的typeof返回值都是object</p>\n<h1 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h1><p>instanceof运算符可以用来判断某个构造函数的prototype属性<strong>是否存在于另外一个</strong>要检测对象<strong>的原型链上</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 定义构造函数</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">C</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125; <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">D</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125; <br><br><span class=\"hljs-keyword\">var</span> o = <span class=\"hljs-keyword\">new</span> C();<br><br><span class=\"hljs-comment\">// true，因为 Object.getPrototypeOf(o) === C.prototype</span><br>o <span class=\"hljs-keyword\">instanceof</span> C; <br><br><span class=\"hljs-comment\">// false，因为 D.prototype不在o的原型链上</span><br>o <span class=\"hljs-keyword\">instanceof</span> D; <br><br>o <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Object</span>; <span class=\"hljs-comment\">// true,因为Object.prototype.isPrototypeOf(o)返回true</span><br>C.prototype <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Object</span> <span class=\"hljs-comment\">// true,同上</span><br><br>C.prototype = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> o2 = <span class=\"hljs-keyword\">new</span> C();<br><br>o2 <span class=\"hljs-keyword\">instanceof</span> C; <span class=\"hljs-comment\">// true</span><br><br>o <span class=\"hljs-keyword\">instanceof</span> C; <span class=\"hljs-comment\">// false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.</span><br><br>D.prototype = <span class=\"hljs-keyword\">new</span> C(); <span class=\"hljs-comment\">// 继承</span><br><span class=\"hljs-keyword\">var</span> o3 = <span class=\"hljs-keyword\">new</span> D();<br>o3 <span class=\"hljs-keyword\">instanceof</span> D; <span class=\"hljs-comment\">// true</span><br>o3 <span class=\"hljs-keyword\">instanceof</span> C; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h1><p>typeof方法<strong>返回一个字符串</strong>，来表示<strong>数据的类型</strong>。</p>\n<p>各个数据类型对应typeof的值：</p>\n<table>\n<thead>\n<tr>\n<th><strong>数据类型</strong></th>\n<th><strong>Type</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Undefined</td>\n<td>“undefined”</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>“object”</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>“boolean”</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>“number”</td>\n</tr>\n<tr>\n<td>String</td>\n<td>“string”</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>“symbol”</td>\n</tr>\n<tr>\n<td>宿主对象(JS环境提供的，比如浏览器)</td>\n<td>Implementation-dependent</td>\n</tr>\n<tr>\n<td>函数对象Function</td>\n<td>“function”</td>\n</tr>\n<tr>\n<td>任何其他对象Object</td>\n<td>“object”</td>\n</tr>\n</tbody></table>\n<p>下面是代码示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Numbers</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">37</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">3.14</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Math</span>.LN2 === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">Infinity</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">NaN</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>; <span class=\"hljs-comment\">// 尽管NaN是&quot;Not-A-Number&quot;的缩写,意思是&quot;不是一个数字&quot;</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-number\">1</span>) === <span class=\"hljs-string\">&#x27;number&#x27;</span>; <span class=\"hljs-comment\">// 不要这样使用!</span><br><br><span class=\"hljs-comment\">// Strings</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-string\">&quot;&quot;</span> === <span class=\"hljs-string\">&#x27;string&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-string\">&quot;bla&quot;</span> === <span class=\"hljs-string\">&#x27;string&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">1</span>) === <span class=\"hljs-string\">&#x27;string&#x27;</span>; <span class=\"hljs-comment\">// typeof返回的肯定是一个字符串</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>) === <span class=\"hljs-string\">&#x27;string&#x27;</span>; <span class=\"hljs-comment\">// 不要这样使用!</span><br><br><span class=\"hljs-comment\">// Booleans</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">true</span> === <span class=\"hljs-string\">&#x27;boolean&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">false</span> === <span class=\"hljs-string\">&#x27;boolean&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Boolean</span>(<span class=\"hljs-literal\">true</span>) === <span class=\"hljs-string\">&#x27;boolean&#x27;</span>; <span class=\"hljs-comment\">// 不要这样使用!</span><br><br><span class=\"hljs-comment\">// Symbols</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span>() === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>) === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span>.iterator === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>;<br><br><span class=\"hljs-comment\">// Undefined</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">undefined</span> === <span class=\"hljs-string\">&#x27;undefined&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> blabla === <span class=\"hljs-string\">&#x27;undefined&#x27;</span>; <span class=\"hljs-comment\">// 一个未定义的变量,或者一个定义了却未赋初值的变量</span><br><br><span class=\"hljs-comment\">// Objects</span><br><span class=\"hljs-keyword\">typeof</span> &#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>&#125; === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-comment\">// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型</span><br><span class=\"hljs-keyword\">typeof</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>] === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>() === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-comment\">// 下面的容易令人迷惑，不要这样使用！</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Boolean</span>(<span class=\"hljs-literal\">true</span>) === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-number\">1</span>) ==== <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>) === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-comment\">// 函数</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125; === <span class=\"hljs-string\">&#x27;function&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Math</span>.sin === <span class=\"hljs-string\">&#x27;function&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>发现typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象hj的typeof返回值都是object</p>\n<h1 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h1><p>instanceof运算符可以用来判断某个构造函数的prototype属性<strong>是否存在于另外一个</strong>要检测对象<strong>的原型链上</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 定义构造函数</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">C</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125; <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">D</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125; <br><br><span class=\"hljs-keyword\">var</span> o = <span class=\"hljs-keyword\">new</span> C();<br><br><span class=\"hljs-comment\">// true，因为 Object.getPrototypeOf(o) === C.prototype</span><br>o <span class=\"hljs-keyword\">instanceof</span> C; <br><br><span class=\"hljs-comment\">// false，因为 D.prototype不在o的原型链上</span><br>o <span class=\"hljs-keyword\">instanceof</span> D; <br><br>o <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Object</span>; <span class=\"hljs-comment\">// true,因为Object.prototype.isPrototypeOf(o)返回true</span><br>C.prototype <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Object</span> <span class=\"hljs-comment\">// true,同上</span><br><br>C.prototype = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> o2 = <span class=\"hljs-keyword\">new</span> C();<br><br>o2 <span class=\"hljs-keyword\">instanceof</span> C; <span class=\"hljs-comment\">// true</span><br><br>o <span class=\"hljs-keyword\">instanceof</span> C; <span class=\"hljs-comment\">// false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.</span><br><br>D.prototype = <span class=\"hljs-keyword\">new</span> C(); <span class=\"hljs-comment\">// 继承</span><br><span class=\"hljs-keyword\">var</span> o3 = <span class=\"hljs-keyword\">new</span> D();<br>o3 <span class=\"hljs-keyword\">instanceof</span> D; <span class=\"hljs-comment\">// true</span><br>o3 <span class=\"hljs-keyword\">instanceof</span> C; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n"},{"title":"JavaScript事件循环","date":"2021-10-14T03:17:45.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n这一篇讲的也特别清楚，建议看看：[这一次，彻底弄懂 JavaScript 执行机制](https://juejin.cn/post/6844903512845860872)\n\n## 一、是什么\n\n`JavaScript` 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事\n\n为什么要这么设计，跟`JavaScript`的应用场景有关\n\n`JavaScript` 初期作为一门浏览器脚本语言，通常用于操作 `DOM` ，如果是多线程，一个线程进行了删除 `DOM` ，另一个添加 `DOM`，此时浏览器该如何处理？\n\n为了解决单线程运行阻塞问题，`JavaScript`用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）\n\n#### 事件循环（Event Loop）\n\n在`JavaScript`中，所有的任务都可以分为\n\n- 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行\n- 异步任务：异步执行的任务，比如`ajax`网络请求，`setTimeout`定时函数等\n\n同步任务与异步任务的运行流程图如下：\n\n![image](https://upload-images.jianshu.io/upload_images/13931286-a4cefb0d8aa74774?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环\n\n## 二、宏任务与微任务\n\n如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：\n\n```\nconsole.log(1)\n\nsetTimeout(()=>{\n    console.log(2)\n}, 0)\n\nnew Promise((resolve, reject)=>{\n    console.log('new Promise')\n    resolve()\n}).then(()=>{\n    console.log('then')\n})\n\nconsole.log(3)\n```\n\n如果按照上面流程图来分析代码，我们会得到下面的执行步骤：\n\n- `console.log(1)`，同步任务，主线程中执行\n- `setTimeout()` ，异步任务，放到 `Event Table`，0 毫秒后`console.log(2)`回调推入 `Event Queue` 中\n- `new Promise` ，同步任务，主线程直接执行\n- `.then` ，异步任务，放到 `Event Table`\n- `console.log(3)`，同步任务，主线程执行\n\n所以按照分析，它的结果应该是 `1` => `'new Promise'` => `3` => `2` => `'then'`\n\n但是实际结果是：`1`=>`'new Promise'`=> `3` => `'then'` => `2`\n\n出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取\n\n例子中 `setTimeout`回调事件是先进入队列中的，按理说应该先于 `.then` 中的执行，但是结果却偏偏相反\n\n原因在于异步任务还可以细分为微任务与宏任务\n\n### 微任务\n\n一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前\n\n常见的微任务有：\n\n- Promise.then\n- MutaionObserver\n- Object.observe（已废弃；Proxy 对象替代）\n- process.nextTick（Node.js）\n\n### 宏任务\n\n宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合\n\n常见的宏任务有：\n\n- script (可以理解为外层同步代码)\n- setTimeout/setInterval\n- UI rendering/UI事件\n- postMessage、MessageChannel\n- setImmediate、I/O（Node.js）\n\n这时候，事件循环，宏任务，微任务的关系如图所示\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibSNwS2EBDtHnxMysjAib2yvIh75NUHZic4J4n5mPSe5jcMcWtsO0LuhRDuqdHVWicqejmPAI8NLLjuKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n按照这个流程，它的执行机制是：\n\n- 执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中\n- 当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完\n\n回到上面的题目\n\n```\nconsole.log(1)\nsetTimeout(()=>{\n    console.log(2)\n}, 0)\nnew Promise((resolve, reject)=>{\n    console.log('new Promise')\n    resolve()\n}).then(()=>{\n    console.log('then')\n})\nconsole.log(3)\n```\n\n流程如下\n\n```\n// 遇到 console.log(1) ，直接打印 1\n// 遇到定时器，属于新的宏任务，留着后面执行\n// 遇到 new Promise，这个是直接执行的，打印 'new Promise'\n// .then 属于微任务，放入微任务队列，后面再执行\n// 遇到 console.log(3) 直接打印 3\n// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 'then'\n// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2\n```\n\n## 三、async与await\n\n`async` 是异步的意思，`await`则可以理解为等待\n\n放到一起可以理解`async`就是用来声明一个异步方法，而 `await`是用来等待异步方法执行\n\n### async\n\n`async`函数返回一个`promise`对象，下面两种方法是等效的\n\n```\nfunction f() {\n    return Promise.resolve('TEST');\n}\n\n// asyncF is equivalent to f!\nasync function asyncF() {\n    return 'TEST';\n}\n```\n\n### await\n\n正常情况下，`await`命令后面是一个 `Promise`对象，返回该对象的结果。如果不是 `Promise`对象，就直接返回对应的值\n\n```\nasync function f(){\n    // 等同于\n    // return 123\n    return await 123\n}\nf().then(v => console.log(v)) // 123\n```\n\n不管`await`后面跟着的是什么，`await`都会阻塞后面的代码\n\n```\nasync function fn1 (){\n    console.log(1)\n    await fn2()\n    console.log(2) // 阻塞\n}\n\nasync function fn2 (){\n    console.log('fn2')\n}\n\nfn1()\nconsole.log(3)\n```\n\n上面的例子中，`await` 会阻塞下面的代码（即加入微任务队列），先执行 `async`外面的同步代码，同步代码执行完，再回到 `async` 函数中，再执行之前阻塞的代码\n\n所以上述输出结果为：`1`，`fn2`，`3`，`2`\n\n## 四、流程分析\n\n通过对上面的了解，我们对`JavaScript`对各种场景的执行顺序有了大致的了解\n\n这里直接上代码：\n\n```\nasync function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\nasync function async2() {\n    console.log('async2')\n}\nconsole.log('script start')\nsetTimeout(function () {\n    console.log('settimeout')\n})\nasync1()\nnew Promise(function (resolve) {\n    console.log('promise1')\n    resolve()\n}).then(function () {\n    console.log('promise2')\n})\nconsole.log('script end')\n```\n\n分析过程：\n\n1. 执行整段代码，遇到 `console.log('script start')` 直接打印结果，输出 `script start`\n2. 遇到定时器了，它是宏任务，先放着不执行\n3. 遇到 `async1()`，执行 `async1` 函数，先打印 `async1 start`，下面遇到`await`怎么办？先执行 `async2`，打印 `async2`，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码\n4. 跳到 `new Promise` 这里，直接执行，打印 `promise1`，下面遇到 `.then()`，它是微任务，放到微任务列表等待执行\n5. 最后一行直接打印 `script end`，现在同步代码执行完了，开始执行微任务，即 `await`下面的代码，打印 `async1 end`\n6. 继续执行下一个微任务，即执行 `then` 的回调，打印 `promise2`\n7. 上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 `settimeout`\n\n所以最后的结果是：`script start`、`async1 start`、`async2`、`promise1`、`script end`、`async1 end`、`promise2`、`settimeout`","source":"_posts/2021-10-14-JavaScript事件循环.md","raw":"---\ntitle: JavaScript事件循环\ndate: 2021-10-14 11:17:45\ntags: [JavaScript,面试]\ncategories: 技术类-前端\n---\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n这一篇讲的也特别清楚，建议看看：[这一次，彻底弄懂 JavaScript 执行机制](https://juejin.cn/post/6844903512845860872)\n\n## 一、是什么\n\n`JavaScript` 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事\n\n为什么要这么设计，跟`JavaScript`的应用场景有关\n\n`JavaScript` 初期作为一门浏览器脚本语言，通常用于操作 `DOM` ，如果是多线程，一个线程进行了删除 `DOM` ，另一个添加 `DOM`，此时浏览器该如何处理？\n\n为了解决单线程运行阻塞问题，`JavaScript`用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）\n\n#### 事件循环（Event Loop）\n\n在`JavaScript`中，所有的任务都可以分为\n\n- 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行\n- 异步任务：异步执行的任务，比如`ajax`网络请求，`setTimeout`定时函数等\n\n同步任务与异步任务的运行流程图如下：\n\n![image](https://upload-images.jianshu.io/upload_images/13931286-a4cefb0d8aa74774?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环\n\n## 二、宏任务与微任务\n\n如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：\n\n```\nconsole.log(1)\n\nsetTimeout(()=>{\n    console.log(2)\n}, 0)\n\nnew Promise((resolve, reject)=>{\n    console.log('new Promise')\n    resolve()\n}).then(()=>{\n    console.log('then')\n})\n\nconsole.log(3)\n```\n\n如果按照上面流程图来分析代码，我们会得到下面的执行步骤：\n\n- `console.log(1)`，同步任务，主线程中执行\n- `setTimeout()` ，异步任务，放到 `Event Table`，0 毫秒后`console.log(2)`回调推入 `Event Queue` 中\n- `new Promise` ，同步任务，主线程直接执行\n- `.then` ，异步任务，放到 `Event Table`\n- `console.log(3)`，同步任务，主线程执行\n\n所以按照分析，它的结果应该是 `1` => `'new Promise'` => `3` => `2` => `'then'`\n\n但是实际结果是：`1`=>`'new Promise'`=> `3` => `'then'` => `2`\n\n出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取\n\n例子中 `setTimeout`回调事件是先进入队列中的，按理说应该先于 `.then` 中的执行，但是结果却偏偏相反\n\n原因在于异步任务还可以细分为微任务与宏任务\n\n### 微任务\n\n一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前\n\n常见的微任务有：\n\n- Promise.then\n- MutaionObserver\n- Object.observe（已废弃；Proxy 对象替代）\n- process.nextTick（Node.js）\n\n### 宏任务\n\n宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合\n\n常见的宏任务有：\n\n- script (可以理解为外层同步代码)\n- setTimeout/setInterval\n- UI rendering/UI事件\n- postMessage、MessageChannel\n- setImmediate、I/O（Node.js）\n\n这时候，事件循环，宏任务，微任务的关系如图所示\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibSNwS2EBDtHnxMysjAib2yvIh75NUHZic4J4n5mPSe5jcMcWtsO0LuhRDuqdHVWicqejmPAI8NLLjuKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n按照这个流程，它的执行机制是：\n\n- 执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中\n- 当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完\n\n回到上面的题目\n\n```\nconsole.log(1)\nsetTimeout(()=>{\n    console.log(2)\n}, 0)\nnew Promise((resolve, reject)=>{\n    console.log('new Promise')\n    resolve()\n}).then(()=>{\n    console.log('then')\n})\nconsole.log(3)\n```\n\n流程如下\n\n```\n// 遇到 console.log(1) ，直接打印 1\n// 遇到定时器，属于新的宏任务，留着后面执行\n// 遇到 new Promise，这个是直接执行的，打印 'new Promise'\n// .then 属于微任务，放入微任务队列，后面再执行\n// 遇到 console.log(3) 直接打印 3\n// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 'then'\n// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2\n```\n\n## 三、async与await\n\n`async` 是异步的意思，`await`则可以理解为等待\n\n放到一起可以理解`async`就是用来声明一个异步方法，而 `await`是用来等待异步方法执行\n\n### async\n\n`async`函数返回一个`promise`对象，下面两种方法是等效的\n\n```\nfunction f() {\n    return Promise.resolve('TEST');\n}\n\n// asyncF is equivalent to f!\nasync function asyncF() {\n    return 'TEST';\n}\n```\n\n### await\n\n正常情况下，`await`命令后面是一个 `Promise`对象，返回该对象的结果。如果不是 `Promise`对象，就直接返回对应的值\n\n```\nasync function f(){\n    // 等同于\n    // return 123\n    return await 123\n}\nf().then(v => console.log(v)) // 123\n```\n\n不管`await`后面跟着的是什么，`await`都会阻塞后面的代码\n\n```\nasync function fn1 (){\n    console.log(1)\n    await fn2()\n    console.log(2) // 阻塞\n}\n\nasync function fn2 (){\n    console.log('fn2')\n}\n\nfn1()\nconsole.log(3)\n```\n\n上面的例子中，`await` 会阻塞下面的代码（即加入微任务队列），先执行 `async`外面的同步代码，同步代码执行完，再回到 `async` 函数中，再执行之前阻塞的代码\n\n所以上述输出结果为：`1`，`fn2`，`3`，`2`\n\n## 四、流程分析\n\n通过对上面的了解，我们对`JavaScript`对各种场景的执行顺序有了大致的了解\n\n这里直接上代码：\n\n```\nasync function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\nasync function async2() {\n    console.log('async2')\n}\nconsole.log('script start')\nsetTimeout(function () {\n    console.log('settimeout')\n})\nasync1()\nnew Promise(function (resolve) {\n    console.log('promise1')\n    resolve()\n}).then(function () {\n    console.log('promise2')\n})\nconsole.log('script end')\n```\n\n分析过程：\n\n1. 执行整段代码，遇到 `console.log('script start')` 直接打印结果，输出 `script start`\n2. 遇到定时器了，它是宏任务，先放着不执行\n3. 遇到 `async1()`，执行 `async1` 函数，先打印 `async1 start`，下面遇到`await`怎么办？先执行 `async2`，打印 `async2`，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码\n4. 跳到 `new Promise` 这里，直接执行，打印 `promise1`，下面遇到 `.then()`，它是微任务，放到微任务列表等待执行\n5. 最后一行直接打印 `script end`，现在同步代码执行完了，开始执行微任务，即 `await`下面的代码，打印 `async1 end`\n6. 继续执行下一个微任务，即执行 `then` 的回调，打印 `promise2`\n7. 上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 `settimeout`\n\n所以最后的结果是：`script start`、`async1 start`、`async2`、`promise1`、`script end`、`async1 end`、`promise2`、`settimeout`","slug":"JavaScript事件循环","published":1,"updated":"2021-10-14T03:51:19.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18aj001bcco9dpi92cl1","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p>这一篇讲的也特别清楚，建议看看：<a href=\"https://juejin.cn/post/6844903512845860872\">这一次，彻底弄懂 JavaScript 执行机制</a></p>\n<h2 id=\"一、是什么\"><a href=\"#一、是什么\" class=\"headerlink\" title=\"一、是什么\"></a>一、是什么</h2><p><code>JavaScript</code> 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事</p>\n<p>为什么要这么设计，跟<code>JavaScript</code>的应用场景有关</p>\n<p><code>JavaScript</code> 初期作为一门浏览器脚本语言，通常用于操作 <code>DOM</code> ，如果是多线程，一个线程进行了删除 <code>DOM</code> ，另一个添加 <code>DOM</code>，此时浏览器该如何处理？</p>\n<p>为了解决单线程运行阻塞问题，<code>JavaScript</code>用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）</p>\n<h4 id=\"事件循环（Event-Loop）\"><a href=\"#事件循环（Event-Loop）\" class=\"headerlink\" title=\"事件循环（Event Loop）\"></a>事件循环（Event Loop）</h4><p>在<code>JavaScript</code>中，所有的任务都可以分为</p>\n<ul>\n<li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</li>\n<li>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等</li>\n</ul>\n<p>同步任务与异步任务的运行流程图如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-a4cefb0d8aa74774?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环</p>\n<h2 id=\"二、宏任务与微任务\"><a href=\"#二、宏任务与微任务\" class=\"headerlink\" title=\"二、宏任务与微任务\"></a>二、宏任务与微任务</h2><p>如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)<br><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>)<br>&#125;, <span class=\"hljs-number\">0</span>)<br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(resolve, reject)</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;new Promise&#x27;</span>)<br>    resolve()<br>&#125;).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;then&#x27;</span>)<br>&#125;)<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<p>如果按照上面流程图来分析代码，我们会得到下面的执行步骤：</p>\n<ul>\n<li><code>console.log(1)</code>，同步任务，主线程中执行</li>\n<li><code>setTimeout()</code> ，异步任务，放到 <code>Event Table</code>，0 毫秒后<code>console.log(2)</code>回调推入 <code>Event Queue</code> 中</li>\n<li><code>new Promise</code> ，同步任务，主线程直接执行</li>\n<li><code>.then</code> ，异步任务，放到 <code>Event Table</code></li>\n<li><code>console.log(3)</code>，同步任务，主线程执行</li>\n</ul>\n<p>所以按照分析，它的结果应该是 <code>1</code> =&gt; <code>&#39;new Promise&#39;</code> =&gt; <code>3</code> =&gt; <code>2</code> =&gt; <code>&#39;then&#39;</code></p>\n<p>但是实际结果是：<code>1</code>=&gt;<code>&#39;new Promise&#39;</code>=&gt; <code>3</code> =&gt; <code>&#39;then&#39;</code> =&gt; <code>2</code></p>\n<p>出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取</p>\n<p>例子中 <code>setTimeout</code>回调事件是先进入队列中的，按理说应该先于 <code>.then</code> 中的执行，但是结果却偏偏相反</p>\n<p>原因在于异步任务还可以细分为微任务与宏任务</p>\n<h3 id=\"微任务\"><a href=\"#微任务\" class=\"headerlink\" title=\"微任务\"></a>微任务</h3><p>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p>\n<p>常见的微任务有：</p>\n<ul>\n<li>Promise.then</li>\n<li>MutaionObserver</li>\n<li>Object.observe（已废弃；Proxy 对象替代）</li>\n<li>process.nextTick（Node.js）</li>\n</ul>\n<h3 id=\"宏任务\"><a href=\"#宏任务\" class=\"headerlink\" title=\"宏任务\"></a>宏任务</h3><p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p>\n<p>常见的宏任务有：</p>\n<ul>\n<li>script (可以理解为外层同步代码)</li>\n<li>setTimeout/setInterval</li>\n<li>UI rendering/UI事件</li>\n<li>postMessage、MessageChannel</li>\n<li>setImmediate、I/O（Node.js）</li>\n</ul>\n<p>这时候，事件循环，宏任务，微任务的关系如图所示</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibSNwS2EBDtHnxMysjAib2yvIh75NUHZic4J4n5mPSe5jcMcWtsO0LuhRDuqdHVWicqejmPAI8NLLjuKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>按照这个流程，它的执行机制是：</p>\n<ul>\n<li>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中</li>\n<li>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</li>\n</ul>\n<p>回到上面的题目</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>)<br>&#125;, <span class=\"hljs-number\">0</span>)<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(resolve, reject)</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;new Promise&#x27;</span>)<br>    resolve()<br>&#125;).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;then&#x27;</span>)<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<p>流程如下</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 遇到 console.log(<span class=\"hljs-number\">1</span>) ，直接打印 <span class=\"hljs-number\">1</span><br><span class=\"hljs-regexp\">//</span> 遇到定时器，属于新的宏任务，留着后面执行<br><span class=\"hljs-regexp\">//</span> 遇到 new Promise，这个是直接执行的，打印 <span class=\"hljs-string\">&#x27;new Promise&#x27;</span><br><span class=\"hljs-regexp\">//</span> .then 属于微任务，放入微任务队列，后面再执行<br><span class=\"hljs-regexp\">//</span> 遇到 console.log(<span class=\"hljs-number\">3</span>) 直接打印 <span class=\"hljs-number\">3</span><br><span class=\"hljs-regexp\">//</span> 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 <span class=\"hljs-string\">&#x27;then&#x27;</span><br><span class=\"hljs-regexp\">//</span> 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、async与await\"><a href=\"#三、async与await\" class=\"headerlink\" title=\"三、async与await\"></a>三、async与await</h2><p><code>async</code> 是异步的意思，<code>await</code>则可以理解为等待</p>\n<p>放到一起可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await</code>是用来等待异步方法执行</p>\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p><code>async</code>函数返回一个<code>promise</code>对象，下面两种方法是等效的</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">Promise.resolve(&#x27;TEST&#x27;)</span>;<br>&#125;<br><br>// asyncF <span class=\"hljs-keyword\">is</span> equivalent to f!<br>async <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncF</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">&#x27;TEST&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await\"></a>await</h3><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code>对象，返回该对象的结果。如果不是 <code>Promise</code>对象，就直接返回对应的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-comment\">// 等同于</span><br>    <span class=\"hljs-comment\">// return 123</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-number\">123</span><br>&#125;<br>f().then(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(v)) <span class=\"hljs-comment\">// 123</span><br></code></pre></td></tr></table></figure>\n\n<p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span> (<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">await</span> fn2()<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 阻塞</span><br>&#125;<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn2</span> (<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;fn2&#x27;</span>)<br>&#125;<br><br>fn1()<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async</code>外面的同步代码，同步代码执行完，再回到 <code>async</code> 函数中，再执行之前阻塞的代码</p>\n<p>所以上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p>\n<h2 id=\"四、流程分析\"><a href=\"#四、流程分析\" class=\"headerlink\" title=\"四、流程分析\"></a>四、流程分析</h2><p>通过对上面的了解，我们对<code>JavaScript</code>对各种场景的执行顺序有了大致的了解</p>\n<p>这里直接上代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">async1</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;async1 start&#x27;</span>)<br>    <span class=\"hljs-keyword\">await</span> async2()<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">async2</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;async2&#x27;</span>)<br>&#125;<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script start&#x27;</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;settimeout&#x27;</span>)<br>&#125;)<br>async1()<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise1&#x27;</span>)<br>    resolve()<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>分析过程：</p>\n<ol>\n<li>执行整段代码，遇到 <code>console.log(&#39;script start&#39;)</code> 直接打印结果，输出 <code>script start</code></li>\n<li>遇到定时器了，它是宏任务，先放着不执行</li>\n<li>遇到 <code>async1()</code>，执行 <code>async1</code> 函数，先打印 <code>async1 start</code>，下面遇到<code>await</code>怎么办？先执行 <code>async2</code>，打印 <code>async2</code>，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码</li>\n<li>跳到 <code>new Promise</code> 这里，直接执行，打印 <code>promise1</code>，下面遇到 <code>.then()</code>，它是微任务，放到微任务列表等待执行</li>\n<li>最后一行直接打印 <code>script end</code>，现在同步代码执行完了，开始执行微任务，即 <code>await</code>下面的代码，打印 <code>async1 end</code></li>\n<li>继续执行下一个微任务，即执行 <code>then</code> 的回调，打印 <code>promise2</code></li>\n<li>上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 <code>settimeout</code></li>\n</ol>\n<p>所以最后的结果是：<code>script start</code>、<code>async1 start</code>、<code>async2</code>、<code>promise1</code>、<code>script end</code>、<code>async1 end</code>、<code>promise2</code>、<code>settimeout</code></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p>这一篇讲的也特别清楚，建议看看：<a href=\"https://juejin.cn/post/6844903512845860872\">这一次，彻底弄懂 JavaScript 执行机制</a></p>\n<h2 id=\"一、是什么\"><a href=\"#一、是什么\" class=\"headerlink\" title=\"一、是什么\"></a>一、是什么</h2><p><code>JavaScript</code> 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事</p>\n<p>为什么要这么设计，跟<code>JavaScript</code>的应用场景有关</p>\n<p><code>JavaScript</code> 初期作为一门浏览器脚本语言，通常用于操作 <code>DOM</code> ，如果是多线程，一个线程进行了删除 <code>DOM</code> ，另一个添加 <code>DOM</code>，此时浏览器该如何处理？</p>\n<p>为了解决单线程运行阻塞问题，<code>JavaScript</code>用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）</p>\n<h4 id=\"事件循环（Event-Loop）\"><a href=\"#事件循环（Event-Loop）\" class=\"headerlink\" title=\"事件循环（Event Loop）\"></a>事件循环（Event Loop）</h4><p>在<code>JavaScript</code>中，所有的任务都可以分为</p>\n<ul>\n<li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</li>\n<li>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等</li>\n</ul>\n<p>同步任务与异步任务的运行流程图如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-a4cefb0d8aa74774?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环</p>\n<h2 id=\"二、宏任务与微任务\"><a href=\"#二、宏任务与微任务\" class=\"headerlink\" title=\"二、宏任务与微任务\"></a>二、宏任务与微任务</h2><p>如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)<br><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>)<br>&#125;, <span class=\"hljs-number\">0</span>)<br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(resolve, reject)</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;new Promise&#x27;</span>)<br>    resolve()<br>&#125;).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;then&#x27;</span>)<br>&#125;)<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<p>如果按照上面流程图来分析代码，我们会得到下面的执行步骤：</p>\n<ul>\n<li><code>console.log(1)</code>，同步任务，主线程中执行</li>\n<li><code>setTimeout()</code> ，异步任务，放到 <code>Event Table</code>，0 毫秒后<code>console.log(2)</code>回调推入 <code>Event Queue</code> 中</li>\n<li><code>new Promise</code> ，同步任务，主线程直接执行</li>\n<li><code>.then</code> ，异步任务，放到 <code>Event Table</code></li>\n<li><code>console.log(3)</code>，同步任务，主线程执行</li>\n</ul>\n<p>所以按照分析，它的结果应该是 <code>1</code> =&gt; <code>&#39;new Promise&#39;</code> =&gt; <code>3</code> =&gt; <code>2</code> =&gt; <code>&#39;then&#39;</code></p>\n<p>但是实际结果是：<code>1</code>=&gt;<code>&#39;new Promise&#39;</code>=&gt; <code>3</code> =&gt; <code>&#39;then&#39;</code> =&gt; <code>2</code></p>\n<p>出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取</p>\n<p>例子中 <code>setTimeout</code>回调事件是先进入队列中的，按理说应该先于 <code>.then</code> 中的执行，但是结果却偏偏相反</p>\n<p>原因在于异步任务还可以细分为微任务与宏任务</p>\n<h3 id=\"微任务\"><a href=\"#微任务\" class=\"headerlink\" title=\"微任务\"></a>微任务</h3><p>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p>\n<p>常见的微任务有：</p>\n<ul>\n<li>Promise.then</li>\n<li>MutaionObserver</li>\n<li>Object.observe（已废弃；Proxy 对象替代）</li>\n<li>process.nextTick（Node.js）</li>\n</ul>\n<h3 id=\"宏任务\"><a href=\"#宏任务\" class=\"headerlink\" title=\"宏任务\"></a>宏任务</h3><p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p>\n<p>常见的宏任务有：</p>\n<ul>\n<li>script (可以理解为外层同步代码)</li>\n<li>setTimeout/setInterval</li>\n<li>UI rendering/UI事件</li>\n<li>postMessage、MessageChannel</li>\n<li>setImmediate、I/O（Node.js）</li>\n</ul>\n<p>这时候，事件循环，宏任务，微任务的关系如图所示</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibSNwS2EBDtHnxMysjAib2yvIh75NUHZic4J4n5mPSe5jcMcWtsO0LuhRDuqdHVWicqejmPAI8NLLjuKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>按照这个流程，它的执行机制是：</p>\n<ul>\n<li>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中</li>\n<li>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</li>\n</ul>\n<p>回到上面的题目</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>)<br>&#125;, <span class=\"hljs-number\">0</span>)<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(resolve, reject)</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;new Promise&#x27;</span>)<br>    resolve()<br>&#125;).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;then&#x27;</span>)<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<p>流程如下</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 遇到 console.log(<span class=\"hljs-number\">1</span>) ，直接打印 <span class=\"hljs-number\">1</span><br><span class=\"hljs-regexp\">//</span> 遇到定时器，属于新的宏任务，留着后面执行<br><span class=\"hljs-regexp\">//</span> 遇到 new Promise，这个是直接执行的，打印 <span class=\"hljs-string\">&#x27;new Promise&#x27;</span><br><span class=\"hljs-regexp\">//</span> .then 属于微任务，放入微任务队列，后面再执行<br><span class=\"hljs-regexp\">//</span> 遇到 console.log(<span class=\"hljs-number\">3</span>) 直接打印 <span class=\"hljs-number\">3</span><br><span class=\"hljs-regexp\">//</span> 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 <span class=\"hljs-string\">&#x27;then&#x27;</span><br><span class=\"hljs-regexp\">//</span> 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、async与await\"><a href=\"#三、async与await\" class=\"headerlink\" title=\"三、async与await\"></a>三、async与await</h2><p><code>async</code> 是异步的意思，<code>await</code>则可以理解为等待</p>\n<p>放到一起可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await</code>是用来等待异步方法执行</p>\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p><code>async</code>函数返回一个<code>promise</code>对象，下面两种方法是等效的</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">Promise.resolve(&#x27;TEST&#x27;)</span>;<br>&#125;<br><br>// asyncF <span class=\"hljs-keyword\">is</span> equivalent to f!<br>async <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncF</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">&#x27;TEST&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await\"></a>await</h3><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code>对象，返回该对象的结果。如果不是 <code>Promise</code>对象，就直接返回对应的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-comment\">// 等同于</span><br>    <span class=\"hljs-comment\">// return 123</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-number\">123</span><br>&#125;<br>f().then(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(v)) <span class=\"hljs-comment\">// 123</span><br></code></pre></td></tr></table></figure>\n\n<p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span> (<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">await</span> fn2()<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 阻塞</span><br>&#125;<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn2</span> (<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;fn2&#x27;</span>)<br>&#125;<br><br>fn1()<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async</code>外面的同步代码，同步代码执行完，再回到 <code>async</code> 函数中，再执行之前阻塞的代码</p>\n<p>所以上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p>\n<h2 id=\"四、流程分析\"><a href=\"#四、流程分析\" class=\"headerlink\" title=\"四、流程分析\"></a>四、流程分析</h2><p>通过对上面的了解，我们对<code>JavaScript</code>对各种场景的执行顺序有了大致的了解</p>\n<p>这里直接上代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">async1</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;async1 start&#x27;</span>)<br>    <span class=\"hljs-keyword\">await</span> async2()<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">async2</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;async2&#x27;</span>)<br>&#125;<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script start&#x27;</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;settimeout&#x27;</span>)<br>&#125;)<br>async1()<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise1&#x27;</span>)<br>    resolve()<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>分析过程：</p>\n<ol>\n<li>执行整段代码，遇到 <code>console.log(&#39;script start&#39;)</code> 直接打印结果，输出 <code>script start</code></li>\n<li>遇到定时器了，它是宏任务，先放着不执行</li>\n<li>遇到 <code>async1()</code>，执行 <code>async1</code> 函数，先打印 <code>async1 start</code>，下面遇到<code>await</code>怎么办？先执行 <code>async2</code>，打印 <code>async2</code>，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码</li>\n<li>跳到 <code>new Promise</code> 这里，直接执行，打印 <code>promise1</code>，下面遇到 <code>.then()</code>，它是微任务，放到微任务列表等待执行</li>\n<li>最后一行直接打印 <code>script end</code>，现在同步代码执行完了，开始执行微任务，即 <code>await</code>下面的代码，打印 <code>async1 end</code></li>\n<li>继续执行下一个微任务，即执行 <code>then</code> 的回调，打印 <code>promise2</code></li>\n<li>上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 <code>settimeout</code></li>\n</ol>\n<p>所以最后的结果是：<code>script start</code>、<code>async1 start</code>、<code>async2</code>、<code>promise1</code>、<code>script end</code>、<code>async1 end</code>、<code>promise2</code>、<code>settimeout</code></p>\n"},{"title":"Array数组的一些发现","date":"2021-10-20T05:49:22.000Z","_content":"今天对一些元素都是纯数字的数组做`forEach`遍历操作，发现无法改变原数组，查找了一些资料发现，`forEach`只能处理数组中的引用类型，元素为基础类型的需要另外的写法。如下：\n```js\nlet arr = [1, 2, 3, 4, 5]\nlet arr1 = [1, 2, 3, 4, 5]\nlet arr2 = [{a:1,b:2}]\n\n// 元素为基础类型number，原数组不变\narr.forEach(item => {\n    item += 1\n})\n\n// 这种写法可行\narr1.forEach((item, index) => {\n    arr1[index] += 1\n})\n\n// 元素为引用类型的，原数组会改变\narr2.forEach(item=>{\n    item.a = 66\n})\nconsole.log(arr);\nconsole.log(arr1);\nconsole.log(arr2);\n```\n\n这主要是和计算机的堆栈有关。基础类型是存储在栈中，`forEach`中得到item也是存储于栈中，所以它就和数组中的元素毫无关系了；而对象是存储于堆中，遍历的时候item虽然在栈中但是它的指针会指向堆中的位置，所以可以直接修改原数组。\n","source":"_posts/2021-10-20-Array数组的一些发现.md","raw":"---\ntitle: Array数组的一些发现\ndate: 2021-10-20 13:49:22\ntags: [JavaScript]\ncategories: 技术类-前端\n---\n今天对一些元素都是纯数字的数组做`forEach`遍历操作，发现无法改变原数组，查找了一些资料发现，`forEach`只能处理数组中的引用类型，元素为基础类型的需要另外的写法。如下：\n```js\nlet arr = [1, 2, 3, 4, 5]\nlet arr1 = [1, 2, 3, 4, 5]\nlet arr2 = [{a:1,b:2}]\n\n// 元素为基础类型number，原数组不变\narr.forEach(item => {\n    item += 1\n})\n\n// 这种写法可行\narr1.forEach((item, index) => {\n    arr1[index] += 1\n})\n\n// 元素为引用类型的，原数组会改变\narr2.forEach(item=>{\n    item.a = 66\n})\nconsole.log(arr);\nconsole.log(arr1);\nconsole.log(arr2);\n```\n\n这主要是和计算机的堆栈有关。基础类型是存储在栈中，`forEach`中得到item也是存储于栈中，所以它就和数组中的元素毫无关系了；而对象是存储于堆中，遍历的时候item虽然在栈中但是它的指针会指向堆中的位置，所以可以直接修改原数组。\n","slug":"Array数组的一些发现","published":1,"updated":"2021-10-20T06:13:41.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18al001fcco9ctoihqv3","content":"<p>今天对一些元素都是纯数字的数组做<code>forEach</code>遍历操作，发现无法改变原数组，查找了一些资料发现，<code>forEach</code>只能处理数组中的引用类型，元素为基础类型的需要另外的写法。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> arr2 = [&#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-attr\">b</span>:<span class=\"hljs-number\">2</span>&#125;]<br><br><span class=\"hljs-comment\">// 元素为基础类型number，原数组不变</span><br>arr.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> &#123;<br>    item += <span class=\"hljs-number\">1</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 这种写法可行</span><br>arr1.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, index</span>) =&gt;</span> &#123;<br>    arr1[index] += <span class=\"hljs-number\">1</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 元素为引用类型的，原数组会改变</span><br>arr2.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>=&gt;</span>&#123;<br>    item.a = <span class=\"hljs-number\">66</span><br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(arr);<br><span class=\"hljs-built_in\">console</span>.log(arr1);<br><span class=\"hljs-built_in\">console</span>.log(arr2);<br></code></pre></td></tr></table></figure>\n\n<p>这主要是和计算机的堆栈有关。基础类型是存储在栈中，<code>forEach</code>中得到item也是存储于栈中，所以它就和数组中的元素毫无关系了；而对象是存储于堆中，遍历的时候item虽然在栈中但是它的指针会指向堆中的位置，所以可以直接修改原数组。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天对一些元素都是纯数字的数组做<code>forEach</code>遍历操作，发现无法改变原数组，查找了一些资料发现，<code>forEach</code>只能处理数组中的引用类型，元素为基础类型的需要另外的写法。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> arr2 = [&#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-attr\">b</span>:<span class=\"hljs-number\">2</span>&#125;]<br><br><span class=\"hljs-comment\">// 元素为基础类型number，原数组不变</span><br>arr.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> &#123;<br>    item += <span class=\"hljs-number\">1</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 这种写法可行</span><br>arr1.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, index</span>) =&gt;</span> &#123;<br>    arr1[index] += <span class=\"hljs-number\">1</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 元素为引用类型的，原数组会改变</span><br>arr2.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>=&gt;</span>&#123;<br>    item.a = <span class=\"hljs-number\">66</span><br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(arr);<br><span class=\"hljs-built_in\">console</span>.log(arr1);<br><span class=\"hljs-built_in\">console</span>.log(arr2);<br></code></pre></td></tr></table></figure>\n\n<p>这主要是和计算机的堆栈有关。基础类型是存储在栈中，<code>forEach</code>中得到item也是存储于栈中，所以它就和数组中的元素毫无关系了；而对象是存储于堆中，遍历的时候item虽然在栈中但是它的指针会指向堆中的位置，所以可以直接修改原数组。</p>\n"},{"title":"call,apply和bind","date":"2021-10-21T03:18:44.000Z","_content":"`call`，`apply`和`bind`都是用来改变this的指向，但是他们在使用和功能上各有区别。\n# call() 方法\n## call() 方法的作用\ncall() 方法的作用：可以**调用**一个函数，与此同时，它还可以改变这个函数内部的 this 指向。\n\ncall() 方法的另一个应用：**可以实现继承**。之所以能实现继承，其实是利用了上面的作用。\n\n## 语法\n```js\nfn1.call(想要将this指向哪里, 函数实参1, 函数实参2);\n```\n备注：第一个参数中，如果不需要改变 this 指向，则传 null。\n\n## call() 方法举例\n举例 1、通过 call() 调用函数：\n```js\nconst obj1 = {\n    nickName: '走花鹿',\n    age: 26,\n};\nfunction fn1() {\n    console.log(this);\n    console.log(this.nickName);\n}\nfn1.call(this); // this的指向并没有被改变，此时相当于 fn1();\n```\n上方代码的打印结果：\n```js\nwindow\nundefined\n```\n上面的代码，跟普通的函数调用 `fn1()` 没有区别。\n\n举例 2、通过 call() 改变 this 指向：\n```js\nvar obj1 = {\n    nickName: '走花鹿',\n    age: 26,\n};\n\nfunction fn1(a, b) {\n    console.log(this);\n    console.log(this.nickName);\n    console.log(a + b);\n}\n\nfn1.call(obj1, 2, 4); // 先将 this 指向 obj1，然后执行 fn1() 函数\n```\n上方代码的打印结果：\n```js\nobj1\n走花鹿\n6\n```\n举例 3、通过 call() 实现继承：\n```js\n// 给 Father 增加 name 和 age 属性\nfunction Father(myName, myAge) {\n    this.name = myName;\n    this.age = myAge;\n}\n\nfunction Son(myName, myAge) {\n    // 【下面这一行，重要代码】\n    // 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承\n    Father.call(this, myName, myAge);\n}\n\nconst son1 = new Son('走花鹿', 26);\nconsole.log(JSON.stringify(son1));\n```\n上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。\n\n打印结果：\n```\n{\"myName\":\"走花鹿\",\"myAge\":26}\n```\n# apply() 方法\n## apply() 方法的作用\napply() 方法的作用：可以**调用**一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。\n\napply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。\n\n## 语法\n```js\nfn1.apply(想要将this指向哪里, [函数实参1, 函数实参2]);\n```\n备注：第一个参数中，如果不需要改变 this 指向，则传 null。\n\n到这里可以看出， **call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。**\n\n## apply() 方法举例\n举例、通过 apply() 改变 this 指向：\n```js\nvar obj1 = {\n    nickName: '走花鹿',\n    age: 26,\n};\n\nfunction fn1(a) {\n    console.log(this);\n    console.log(this.nickName);\n    console.log(a);\n}\n\nfn1.apply(obj1, ['hello']); // 先将 this 指向 obj1，然后执行 fn1() 函数\n```\n注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。\n\n打印结果：\n```js\nobj1\n走花鹿\nhello\n```\n## apply() 方法的巧妙应用：求数组的最大值\n我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？\n\n虽然数组里没有获取最大值的方法，但是数值里面有 `Math.max(数字1，数字2，数字3)` 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。\n\n举例：求数组中多个元素的最大值：\n```js\nconst arr1 = [3, 7, 10, 8];\n\n// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。\nconst maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值\nconsole.log(maxValue);\n\nconst minValue = Math.min.apply(Math, arr1); // 求数组 arr1 中元素的最小值\nconsole.log(minValue);\n```\n打印结果：\n```js\n10\n3\n```\n# bind() 方法\n## bind() 方法的作用\nbind() 方法**不会调用函数**，但是可以改变函数内部的 this 指向。\n\n把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。\n\n语法\n```js\n新函数 = fn1.bind(想要将this指向哪里, 函数实参1, 函数实参2);\n```\n参数：\n\n- 第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。\n\n- 其他参数：fn1 函数的实参。\n\n解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。","source":"_posts/2021-10-21-call-apply和bind.md","raw":"---\ntitle: 'call,apply和bind'\ndate: 2021-10-21 11:18:44\ntags: [JavaScript,面试]\ncategories: 技术类-前端\n---\n`call`，`apply`和`bind`都是用来改变this的指向，但是他们在使用和功能上各有区别。\n# call() 方法\n## call() 方法的作用\ncall() 方法的作用：可以**调用**一个函数，与此同时，它还可以改变这个函数内部的 this 指向。\n\ncall() 方法的另一个应用：**可以实现继承**。之所以能实现继承，其实是利用了上面的作用。\n\n## 语法\n```js\nfn1.call(想要将this指向哪里, 函数实参1, 函数实参2);\n```\n备注：第一个参数中，如果不需要改变 this 指向，则传 null。\n\n## call() 方法举例\n举例 1、通过 call() 调用函数：\n```js\nconst obj1 = {\n    nickName: '走花鹿',\n    age: 26,\n};\nfunction fn1() {\n    console.log(this);\n    console.log(this.nickName);\n}\nfn1.call(this); // this的指向并没有被改变，此时相当于 fn1();\n```\n上方代码的打印结果：\n```js\nwindow\nundefined\n```\n上面的代码，跟普通的函数调用 `fn1()` 没有区别。\n\n举例 2、通过 call() 改变 this 指向：\n```js\nvar obj1 = {\n    nickName: '走花鹿',\n    age: 26,\n};\n\nfunction fn1(a, b) {\n    console.log(this);\n    console.log(this.nickName);\n    console.log(a + b);\n}\n\nfn1.call(obj1, 2, 4); // 先将 this 指向 obj1，然后执行 fn1() 函数\n```\n上方代码的打印结果：\n```js\nobj1\n走花鹿\n6\n```\n举例 3、通过 call() 实现继承：\n```js\n// 给 Father 增加 name 和 age 属性\nfunction Father(myName, myAge) {\n    this.name = myName;\n    this.age = myAge;\n}\n\nfunction Son(myName, myAge) {\n    // 【下面这一行，重要代码】\n    // 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承\n    Father.call(this, myName, myAge);\n}\n\nconst son1 = new Son('走花鹿', 26);\nconsole.log(JSON.stringify(son1));\n```\n上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。\n\n打印结果：\n```\n{\"myName\":\"走花鹿\",\"myAge\":26}\n```\n# apply() 方法\n## apply() 方法的作用\napply() 方法的作用：可以**调用**一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。\n\napply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。\n\n## 语法\n```js\nfn1.apply(想要将this指向哪里, [函数实参1, 函数实参2]);\n```\n备注：第一个参数中，如果不需要改变 this 指向，则传 null。\n\n到这里可以看出， **call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。**\n\n## apply() 方法举例\n举例、通过 apply() 改变 this 指向：\n```js\nvar obj1 = {\n    nickName: '走花鹿',\n    age: 26,\n};\n\nfunction fn1(a) {\n    console.log(this);\n    console.log(this.nickName);\n    console.log(a);\n}\n\nfn1.apply(obj1, ['hello']); // 先将 this 指向 obj1，然后执行 fn1() 函数\n```\n注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。\n\n打印结果：\n```js\nobj1\n走花鹿\nhello\n```\n## apply() 方法的巧妙应用：求数组的最大值\n我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？\n\n虽然数组里没有获取最大值的方法，但是数值里面有 `Math.max(数字1，数字2，数字3)` 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。\n\n举例：求数组中多个元素的最大值：\n```js\nconst arr1 = [3, 7, 10, 8];\n\n// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。\nconst maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值\nconsole.log(maxValue);\n\nconst minValue = Math.min.apply(Math, arr1); // 求数组 arr1 中元素的最小值\nconsole.log(minValue);\n```\n打印结果：\n```js\n10\n3\n```\n# bind() 方法\n## bind() 方法的作用\nbind() 方法**不会调用函数**，但是可以改变函数内部的 this 指向。\n\n把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。\n\n语法\n```js\n新函数 = fn1.bind(想要将this指向哪里, 函数实参1, 函数实参2);\n```\n参数：\n\n- 第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。\n\n- 其他参数：fn1 函数的实参。\n\n解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。","slug":"call-apply和bind","published":1,"updated":"2021-10-21T03:37:52.895Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18am001icco9237qf4l5","content":"<p><code>call</code>，<code>apply</code>和<code>bind</code>都是用来改变this的指向，但是他们在使用和功能上各有区别。</p>\n<h1 id=\"call-方法\"><a href=\"#call-方法\" class=\"headerlink\" title=\"call() 方法\"></a>call() 方法</h1><h2 id=\"call-方法的作用\"><a href=\"#call-方法的作用\" class=\"headerlink\" title=\"call() 方法的作用\"></a>call() 方法的作用</h2><p>call() 方法的作用：可以<strong>调用</strong>一个函数，与此同时，它还可以改变这个函数内部的 this 指向。</p>\n<p>call() 方法的另一个应用：<strong>可以实现继承</strong>。之所以能实现继承，其实是利用了上面的作用。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">fn1.call(想要将<span class=\"hljs-built_in\">this</span>指向哪里, 函数实参<span class=\"hljs-number\">1</span>, 函数实参<span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p>备注：第一个参数中，如果不需要改变 this 指向，则传 null。</p>\n<h2 id=\"call-方法举例\"><a href=\"#call-方法举例\" class=\"headerlink\" title=\"call() 方法举例\"></a>call() 方法举例</h2><p>举例 1、通过 call() 调用函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj1 = &#123;<br>    <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.nickName);<br>&#125;<br>fn1.call(<span class=\"hljs-built_in\">this</span>); <span class=\"hljs-comment\">// this的指向并没有被改变，此时相当于 fn1();</span><br></code></pre></td></tr></table></figure>\n<p>上方代码的打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">window</span><br><span class=\"hljs-literal\">undefined</span><br></code></pre></td></tr></table></figure>\n<p>上面的代码，跟普通的函数调用 <code>fn1()</code> 没有区别。</p>\n<p>举例 2、通过 call() 改变 this 指向：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>    <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\">a, b</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.nickName);<br>    <span class=\"hljs-built_in\">console</span>.log(a + b);<br>&#125;<br><br>fn1.call(obj1, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 先将 this 指向 obj1，然后执行 fn1() 函数</span><br></code></pre></td></tr></table></figure>\n<p>上方代码的打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">obj1<br>走花鹿<br><span class=\"hljs-number\">6</span><br></code></pre></td></tr></table></figure>\n<p>举例 3、通过 call() 实现继承：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 给 Father 增加 name 和 age 属性</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Father</span>(<span class=\"hljs-params\">myName, myAge</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.name = myName;<br>    <span class=\"hljs-built_in\">this</span>.age = myAge;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Son</span>(<span class=\"hljs-params\">myName, myAge</span>) </span>&#123;<br>    <span class=\"hljs-comment\">// 【下面这一行，重要代码】</span><br>    <span class=\"hljs-comment\">// 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承</span><br>    Father.call(<span class=\"hljs-built_in\">this</span>, myName, myAge);<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> son1 = <span class=\"hljs-keyword\">new</span> Son(<span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>, <span class=\"hljs-number\">26</span>);<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">JSON</span>.stringify(son1));<br></code></pre></td></tr></table></figure>\n<p>上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。</p>\n<p>打印结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<span class=\"hljs-attr\">&quot;myName&quot;</span>:<span class=\"hljs-string\">&quot;走花鹿&quot;</span>,<span class=\"hljs-attr\">&quot;myAge&quot;</span>:<span class=\"hljs-number\">26</span>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"apply-方法\"><a href=\"#apply-方法\" class=\"headerlink\" title=\"apply() 方法\"></a>apply() 方法</h1><h2 id=\"apply-方法的作用\"><a href=\"#apply-方法的作用\" class=\"headerlink\" title=\"apply() 方法的作用\"></a>apply() 方法的作用</h2><p>apply() 方法的作用：可以<strong>调用</strong>一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。</p>\n<p>apply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。</p>\n<h2 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">fn1.apply(想要将<span class=\"hljs-built_in\">this</span>指向哪里, [函数实参<span class=\"hljs-number\">1</span>, 函数实参<span class=\"hljs-number\">2</span>]);<br></code></pre></td></tr></table></figure>\n<p>备注：第一个参数中，如果不需要改变 this 指向，则传 null。</p>\n<p>到这里可以看出， <strong>call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。</strong></p>\n<h2 id=\"apply-方法举例\"><a href=\"#apply-方法举例\" class=\"headerlink\" title=\"apply() 方法举例\"></a>apply() 方法举例</h2><p>举例、通过 apply() 改变 this 指向：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>    <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\">a</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.nickName);<br>    <span class=\"hljs-built_in\">console</span>.log(a);<br>&#125;<br><br>fn1.apply(obj1, [<span class=\"hljs-string\">&#x27;hello&#x27;</span>]); <span class=\"hljs-comment\">// 先将 this 指向 obj1，然后执行 fn1() 函数</span><br></code></pre></td></tr></table></figure>\n<p>注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。</p>\n<p>打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">obj1<br>走花鹿<br>hello<br></code></pre></td></tr></table></figure>\n<h2 id=\"apply-方法的巧妙应用：求数组的最大值\"><a href=\"#apply-方法的巧妙应用：求数组的最大值\" class=\"headerlink\" title=\"apply() 方法的巧妙应用：求数组的最大值\"></a>apply() 方法的巧妙应用：求数组的最大值</h2><p>我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？</p>\n<p>虽然数组里没有获取最大值的方法，但是数值里面有 <code>Math.max(数字1，数字2，数字3)</code> 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。</p>\n<p>举例：求数组中多个元素的最大值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr1 = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">8</span>];<br><br><span class=\"hljs-comment\">// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。</span><br><span class=\"hljs-keyword\">const</span> maxValue = <span class=\"hljs-built_in\">Math</span>.max.apply(<span class=\"hljs-built_in\">Math</span>, arr1); <span class=\"hljs-comment\">// 求数组 arr1 中元素的最大值</span><br><span class=\"hljs-built_in\">console</span>.log(maxValue);<br><br><span class=\"hljs-keyword\">const</span> minValue = <span class=\"hljs-built_in\">Math</span>.min.apply(<span class=\"hljs-built_in\">Math</span>, arr1); <span class=\"hljs-comment\">// 求数组 arr1 中元素的最小值</span><br><span class=\"hljs-built_in\">console</span>.log(minValue);<br></code></pre></td></tr></table></figure>\n<p>打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-number\">10</span><br><span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind() 方法\"></a>bind() 方法</h1><h2 id=\"bind-方法的作用\"><a href=\"#bind-方法的作用\" class=\"headerlink\" title=\"bind() 方法的作用\"></a>bind() 方法的作用</h2><p>bind() 方法<strong>不会调用函数</strong>，但是可以改变函数内部的 this 指向。</p>\n<p>把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。</p>\n<p>语法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">新函数 = fn1.bind(想要将<span class=\"hljs-built_in\">this</span>指向哪里, 函数实参<span class=\"hljs-number\">1</span>, 函数实参<span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p>参数：</p>\n<ul>\n<li><p>第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。</p>\n</li>\n<li><p>其他参数：fn1 函数的实参。</p>\n</li>\n</ul>\n<p>解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>call</code>，<code>apply</code>和<code>bind</code>都是用来改变this的指向，但是他们在使用和功能上各有区别。</p>\n<h1 id=\"call-方法\"><a href=\"#call-方法\" class=\"headerlink\" title=\"call() 方法\"></a>call() 方法</h1><h2 id=\"call-方法的作用\"><a href=\"#call-方法的作用\" class=\"headerlink\" title=\"call() 方法的作用\"></a>call() 方法的作用</h2><p>call() 方法的作用：可以<strong>调用</strong>一个函数，与此同时，它还可以改变这个函数内部的 this 指向。</p>\n<p>call() 方法的另一个应用：<strong>可以实现继承</strong>。之所以能实现继承，其实是利用了上面的作用。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">fn1.call(想要将<span class=\"hljs-built_in\">this</span>指向哪里, 函数实参<span class=\"hljs-number\">1</span>, 函数实参<span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p>备注：第一个参数中，如果不需要改变 this 指向，则传 null。</p>\n<h2 id=\"call-方法举例\"><a href=\"#call-方法举例\" class=\"headerlink\" title=\"call() 方法举例\"></a>call() 方法举例</h2><p>举例 1、通过 call() 调用函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj1 = &#123;<br>    <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.nickName);<br>&#125;<br>fn1.call(<span class=\"hljs-built_in\">this</span>); <span class=\"hljs-comment\">// this的指向并没有被改变，此时相当于 fn1();</span><br></code></pre></td></tr></table></figure>\n<p>上方代码的打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">window</span><br><span class=\"hljs-literal\">undefined</span><br></code></pre></td></tr></table></figure>\n<p>上面的代码，跟普通的函数调用 <code>fn1()</code> 没有区别。</p>\n<p>举例 2、通过 call() 改变 this 指向：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>    <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\">a, b</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.nickName);<br>    <span class=\"hljs-built_in\">console</span>.log(a + b);<br>&#125;<br><br>fn1.call(obj1, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 先将 this 指向 obj1，然后执行 fn1() 函数</span><br></code></pre></td></tr></table></figure>\n<p>上方代码的打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">obj1<br>走花鹿<br><span class=\"hljs-number\">6</span><br></code></pre></td></tr></table></figure>\n<p>举例 3、通过 call() 实现继承：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 给 Father 增加 name 和 age 属性</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Father</span>(<span class=\"hljs-params\">myName, myAge</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.name = myName;<br>    <span class=\"hljs-built_in\">this</span>.age = myAge;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Son</span>(<span class=\"hljs-params\">myName, myAge</span>) </span>&#123;<br>    <span class=\"hljs-comment\">// 【下面这一行，重要代码】</span><br>    <span class=\"hljs-comment\">// 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承</span><br>    Father.call(<span class=\"hljs-built_in\">this</span>, myName, myAge);<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> son1 = <span class=\"hljs-keyword\">new</span> Son(<span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>, <span class=\"hljs-number\">26</span>);<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">JSON</span>.stringify(son1));<br></code></pre></td></tr></table></figure>\n<p>上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。</p>\n<p>打印结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<span class=\"hljs-attr\">&quot;myName&quot;</span>:<span class=\"hljs-string\">&quot;走花鹿&quot;</span>,<span class=\"hljs-attr\">&quot;myAge&quot;</span>:<span class=\"hljs-number\">26</span>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"apply-方法\"><a href=\"#apply-方法\" class=\"headerlink\" title=\"apply() 方法\"></a>apply() 方法</h1><h2 id=\"apply-方法的作用\"><a href=\"#apply-方法的作用\" class=\"headerlink\" title=\"apply() 方法的作用\"></a>apply() 方法的作用</h2><p>apply() 方法的作用：可以<strong>调用</strong>一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。</p>\n<p>apply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。</p>\n<h2 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">fn1.apply(想要将<span class=\"hljs-built_in\">this</span>指向哪里, [函数实参<span class=\"hljs-number\">1</span>, 函数实参<span class=\"hljs-number\">2</span>]);<br></code></pre></td></tr></table></figure>\n<p>备注：第一个参数中，如果不需要改变 this 指向，则传 null。</p>\n<p>到这里可以看出， <strong>call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。</strong></p>\n<h2 id=\"apply-方法举例\"><a href=\"#apply-方法举例\" class=\"headerlink\" title=\"apply() 方法举例\"></a>apply() 方法举例</h2><p>举例、通过 apply() 改变 this 指向：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>    <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\">a</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.nickName);<br>    <span class=\"hljs-built_in\">console</span>.log(a);<br>&#125;<br><br>fn1.apply(obj1, [<span class=\"hljs-string\">&#x27;hello&#x27;</span>]); <span class=\"hljs-comment\">// 先将 this 指向 obj1，然后执行 fn1() 函数</span><br></code></pre></td></tr></table></figure>\n<p>注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。</p>\n<p>打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">obj1<br>走花鹿<br>hello<br></code></pre></td></tr></table></figure>\n<h2 id=\"apply-方法的巧妙应用：求数组的最大值\"><a href=\"#apply-方法的巧妙应用：求数组的最大值\" class=\"headerlink\" title=\"apply() 方法的巧妙应用：求数组的最大值\"></a>apply() 方法的巧妙应用：求数组的最大值</h2><p>我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？</p>\n<p>虽然数组里没有获取最大值的方法，但是数值里面有 <code>Math.max(数字1，数字2，数字3)</code> 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。</p>\n<p>举例：求数组中多个元素的最大值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr1 = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">8</span>];<br><br><span class=\"hljs-comment\">// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。</span><br><span class=\"hljs-keyword\">const</span> maxValue = <span class=\"hljs-built_in\">Math</span>.max.apply(<span class=\"hljs-built_in\">Math</span>, arr1); <span class=\"hljs-comment\">// 求数组 arr1 中元素的最大值</span><br><span class=\"hljs-built_in\">console</span>.log(maxValue);<br><br><span class=\"hljs-keyword\">const</span> minValue = <span class=\"hljs-built_in\">Math</span>.min.apply(<span class=\"hljs-built_in\">Math</span>, arr1); <span class=\"hljs-comment\">// 求数组 arr1 中元素的最小值</span><br><span class=\"hljs-built_in\">console</span>.log(minValue);<br></code></pre></td></tr></table></figure>\n<p>打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-number\">10</span><br><span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind() 方法\"></a>bind() 方法</h1><h2 id=\"bind-方法的作用\"><a href=\"#bind-方法的作用\" class=\"headerlink\" title=\"bind() 方法的作用\"></a>bind() 方法的作用</h2><p>bind() 方法<strong>不会调用函数</strong>，但是可以改变函数内部的 this 指向。</p>\n<p>把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。</p>\n<p>语法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">新函数 = fn1.bind(想要将<span class=\"hljs-built_in\">this</span>指向哪里, 函数实参<span class=\"hljs-number\">1</span>, 函数实参<span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p>参数：</p>\n<ul>\n<li><p>第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。</p>\n</li>\n<li><p>其他参数：fn1 函数的实参。</p>\n</li>\n</ul>\n<p>解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。</p>\n"},{"title":"Node.js学习记录","date":"2021-10-31T06:26:14.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n## 使用exports从Node.js文件中公开功能\n\n两种方式：\n\n1. 第一种方式是将对象赋值给 module.exports（这是模块系统提供的对象），这会使文件只导出该对象:\n\n    ```js\n        const car = {\n            brand: 'Ford',\n            model: 'Fiesta'\n        }\n\n        module.exports = car\n\n        //在另一个文件中\n\n        const car = require('./car')\n    ```\n\n2. 第二种方式是将要导出的对象添加为 exports 的属性。这种方式可以导出多个对象、函数或数据：\n\n    ```js\n    const car = {\n    brand: 'Ford',\n    model: 'Fiesta'\n    }\n\n    exports.car = car\n    ```\n\n    或者直接\n\n    ```js\n    exports.car = {\n        brand: 'Ford',\n        model: 'Fiesta'\n    }\n    ```\n\n    在另一个文件中，则通过引用导入的属性来使用它：\n\n    ```js\n        const items = require('./items')\n        items.car\n    ```\n\n    或\n\n    ```js\n        const car = require('./items').car\n    ```\n\nmodule.exports 和 export 之间有什么区别？\n\n前者公开了它指向的对象。 后者公开了它指向的对象的属性。\n\n## package.json指南\n\n`package.json` 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 `npm` 和 `yarn` 存储所有已安装软件包的名称和版本的地方。\n\n对于应用程序，`package.json` 文件中的内容没有固定的要求。 唯一的要求是必须遵守 `JSON 格式`，否则，尝试以编程的方式访问其属性的程序则无法读取它。\n\n例子：\n\n```json\n{\n  \"name\": \"test-project\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Vue.js project\",\n  \"main\": \"src/main.js\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\",\n    \"start\": \"npm run dev\",\n    \"unit\": \"jest --config test/unit/jest.conf.js --coverage\",\n    \"test\": \"npm run unit\",\n    \"lint\": \"eslint --ext .js,.vue src test/unit\",\n    \"build\": \"node build/build.js\"\n  },\n  \"dependencies\": {\n    \"vue\": \"^2.5.2\"\n  },\n  \"devDependencies\": {\n    \"autoprefixer\": \"^7.1.2\",\n    \"babel-core\": \"^6.22.1\",\n    \"babel-eslint\": \"^8.2.1\",\n    \"babel-helper-vue-jsx-merge-props\": \"^2.0.3\",\n    \"babel-jest\": \"^21.0.2\",\n    \"babel-loader\": \"^7.1.1\",\n    \"babel-plugin-dynamic-import-node\": \"^1.2.0\",\n    \"babel-plugin-syntax-jsx\": \"^6.18.0\",\n    \"babel-plugin-transform-es2015-modules-commonjs\": \"^6.26.0\",\n    \"babel-plugin-transform-runtime\": \"^6.22.0\",\n    \"babel-plugin-transform-vue-jsx\": \"^3.5.0\",\n    \"babel-preset-env\": \"^1.3.2\",\n    \"babel-preset-stage-2\": \"^6.22.0\",\n    \"chalk\": \"^2.0.1\",\n    \"copy-webpack-plugin\": \"^4.0.1\",\n    \"css-loader\": \"^0.28.0\",\n    \"eslint\": \"^4.15.0\",\n    \"eslint-config-airbnb-base\": \"^11.3.0\",\n    \"eslint-friendly-formatter\": \"^3.0.0\",\n    \"eslint-import-resolver-webpack\": \"^0.8.3\",\n    \"eslint-loader\": \"^1.7.1\",\n    \"eslint-plugin-import\": \"^2.7.0\",\n    \"eslint-plugin-vue\": \"^4.0.0\",\n    \"extract-text-webpack-plugin\": \"^3.0.0\",\n    \"file-loader\": \"^1.1.4\",\n    \"friendly-errors-webpack-plugin\": \"^1.6.1\",\n    \"html-webpack-plugin\": \"^2.30.1\",\n    \"jest\": \"^22.0.4\",\n    \"jest-serializer-vue\": \"^0.3.0\",\n    \"node-notifier\": \"^5.1.2\",\n    \"optimize-css-assets-webpack-plugin\": \"^3.2.0\",\n    \"ora\": \"^1.2.0\",\n    \"portfinder\": \"^1.0.13\",\n    \"postcss-import\": \"^11.0.0\",\n    \"postcss-loader\": \"^2.0.8\",\n    \"postcss-url\": \"^7.2.1\",\n    \"rimraf\": \"^2.6.0\",\n    \"semver\": \"^5.3.0\",\n    \"shelljs\": \"^0.7.6\",\n    \"uglifyjs-webpack-plugin\": \"^1.1.1\",\n    \"url-loader\": \"^0.5.8\",\n    \"vue-jest\": \"^1.0.2\",\n    \"vue-loader\": \"^13.3.0\",\n    \"vue-style-loader\": \"^3.0.1\",\n    \"vue-template-compiler\": \"^2.5.2\",\n    \"webpack\": \"^3.6.0\",\n    \"webpack-bundle-analyzer\": \"^2.9.0\",\n    \"webpack-dev-server\": \"^2.9.1\",\n    \"webpack-merge\": \"^4.1.0\"\n  },\n  \"engines\": {\n    \"node\": \">= 6.0.0\",\n    \"npm\": \">= 3.0.0\"\n  },\n  \"browserslist\": [\"> 1%\", \"last 2 versions\", \"not ie <= 8\"]\n}\n```\n\n这里有很多东西：\n\n- version 表明了当前的版本。\n- name 设置了应用程序/软件包的名称。\n- description 是应用程序/软件包的简短描述。\n- main 设置了应用程序的入口点。\n- private 如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。\n- scripts 定义了一组可以运行的 node 脚本。\n- dependencies 设置了作为依赖安装的 npm 软件包的列表。\n- devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。\n- engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。\n- browserslist 用于告知要支持哪些浏览器（及其版本）。\n以上所有的这些属性都可被 npm 或其他工具使用。\n\n## package-lock.json 文件\n\n该文件旨在跟踪被安装的每个软件包的确切版本，以便产品可以以相同的方式被 100％ 复制（即使软件包的维护者更新了软件包）。\n\n## npm依赖与开发依赖\n\n当使用 `npm install <package-name>` 安装 npm 软件包时，是将其安装为依赖项。\n\n该软件包会被自动地列出在 `package.json` 文件中的 `dependencies` 列表下（在 npm 5 之前：必须手动指定 `--save`）。\n\n当添加了 `-D` 或 `--save-dev` 标志时，则会将其安装为开发依赖项（会被添加到 `devDependencies` 列表）。\n\n开发依赖是仅用于开发的程序包，在生产环境中并不需要。 例如测试的软件包、webpack 或 Babel。\n\n当投入生产环境时，如果输入 `npm install` 且该文件夹包含 `package.json` 文件时，则会安装它们，因为 npm 会假定这是开发部署。\n\n## Node.js 包运行器 npxs\n\n- 轻松地运行本地命令\n\n  Node.js 开发者过去通常将大多数可执行命令发布为全局的软件包，以使它们处于路径中且可被立即地执行。\n\n  运行 `npx commandname` 会自动地在项目的 `node_modules` 文件夹中找到命令的正确引用，而无需知道确切的路径，也不需要在全局和用户路径中安装软件包。\n\n- 无需安装的命令执行\n\n  `npx` 的另一个重要的特性是，无需先安装命令即可运行命令。\n\n- 使用不同的 Node.js 版本运行代码\n\n- 直接从 URL 运行任意代码片段\n\n## Node.js 事件循环\n\n原文链接：[Node.js事件循环](http://nodejs.cn/learn/the-nodejs-event-loop)\n\n### 一个简单的事件循环的阐释\n\n```js\nconst bar = () => console.log('bar')\n\nconst baz = () => console.log('baz')\n\nconst foo = () => {\n  console.log('foo')\n  bar()\n  baz()\n}\n\nfoo()\n\n// 输出\n// foo\n// bar\n// baz\n```\n\n当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 bar()，然后调用 baz()。\n\n此时，调用堆栈如下所示：\n\n![调用堆栈](http://nodejs.cn/website2/static/270ebeb6dbfa7d613152b71257c72a9e/11a8f/call-stack-first-example.png)\n\n### 入队函数执行\n\n```js\nconst bar = () => console.log('bar')\n\nconst baz = () => console.log('baz')\n\nconst foo = () => {\n  console.log('foo')\n  setTimeout(bar, 0)\n  baz()\n}\n\nfoo()\n\n/**\n * 打印输出：\n * foo\n * baz\n * bar\n*/\n```\n\n当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 setTimeout，将 bar 作为参数传入，并传入 0 作为定时器指示它尽快运行。 然后调用 baz()。\n\n调用堆栈如图：\n![调用堆栈](http://nodejs.cn/website2/static/be55515b9343074d00b43de88c495331/966a0/call-stack-second-example.png)\n\n执行顺序是：\n![执行顺序](http://nodejs.cn/website2/static/585ff3207d814911a7e44d55fbde483b/f96db/execution-order-second-example.png)\n\n为什么会这样呢？\n\n### 消息队列\n\n当调用 `setTimeout()` 时，浏览器或 Node.js 会启动定时器。 **当定时器到期时（在此示例中会立即到期，因为将超时值设为 0），则回调函数会被放入“消息队列”中。**\n\n在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 onLoad 这样的 DOM 事件也如此。\n\n事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。\n\n我们不必等待诸如 `setTimeout`、`fetch`、或其他的函数来完成它们自身的工作，因为它们是由浏览器提供的，并且位于它们自身的线程中。 例如，如果将 setTimeout 的超时设置为 2 秒，但不必等待 2 秒，等待发生在其他地方。\n\n### ES6 作业队列\n\n`ECMAScript 2015` 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。\n\n在当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。\n\n有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。\n\n例子：\n\n```js\nconst bar = () => console.log('bar')\n\nconst baz = () => console.log('baz')\n\nconst foo = () => {\n  console.log('foo')\n  setTimeout(bar, 0)\n  new Promise((resolve, reject) =>\n    resolve('应该在 baz 之后、bar 之前')\n  ).then(resolve => console.log(resolve))\n  baz()\n}\n\nfoo()\n/**\n * 输出：\n *  foo\n *  baz\n *  应该在 baz 之后、bar 之前\n *  bar\n * /\n```\n\n这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。\n\n## 了解 process.nextTick()\n\n当尝试了解 Node.js 事件循环时，其中一个重要的部分就是 process.nextTick()。\n\n每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。\n\n当将一个函数传给 process.nextTick() 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数\n\n事件循环正在忙于处理当前的函数代码。\n\n当该操作结束时，JS 引擎会运行在该操作期间传给 nextTick 调用的所有函数。\n\n这是可以告诉 JS 引擎异步地（在当前函数之后）处理函数的方式，但是尽快执行而不是将其排入队列。\n\n调用 setTimeout(() => {}, 0) 会在下一个滴答结束时执行该函数，比使用 nextTick()（其会优先执行该调用并在下一个滴答开始之前执行该函数）晚得多。\n\n**也就是说在当前调用堆栈的执行完成后就开始执行`process.nextTick()`里面的函数**\n\n## 了解 setImmediate()\n\n作为 setImmediate() 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调。\n\n### setImmediate() 与 setTimeout(() => {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？\n\n传给 process.nextTick() 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 setTimeout 和 setImmediate 之前执行。\n\n延迟 0 毫秒的 setTimeout() 回调与 setImmediate() 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。\n","source":"_posts/2021-10-31-Node-js学习记录.md","raw":"---\ntitle: Node.js学习记录\ndate: 2021-10-31 14:26:14\ntags: [Node.js]\ncategories: 技术类-后端\n---\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n## 使用exports从Node.js文件中公开功能\n\n两种方式：\n\n1. 第一种方式是将对象赋值给 module.exports（这是模块系统提供的对象），这会使文件只导出该对象:\n\n    ```js\n        const car = {\n            brand: 'Ford',\n            model: 'Fiesta'\n        }\n\n        module.exports = car\n\n        //在另一个文件中\n\n        const car = require('./car')\n    ```\n\n2. 第二种方式是将要导出的对象添加为 exports 的属性。这种方式可以导出多个对象、函数或数据：\n\n    ```js\n    const car = {\n    brand: 'Ford',\n    model: 'Fiesta'\n    }\n\n    exports.car = car\n    ```\n\n    或者直接\n\n    ```js\n    exports.car = {\n        brand: 'Ford',\n        model: 'Fiesta'\n    }\n    ```\n\n    在另一个文件中，则通过引用导入的属性来使用它：\n\n    ```js\n        const items = require('./items')\n        items.car\n    ```\n\n    或\n\n    ```js\n        const car = require('./items').car\n    ```\n\nmodule.exports 和 export 之间有什么区别？\n\n前者公开了它指向的对象。 后者公开了它指向的对象的属性。\n\n## package.json指南\n\n`package.json` 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 `npm` 和 `yarn` 存储所有已安装软件包的名称和版本的地方。\n\n对于应用程序，`package.json` 文件中的内容没有固定的要求。 唯一的要求是必须遵守 `JSON 格式`，否则，尝试以编程的方式访问其属性的程序则无法读取它。\n\n例子：\n\n```json\n{\n  \"name\": \"test-project\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Vue.js project\",\n  \"main\": \"src/main.js\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\",\n    \"start\": \"npm run dev\",\n    \"unit\": \"jest --config test/unit/jest.conf.js --coverage\",\n    \"test\": \"npm run unit\",\n    \"lint\": \"eslint --ext .js,.vue src test/unit\",\n    \"build\": \"node build/build.js\"\n  },\n  \"dependencies\": {\n    \"vue\": \"^2.5.2\"\n  },\n  \"devDependencies\": {\n    \"autoprefixer\": \"^7.1.2\",\n    \"babel-core\": \"^6.22.1\",\n    \"babel-eslint\": \"^8.2.1\",\n    \"babel-helper-vue-jsx-merge-props\": \"^2.0.3\",\n    \"babel-jest\": \"^21.0.2\",\n    \"babel-loader\": \"^7.1.1\",\n    \"babel-plugin-dynamic-import-node\": \"^1.2.0\",\n    \"babel-plugin-syntax-jsx\": \"^6.18.0\",\n    \"babel-plugin-transform-es2015-modules-commonjs\": \"^6.26.0\",\n    \"babel-plugin-transform-runtime\": \"^6.22.0\",\n    \"babel-plugin-transform-vue-jsx\": \"^3.5.0\",\n    \"babel-preset-env\": \"^1.3.2\",\n    \"babel-preset-stage-2\": \"^6.22.0\",\n    \"chalk\": \"^2.0.1\",\n    \"copy-webpack-plugin\": \"^4.0.1\",\n    \"css-loader\": \"^0.28.0\",\n    \"eslint\": \"^4.15.0\",\n    \"eslint-config-airbnb-base\": \"^11.3.0\",\n    \"eslint-friendly-formatter\": \"^3.0.0\",\n    \"eslint-import-resolver-webpack\": \"^0.8.3\",\n    \"eslint-loader\": \"^1.7.1\",\n    \"eslint-plugin-import\": \"^2.7.0\",\n    \"eslint-plugin-vue\": \"^4.0.0\",\n    \"extract-text-webpack-plugin\": \"^3.0.0\",\n    \"file-loader\": \"^1.1.4\",\n    \"friendly-errors-webpack-plugin\": \"^1.6.1\",\n    \"html-webpack-plugin\": \"^2.30.1\",\n    \"jest\": \"^22.0.4\",\n    \"jest-serializer-vue\": \"^0.3.0\",\n    \"node-notifier\": \"^5.1.2\",\n    \"optimize-css-assets-webpack-plugin\": \"^3.2.0\",\n    \"ora\": \"^1.2.0\",\n    \"portfinder\": \"^1.0.13\",\n    \"postcss-import\": \"^11.0.0\",\n    \"postcss-loader\": \"^2.0.8\",\n    \"postcss-url\": \"^7.2.1\",\n    \"rimraf\": \"^2.6.0\",\n    \"semver\": \"^5.3.0\",\n    \"shelljs\": \"^0.7.6\",\n    \"uglifyjs-webpack-plugin\": \"^1.1.1\",\n    \"url-loader\": \"^0.5.8\",\n    \"vue-jest\": \"^1.0.2\",\n    \"vue-loader\": \"^13.3.0\",\n    \"vue-style-loader\": \"^3.0.1\",\n    \"vue-template-compiler\": \"^2.5.2\",\n    \"webpack\": \"^3.6.0\",\n    \"webpack-bundle-analyzer\": \"^2.9.0\",\n    \"webpack-dev-server\": \"^2.9.1\",\n    \"webpack-merge\": \"^4.1.0\"\n  },\n  \"engines\": {\n    \"node\": \">= 6.0.0\",\n    \"npm\": \">= 3.0.0\"\n  },\n  \"browserslist\": [\"> 1%\", \"last 2 versions\", \"not ie <= 8\"]\n}\n```\n\n这里有很多东西：\n\n- version 表明了当前的版本。\n- name 设置了应用程序/软件包的名称。\n- description 是应用程序/软件包的简短描述。\n- main 设置了应用程序的入口点。\n- private 如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。\n- scripts 定义了一组可以运行的 node 脚本。\n- dependencies 设置了作为依赖安装的 npm 软件包的列表。\n- devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。\n- engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。\n- browserslist 用于告知要支持哪些浏览器（及其版本）。\n以上所有的这些属性都可被 npm 或其他工具使用。\n\n## package-lock.json 文件\n\n该文件旨在跟踪被安装的每个软件包的确切版本，以便产品可以以相同的方式被 100％ 复制（即使软件包的维护者更新了软件包）。\n\n## npm依赖与开发依赖\n\n当使用 `npm install <package-name>` 安装 npm 软件包时，是将其安装为依赖项。\n\n该软件包会被自动地列出在 `package.json` 文件中的 `dependencies` 列表下（在 npm 5 之前：必须手动指定 `--save`）。\n\n当添加了 `-D` 或 `--save-dev` 标志时，则会将其安装为开发依赖项（会被添加到 `devDependencies` 列表）。\n\n开发依赖是仅用于开发的程序包，在生产环境中并不需要。 例如测试的软件包、webpack 或 Babel。\n\n当投入生产环境时，如果输入 `npm install` 且该文件夹包含 `package.json` 文件时，则会安装它们，因为 npm 会假定这是开发部署。\n\n## Node.js 包运行器 npxs\n\n- 轻松地运行本地命令\n\n  Node.js 开发者过去通常将大多数可执行命令发布为全局的软件包，以使它们处于路径中且可被立即地执行。\n\n  运行 `npx commandname` 会自动地在项目的 `node_modules` 文件夹中找到命令的正确引用，而无需知道确切的路径，也不需要在全局和用户路径中安装软件包。\n\n- 无需安装的命令执行\n\n  `npx` 的另一个重要的特性是，无需先安装命令即可运行命令。\n\n- 使用不同的 Node.js 版本运行代码\n\n- 直接从 URL 运行任意代码片段\n\n## Node.js 事件循环\n\n原文链接：[Node.js事件循环](http://nodejs.cn/learn/the-nodejs-event-loop)\n\n### 一个简单的事件循环的阐释\n\n```js\nconst bar = () => console.log('bar')\n\nconst baz = () => console.log('baz')\n\nconst foo = () => {\n  console.log('foo')\n  bar()\n  baz()\n}\n\nfoo()\n\n// 输出\n// foo\n// bar\n// baz\n```\n\n当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 bar()，然后调用 baz()。\n\n此时，调用堆栈如下所示：\n\n![调用堆栈](http://nodejs.cn/website2/static/270ebeb6dbfa7d613152b71257c72a9e/11a8f/call-stack-first-example.png)\n\n### 入队函数执行\n\n```js\nconst bar = () => console.log('bar')\n\nconst baz = () => console.log('baz')\n\nconst foo = () => {\n  console.log('foo')\n  setTimeout(bar, 0)\n  baz()\n}\n\nfoo()\n\n/**\n * 打印输出：\n * foo\n * baz\n * bar\n*/\n```\n\n当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 setTimeout，将 bar 作为参数传入，并传入 0 作为定时器指示它尽快运行。 然后调用 baz()。\n\n调用堆栈如图：\n![调用堆栈](http://nodejs.cn/website2/static/be55515b9343074d00b43de88c495331/966a0/call-stack-second-example.png)\n\n执行顺序是：\n![执行顺序](http://nodejs.cn/website2/static/585ff3207d814911a7e44d55fbde483b/f96db/execution-order-second-example.png)\n\n为什么会这样呢？\n\n### 消息队列\n\n当调用 `setTimeout()` 时，浏览器或 Node.js 会启动定时器。 **当定时器到期时（在此示例中会立即到期，因为将超时值设为 0），则回调函数会被放入“消息队列”中。**\n\n在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 onLoad 这样的 DOM 事件也如此。\n\n事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。\n\n我们不必等待诸如 `setTimeout`、`fetch`、或其他的函数来完成它们自身的工作，因为它们是由浏览器提供的，并且位于它们自身的线程中。 例如，如果将 setTimeout 的超时设置为 2 秒，但不必等待 2 秒，等待发生在其他地方。\n\n### ES6 作业队列\n\n`ECMAScript 2015` 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。\n\n在当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。\n\n有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。\n\n例子：\n\n```js\nconst bar = () => console.log('bar')\n\nconst baz = () => console.log('baz')\n\nconst foo = () => {\n  console.log('foo')\n  setTimeout(bar, 0)\n  new Promise((resolve, reject) =>\n    resolve('应该在 baz 之后、bar 之前')\n  ).then(resolve => console.log(resolve))\n  baz()\n}\n\nfoo()\n/**\n * 输出：\n *  foo\n *  baz\n *  应该在 baz 之后、bar 之前\n *  bar\n * /\n```\n\n这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。\n\n## 了解 process.nextTick()\n\n当尝试了解 Node.js 事件循环时，其中一个重要的部分就是 process.nextTick()。\n\n每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。\n\n当将一个函数传给 process.nextTick() 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数\n\n事件循环正在忙于处理当前的函数代码。\n\n当该操作结束时，JS 引擎会运行在该操作期间传给 nextTick 调用的所有函数。\n\n这是可以告诉 JS 引擎异步地（在当前函数之后）处理函数的方式，但是尽快执行而不是将其排入队列。\n\n调用 setTimeout(() => {}, 0) 会在下一个滴答结束时执行该函数，比使用 nextTick()（其会优先执行该调用并在下一个滴答开始之前执行该函数）晚得多。\n\n**也就是说在当前调用堆栈的执行完成后就开始执行`process.nextTick()`里面的函数**\n\n## 了解 setImmediate()\n\n作为 setImmediate() 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调。\n\n### setImmediate() 与 setTimeout(() => {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？\n\n传给 process.nextTick() 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 setTimeout 和 setImmediate 之前执行。\n\n延迟 0 毫秒的 setTimeout() 回调与 setImmediate() 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。\n","slug":"Node-js学习记录","published":1,"updated":"2021-11-01T04:01:10.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18aq001ncco992u4cpfg","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h2 id=\"使用exports从Node-js文件中公开功能\"><a href=\"#使用exports从Node-js文件中公开功能\" class=\"headerlink\" title=\"使用exports从Node.js文件中公开功能\"></a>使用exports从Node.js文件中公开功能</h2><p>两种方式：</p>\n<ol>\n<li><p>第一种方式是将对象赋值给 module.exports（这是模块系统提供的对象），这会使文件只导出该对象:</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> car = &#123;<br>    <span class=\"hljs-attr\">brand</span>: <span class=\"hljs-string\">&#x27;Ford&#x27;</span>,<br>    <span class=\"hljs-attr\">model</span>: <span class=\"hljs-string\">&#x27;Fiesta&#x27;</span><br>&#125;<br><br><span class=\"hljs-built_in\">module</span>.exports = car<br><br><span class=\"hljs-comment\">//在另一个文件中</span><br><br><span class=\"hljs-keyword\">const</span> car = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./car&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n<li><p>第二种方式是将要导出的对象添加为 exports 的属性。这种方式可以导出多个对象、函数或数据：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> car = &#123;<br><span class=\"hljs-attr\">brand</span>: <span class=\"hljs-string\">&#x27;Ford&#x27;</span>,<br><span class=\"hljs-attr\">model</span>: <span class=\"hljs-string\">&#x27;Fiesta&#x27;</span><br>&#125;<br><br><span class=\"hljs-built_in\">exports</span>.car = car<br></code></pre></td></tr></table></figure>\n\n<p> 或者直接</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">exports</span>.car = &#123;<br>    <span class=\"hljs-attr\">brand</span>: <span class=\"hljs-string\">&#x27;Ford&#x27;</span>,<br>    <span class=\"hljs-attr\">model</span>: <span class=\"hljs-string\">&#x27;Fiesta&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p> 在另一个文件中，则通过引用导入的属性来使用它：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> items = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./items&#x27;</span>)<br>items.car<br></code></pre></td></tr></table></figure>\n\n<p> 或</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> car = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./items&#x27;</span>).car<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>module.exports 和 export 之间有什么区别？</p>\n<p>前者公开了它指向的对象。 后者公开了它指向的对象的属性。</p>\n<h2 id=\"package-json指南\"><a href=\"#package-json指南\" class=\"headerlink\" title=\"package.json指南\"></a>package.json指南</h2><p><code>package.json</code> 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 <code>npm</code> 和 <code>yarn</code> 存储所有已安装软件包的名称和版本的地方。</p>\n<p>对于应用程序，<code>package.json</code> 文件中的内容没有固定的要求。 唯一的要求是必须遵守 <code>JSON 格式</code>，否则，尝试以编程的方式访问其属性的程序则无法读取它。</p>\n<p>例子：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<br>  <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;test-project&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;A Vue.js project&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;main&quot;</span>: <span class=\"hljs-string\">&quot;src/main.js&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;private&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>  <span class=\"hljs-attr\">&quot;scripts&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;dev&quot;</span>: <span class=\"hljs-string\">&quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;start&quot;</span>: <span class=\"hljs-string\">&quot;npm run dev&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;unit&quot;</span>: <span class=\"hljs-string\">&quot;jest --config test/unit/jest.conf.js --coverage&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;test&quot;</span>: <span class=\"hljs-string\">&quot;npm run unit&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;lint&quot;</span>: <span class=\"hljs-string\">&quot;eslint --ext .js,.vue src test/unit&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;build&quot;</span>: <span class=\"hljs-string\">&quot;node build/build.js&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;dependencies&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;vue&quot;</span>: <span class=\"hljs-string\">&quot;^2.5.2&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;devDependencies&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;autoprefixer&quot;</span>: <span class=\"hljs-string\">&quot;^7.1.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-core&quot;</span>: <span class=\"hljs-string\">&quot;^6.22.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-eslint&quot;</span>: <span class=\"hljs-string\">&quot;^8.2.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-helper-vue-jsx-merge-props&quot;</span>: <span class=\"hljs-string\">&quot;^2.0.3&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-jest&quot;</span>: <span class=\"hljs-string\">&quot;^21.0.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-loader&quot;</span>: <span class=\"hljs-string\">&quot;^7.1.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-dynamic-import-node&quot;</span>: <span class=\"hljs-string\">&quot;^1.2.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-syntax-jsx&quot;</span>: <span class=\"hljs-string\">&quot;^6.18.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-transform-es2015-modules-commonjs&quot;</span>: <span class=\"hljs-string\">&quot;^6.26.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-transform-runtime&quot;</span>: <span class=\"hljs-string\">&quot;^6.22.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-transform-vue-jsx&quot;</span>: <span class=\"hljs-string\">&quot;^3.5.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-preset-env&quot;</span>: <span class=\"hljs-string\">&quot;^1.3.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-preset-stage-2&quot;</span>: <span class=\"hljs-string\">&quot;^6.22.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;chalk&quot;</span>: <span class=\"hljs-string\">&quot;^2.0.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;copy-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^4.0.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;css-loader&quot;</span>: <span class=\"hljs-string\">&quot;^0.28.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint&quot;</span>: <span class=\"hljs-string\">&quot;^4.15.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-config-airbnb-base&quot;</span>: <span class=\"hljs-string\">&quot;^11.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-friendly-formatter&quot;</span>: <span class=\"hljs-string\">&quot;^3.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-import-resolver-webpack&quot;</span>: <span class=\"hljs-string\">&quot;^0.8.3&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-loader&quot;</span>: <span class=\"hljs-string\">&quot;^1.7.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-plugin-import&quot;</span>: <span class=\"hljs-string\">&quot;^2.7.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-plugin-vue&quot;</span>: <span class=\"hljs-string\">&quot;^4.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;extract-text-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^3.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;file-loader&quot;</span>: <span class=\"hljs-string\">&quot;^1.1.4&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;friendly-errors-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^1.6.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;html-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^2.30.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;jest&quot;</span>: <span class=\"hljs-string\">&quot;^22.0.4&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;jest-serializer-vue&quot;</span>: <span class=\"hljs-string\">&quot;^0.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;node-notifier&quot;</span>: <span class=\"hljs-string\">&quot;^5.1.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;optimize-css-assets-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^3.2.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;ora&quot;</span>: <span class=\"hljs-string\">&quot;^1.2.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;portfinder&quot;</span>: <span class=\"hljs-string\">&quot;^1.0.13&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;postcss-import&quot;</span>: <span class=\"hljs-string\">&quot;^11.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;postcss-loader&quot;</span>: <span class=\"hljs-string\">&quot;^2.0.8&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;postcss-url&quot;</span>: <span class=\"hljs-string\">&quot;^7.2.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;rimraf&quot;</span>: <span class=\"hljs-string\">&quot;^2.6.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;semver&quot;</span>: <span class=\"hljs-string\">&quot;^5.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;shelljs&quot;</span>: <span class=\"hljs-string\">&quot;^0.7.6&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;uglifyjs-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^1.1.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;url-loader&quot;</span>: <span class=\"hljs-string\">&quot;^0.5.8&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-jest&quot;</span>: <span class=\"hljs-string\">&quot;^1.0.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-loader&quot;</span>: <span class=\"hljs-string\">&quot;^13.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-style-loader&quot;</span>: <span class=\"hljs-string\">&quot;^3.0.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-template-compiler&quot;</span>: <span class=\"hljs-string\">&quot;^2.5.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack&quot;</span>: <span class=\"hljs-string\">&quot;^3.6.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack-bundle-analyzer&quot;</span>: <span class=\"hljs-string\">&quot;^2.9.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack-dev-server&quot;</span>: <span class=\"hljs-string\">&quot;^2.9.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack-merge&quot;</span>: <span class=\"hljs-string\">&quot;^4.1.0&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;engines&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;node&quot;</span>: <span class=\"hljs-string\">&quot;&gt;= 6.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;npm&quot;</span>: <span class=\"hljs-string\">&quot;&gt;= 3.0.0&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;browserslist&quot;</span>: [<span class=\"hljs-string\">&quot;&gt; 1%&quot;</span>, <span class=\"hljs-string\">&quot;last 2 versions&quot;</span>, <span class=\"hljs-string\">&quot;not ie &lt;= 8&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里有很多东西：</p>\n<ul>\n<li>version 表明了当前的版本。</li>\n<li>name 设置了应用程序/软件包的名称。</li>\n<li>description 是应用程序/软件包的简短描述。</li>\n<li>main 设置了应用程序的入口点。</li>\n<li>private 如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。</li>\n<li>scripts 定义了一组可以运行的 node 脚本。</li>\n<li>dependencies 设置了作为依赖安装的 npm 软件包的列表。</li>\n<li>devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。</li>\n<li>engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。</li>\n<li>browserslist 用于告知要支持哪些浏览器（及其版本）。<br>以上所有的这些属性都可被 npm 或其他工具使用。</li>\n</ul>\n<h2 id=\"package-lock-json-文件\"><a href=\"#package-lock-json-文件\" class=\"headerlink\" title=\"package-lock.json 文件\"></a>package-lock.json 文件</h2><p>该文件旨在跟踪被安装的每个软件包的确切版本，以便产品可以以相同的方式被 100％ 复制（即使软件包的维护者更新了软件包）。</p>\n<h2 id=\"npm依赖与开发依赖\"><a href=\"#npm依赖与开发依赖\" class=\"headerlink\" title=\"npm依赖与开发依赖\"></a>npm依赖与开发依赖</h2><p>当使用 <code>npm install &lt;package-name&gt;</code> 安装 npm 软件包时，是将其安装为依赖项。</p>\n<p>该软件包会被自动地列出在 <code>package.json</code> 文件中的 <code>dependencies</code> 列表下（在 npm 5 之前：必须手动指定 <code>--save</code>）。</p>\n<p>当添加了 <code>-D</code> 或 <code>--save-dev</code> 标志时，则会将其安装为开发依赖项（会被添加到 <code>devDependencies</code> 列表）。</p>\n<p>开发依赖是仅用于开发的程序包，在生产环境中并不需要。 例如测试的软件包、webpack 或 Babel。</p>\n<p>当投入生产环境时，如果输入 <code>npm install</code> 且该文件夹包含 <code>package.json</code> 文件时，则会安装它们，因为 npm 会假定这是开发部署。</p>\n<h2 id=\"Node-js-包运行器-npxs\"><a href=\"#Node-js-包运行器-npxs\" class=\"headerlink\" title=\"Node.js 包运行器 npxs\"></a>Node.js 包运行器 npxs</h2><ul>\n<li><p>轻松地运行本地命令</p>\n<p>Node.js 开发者过去通常将大多数可执行命令发布为全局的软件包，以使它们处于路径中且可被立即地执行。</p>\n<p>运行 <code>npx commandname</code> 会自动地在项目的 <code>node_modules</code> 文件夹中找到命令的正确引用，而无需知道确切的路径，也不需要在全局和用户路径中安装软件包。</p>\n</li>\n<li><p>无需安装的命令执行</p>\n<p><code>npx</code> 的另一个重要的特性是，无需先安装命令即可运行命令。</p>\n</li>\n<li><p>使用不同的 Node.js 版本运行代码</p>\n</li>\n<li><p>直接从 URL 运行任意代码片段</p>\n</li>\n</ul>\n<h2 id=\"Node-js-事件循环\"><a href=\"#Node-js-事件循环\" class=\"headerlink\" title=\"Node.js 事件循环\"></a>Node.js 事件循环</h2><p>原文链接：<a href=\"http://nodejs.cn/learn/the-nodejs-event-loop\">Node.js事件循环</a></p>\n<h3 id=\"一个简单的事件循环的阐释\"><a href=\"#一个简单的事件循环的阐释\" class=\"headerlink\" title=\"一个简单的事件循环的阐释\"></a>一个简单的事件循环的阐释</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;bar&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> baz = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;baz&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>  bar()<br>  baz()<br>&#125;<br><br>foo()<br><br><span class=\"hljs-comment\">// 输出</span><br><span class=\"hljs-comment\">// foo</span><br><span class=\"hljs-comment\">// bar</span><br><span class=\"hljs-comment\">// baz</span><br></code></pre></td></tr></table></figure>\n\n<p>当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 bar()，然后调用 baz()。</p>\n<p>此时，调用堆栈如下所示：</p>\n<p><img src=\"http://nodejs.cn/website2/static/270ebeb6dbfa7d613152b71257c72a9e/11a8f/call-stack-first-example.png\" alt=\"调用堆栈\"></p>\n<h3 id=\"入队函数执行\"><a href=\"#入队函数执行\" class=\"headerlink\" title=\"入队函数执行\"></a>入队函数执行</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;bar&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> baz = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;baz&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>  <span class=\"hljs-built_in\">setTimeout</span>(bar, <span class=\"hljs-number\">0</span>)<br>  baz()<br>&#125;<br><br>foo()<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 打印输出：</span><br><span class=\"hljs-comment\"> * foo</span><br><span class=\"hljs-comment\"> * baz</span><br><span class=\"hljs-comment\"> * bar</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<p>当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 setTimeout，将 bar 作为参数传入，并传入 0 作为定时器指示它尽快运行。 然后调用 baz()。</p>\n<p>调用堆栈如图：<br><img src=\"http://nodejs.cn/website2/static/be55515b9343074d00b43de88c495331/966a0/call-stack-second-example.png\" alt=\"调用堆栈\"></p>\n<p>执行顺序是：<br><img src=\"http://nodejs.cn/website2/static/585ff3207d814911a7e44d55fbde483b/f96db/execution-order-second-example.png\" alt=\"执行顺序\"></p>\n<p>为什么会这样呢？</p>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><p>当调用 <code>setTimeout()</code> 时，浏览器或 Node.js 会启动定时器。 <strong>当定时器到期时（在此示例中会立即到期，因为将超时值设为 0），则回调函数会被放入“消息队列”中。</strong></p>\n<p>在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 onLoad 这样的 DOM 事件也如此。</p>\n<p>事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。</p>\n<p>我们不必等待诸如 <code>setTimeout</code>、<code>fetch</code>、或其他的函数来完成它们自身的工作，因为它们是由浏览器提供的，并且位于它们自身的线程中。 例如，如果将 setTimeout 的超时设置为 2 秒，但不必等待 2 秒，等待发生在其他地方。</p>\n<h3 id=\"ES6-作业队列\"><a href=\"#ES6-作业队列\" class=\"headerlink\" title=\"ES6 作业队列\"></a>ES6 作业队列</h3><p><code>ECMAScript 2015</code> 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。</p>\n<p>在当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。</p>\n<p>有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。</p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;bar&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> baz = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;baz&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>  <span class=\"hljs-built_in\">setTimeout</span>(bar, <span class=\"hljs-number\">0</span>)<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span><br>    resolve(<span class=\"hljs-string\">&#x27;应该在 baz 之后、bar 之前&#x27;</span>)<br>  ).then(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(resolve))<br>  baz()<br>&#125;<br><br>foo()<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 输出：</span><br><span class=\"hljs-comment\"> *  foo</span><br><span class=\"hljs-comment\"> *  baz</span><br><span class=\"hljs-comment\"> *  应该在 baz 之后、bar 之前</span><br><span class=\"hljs-comment\"> *  bar</span><br><span class=\"hljs-comment\"> * /</span><br></code></pre></td></tr></table></figure>\n\n<p>这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。</p>\n<h2 id=\"了解-process-nextTick\"><a href=\"#了解-process-nextTick\" class=\"headerlink\" title=\"了解 process.nextTick()\"></a>了解 process.nextTick()</h2><p>当尝试了解 Node.js 事件循环时，其中一个重要的部分就是 process.nextTick()。</p>\n<p>每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。</p>\n<p>当将一个函数传给 process.nextTick() 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数</p>\n<p>事件循环正在忙于处理当前的函数代码。</p>\n<p>当该操作结束时，JS 引擎会运行在该操作期间传给 nextTick 调用的所有函数。</p>\n<p>这是可以告诉 JS 引擎异步地（在当前函数之后）处理函数的方式，但是尽快执行而不是将其排入队列。</p>\n<p>调用 setTimeout(() =&gt; {}, 0) 会在下一个滴答结束时执行该函数，比使用 nextTick()（其会优先执行该调用并在下一个滴答开始之前执行该函数）晚得多。</p>\n<p><strong>也就是说在当前调用堆栈的执行完成后就开始执行<code>process.nextTick()</code>里面的函数</strong></p>\n<h2 id=\"了解-setImmediate\"><a href=\"#了解-setImmediate\" class=\"headerlink\" title=\"了解 setImmediate()\"></a>了解 setImmediate()</h2><p>作为 setImmediate() 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调。</p>\n<h3 id=\"setImmediate-与-setTimeout-gt-0-（传入-0-毫秒的超时）、process-nextTick-有何不同？\"><a href=\"#setImmediate-与-setTimeout-gt-0-（传入-0-毫秒的超时）、process-nextTick-有何不同？\" class=\"headerlink\" title=\"setImmediate() 与 setTimeout(() =&gt; {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？\"></a>setImmediate() 与 setTimeout(() =&gt; {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？</h3><p>传给 process.nextTick() 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 setTimeout 和 setImmediate 之前执行。</p>\n<p>延迟 0 毫秒的 setTimeout() 回调与 setImmediate() 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h2 id=\"使用exports从Node-js文件中公开功能\"><a href=\"#使用exports从Node-js文件中公开功能\" class=\"headerlink\" title=\"使用exports从Node.js文件中公开功能\"></a>使用exports从Node.js文件中公开功能</h2><p>两种方式：</p>\n<ol>\n<li><p>第一种方式是将对象赋值给 module.exports（这是模块系统提供的对象），这会使文件只导出该对象:</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> car = &#123;<br>    <span class=\"hljs-attr\">brand</span>: <span class=\"hljs-string\">&#x27;Ford&#x27;</span>,<br>    <span class=\"hljs-attr\">model</span>: <span class=\"hljs-string\">&#x27;Fiesta&#x27;</span><br>&#125;<br><br><span class=\"hljs-built_in\">module</span>.exports = car<br><br><span class=\"hljs-comment\">//在另一个文件中</span><br><br><span class=\"hljs-keyword\">const</span> car = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./car&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n<li><p>第二种方式是将要导出的对象添加为 exports 的属性。这种方式可以导出多个对象、函数或数据：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> car = &#123;<br><span class=\"hljs-attr\">brand</span>: <span class=\"hljs-string\">&#x27;Ford&#x27;</span>,<br><span class=\"hljs-attr\">model</span>: <span class=\"hljs-string\">&#x27;Fiesta&#x27;</span><br>&#125;<br><br><span class=\"hljs-built_in\">exports</span>.car = car<br></code></pre></td></tr></table></figure>\n\n<p> 或者直接</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">exports</span>.car = &#123;<br>    <span class=\"hljs-attr\">brand</span>: <span class=\"hljs-string\">&#x27;Ford&#x27;</span>,<br>    <span class=\"hljs-attr\">model</span>: <span class=\"hljs-string\">&#x27;Fiesta&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p> 在另一个文件中，则通过引用导入的属性来使用它：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> items = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./items&#x27;</span>)<br>items.car<br></code></pre></td></tr></table></figure>\n\n<p> 或</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> car = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./items&#x27;</span>).car<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>module.exports 和 export 之间有什么区别？</p>\n<p>前者公开了它指向的对象。 后者公开了它指向的对象的属性。</p>\n<h2 id=\"package-json指南\"><a href=\"#package-json指南\" class=\"headerlink\" title=\"package.json指南\"></a>package.json指南</h2><p><code>package.json</code> 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 <code>npm</code> 和 <code>yarn</code> 存储所有已安装软件包的名称和版本的地方。</p>\n<p>对于应用程序，<code>package.json</code> 文件中的内容没有固定的要求。 唯一的要求是必须遵守 <code>JSON 格式</code>，否则，尝试以编程的方式访问其属性的程序则无法读取它。</p>\n<p>例子：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<br>  <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;test-project&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;A Vue.js project&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;main&quot;</span>: <span class=\"hljs-string\">&quot;src/main.js&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;private&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>  <span class=\"hljs-attr\">&quot;scripts&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;dev&quot;</span>: <span class=\"hljs-string\">&quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;start&quot;</span>: <span class=\"hljs-string\">&quot;npm run dev&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;unit&quot;</span>: <span class=\"hljs-string\">&quot;jest --config test/unit/jest.conf.js --coverage&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;test&quot;</span>: <span class=\"hljs-string\">&quot;npm run unit&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;lint&quot;</span>: <span class=\"hljs-string\">&quot;eslint --ext .js,.vue src test/unit&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;build&quot;</span>: <span class=\"hljs-string\">&quot;node build/build.js&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;dependencies&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;vue&quot;</span>: <span class=\"hljs-string\">&quot;^2.5.2&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;devDependencies&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;autoprefixer&quot;</span>: <span class=\"hljs-string\">&quot;^7.1.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-core&quot;</span>: <span class=\"hljs-string\">&quot;^6.22.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-eslint&quot;</span>: <span class=\"hljs-string\">&quot;^8.2.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-helper-vue-jsx-merge-props&quot;</span>: <span class=\"hljs-string\">&quot;^2.0.3&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-jest&quot;</span>: <span class=\"hljs-string\">&quot;^21.0.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-loader&quot;</span>: <span class=\"hljs-string\">&quot;^7.1.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-dynamic-import-node&quot;</span>: <span class=\"hljs-string\">&quot;^1.2.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-syntax-jsx&quot;</span>: <span class=\"hljs-string\">&quot;^6.18.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-transform-es2015-modules-commonjs&quot;</span>: <span class=\"hljs-string\">&quot;^6.26.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-transform-runtime&quot;</span>: <span class=\"hljs-string\">&quot;^6.22.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-transform-vue-jsx&quot;</span>: <span class=\"hljs-string\">&quot;^3.5.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-preset-env&quot;</span>: <span class=\"hljs-string\">&quot;^1.3.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-preset-stage-2&quot;</span>: <span class=\"hljs-string\">&quot;^6.22.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;chalk&quot;</span>: <span class=\"hljs-string\">&quot;^2.0.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;copy-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^4.0.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;css-loader&quot;</span>: <span class=\"hljs-string\">&quot;^0.28.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint&quot;</span>: <span class=\"hljs-string\">&quot;^4.15.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-config-airbnb-base&quot;</span>: <span class=\"hljs-string\">&quot;^11.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-friendly-formatter&quot;</span>: <span class=\"hljs-string\">&quot;^3.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-import-resolver-webpack&quot;</span>: <span class=\"hljs-string\">&quot;^0.8.3&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-loader&quot;</span>: <span class=\"hljs-string\">&quot;^1.7.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-plugin-import&quot;</span>: <span class=\"hljs-string\">&quot;^2.7.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-plugin-vue&quot;</span>: <span class=\"hljs-string\">&quot;^4.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;extract-text-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^3.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;file-loader&quot;</span>: <span class=\"hljs-string\">&quot;^1.1.4&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;friendly-errors-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^1.6.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;html-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^2.30.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;jest&quot;</span>: <span class=\"hljs-string\">&quot;^22.0.4&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;jest-serializer-vue&quot;</span>: <span class=\"hljs-string\">&quot;^0.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;node-notifier&quot;</span>: <span class=\"hljs-string\">&quot;^5.1.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;optimize-css-assets-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^3.2.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;ora&quot;</span>: <span class=\"hljs-string\">&quot;^1.2.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;portfinder&quot;</span>: <span class=\"hljs-string\">&quot;^1.0.13&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;postcss-import&quot;</span>: <span class=\"hljs-string\">&quot;^11.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;postcss-loader&quot;</span>: <span class=\"hljs-string\">&quot;^2.0.8&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;postcss-url&quot;</span>: <span class=\"hljs-string\">&quot;^7.2.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;rimraf&quot;</span>: <span class=\"hljs-string\">&quot;^2.6.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;semver&quot;</span>: <span class=\"hljs-string\">&quot;^5.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;shelljs&quot;</span>: <span class=\"hljs-string\">&quot;^0.7.6&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;uglifyjs-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^1.1.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;url-loader&quot;</span>: <span class=\"hljs-string\">&quot;^0.5.8&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-jest&quot;</span>: <span class=\"hljs-string\">&quot;^1.0.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-loader&quot;</span>: <span class=\"hljs-string\">&quot;^13.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-style-loader&quot;</span>: <span class=\"hljs-string\">&quot;^3.0.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-template-compiler&quot;</span>: <span class=\"hljs-string\">&quot;^2.5.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack&quot;</span>: <span class=\"hljs-string\">&quot;^3.6.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack-bundle-analyzer&quot;</span>: <span class=\"hljs-string\">&quot;^2.9.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack-dev-server&quot;</span>: <span class=\"hljs-string\">&quot;^2.9.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack-merge&quot;</span>: <span class=\"hljs-string\">&quot;^4.1.0&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;engines&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;node&quot;</span>: <span class=\"hljs-string\">&quot;&gt;= 6.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;npm&quot;</span>: <span class=\"hljs-string\">&quot;&gt;= 3.0.0&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;browserslist&quot;</span>: [<span class=\"hljs-string\">&quot;&gt; 1%&quot;</span>, <span class=\"hljs-string\">&quot;last 2 versions&quot;</span>, <span class=\"hljs-string\">&quot;not ie &lt;= 8&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里有很多东西：</p>\n<ul>\n<li>version 表明了当前的版本。</li>\n<li>name 设置了应用程序/软件包的名称。</li>\n<li>description 是应用程序/软件包的简短描述。</li>\n<li>main 设置了应用程序的入口点。</li>\n<li>private 如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。</li>\n<li>scripts 定义了一组可以运行的 node 脚本。</li>\n<li>dependencies 设置了作为依赖安装的 npm 软件包的列表。</li>\n<li>devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。</li>\n<li>engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。</li>\n<li>browserslist 用于告知要支持哪些浏览器（及其版本）。<br>以上所有的这些属性都可被 npm 或其他工具使用。</li>\n</ul>\n<h2 id=\"package-lock-json-文件\"><a href=\"#package-lock-json-文件\" class=\"headerlink\" title=\"package-lock.json 文件\"></a>package-lock.json 文件</h2><p>该文件旨在跟踪被安装的每个软件包的确切版本，以便产品可以以相同的方式被 100％ 复制（即使软件包的维护者更新了软件包）。</p>\n<h2 id=\"npm依赖与开发依赖\"><a href=\"#npm依赖与开发依赖\" class=\"headerlink\" title=\"npm依赖与开发依赖\"></a>npm依赖与开发依赖</h2><p>当使用 <code>npm install &lt;package-name&gt;</code> 安装 npm 软件包时，是将其安装为依赖项。</p>\n<p>该软件包会被自动地列出在 <code>package.json</code> 文件中的 <code>dependencies</code> 列表下（在 npm 5 之前：必须手动指定 <code>--save</code>）。</p>\n<p>当添加了 <code>-D</code> 或 <code>--save-dev</code> 标志时，则会将其安装为开发依赖项（会被添加到 <code>devDependencies</code> 列表）。</p>\n<p>开发依赖是仅用于开发的程序包，在生产环境中并不需要。 例如测试的软件包、webpack 或 Babel。</p>\n<p>当投入生产环境时，如果输入 <code>npm install</code> 且该文件夹包含 <code>package.json</code> 文件时，则会安装它们，因为 npm 会假定这是开发部署。</p>\n<h2 id=\"Node-js-包运行器-npxs\"><a href=\"#Node-js-包运行器-npxs\" class=\"headerlink\" title=\"Node.js 包运行器 npxs\"></a>Node.js 包运行器 npxs</h2><ul>\n<li><p>轻松地运行本地命令</p>\n<p>Node.js 开发者过去通常将大多数可执行命令发布为全局的软件包，以使它们处于路径中且可被立即地执行。</p>\n<p>运行 <code>npx commandname</code> 会自动地在项目的 <code>node_modules</code> 文件夹中找到命令的正确引用，而无需知道确切的路径，也不需要在全局和用户路径中安装软件包。</p>\n</li>\n<li><p>无需安装的命令执行</p>\n<p><code>npx</code> 的另一个重要的特性是，无需先安装命令即可运行命令。</p>\n</li>\n<li><p>使用不同的 Node.js 版本运行代码</p>\n</li>\n<li><p>直接从 URL 运行任意代码片段</p>\n</li>\n</ul>\n<h2 id=\"Node-js-事件循环\"><a href=\"#Node-js-事件循环\" class=\"headerlink\" title=\"Node.js 事件循环\"></a>Node.js 事件循环</h2><p>原文链接：<a href=\"http://nodejs.cn/learn/the-nodejs-event-loop\">Node.js事件循环</a></p>\n<h3 id=\"一个简单的事件循环的阐释\"><a href=\"#一个简单的事件循环的阐释\" class=\"headerlink\" title=\"一个简单的事件循环的阐释\"></a>一个简单的事件循环的阐释</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;bar&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> baz = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;baz&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>  bar()<br>  baz()<br>&#125;<br><br>foo()<br><br><span class=\"hljs-comment\">// 输出</span><br><span class=\"hljs-comment\">// foo</span><br><span class=\"hljs-comment\">// bar</span><br><span class=\"hljs-comment\">// baz</span><br></code></pre></td></tr></table></figure>\n\n<p>当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 bar()，然后调用 baz()。</p>\n<p>此时，调用堆栈如下所示：</p>\n<p><img src=\"http://nodejs.cn/website2/static/270ebeb6dbfa7d613152b71257c72a9e/11a8f/call-stack-first-example.png\" alt=\"调用堆栈\"></p>\n<h3 id=\"入队函数执行\"><a href=\"#入队函数执行\" class=\"headerlink\" title=\"入队函数执行\"></a>入队函数执行</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;bar&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> baz = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;baz&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>  <span class=\"hljs-built_in\">setTimeout</span>(bar, <span class=\"hljs-number\">0</span>)<br>  baz()<br>&#125;<br><br>foo()<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 打印输出：</span><br><span class=\"hljs-comment\"> * foo</span><br><span class=\"hljs-comment\"> * baz</span><br><span class=\"hljs-comment\"> * bar</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<p>当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 setTimeout，将 bar 作为参数传入，并传入 0 作为定时器指示它尽快运行。 然后调用 baz()。</p>\n<p>调用堆栈如图：<br><img src=\"http://nodejs.cn/website2/static/be55515b9343074d00b43de88c495331/966a0/call-stack-second-example.png\" alt=\"调用堆栈\"></p>\n<p>执行顺序是：<br><img src=\"http://nodejs.cn/website2/static/585ff3207d814911a7e44d55fbde483b/f96db/execution-order-second-example.png\" alt=\"执行顺序\"></p>\n<p>为什么会这样呢？</p>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><p>当调用 <code>setTimeout()</code> 时，浏览器或 Node.js 会启动定时器。 <strong>当定时器到期时（在此示例中会立即到期，因为将超时值设为 0），则回调函数会被放入“消息队列”中。</strong></p>\n<p>在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 onLoad 这样的 DOM 事件也如此。</p>\n<p>事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。</p>\n<p>我们不必等待诸如 <code>setTimeout</code>、<code>fetch</code>、或其他的函数来完成它们自身的工作，因为它们是由浏览器提供的，并且位于它们自身的线程中。 例如，如果将 setTimeout 的超时设置为 2 秒，但不必等待 2 秒，等待发生在其他地方。</p>\n<h3 id=\"ES6-作业队列\"><a href=\"#ES6-作业队列\" class=\"headerlink\" title=\"ES6 作业队列\"></a>ES6 作业队列</h3><p><code>ECMAScript 2015</code> 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。</p>\n<p>在当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。</p>\n<p>有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。</p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;bar&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> baz = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;baz&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>  <span class=\"hljs-built_in\">setTimeout</span>(bar, <span class=\"hljs-number\">0</span>)<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span><br>    resolve(<span class=\"hljs-string\">&#x27;应该在 baz 之后、bar 之前&#x27;</span>)<br>  ).then(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(resolve))<br>  baz()<br>&#125;<br><br>foo()<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 输出：</span><br><span class=\"hljs-comment\"> *  foo</span><br><span class=\"hljs-comment\"> *  baz</span><br><span class=\"hljs-comment\"> *  应该在 baz 之后、bar 之前</span><br><span class=\"hljs-comment\"> *  bar</span><br><span class=\"hljs-comment\"> * /</span><br></code></pre></td></tr></table></figure>\n\n<p>这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。</p>\n<h2 id=\"了解-process-nextTick\"><a href=\"#了解-process-nextTick\" class=\"headerlink\" title=\"了解 process.nextTick()\"></a>了解 process.nextTick()</h2><p>当尝试了解 Node.js 事件循环时，其中一个重要的部分就是 process.nextTick()。</p>\n<p>每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。</p>\n<p>当将一个函数传给 process.nextTick() 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数</p>\n<p>事件循环正在忙于处理当前的函数代码。</p>\n<p>当该操作结束时，JS 引擎会运行在该操作期间传给 nextTick 调用的所有函数。</p>\n<p>这是可以告诉 JS 引擎异步地（在当前函数之后）处理函数的方式，但是尽快执行而不是将其排入队列。</p>\n<p>调用 setTimeout(() =&gt; {}, 0) 会在下一个滴答结束时执行该函数，比使用 nextTick()（其会优先执行该调用并在下一个滴答开始之前执行该函数）晚得多。</p>\n<p><strong>也就是说在当前调用堆栈的执行完成后就开始执行<code>process.nextTick()</code>里面的函数</strong></p>\n<h2 id=\"了解-setImmediate\"><a href=\"#了解-setImmediate\" class=\"headerlink\" title=\"了解 setImmediate()\"></a>了解 setImmediate()</h2><p>作为 setImmediate() 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调。</p>\n<h3 id=\"setImmediate-与-setTimeout-gt-0-（传入-0-毫秒的超时）、process-nextTick-有何不同？\"><a href=\"#setImmediate-与-setTimeout-gt-0-（传入-0-毫秒的超时）、process-nextTick-有何不同？\" class=\"headerlink\" title=\"setImmediate() 与 setTimeout(() =&gt; {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？\"></a>setImmediate() 与 setTimeout(() =&gt; {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？</h3><p>传给 process.nextTick() 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 setTimeout 和 setImmediate 之前执行。</p>\n<p>延迟 0 毫秒的 setTimeout() 回调与 setImmediate() 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。</p>\n"},{"title":"最近在忙什么","date":"2021-11-18T08:59:09.000Z","_content":"最近在做一个个人的全栈项目\n\n前端技术栈是：Vite+Vue3+TypeScript+Scss\n\n后端技术栈是：NodeJs+Express+MySQL\n\n已经上线一部分功能,部署在阿里云上了\n\n目前没啥功能。后续会慢慢完善优化\n\n地址在：www.hjzouhualu.com\n","source":"_posts/2021-11-18-最近在忙什么.md","raw":"---\ntitle: 最近在忙什么\ndate: 2021-11-18 16:59:09\ntags:\n- [日常]\ncategories:\n- [日常]\n---\n最近在做一个个人的全栈项目\n\n前端技术栈是：Vite+Vue3+TypeScript+Scss\n\n后端技术栈是：NodeJs+Express+MySQL\n\n已经上线一部分功能,部署在阿里云上了\n\n目前没啥功能。后续会慢慢完善优化\n\n地址在：www.hjzouhualu.com\n","slug":"最近在忙什么","published":1,"updated":"2021-11-18T09:06:06.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18aq001qcco9h5hcexsk","content":"<p>最近在做一个个人的全栈项目</p>\n<p>前端技术栈是：Vite+Vue3+TypeScript+Scss</p>\n<p>后端技术栈是：NodeJs+Express+MySQL</p>\n<p>已经上线一部分功能,部署在阿里云上了</p>\n<p>目前没啥功能。后续会慢慢完善优化</p>\n<p>地址在：<a href=\"http://www.hjzouhualu.com/\">www.hjzouhualu.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在做一个个人的全栈项目</p>\n<p>前端技术栈是：Vite+Vue3+TypeScript+Scss</p>\n<p>后端技术栈是：NodeJs+Express+MySQL</p>\n<p>已经上线一部分功能,部署在阿里云上了</p>\n<p>目前没啥功能。后续会慢慢完善优化</p>\n<p>地址在：<a href=\"http://www.hjzouhualu.com/\">www.hjzouhualu.com</a></p>\n"},{"title":"create-react-app 搭建项目踩坑记录","date":"2021-11-29T11:44:25.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n\n# 中文说明\n\n## 搭建前端开发环境笔记\n\n由`npx create-react-app articles_published_system`创建的项目\n\n后来漏掉了`typescript`支持，原本可以由命令`npx create-react-app articles_published_system --template typescript`可以直接创建支持ts的应用\n\n后续要将ts添加到已有项目中，用以下命令：\n\n`npm install --save typescript @types/node @types/react @types/react-dom @types/jest`\n\n项目中配置`sass`:\n\n1. 执行`yarn add node-sass`下载包（按理说执行`npm install node-sass --save`也应该有用，但是我这边报错了）。\n\n    报错如下：\n\n    ![npm安装sass报错](https://upload-images.jianshu.io/upload_images/13931286-44bf5ea859ce44fd.png?imageMogr2/auto-orient/strip|imageView2/2/w/672/format/webp)\n\n    我的vscode和node版本都是最新的\n\n    建议大家用`yarn`来安装项目\n\n    **发现启动后sass会报错**\n\n    解决办法：sass指定版本为`^1.43.5`，postcss-pxtorem为`^5.1.1`，不要安装node-sass了\n\n    前端生态配置仍然复杂\n\n2. 将样式文件后缀改为`.scss`并在tsx或者js文件中引入，项目会自动编译。\n\n为了实现自适应，给项目配置postcss-pxtorem\n\n1. 执行`yarn add lib-flexible postcss-pxtorem`\n\n2. 在应用入口引入`import 'lib-flexible'`\n\n3. 执行`npm run eject`可以打开`create-react-app`应用的配置文件\n\n4. 在`config/webpack.config.js`文件中配置postcss，位置及方法如下图：\n\n![引入postcss](https://upload-images.jianshu.io/upload_images/13931286-da7732a5f0bf175d.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)\n\n![配置postcss](https://upload-images.jianshu.io/upload_images/13931286-7f538e5227508fa5.png?imageMogr2/auto-orient/strip|imageView2/2/w/630/format/webp)\n\nUI库使用antdesign\n\n1. 安装antd，`yarn add antd`\n\n2. 在App.css 中导入样式`@import '~antd/dist/antd.css'`，然后在组件中引入相应的ui组件就可以用了。\n\n---\n\n完~","source":"_posts/2021-11-29-create-react-app-搭建项目踩坑记录.md","raw":"---\ntitle: create-react-app 搭建项目踩坑记录\ndate: 2021-11-29 19:44:25\ntags: React\ncategories: 技术类-React\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n\n# 中文说明\n\n## 搭建前端开发环境笔记\n\n由`npx create-react-app articles_published_system`创建的项目\n\n后来漏掉了`typescript`支持，原本可以由命令`npx create-react-app articles_published_system --template typescript`可以直接创建支持ts的应用\n\n后续要将ts添加到已有项目中，用以下命令：\n\n`npm install --save typescript @types/node @types/react @types/react-dom @types/jest`\n\n项目中配置`sass`:\n\n1. 执行`yarn add node-sass`下载包（按理说执行`npm install node-sass --save`也应该有用，但是我这边报错了）。\n\n    报错如下：\n\n    ![npm安装sass报错](https://upload-images.jianshu.io/upload_images/13931286-44bf5ea859ce44fd.png?imageMogr2/auto-orient/strip|imageView2/2/w/672/format/webp)\n\n    我的vscode和node版本都是最新的\n\n    建议大家用`yarn`来安装项目\n\n    **发现启动后sass会报错**\n\n    解决办法：sass指定版本为`^1.43.5`，postcss-pxtorem为`^5.1.1`，不要安装node-sass了\n\n    前端生态配置仍然复杂\n\n2. 将样式文件后缀改为`.scss`并在tsx或者js文件中引入，项目会自动编译。\n\n为了实现自适应，给项目配置postcss-pxtorem\n\n1. 执行`yarn add lib-flexible postcss-pxtorem`\n\n2. 在应用入口引入`import 'lib-flexible'`\n\n3. 执行`npm run eject`可以打开`create-react-app`应用的配置文件\n\n4. 在`config/webpack.config.js`文件中配置postcss，位置及方法如下图：\n\n![引入postcss](https://upload-images.jianshu.io/upload_images/13931286-da7732a5f0bf175d.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)\n\n![配置postcss](https://upload-images.jianshu.io/upload_images/13931286-7f538e5227508fa5.png?imageMogr2/auto-orient/strip|imageView2/2/w/630/format/webp)\n\nUI库使用antdesign\n\n1. 安装antd，`yarn add antd`\n\n2. 在App.css 中导入样式`@import '~antd/dist/antd.css'`，然后在组件中引入相应的ui组件就可以用了。\n\n---\n\n完~","slug":"create-react-app-搭建项目踩坑记录","published":1,"updated":"2021-12-01T02:45:37.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18as001ucco947sx2rt6","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n\n<h1 id=\"中文说明\"><a href=\"#中文说明\" class=\"headerlink\" title=\"中文说明\"></a>中文说明</h1><h2 id=\"搭建前端开发环境笔记\"><a href=\"#搭建前端开发环境笔记\" class=\"headerlink\" title=\"搭建前端开发环境笔记\"></a>搭建前端开发环境笔记</h2><p>由<code>npx create-react-app articles_published_system</code>创建的项目</p>\n<p>后来漏掉了<code>typescript</code>支持，原本可以由命令<code>npx create-react-app articles_published_system --template typescript</code>可以直接创建支持ts的应用</p>\n<p>后续要将ts添加到已有项目中，用以下命令：</p>\n<p><code>npm install --save typescript @types/node @types/react @types/react-dom @types/jest</code></p>\n<p>项目中配置<code>sass</code>:</p>\n<ol>\n<li><p>执行<code>yarn add node-sass</code>下载包（按理说执行<code>npm install node-sass --save</code>也应该有用，但是我这边报错了）。</p>\n<p> 报错如下：</p>\n<p> <img src=\"https://upload-images.jianshu.io/upload_images/13931286-44bf5ea859ce44fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/672/format/webp\" alt=\"npm安装sass报错\"></p>\n<p> 我的vscode和node版本都是最新的</p>\n<p> 建议大家用<code>yarn</code>来安装项目</p>\n<p> <strong>发现启动后sass会报错</strong></p>\n<p> 解决办法：sass指定版本为<code>^1.43.5</code>，postcss-pxtorem为<code>^5.1.1</code>，不要安装node-sass了</p>\n<p> 前端生态配置仍然复杂</p>\n</li>\n<li><p>将样式文件后缀改为<code>.scss</code>并在tsx或者js文件中引入，项目会自动编译。</p>\n</li>\n</ol>\n<p>为了实现自适应，给项目配置postcss-pxtorem</p>\n<ol>\n<li><p>执行<code>yarn add lib-flexible postcss-pxtorem</code></p>\n</li>\n<li><p>在应用入口引入<code>import &#39;lib-flexible&#39;</code></p>\n</li>\n<li><p>执行<code>npm run eject</code>可以打开<code>create-react-app</code>应用的配置文件</p>\n</li>\n<li><p>在<code>config/webpack.config.js</code>文件中配置postcss，位置及方法如下图：</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-da7732a5f0bf175d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp\" alt=\"引入postcss\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-7f538e5227508fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp\" alt=\"配置postcss\"></p>\n<p>UI库使用antdesign</p>\n<ol>\n<li><p>安装antd，<code>yarn add antd</code></p>\n</li>\n<li><p>在App.css 中导入样式<code>@import &#39;~antd/dist/antd.css&#39;</code>，然后在组件中引入相应的ui组件就可以用了。</p>\n</li>\n</ol>\n<hr>\n<p>完~</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n\n<h1 id=\"中文说明\"><a href=\"#中文说明\" class=\"headerlink\" title=\"中文说明\"></a>中文说明</h1><h2 id=\"搭建前端开发环境笔记\"><a href=\"#搭建前端开发环境笔记\" class=\"headerlink\" title=\"搭建前端开发环境笔记\"></a>搭建前端开发环境笔记</h2><p>由<code>npx create-react-app articles_published_system</code>创建的项目</p>\n<p>后来漏掉了<code>typescript</code>支持，原本可以由命令<code>npx create-react-app articles_published_system --template typescript</code>可以直接创建支持ts的应用</p>\n<p>后续要将ts添加到已有项目中，用以下命令：</p>\n<p><code>npm install --save typescript @types/node @types/react @types/react-dom @types/jest</code></p>\n<p>项目中配置<code>sass</code>:</p>\n<ol>\n<li><p>执行<code>yarn add node-sass</code>下载包（按理说执行<code>npm install node-sass --save</code>也应该有用，但是我这边报错了）。</p>\n<p> 报错如下：</p>\n<p> <img src=\"https://upload-images.jianshu.io/upload_images/13931286-44bf5ea859ce44fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/672/format/webp\" alt=\"npm安装sass报错\"></p>\n<p> 我的vscode和node版本都是最新的</p>\n<p> 建议大家用<code>yarn</code>来安装项目</p>\n<p> <strong>发现启动后sass会报错</strong></p>\n<p> 解决办法：sass指定版本为<code>^1.43.5</code>，postcss-pxtorem为<code>^5.1.1</code>，不要安装node-sass了</p>\n<p> 前端生态配置仍然复杂</p>\n</li>\n<li><p>将样式文件后缀改为<code>.scss</code>并在tsx或者js文件中引入，项目会自动编译。</p>\n</li>\n</ol>\n<p>为了实现自适应，给项目配置postcss-pxtorem</p>\n<ol>\n<li><p>执行<code>yarn add lib-flexible postcss-pxtorem</code></p>\n</li>\n<li><p>在应用入口引入<code>import &#39;lib-flexible&#39;</code></p>\n</li>\n<li><p>执行<code>npm run eject</code>可以打开<code>create-react-app</code>应用的配置文件</p>\n</li>\n<li><p>在<code>config/webpack.config.js</code>文件中配置postcss，位置及方法如下图：</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-da7732a5f0bf175d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp\" alt=\"引入postcss\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-7f538e5227508fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp\" alt=\"配置postcss\"></p>\n<p>UI库使用antdesign</p>\n<ol>\n<li><p>安装antd，<code>yarn add antd</code></p>\n</li>\n<li><p>在App.css 中导入样式<code>@import &#39;~antd/dist/antd.css&#39;</code>，然后在组件中引入相应的ui组件就可以用了。</p>\n</li>\n</ol>\n<hr>\n<p>完~</p>\n"},{"title":"git rebase 用法","date":"2021-12-02T09:16:28.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n[参考自此文章](https://zhuanlan.zhihu.com/p/34197548)\n\n以前提交代码一直是用命令行提交的\n\n```js\n\n// 一把梭\ngit pull\ngit add .\ngit commit -m 'xxxxxx'\ngit push\n```\n\n在多人开发项目下，这样提交的话会有如下效果:\n\n![显示效果](https://upload-images.jianshu.io/upload_images/13931286-3d42d72b334fc7c7.png?imageMogr2/auto-orient/strip|imageView2/2/w/594/format/webp)\n\n![显示效果](https://upload-images.jianshu.io/upload_images/13931286-d0fb965ce204e6f4.png?imageMogr2/auto-orient/strip|imageView2/2/w/222/format/webp)\n\n当很多人都把自己的分支合到主分支的时候，这样会显得主线很乱而且还会有自动生成的提交信息\n\n**所以提倡用`git rebase`**\n\n## 使用 rebase 和 merge 的基本原则\n\n1. 下游分支更新上游分支内容的时候使用 rebase\n2. 上游分支合并下游分支内容的时候使用 merge\n3. 更新当前分支的内容时一定要使用 --rebase 参数\n\n例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 `git rebase master`\n\n等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 `git merge dev`\n\n## 实际开发中遇到操作\n\n当你和其他人在同一个分支开发时，在你提交的时候发现有人已经提交了一些东西上去了，你可以这样操作：\n\n1. `git pull --rebase`\n\n2. `git push`\n\n你也可以使用vscode上下载的git插件来操作：\n\n![vscode操作](https://upload-images.jianshu.io/upload_images/13931286-ecca9bb5bd96dc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后再push上去。\n","source":"_posts/2021-12-02-git-rebase-用法.md","raw":"---\ntitle: git rebase 用法\ndate: 2021-12-02 17:16:28\ntags: [JavaScript,面试]\ncategories: 技术类-前端\n---\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n[参考自此文章](https://zhuanlan.zhihu.com/p/34197548)\n\n以前提交代码一直是用命令行提交的\n\n```js\n\n// 一把梭\ngit pull\ngit add .\ngit commit -m 'xxxxxx'\ngit push\n```\n\n在多人开发项目下，这样提交的话会有如下效果:\n\n![显示效果](https://upload-images.jianshu.io/upload_images/13931286-3d42d72b334fc7c7.png?imageMogr2/auto-orient/strip|imageView2/2/w/594/format/webp)\n\n![显示效果](https://upload-images.jianshu.io/upload_images/13931286-d0fb965ce204e6f4.png?imageMogr2/auto-orient/strip|imageView2/2/w/222/format/webp)\n\n当很多人都把自己的分支合到主分支的时候，这样会显得主线很乱而且还会有自动生成的提交信息\n\n**所以提倡用`git rebase`**\n\n## 使用 rebase 和 merge 的基本原则\n\n1. 下游分支更新上游分支内容的时候使用 rebase\n2. 上游分支合并下游分支内容的时候使用 merge\n3. 更新当前分支的内容时一定要使用 --rebase 参数\n\n例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 `git rebase master`\n\n等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 `git merge dev`\n\n## 实际开发中遇到操作\n\n当你和其他人在同一个分支开发时，在你提交的时候发现有人已经提交了一些东西上去了，你可以这样操作：\n\n1. `git pull --rebase`\n\n2. `git push`\n\n你也可以使用vscode上下载的git插件来操作：\n\n![vscode操作](https://upload-images.jianshu.io/upload_images/13931286-ecca9bb5bd96dc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后再push上去。\n","slug":"git-rebase-用法","published":1,"updated":"2021-12-09T05:07:01.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwyi18at001xcco9e5s6g2pc","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n<p><a href=\"https://zhuanlan.zhihu.com/p/34197548\">参考自此文章</a></p>\n<p>以前提交代码一直是用命令行提交的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><br><span class=\"hljs-comment\">// 一把梭</span><br>git pull<br>git add .<br>git commit -m <span class=\"hljs-string\">&#x27;xxxxxx&#x27;</span><br>git push<br></code></pre></td></tr></table></figure>\n\n<p>在多人开发项目下，这样提交的话会有如下效果:</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-3d42d72b334fc7c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/594/format/webp\" alt=\"显示效果\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-d0fb965ce204e6f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/222/format/webp\" alt=\"显示效果\"></p>\n<p>当很多人都把自己的分支合到主分支的时候，这样会显得主线很乱而且还会有自动生成的提交信息</p>\n<p><strong>所以提倡用<code>git rebase</code></strong></p>\n<h2 id=\"使用-rebase-和-merge-的基本原则\"><a href=\"#使用-rebase-和-merge-的基本原则\" class=\"headerlink\" title=\"使用 rebase 和 merge 的基本原则\"></a>使用 rebase 和 merge 的基本原则</h2><ol>\n<li>下游分支更新上游分支内容的时候使用 rebase</li>\n<li>上游分支合并下游分支内容的时候使用 merge</li>\n<li>更新当前分支的内容时一定要使用 –rebase 参数</li>\n</ol>\n<p>例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 <code>git rebase master</code></p>\n<p>等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 <code>git merge dev</code></p>\n<h2 id=\"实际开发中遇到操作\"><a href=\"#实际开发中遇到操作\" class=\"headerlink\" title=\"实际开发中遇到操作\"></a>实际开发中遇到操作</h2><p>当你和其他人在同一个分支开发时，在你提交的时候发现有人已经提交了一些东西上去了，你可以这样操作：</p>\n<ol>\n<li><p><code>git pull --rebase</code></p>\n</li>\n<li><p><code>git push</code></p>\n</li>\n</ol>\n<p>你也可以使用vscode上下载的git插件来操作：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-ecca9bb5bd96dc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vscode操作\"></p>\n<p>然后再push上去。</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n<p><a href=\"https://zhuanlan.zhihu.com/p/34197548\">参考自此文章</a></p>\n<p>以前提交代码一直是用命令行提交的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><br><span class=\"hljs-comment\">// 一把梭</span><br>git pull<br>git add .<br>git commit -m <span class=\"hljs-string\">&#x27;xxxxxx&#x27;</span><br>git push<br></code></pre></td></tr></table></figure>\n\n<p>在多人开发项目下，这样提交的话会有如下效果:</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-3d42d72b334fc7c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/594/format/webp\" alt=\"显示效果\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-d0fb965ce204e6f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/222/format/webp\" alt=\"显示效果\"></p>\n<p>当很多人都把自己的分支合到主分支的时候，这样会显得主线很乱而且还会有自动生成的提交信息</p>\n<p><strong>所以提倡用<code>git rebase</code></strong></p>\n<h2 id=\"使用-rebase-和-merge-的基本原则\"><a href=\"#使用-rebase-和-merge-的基本原则\" class=\"headerlink\" title=\"使用 rebase 和 merge 的基本原则\"></a>使用 rebase 和 merge 的基本原则</h2><ol>\n<li>下游分支更新上游分支内容的时候使用 rebase</li>\n<li>上游分支合并下游分支内容的时候使用 merge</li>\n<li>更新当前分支的内容时一定要使用 –rebase 参数</li>\n</ol>\n<p>例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 <code>git rebase master</code></p>\n<p>等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 <code>git merge dev</code></p>\n<h2 id=\"实际开发中遇到操作\"><a href=\"#实际开发中遇到操作\" class=\"headerlink\" title=\"实际开发中遇到操作\"></a>实际开发中遇到操作</h2><p>当你和其他人在同一个分支开发时，在你提交的时候发现有人已经提交了一些东西上去了，你可以这样操作：</p>\n<ol>\n<li><p><code>git pull --rebase</code></p>\n</li>\n<li><p><code>git push</code></p>\n</li>\n</ol>\n<p>你也可以使用vscode上下载的git插件来操作：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-ecca9bb5bd96dc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vscode操作\"></p>\n<p>然后再push上去。</p>\n"},{"title":"本博客说明书","date":"2021-09-07T03:19:02.000Z","comments":1,"sticky":100,"_content":"{% blockquote %}\n幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔\n{% endblockquote %}\n\n19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。\n所以我又重新搭了一个。\n后续会把写过的文档陆续上传到这边\n本博客主要记录学习过程，技术文档以及日常。\n\n以下是功能测试：\n嵌入B站视频\n{% raw %}\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n<iframe src=\"//player.bilibili.com/player.html?aid=846655043&bvid=BV1e54y1n7XK&cid=371989206&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\"allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; Left: 0; top: 0;\"> </iframe></div>\n{% endraw %}\n\n\n代码块\n```js\nconsole.log('zouHuaLu')\nhexo g\nhexo g -w\nhexo server\nhexo clean\nhexo deploy\n```\n以后有时间弄一下评论功能\n\n---\n2021-09-23 本博客新增评论功能，支持评论啦！","source":"_posts/about-me.md","raw":"---\ntitle: 本博客说明书\ndate: 2021-09-07 11:19:02\ntags: 博客说明\ncategories: 博客说明\ncomments: true\nsticky: 100\n---\n{% blockquote %}\n幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔\n{% endblockquote %}\n\n19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。\n所以我又重新搭了一个。\n后续会把写过的文档陆续上传到这边\n本博客主要记录学习过程，技术文档以及日常。\n\n以下是功能测试：\n嵌入B站视频\n{% raw %}\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n<iframe src=\"//player.bilibili.com/player.html?aid=846655043&bvid=BV1e54y1n7XK&cid=371989206&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\"allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; Left: 0; top: 0;\"> </iframe></div>\n{% endraw %}\n\n\n代码块\n```js\nconsole.log('zouHuaLu')\nhexo g\nhexo g -w\nhexo server\nhexo clean\nhexo deploy\n```\n以后有时间弄一下评论功能\n\n---\n2021-09-23 本博客新增评论功能，支持评论啦！","slug":"about-me","published":1,"updated":"2021-09-26T02:21:21.380Z","layout":"post","photos":[],"link":"","_id":"ckwyi18au0021cco9g60o3vvc","content":"<blockquote><p>幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔</p>\n</blockquote>\n\n<p>19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。<br>所以我又重新搭了一个。<br>后续会把写过的文档陆续上传到这边<br>本博客主要记录学习过程，技术文档以及日常。</p>\n<p>以下是功能测试：<br>嵌入B站视频</p>\n\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n<iframe src=\"//player.bilibili.com/player.html?aid=846655043&bvid=BV1e54y1n7XK&cid=371989206&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\"allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; Left: 0; top: 0;\"> </iframe></div>\n\n\n\n<p>代码块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>hexo g<br>hexo g -w<br>hexo server<br>hexo clean<br>hexo deploy<br></code></pre></td></tr></table></figure>\n<p>以后有时间弄一下评论功能</p>\n<hr>\n<p>2021-09-23 本博客新增评论功能，支持评论啦！</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote><p>幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔</p>\n</blockquote>\n\n<p>19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。<br>所以我又重新搭了一个。<br>后续会把写过的文档陆续上传到这边<br>本博客主要记录学习过程，技术文档以及日常。</p>\n<p>以下是功能测试：<br>嵌入B站视频</p>\n\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n<iframe src=\"//player.bilibili.com/player.html?aid=846655043&bvid=BV1e54y1n7XK&cid=371989206&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\"allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; Left: 0; top: 0;\"> </iframe></div>\n\n\n\n<p>代码块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>hexo g<br>hexo g -w<br>hexo server<br>hexo clean<br>hexo deploy<br></code></pre></td></tr></table></figure>\n<p>以后有时间弄一下评论功能</p>\n<hr>\n<p>2021-09-23 本博客新增评论功能，支持评论啦！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckwyi189u0001cco93scza3x6","category_id":"ckwyi189z0004cco94lns2k9t","_id":"ckwyi18a8000fcco969gt7rfk"},{"post_id":"ckwyi189x0003cco923593e7i","category_id":"ckwyi189z0004cco94lns2k9t","_id":"ckwyi18aa000kcco9dq0p1jmp"},{"post_id":"ckwyi18a10006cco90b766yaz","category_id":"ckwyi18a8000ecco96nwngfxi","_id":"ckwyi18ae000tcco92r7acxmp"},{"post_id":"ckwyi18aa000ncco9e65dchue","category_id":"ckwyi18aa000lcco96qn98lrd","_id":"ckwyi18af000wcco9c48y7azt"},{"post_id":"ckwyi18a20007cco9cmmreqv1","category_id":"ckwyi18aa000lcco96qn98lrd","_id":"ckwyi18ag0010cco95hpj6tca"},{"post_id":"ckwyi18ab000pcco9eyj40fqc","category_id":"ckwyi18aa000lcco96qn98lrd","_id":"ckwyi18ah0013cco95nbz72u1"},{"post_id":"ckwyi18a30008cco915lpbzn8","category_id":"ckwyi18ad000qcco90inga8h8","_id":"ckwyi18ai0017cco9bb3r5qbj"},{"post_id":"ckwyi18af000zcco9736fedpt","category_id":"ckwyi18a8000ecco96nwngfxi","_id":"ckwyi18ak001ccco9c9cw8nij"},{"post_id":"ckwyi18a6000ccco9dqjugx7a","category_id":"ckwyi18af000xcco95ai2hg2p","_id":"ckwyi18al001gcco97rr2e11n"},{"post_id":"ckwyi18aj001acco91u309k4e","category_id":"ckwyi18aa000lcco96qn98lrd","_id":"ckwyi18ap001jcco99siw6n4y"},{"post_id":"ckwyi18a7000dcco9b0exde1p","category_id":"ckwyi18aa000lcco96qn98lrd","_id":"ckwyi18aq001occo9d0ys2lsv"},{"post_id":"ckwyi18aj001bcco9dpi92cl1","category_id":"ckwyi18aa000lcco96qn98lrd","_id":"ckwyi18ar001rcco90b1d3jjg"},{"post_id":"ckwyi18al001fcco9ctoihqv3","category_id":"ckwyi18aa000lcco96qn98lrd","_id":"ckwyi18as001vcco94tf4e88l"},{"post_id":"ckwyi18a8000icco9guboe1lw","category_id":"ckwyi18af000xcco95ai2hg2p","_id":"ckwyi18at001ycco9b9sibnpv"},{"post_id":"ckwyi18am001icco9237qf4l5","category_id":"ckwyi18aa000lcco96qn98lrd","_id":"ckwyi18av0022cco9ahmy1r4c"},{"post_id":"ckwyi18a9000jcco90hyi0lsv","category_id":"ckwyi18aa000lcco96qn98lrd","_id":"ckwyi18av0024cco9d2tb7y9e"},{"post_id":"ckwyi18aq001qcco9h5hcexsk","category_id":"ckwyi18a8000ecco96nwngfxi","_id":"ckwyi18aw0028cco92gd55fu7"},{"post_id":"ckwyi18ad000scco91hty5onj","category_id":"ckwyi18ar001scco91rbj3ave","_id":"ckwyi18aw0029cco9hc0sbcgz"},{"post_id":"ckwyi18at001xcco9e5s6g2pc","category_id":"ckwyi18aa000lcco96qn98lrd","_id":"ckwyi18ax002ccco90c70arbr"},{"post_id":"ckwyi18ae000vcco9dgjf77md","category_id":"ckwyi18af000xcco95ai2hg2p","_id":"ckwyi18ax002ecco9dp7acv9g"},{"post_id":"ckwyi18ag0012cco98yop5uz3","category_id":"ckwyi18av0025cco90xx2a7tv","_id":"ckwyi18ay002icco92v9l4pb9"},{"post_id":"ckwyi18ah0015cco9285bb692","category_id":"ckwyi18ar001scco91rbj3ave","_id":"ckwyi18ay002jcco90eg793sh"},{"post_id":"ckwyi18aq001ncco992u4cpfg","category_id":"ckwyi18ax002fcco922081s15","_id":"ckwyi18az002occo96tzih0oi"},{"post_id":"ckwyi18as001ucco947sx2rt6","category_id":"ckwyi18ay002kcco945902y8p","_id":"ckwyi18b0002scco9g0x580w6"},{"post_id":"ckwyi18au0021cco9g60o3vvc","category_id":"ckwyi18az002pcco9dlti1ibl","_id":"ckwyi18b0002vcco93f94fpjp"}],"PostTag":[{"post_id":"ckwyi189u0001cco93scza3x6","tag_id":"ckwyi18a00005cco9g5rf9bq3","_id":"ckwyi18a6000bcco927ll45mx"},{"post_id":"ckwyi189x0003cco923593e7i","tag_id":"ckwyi18a00005cco9g5rf9bq3","_id":"ckwyi18a8000hcco9dt9ehy14"},{"post_id":"ckwyi18a10006cco90b766yaz","tag_id":"ckwyi18a8000gcco92b9w73v9","_id":"ckwyi18ab000occo9g2l8327g"},{"post_id":"ckwyi18a20007cco9cmmreqv1","tag_id":"ckwyi18aa000mcco9eyza41wv","_id":"ckwyi18ae000ucco975dvazl6"},{"post_id":"ckwyi18a30008cco915lpbzn8","tag_id":"ckwyi18ad000rcco9alq1bvzz","_id":"ckwyi18ag0011cco93ecr233q"},{"post_id":"ckwyi18af000zcco9736fedpt","tag_id":"ckwyi18a8000gcco92b9w73v9","_id":"ckwyi18ah0014cco914yc81qe"},{"post_id":"ckwyi18a6000ccco9dqjugx7a","tag_id":"ckwyi18af000ycco9eeo6fdvu","_id":"ckwyi18aj0019cco9dnhcghlv"},{"post_id":"ckwyi18a7000dcco9b0exde1p","tag_id":"ckwyi18ai0018cco96f9u6gv5","_id":"ckwyi18al001hcco91d0i90zy"},{"post_id":"ckwyi18al001fcco9ctoihqv3","tag_id":"ckwyi18ai0018cco96f9u6gv5","_id":"ckwyi18aq001mcco905t462az"},{"post_id":"ckwyi18a8000icco9guboe1lw","tag_id":"ckwyi18af000ycco9eeo6fdvu","_id":"ckwyi18aq001pcco970t7bwhs"},{"post_id":"ckwyi18aq001qcco9h5hcexsk","tag_id":"ckwyi18a8000gcco92b9w73v9","_id":"ckwyi18as001wcco9hl1tbish"},{"post_id":"ckwyi18a9000jcco90hyi0lsv","tag_id":"ckwyi18ai0018cco96f9u6gv5","_id":"ckwyi18av0023cco9dmkcbfz6"},{"post_id":"ckwyi18a9000jcco90hyi0lsv","tag_id":"ckwyi18ar001tcco955o3cgj2","_id":"ckwyi18aw0026cco909ao92y6"},{"post_id":"ckwyi18aa000ncco9e65dchue","tag_id":"ckwyi18ai0018cco96f9u6gv5","_id":"ckwyi18ax002dcco90zz19vkn"},{"post_id":"ckwyi18aa000ncco9e65dchue","tag_id":"ckwyi18aw0027cco9hf5u9ltg","_id":"ckwyi18ax002gcco9f0b070kh"},{"post_id":"ckwyi18ab000pcco9eyj40fqc","tag_id":"ckwyi18ai0018cco96f9u6gv5","_id":"ckwyi18az002mcco9gk1carnm"},{"post_id":"ckwyi18ab000pcco9eyj40fqc","tag_id":"ckwyi18aw0027cco9hf5u9ltg","_id":"ckwyi18az002ncco94wgddcla"},{"post_id":"ckwyi18ad000scco91hty5onj","tag_id":"ckwyi18ay002lcco90cca9942","_id":"ckwyi18b0002rcco99r3uhah6"},{"post_id":"ckwyi18ae000vcco9dgjf77md","tag_id":"ckwyi18af000ycco9eeo6fdvu","_id":"ckwyi18b0002ucco90hpc1fov"},{"post_id":"ckwyi18ag0012cco98yop5uz3","tag_id":"ckwyi18b0002tcco9endbeaip","_id":"ckwyi18b1002ycco94ww5gn41"},{"post_id":"ckwyi18ag0012cco98yop5uz3","tag_id":"ckwyi18b0002wcco9h938egoi","_id":"ckwyi18b1002zcco9clgc0cmp"},{"post_id":"ckwyi18ah0015cco9285bb692","tag_id":"ckwyi18ay002lcco90cca9942","_id":"ckwyi18b10031cco9a7qm29ii"},{"post_id":"ckwyi18aj001acco91u309k4e","tag_id":"ckwyi18ai0018cco96f9u6gv5","_id":"ckwyi18b20033cco95eb40g5e"},{"post_id":"ckwyi18aj001acco91u309k4e","tag_id":"ckwyi18aw0027cco9hf5u9ltg","_id":"ckwyi18b20034cco9ezzhhd8n"},{"post_id":"ckwyi18aj001bcco9dpi92cl1","tag_id":"ckwyi18ai0018cco96f9u6gv5","_id":"ckwyi18b20036cco9713pciwl"},{"post_id":"ckwyi18aj001bcco9dpi92cl1","tag_id":"ckwyi18aw0027cco9hf5u9ltg","_id":"ckwyi18b20037cco92xj59wq0"},{"post_id":"ckwyi18am001icco9237qf4l5","tag_id":"ckwyi18ai0018cco96f9u6gv5","_id":"ckwyi18b20039cco9f6yx8dys"},{"post_id":"ckwyi18am001icco9237qf4l5","tag_id":"ckwyi18aw0027cco9hf5u9ltg","_id":"ckwyi18b2003acco951ivb64x"},{"post_id":"ckwyi18aq001ncco992u4cpfg","tag_id":"ckwyi18b20038cco998eu3gwx","_id":"ckwyi18b3003ccco990hkcf9q"},{"post_id":"ckwyi18as001ucco947sx2rt6","tag_id":"ckwyi18b2003bcco92awo0oqj","_id":"ckwyi18b3003ecco959vze0ly"},{"post_id":"ckwyi18at001xcco9e5s6g2pc","tag_id":"ckwyi18ai0018cco96f9u6gv5","_id":"ckwyi18b3003gcco973mogdyk"},{"post_id":"ckwyi18at001xcco9e5s6g2pc","tag_id":"ckwyi18aw0027cco9hf5u9ltg","_id":"ckwyi18b3003hcco95l7k8dz3"},{"post_id":"ckwyi18au0021cco9g60o3vvc","tag_id":"ckwyi18b3003fcco9fkoo5q6r","_id":"ckwyi18b4003icco98vhucf1d"}],"Tag":[{"name":"TypeScript","_id":"ckwyi18a00005cco9g5rf9bq3"},{"name":"日常","_id":"ckwyi18a8000gcco92b9w73v9"},{"name":"课程","_id":"ckwyi18aa000mcco9eyza41wv"},{"name":"阅读","_id":"ckwyi18ad000rcco9alq1bvzz"},{"name":"Vue3","_id":"ckwyi18af000ycco9eeo6fdvu"},{"name":"JavaScript","_id":"ckwyi18ai0018cco96f9u6gv5"},{"name":"ES6","_id":"ckwyi18ar001tcco955o3cgj2"},{"name":"面试","_id":"ckwyi18aw0027cco9hf5u9ltg"},{"name":"计算机基础","_id":"ckwyi18ay002lcco90cca9942"},{"name":"算法","_id":"ckwyi18b0002tcco9endbeaip"},{"name":"leetcode","_id":"ckwyi18b0002wcco9h938egoi"},{"name":"Node.js","_id":"ckwyi18b20038cco998eu3gwx"},{"name":"React","_id":"ckwyi18b2003bcco92awo0oqj"},{"name":"博客说明","_id":"ckwyi18b3003fcco9fkoo5q6r"}]}}
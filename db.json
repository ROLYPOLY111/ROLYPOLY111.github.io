{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":1,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/20210913/renshengdezhihui.png","path":"img/20210913/renshengdezhihui.png","modified":1,"renderable":0},{"_id":"source/img/20210913/renshengdezhihui2.png","path":"img/20210913/renshengdezhihui2.png","modified":1,"renderable":0},{"_id":"source/img/20210911/AirPods.jpeg","path":"img/20210911/AirPods.jpeg","modified":1,"renderable":0},{"_id":"source/img/20210911/pic1.jpeg","path":"img/20210911/pic1.jpeg","modified":1,"renderable":0},{"_id":"source/img/20210911/pic2.jpeg","path":"img/20210911/pic2.jpeg","modified":1,"renderable":0},{"_id":"source/img/20210911/图片.jpeg","path":"img/20210911/图片.jpeg","modified":1,"renderable":0},{"_id":"source/img/bg/benjamin.jpeg","path":"img/bg/benjamin.jpeg","modified":1,"renderable":0},{"_id":"source/img/bg/bg1.jpg","path":"img/bg/bg1.jpg","modified":1,"renderable":0},{"_id":"source/img/bg/bg2.jpg","path":"img/bg/bg2.jpg","modified":1,"renderable":0},{"_id":"source/img/bg/bg3.jpg","path":"img/bg/bg3.jpg","modified":1,"renderable":0},{"_id":"source/img/bg/shashou.jpeg","path":"img/bg/shashou.jpeg","modified":1,"renderable":0},{"_id":"source/img/bg/bg4.jpg","path":"img/bg/bg4.jpg","modified":1,"renderable":0},{"_id":"source/img/bg/tianruoyouqing.jpeg","path":"img/bg/tianruoyouqing.jpeg","modified":1,"renderable":0},{"_id":"source/img/bg/zhimingyuchunjiao.jpeg","path":"img/bg/zhimingyuchunjiao.jpeg","modified":1,"renderable":0},{"_id":"source/img/user/jianshu.jpeg","path":"img/user/jianshu.jpeg","modified":1,"renderable":0},{"_id":"source/img/user/bilibili.jpeg","path":"img/user/bilibili.jpeg","modified":1,"renderable":0},{"_id":"source/img/user/user.jpg","path":"img/user/user.jpg","modified":1,"renderable":0},{"_id":"source/img/user/user1.png","path":"img/user/user1.png","modified":1,"renderable":0},{"_id":"source/img/user/wazi.png","path":"img/user/wazi.png","modified":1,"renderable":0},{"_id":"source/img/user/weChat.jpg","path":"img/user/weChat.jpg","modified":1,"renderable":0},{"_id":"source/img/user/webo.jpg","path":"img/user/webo.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"61e7919ef45b0fd313fcb2de41b7021f7ccbf47b","modified":1632386175708},{"_id":"source/baidu_verify_code-TmkkRxX4ps.html","hash":"59ea65a0795dc0964e8b356cb89b666fef6e1a53","modified":1631151814047},{"_id":"source/_posts/2021-09-11-浮生一日.md","hash":"4e376a776914285e79b16f7ed280aa665bc2e399","modified":1637226056110},{"_id":"source/.DS_Store","hash":"19332cfdf39a2776f27d87208af7b99819d9425f","modified":1631151814046},{"_id":"source/_posts/2021-09-09-TypeScript中类的理解.md","hash":"e308ebb054af702062bc20534344f00c6492f4d0","modified":1631172900949},{"_id":"source/_posts/2021-09-10-TypeScript中函数的理解.md","hash":"8e9a73fcd541ec49244f4ada6837c61b75fc514c","modified":1631264607141},{"_id":"source/_posts/2021-09-12-web设计模式解析与实战.md","hash":"a2e136a9f1ebcf90b76fabfef8b612977643e296","modified":1633662665384},{"_id":"source/_posts/2021-09-23-JavaScript中的堆栈以及数据类型.md","hash":"e7c9c240e305fe5035f67d19cdf4f86ae6134798","modified":1643086810989},{"_id":"source/_posts/2021-09-23-export与export-default的区别.md","hash":"68e9ae7e85c15405af92819f3a387b0151b4e744","modified":1633662682166},{"_id":"source/_posts/2021-09-23-Vue自定义全局组件.md","hash":"4698d7ba81c3877bcdb830c5c89c7f45d85dfd84","modified":1632363995030},{"_id":"source/_posts/2021-09-15-vue3文档记录.md","hash":"bac16fa39b89ee7aeec60e0af9c56918626e6973","modified":1631875319128},{"_id":"source/_posts/2021-09-23-new操作符的实现.md","hash":"b6297324ae74d5ab10044772892d13c71d2639cf","modified":1634114529247},{"_id":"source/_posts/2021-09-25-Vue3-一.md","hash":"730ddef00fc1e6cc6e99bca9030d25606eceeae2","modified":1632622598702},{"_id":"source/_posts/2021-09-27-leetcode每日算法（2021-09-27）.md","hash":"f7e14949d403275c20510271dd8a66b2c215de62","modified":1632795852490},{"_id":"source/_posts/2021-09-23-栈与队列的理解以及应用场景.md","hash":"573d157b3f6e4893bc6b52f902359015f2775c59","modified":1643081625703},{"_id":"source/_posts/2021-09-25-浮生一日-最爱的电影.md","hash":"e612bb2181f870bfe3801fb6e7ce1311325433e5","modified":1637226036337},{"_id":"source/_posts/2021-09-23-原型与原型链与constructor.md","hash":"ddb4f9a166f6984c606ee229730e4e71737facfd","modified":1634114746967},{"_id":"source/_posts/2021-10-08-互联网是如何运作的.md","hash":"d3cf0f5d9e7b19f6424a5ae2d58fe62930e62506","modified":1634114812438},{"_id":"source/_posts/2021-10-21-call-apply和bind.md","hash":"e7fcd5d36896e1689ba0aaacf7c04e0b031b3f56","modified":1634787472895},{"_id":"source/_posts/2021-10-13-深入理解javascript之typeof和instanceof.md","hash":"044e49afac8ab1c0408c33fdf18b66ffb095017c","modified":1634114593089},{"_id":"source/_posts/2021-10-20-Array数组的一些发现.md","hash":"4d6c682e18cf90e29724fdbc3904eb72b8864c6d","modified":1634710421777},{"_id":"source/_posts/2021-11-18-最近在忙什么.md","hash":"f2eef784f860ee06371961c94dc59c550645d7d4","modified":1637226366763},{"_id":"source/_posts/2021-10-14-JavaScript事件循环.md","hash":"70be1cfb50b0216a0bc5034b61a9e4b749f1ecf1","modified":1634183479548},{"_id":"source/_posts/2021-11-29-create-react-app-搭建项目踩坑记录.md","hash":"d44bce72342515a1ee7b5476592a9e631dc661ad","modified":1638326737400},{"_id":"source/_posts/2021-10-31-Node-js学习记录.md","hash":"dae264bac4588af7da26fa805560e107b958b843","modified":1640160656079},{"_id":"source/_posts/2021-12-22-React搭配Mobx开发.md","hash":"83b5f42798391338ac4528f7d8a0616c5d202e95","modified":1640160479333},{"_id":"source/_posts/2021-12-02-git-rebase-用法.md","hash":"41d820f62201b49008674d250cec0215f4b329a7","modified":1639026421370},{"_id":"source/_posts/2021-12-18-React随笔.md","hash":"7d63dc94edb3350d6cd58d468770b9952cabb5e6","modified":1642127661945},{"_id":"source/_posts/2021-12-23-2021-12-23-每日TODO.md","hash":"d2c0c684aa90e1d057b55557db6f15a1ca9aa724","modified":1640936038749},{"_id":"source/_posts/2022-01-07-Vue随笔.md","hash":"1cf866ba4c8086f6f5af81bf342b2e614a3b51b6","modified":1642583675674},{"_id":"source/_posts/2021-12-14-JavaScript的同步与异步.md","hash":"e7b31be549dafd7e4d6737e2a86f64644c823164","modified":1639468260182},{"_id":"source/_posts/2021-12-23-装饰器的使用.md","hash":"87e0e0dbf6804813bd6afaa2af3551e313edab97","modified":1640251221429},{"_id":"source/_posts/2022-01-27-数据结构与算法.md","hash":"5ed52409ee0419db9f0e9d7bb64f067bc2fc1fc4","modified":1643263481281},{"_id":"source/_posts/2022-01-11-浏览器相关面试知识点.md","hash":"970b445153b2085384112c15b06c6b61bdd010f5","modified":1641881420846},{"_id":"source/_posts/2022-01-19-vue-router随笔.md","hash":"5660078b2b2627323bdca2d0ae142025dbf68d22","modified":1642584457718},{"_id":"source/about/index.md","hash":"da13c928b0ca79459517b9021f9fa5e4b5db83bf","modified":1641883208986},{"_id":"source/_posts/2022-01-27-数据结构与算法/线性表的分类.jpg","hash":"34ab8cc42350327a8f8325f841115caa29253dfd","modified":1643252792205},{"_id":"source/_posts/about-me.md","hash":"7ce3bdd9978dd3a10d5d307770cc91ced5b41502","modified":1632622881380},{"_id":"source/_posts/2022-01-14-ES6随笔.md","hash":"d0db57a95d7dc21f0d6b050609f26261e95904ff","modified":1642141204172},{"_id":"source/img/.DS_Store","hash":"9ce77c9f9c098f72174548c7e3ec2e4a75e20803","modified":1631703679023},{"_id":"source/img/user/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1631703679061},{"_id":"source/img/bg/zhimingyuchunjiao.jpeg","hash":"03f9c96b520c0976c03c5bc45901b0c0e64b1c4d","modified":1631703679058},{"_id":"source/img/user/jianshu.jpeg","hash":"e3f77ae1071b74c68f0a7237850a3dc7a41a9936","modified":1631012709659},{"_id":"source/img/user/wazi.png","hash":"a6489d50d8b4fa846cbfd4ae094897586f5b5d76","modified":1636023241685},{"_id":"source/img/20210911/AirPods.jpeg","hash":"8601c573436498d33b4016f948869ad8de42c543","modified":1631703679024},{"_id":"source/img/20210911/pic1.jpeg","hash":"dc36460fc6f228a5f85c9906359a3e777ec4f9ea","modified":1631703679026},{"_id":"source/img/bg/bg1.jpg","hash":"026a9e6ef05b063cf0c62142634d092b5e7015db","modified":1636078423569},{"_id":"source/img/bg/benjamin.jpeg","hash":"83c5636568ee5c2fe4602edf4a418414d242d155","modified":1631703679054},{"_id":"source/img/bg/tianruoyouqing.jpeg","hash":"c03c2d638c9858b48791019759e06f54c57f3730","modified":1631703679057},{"_id":"source/img/bg/bg4.jpg","hash":"e766eb50706a9f2a10fc25ba479bfb7944cfb9dc","modified":1636078507472},{"_id":"source/img/user/user.jpg","hash":"5a1c8f2385741605649bacf36bfe84f3d0b7983a","modified":1631012709660},{"_id":"source/img/20210911/图片.jpeg","hash":"ce86726a54981795d8a5f6cc166af0b2ed050afb","modified":1631703679030},{"_id":"source/img/bg/bg2.jpg","hash":"4df0a1e43accbb1a2c5fa6e2c26e324d7c280499","modified":1636078502399},{"_id":"source/img/user/weChat.jpg","hash":"1c490e9ab2206003f6d84446bf8dc347b2d416ef","modified":1631012709662},{"_id":"source/img/user/bilibili.jpeg","hash":"2a1493d349d20f5b682a43639104ceeda3734ba1","modified":1631012709659},{"_id":"source/img/20210911/pic2.jpeg","hash":"e66ac1c464555050a5e57d610d41df3ea2300772","modified":1631703679028},{"_id":"source/img/bg/bg3.jpg","hash":"43ea9f0ae1c75b0edf7623cb0ff57fbc545fe3c5","modified":1636078505270},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"dac9d10d95b9e179e8cd7c439300b450db51f0c2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"76c2cf56f16dccb2fc057977f9dd7b39800a5cb4","modified":1630999001319},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"6cbd88a2ef9dd2198d72ccc1899c4966ac5f49f9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"a154785aef120988d29409847977f24069d3a3d5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"9d6ff8772bf54d7458ae4e846e5a2d1f2921b8a7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"19c6db0ccebc8f59fa4ef9567a066b33223eccd6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/gulpfile.js","hash":"a7c87a83becf7080bddd14e81a6f09ce8c3df109","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"523b9db3801ca892124502c17d72864457cc4b21","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"8723aa57f61134a2c1dc84cc7ea88ea366f4fda3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"6ec30a9dd56341590af07f4227324f619025c109","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"cdcb607f1104543a42beda647f3c9cf0f3d11623","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"39e63b3e1502803c9e8ea0c44ea662a7bbe15744","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"9328ebe2abbe00f82cd6f701230e80e04618ade0","modified":1631093425550},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"245f49aad0e4124b52aa82d981281ad9c871f1f8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"3e0fa1731b6e54dbcf52ccf8e200e83dc4549bfa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"b3d93135d9ae74f006da31ec54343308bbd77cb5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"606131cb807846bf43776a9073fcc1473d359ec9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/lint.yaml","hash":"64d521c9c5b61d3a4852c74894fb574082dc7009","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"cc712fc71bf33d561e1ba74fe1d52d2353092171","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"bf00f5786bb8de7241f635455b67243d26656222","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"342b1fbc30d1465687ce389a4e07f967266d5d86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"9d492fab9c26311ad0ab553c890e09b9575a76f2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"725a1fe23c672fca87edc57739b748c3adf705da","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"fb4502fc9204284f8b4e8dabde8477d478e826e5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"ffe08e76c9ebd4fc27715b8a60f385b3f10d0348","modified":1631097677877},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"9238063c5e2928bb6fce2b99cd25ad85e78c4d1c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"5b61661fbc65752f54f99402077dbb03044149a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"ab71df2e56b60e8e193ff827e81704e5b358a977","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"deed966f38cf0c8dee3f72e5b1f2e878510db0e1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"a2d08e3b9f98b6371b2e64d664f079c99571494b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"26d29403d8ecb0b533e63bde3ca73b2c91f171ff","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"32fb938d72b2d86159cb315a98b086bd17fa4415","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"dabd87267d60240c0daea0f35a46f30ee1b2337a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"4c6fffc6d4a3b8830931800ee7da99dccf1be36e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"ad7dcc8a060d94d3c44ca5e0788a24ca38be0f79","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"3a6b4f8a29648d9d2c1e99b52a7b42df3f15cf62","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"766fcf017deb4c8b0c260ac4c8d2e3489407ad89","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"35539a1ce8476e75515015a06d01ec66e4af6834","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"461d609a802a4f9aa9f492411ed8074813a956b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"b7985ac3cff9ee2722db43ee6b32b5484c43f5f2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"source/img/20210913/renshengdezhihui.png","hash":"7981415b28a16c4ac3fc282c53b488c779a7eacc","modified":1631703679039},{"_id":"source/img/20210913/renshengdezhihui2.png","hash":"b217a9b7523a7300876a97bf32959f678794ed38","modified":1631703679053},{"_id":"source/img/user/user1.png","hash":"de768c0d778b4ce91d17a4fa6643fcdaecc0d960","modified":1633664711410},{"_id":"source/img/user/webo.jpg","hash":"e13a0af612e0944a2014104058242b4fbebe8e56","modified":1631012709670},{"_id":"source/img/bg/shashou.jpeg","hash":"b6fccd7c1c535c73c3f374583d0bd26daa84874a","modified":1632362634037},{"_id":"public/baidu_verify_code-TmkkRxX4ps.html","hash":"e38c85c4546a055dfa8e38926f8b25a657ab1c3d","modified":1643263494525},{"_id":"public/baidu_urls.txt","hash":"6c21f48a21829db910a012b3336ce8068bc32130","modified":1643263494525},{"_id":"public/baidusitemap.xml","hash":"3c4fbdae436a16a48c08dc4fcfb92b4228ae2230","modified":1643263494525},{"_id":"public/content.json","hash":"6ae429d30a03036faf7392ea5b6a2262956fbcc6","modified":1643263494525},{"_id":"public/sitemap.xml","hash":"81fd0e60adb17dc2562977c4c88d6869c4cc6f14","modified":1643263494525},{"_id":"public/local-search.xml","hash":"54ddd1804f94fd71cf8dc2f8b3465ee846769e20","modified":1643263494525},{"_id":"public/about/index.html","hash":"3b16fcc41a47798df7927e58ebac7456b94ea1d3","modified":1643263494525},{"_id":"public/20211223/2021-12-23-每日TODO/index.html","hash":"ccf9b09adc0384d25bf6a059689eb7fbd2027ac5","modified":1643263494525},{"_id":"public/20211222/React搭配Mobx开发/index.html","hash":"4207a0928edd849cbd9621c8642c1092c1c1aaeb","modified":1643263494525},{"_id":"public/20211118/最近在忙什么/index.html","hash":"907895da477f42e0c1000b436a162f6f97110ec1","modified":1643263494525},{"_id":"public/20210925/浮生一日-最爱的电影/index.html","hash":"ea8b7ac4927abbc8910427609ed2e0a660f98032","modified":1643263494525},{"_id":"public/20210916/Vue3-一/index.html","hash":"55d1a08a886b0f37826cdc2597eeca83602e214f","modified":1643263494525},{"_id":"public/20210911/浮生一日/index.html","hash":"877813fb8abbaef1730b13482f8872fd4e9957ff","modified":1643263494525},{"_id":"public/archives/index.html","hash":"8155ab4166b74217bbc71ef18c0586f9e0841cb0","modified":1643263494525},{"_id":"public/archives/page/2/index.html","hash":"7236b0170a26294a54bc672ce3955f254cf932e1","modified":1643263494525},{"_id":"public/archives/page/3/index.html","hash":"93ba4f64b0cb558b43dfde8840c67487eb222434","modified":1643263494525},{"_id":"public/archives/page/4/index.html","hash":"ec26425eb5162f1201f6b19b6f933fa141fb654d","modified":1643263494525},{"_id":"public/archives/2021/index.html","hash":"01783ce408fb7d8eb872033b396278e393bf59e4","modified":1643263494525},{"_id":"public/archives/2021/page/2/index.html","hash":"038ce644c6e8f4f2ea796c955606c5b241a1e8cd","modified":1643263494525},{"_id":"public/archives/2021/page/3/index.html","hash":"e8eca5e49987650bbd49357673b39bc4cf3a01de","modified":1643263494525},{"_id":"public/archives/2021/06/index.html","hash":"cd90bd2d45fa95a0ae6075eae368d4b0e66174d3","modified":1643263494525},{"_id":"public/archives/2021/07/index.html","hash":"016f2945bd940210a65ec7ae460b7012c3d930dc","modified":1643263494525},{"_id":"public/archives/2021/09/index.html","hash":"b1c94c7f14aafd9029695a6d845bd8334160fa79","modified":1643263494525},{"_id":"public/archives/2021/10/index.html","hash":"4bdc7b9449b9f67ecd957144d80242c527d2bc27","modified":1643263494525},{"_id":"public/archives/2021/11/index.html","hash":"1fdb6cbebea2e139511fcac6e4f1b8d7996641b4","modified":1643263494525},{"_id":"public/archives/2021/12/index.html","hash":"542956e704c56c08e4b9fb3d414636bc07ab3885","modified":1643263494525},{"_id":"public/archives/2022/index.html","hash":"291098cb08dea0395442a750b41293fb8bb138b4","modified":1643263494525},{"_id":"public/archives/2022/01/index.html","hash":"291098cb08dea0395442a750b41293fb8bb138b4","modified":1643263494525},{"_id":"public/categories/技术类-TypeScript/index.html","hash":"d83640cf40f954d99d4285473a48922338fdf17f","modified":1643263494525},{"_id":"public/categories/日常/index.html","hash":"7c27f8b86b65561ad62c09c3d18c461ca4e00874","modified":1643263494525},{"_id":"public/categories/技术类-前端/index.html","hash":"01e862a7b6027001524e97e9c7a2876c04d5b4b0","modified":1643263494525},{"_id":"public/categories/技术类-前端/page/2/index.html","hash":"c5765d6ef1f5ac54af80e375f0d7cf3747b9c343","modified":1643263494525},{"_id":"public/categories/技术类-Vue/index.html","hash":"316eee7d49c4f32603f28d29b176b30c3ba4dd72","modified":1643263494525},{"_id":"public/categories/计算机基础/index.html","hash":"4a16523fac259ce3840618d0a8c9272d711a21ae","modified":1643263494525},{"_id":"public/categories/算法类/index.html","hash":"c1a1044da92746e01590388f9b8c4bf358879425","modified":1643263494525},{"_id":"public/categories/技术类-Node-js/index.html","hash":"f2d3cf31c6a075171d984ba3a3e254e19389729e","modified":1643263494525},{"_id":"public/categories/技术类-React/index.html","hash":"820e003d3664b38cd93c4c79dcf87d52f9e32a6a","modified":1643263494525},{"_id":"public/categories/博客说明/index.html","hash":"cba9994d6035805d7d6233545c348fde74716040","modified":1643263494525},{"_id":"public/tags/TypeScript/index.html","hash":"3c024ba17c5703410ed6bf5d974369137e7d8ada","modified":1643263494525},{"_id":"public/tags/日常/index.html","hash":"af91a66b44910e3c533a74ab84d9ff282a54631f","modified":1643263494525},{"_id":"public/tags/课程/index.html","hash":"73105c924ed7ffe5843e5dbb0e76628a8870b670","modified":1643263494525},{"_id":"public/tags/Vue3/index.html","hash":"3ba70907400c295d7fab9caf51391b1ac701e7b4","modified":1643263494525},{"_id":"public/tags/JavaScript/index.html","hash":"39bcf746bdf4d11df89764166f48d73316881c1a","modified":1643263494525},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"8e13eca4c68f3551399b20acab9e31daf4ad3834","modified":1643263494525},{"_id":"public/tags/ES6/index.html","hash":"25c87c26c147ae3e919354f4dd30c71993ef5417","modified":1643263494525},{"_id":"public/tags/面试/index.html","hash":"1c1e4355184176c3d06942fb483dc1b8df54f562","modified":1643263494525},{"_id":"public/tags/面试/page/2/index.html","hash":"23c57d5136ac6fafafd33c4255b53171b000bfd3","modified":1643263494525},{"_id":"public/tags/计算机基础/index.html","hash":"f1184f3972b96670b148e0f76982177b4116314c","modified":1643263494525},{"_id":"public/tags/算法/index.html","hash":"c502edad7b9b84398c752121454f2162bdbce012","modified":1643263494525},{"_id":"public/tags/leetcode/index.html","hash":"66ea35200cb82aaf3c52aecca344817571e58d5b","modified":1643263494525},{"_id":"public/tags/Node-js/index.html","hash":"b78e4f5932d7da7bb790078c238e1c558b47430f","modified":1643263494525},{"_id":"public/tags/React/index.html","hash":"337936d47dc8148d8e470f395080aeaf350489d3","modified":1643263494525},{"_id":"public/tags/TODO/index.html","hash":"c2b8e490d751adde5781beaa04cdd707034ccc02","modified":1643263494525},{"_id":"public/tags/Vue/index.html","hash":"aa255419dec99bd97d4decd4d70c520e36327be4","modified":1643263494525},{"_id":"public/tags/博客说明/index.html","hash":"1174372be01cbe748ebd586bac36bcb1cba461f4","modified":1643263494525},{"_id":"public/404.html","hash":"1fd6d165449d44413244035a81cc18e6ab58a4bd","modified":1643263494525},{"_id":"public/tags/index.html","hash":"bdc6ac12489dc569e1273f3d71855c8170b2f4f3","modified":1643263494525},{"_id":"public/links/index.html","hash":"14efdca0ff1483564972317b55a5a0155f950e79","modified":1643263494525},{"_id":"public/20220127/数据结构与算法/index.html","hash":"1dccd081e9914f4c7684d00514c3a028e20975ab","modified":1643263494525},{"_id":"public/20220119/vue-router随笔/index.html","hash":"3a2fd22cf74844c34175d0f0f04d4ed6959d05fc","modified":1643263494525},{"_id":"public/20220114/ES6随笔/index.html","hash":"6540fa2ffdc376605a25dd9b0949b1e0226e20ab","modified":1643263494525},{"_id":"public/20220111/浏览器相关面试知识点/index.html","hash":"5fa414a5574e08acd8b50647b9d6d0d9911b0469","modified":1643263494525},{"_id":"public/20220107/Vue随笔/index.html","hash":"0bceba6808914a0bed760c69ec79d47e179c37bb","modified":1643263494525},{"_id":"public/20211223/装饰器的使用/index.html","hash":"fd478e5e8bf39f57690b6a795f74c93a81592167","modified":1643263494525},{"_id":"public/20211218/React随笔/index.html","hash":"830dbc6ced8ac2d92449b20ef106d986a670f3d4","modified":1643263494525},{"_id":"public/20211214/JavaScript的同步与异步/index.html","hash":"c0297a1630c1175be96c13ef5d2edd6a430285f8","modified":1643263494525},{"_id":"public/20211202/git-rebase-用法/index.html","hash":"ffeb87cd191ef7b7754ea3de8ed3daa0a5b5b83f","modified":1643263494525},{"_id":"public/20211129/create-react-app-搭建项目踩坑记录/index.html","hash":"80a95fadd317d7380c75c8a29313532f7d25ed2e","modified":1643263494525},{"_id":"public/20211031/Node-js学习记录/index.html","hash":"2da296c4dd897e067233ca22ee92a960eecf78a1","modified":1643263494525},{"_id":"public/20211021/call-apply和bind/index.html","hash":"45ac183dde308b508fb0314c1e883fa3c9dd6aab","modified":1643263494525},{"_id":"public/20211020/Array数组的一些发现/index.html","hash":"7456c070b5b7cd6b60318265fb6ad257c8d239a9","modified":1643263494525},{"_id":"public/20211014/JavaScript事件循环/index.html","hash":"fb2ced579c172a3dbd14be12a54e85f18c6a4f3a","modified":1643263494525},{"_id":"public/20211013/深入理解javascript之typeof和instanceof/index.html","hash":"b091d21f04204bfddedd86a0974dd21d017b521d","modified":1643263494525},{"_id":"public/20211007/互联网是如何运作的/index.html","hash":"a8ccc8b2aa0d224a0e86d8b8c9d17c355644596b","modified":1643263494525},{"_id":"public/20210927/leetcode每日算法（2021-09-27）/index.html","hash":"ef16e02dea339efdecf63e70deee1299eed5a664","modified":1643263494525},{"_id":"public/20210923/栈与队列的理解以及应用场景/index.html","hash":"fc55738a37f8a7cca1624e0cc5c1a7490ebe6801","modified":1643263494525},{"_id":"public/20210915/vue3文档记录/index.html","hash":"e3b1849f2310db52f80d2f1e9490827a6f48a767","modified":1643263494525},{"_id":"public/20210912/web设计模式解析与实战/index.html","hash":"37124ac0b6a0a1de26b180edcea71e617ac4c981","modified":1643263494525},{"_id":"public/20210910/TypeScript中函数的理解/index.html","hash":"26c03031003a0207582f53c3cf56d58e009309b1","modified":1643263494525},{"_id":"public/20210907/about-me/index.html","hash":"8a5139b932558cf4fd1e8c45df616826ce021d25","modified":1643263494525},{"_id":"public/20210906/TypeScript中类的理解/index.html","hash":"96c4d5a801832ce855306829d48de5982c454f1a","modified":1643263494525},{"_id":"public/20210701/export与export-default的区别/index.html","hash":"ec989084820272cc7b2ee50a9f8d5fa31dcc5f01","modified":1643263494525},{"_id":"public/20210619/new操作符的实现/index.html","hash":"6e6359ff5c537367e3152f15e5b9899f4853ab2a","modified":1643263494525},{"_id":"public/20210618/原型与原型链与constructor/index.html","hash":"9d623483a6bce218465b55214372ff6305a99d48","modified":1643263494525},{"_id":"public/20210618/Vue自定义全局组件/index.html","hash":"12f10c9662267fdfff8553188a248f3dc4de4e5d","modified":1643263494525},{"_id":"public/20210617/JavaScript中的堆栈以及数据类型/index.html","hash":"6e146f99c09b6389319e55b6e5f897fabbf81786","modified":1643263494525},{"_id":"public/index.html","hash":"2fa31fc54f02c30f67660b15bfca6ec3ee829f5d","modified":1643263494525},{"_id":"public/page/2/index.html","hash":"40f8104e31de62c4ecf0084b01c7385e9a0b58f5","modified":1643263494525},{"_id":"public/page/3/index.html","hash":"02ad9348adc5d45aa18986e0bd424ee63a75bb26","modified":1643263494525},{"_id":"public/page/4/index.html","hash":"e4eed6b6833fe76796a6039eda0d71428347f0d3","modified":1643263494525},{"_id":"public/categories/index.html","hash":"5b3b3a6626f15f970ff2684e95651201c70d3471","modified":1643263494525},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1643263494525},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1643263494525},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1643263494525},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1643263494525},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1643263494525},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1643263494525},{"_id":"public/CNAME","hash":"61e7919ef45b0fd313fcb2de41b7021f7ccbf47b","modified":1643263494525},{"_id":"public/img/bg/zhimingyuchunjiao.jpeg","hash":"03f9c96b520c0976c03c5bc45901b0c0e64b1c4d","modified":1643263494525},{"_id":"public/img/user/jianshu.jpeg","hash":"e3f77ae1071b74c68f0a7237850a3dc7a41a9936","modified":1643263494525},{"_id":"public/img/user/wazi.png","hash":"a6489d50d8b4fa846cbfd4ae094897586f5b5d76","modified":1643263494525},{"_id":"public/20220127/数据结构与算法/线性表的分类.jpg","hash":"34ab8cc42350327a8f8325f841115caa29253dfd","modified":1643263494525},{"_id":"public/img/20210911/AirPods.jpeg","hash":"8601c573436498d33b4016f948869ad8de42c543","modified":1643263494525},{"_id":"public/img/20210911/pic1.jpeg","hash":"dc36460fc6f228a5f85c9906359a3e777ec4f9ea","modified":1643263494525},{"_id":"public/img/bg/bg1.jpg","hash":"026a9e6ef05b063cf0c62142634d092b5e7015db","modified":1643263494525},{"_id":"public/img/bg/benjamin.jpeg","hash":"83c5636568ee5c2fe4602edf4a418414d242d155","modified":1643263494525},{"_id":"public/img/bg/bg4.jpg","hash":"e766eb50706a9f2a10fc25ba479bfb7944cfb9dc","modified":1643263494525},{"_id":"public/img/bg/tianruoyouqing.jpeg","hash":"c03c2d638c9858b48791019759e06f54c57f3730","modified":1643263494525},{"_id":"public/img/user/user.jpg","hash":"5a1c8f2385741605649bacf36bfe84f3d0b7983a","modified":1643263494525},{"_id":"public/img/user/weChat.jpg","hash":"1c490e9ab2206003f6d84446bf8dc347b2d416ef","modified":1643263494525},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1643263494525},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1643263494525},{"_id":"public/js/color-schema.js","hash":"cc712fc71bf33d561e1ba74fe1d52d2353092171","modified":1643263494525},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1643263494525},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1643263494525},{"_id":"public/js/leancloud.js","hash":"b7985ac3cff9ee2722db43ee6b32b5484c43f5f2","modified":1643263494525},{"_id":"public/js/plugins.js","hash":"342b1fbc30d1465687ce389a4e07f967266d5d86","modified":1643263494525},{"_id":"public/js/local-search.js","hash":"bf00f5786bb8de7241f635455b67243d26656222","modified":1643263494525},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1643263494525},{"_id":"public/js/utils.js","hash":"9d492fab9c26311ad0ab553c890e09b9575a76f2","modified":1643263494525},{"_id":"public/css/main.css","hash":"e05fec65bc65f33877d2eec979b2c70a61533a64","modified":1643263494525},{"_id":"public/img/20210911/pic2.jpeg","hash":"e66ac1c464555050a5e57d610d41df3ea2300772","modified":1643263494525},{"_id":"public/img/20210911/图片.jpeg","hash":"ce86726a54981795d8a5f6cc166af0b2ed050afb","modified":1643263494525},{"_id":"public/img/bg/bg2.jpg","hash":"4df0a1e43accbb1a2c5fa6e2c26e324d7c280499","modified":1643263494525},{"_id":"public/img/user/bilibili.jpeg","hash":"2a1493d349d20f5b682a43639104ceeda3734ba1","modified":1643263494525},{"_id":"public/img/bg/bg3.jpg","hash":"43ea9f0ae1c75b0edf7623cb0ff57fbc545fe3c5","modified":1643263494525},{"_id":"public/img/20210913/renshengdezhihui.png","hash":"7981415b28a16c4ac3fc282c53b488c779a7eacc","modified":1643263494525},{"_id":"public/img/user/user1.png","hash":"de768c0d778b4ce91d17a4fa6643fcdaecc0d960","modified":1643263494525},{"_id":"public/img/20210913/renshengdezhihui2.png","hash":"b217a9b7523a7300876a97bf32959f678794ed38","modified":1643263494525},{"_id":"public/img/user/webo.jpg","hash":"e13a0af612e0944a2014104058242b4fbebe8e56","modified":1643263494525},{"_id":"public/img/bg/shashou.jpeg","hash":"b6fccd7c1c535c73c3f374583d0bd26daa84874a","modified":1643263494525}],"Category":[{"name":"技术类-TypeScript","_id":"ckywkno4v00047oo984l3cl7n"},{"name":"日常","_id":"ckywkno57000e7oo90rb0gm0z"},{"name":"技术类-前端","_id":"ckywkno5b000l7oo9asyy2dpo"},{"name":"技术类-Vue","_id":"ckywkno5f000q7oo9d91i6gl2"},{"name":"计算机基础","_id":"ckywkno5v001x7oo9anuj9s04"},{"name":"算法类","_id":"ckywkno5y00267oo9dgze0acm"},{"name":"技术类-Node.js","_id":"ckywkno63002l7oo96ncr0j52"},{"name":"技术类-React","_id":"ckywkno66002t7oo9fhuu9xtu"},{"name":"博客说明","_id":"ckywkno6i004f7oo96jao81lw"}],"Data":[],"Page":[{"layout":"false","_content":"676194d86471561a70b8026338973ebc","source":"baidu_verify_code-TmkkRxX4ps.html","raw":"---\n\nlayout: false\n\n---\n676194d86471561a70b8026338973ebc","date":"2021-09-09T01:43:34.047Z","updated":"2021-09-09T01:43:34.047Z","path":"baidu_verify_code-TmkkRxX4ps.html","title":"","comments":1,"_id":"ckywkno4l00007oo90s4galh8","content":"676194d86471561a70b8026338973ebc","site":{"data":{}},"excerpt":"","more":"676194d86471561a70b8026338973ebc"},{"title":"about","layout":"about","comment":"utterances","date":"2021-09-07T07:20:04.000Z","_content":"网速足够快或者翻墙的话会使本网站打开的更快一些，网站有缓存，第一次打开可能会比较慢，后面就好了。\n\n我新写了一个博客并放在了自己的服务器上:[我的新博客，点击跳转](http://www.hjzouhualu.com/ \"新的博客\")","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ncomment: utterances\ndate: 2021-09-07 15:20:04\n---\n网速足够快或者翻墙的话会使本网站打开的更快一些，网站有缓存，第一次打开可能会比较慢，后面就好了。\n\n我新写了一个博客并放在了自己的服务器上:[我的新博客，点击跳转](http://www.hjzouhualu.com/ \"新的博客\")","updated":"2022-01-11T06:40:08.986Z","path":"about/index.html","comments":1,"_id":"ckywkno4s00027oo9gknqeqy2","content":"<p>网速足够快或者翻墙的话会使本网站打开的更快一些，网站有缓存，第一次打开可能会比较慢，后面就好了。</p>\n<p>我新写了一个博客并放在了自己的服务器上:<a href=\"http://www.hjzouhualu.com/\" title=\"新的博客\">我的新博客，点击跳转</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>网速足够快或者翻墙的话会使本网站打开的更快一些，网站有缓存，第一次打开可能会比较慢，后面就好了。</p>\n<p>我新写了一个博客并放在了自己的服务器上:<a href=\"http://www.hjzouhualu.com/\" title=\"新的博客\">我的新博客，点击跳转</a></p>\n"}],"Post":[{"layout":"tech","title":"TypeScript中类的理解","date":"2021-09-06T06:48:00.000Z","_content":"\n# 一、是什么\n\n类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础\n> ❝类是一种用户定义的引用数据类型，也称类类型❞\n\n传统的面向对象语言基本都是基于类的，`JavaScript` 基于原型的方式让开发者多了很多理解成本\n在 `ES6` 之后，`JavaScript` 拥有了 `class` 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多\n但是`JavaScript` 的`class`依然有一些特性还没有加入，比如修饰符和抽象类\n`TypeScript` 的 `class`  支持面向对象的所有特性，比如 类、接口等\n# 二、使用方式\n定义类的关键字为 `class`，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：\n\n「字段」：字段是类里面声明的变量。字段表示对象的有关数据。\n\n「构造函数」：类实例化时调用，可以为类的对象分配内存。\n\n「方法」：方法为对象要执行的操作\n如下例子：\n```typescript\nclass Car { \n    // 字段 \n    engine:string; \n \n    // 构造函数 \n    constructor(engine:string) { \n        this.engine = engine \n    }  \n \n    // 方法 \n    disp():void { \n        console.log(\"发动机为 :   \"+this.engine) \n    } \n}\n\n```\n\n## 继承\n类的继承使用过`extends`的关键字\n```typescript\nclass Animal {\n    move(distanceInMeters: number = 0) {\n        console.log(`Animal moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Dog extends Animal {\n    bark() {\n        console.log('Woof! Woof!');\n    }\n}\n\nconst dog = new Dog();\ndog.bark();\ndog.move(10);\ndog.bark();\n\n```\n\n`Dog`是一个 派生类，它派生自 `Animal` 基类，派生类通常被称作子类，基类通常被称作 **超类**。\n\n`Dog`类继承了`Animal`类，因此实例`dog`也能够使用`Animal`类`move`方法。\n同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。\n\n通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：\n```typescript\nclass PrinterClass { \n   doPrint():void {\n      console.log(\"父类的 doPrint() 方法。\") \n   } \n} \n \nclass StringPrinter extends PrinterClass { \n   doPrint():void { \n      super.doPrint() // 调用父类的函数\n      console.log(\"子类的 doPrint()方法。\")\n   } \n}\n\n```\n## 修饰符\n可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：\n\n- 公共 public：可以自由的访问类程序里定义的成员\n- 私有 private：只能够在该类的内部进行访问\n- 受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问\n\n### 私有修饰符\n只能够在该类的内部进行访问，实例对象并不能够访问\n```typescript\nclass Father{\n    private name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错，提示 \"属性name为私有属性，只能在Father类中访问\"\n```\n并且继承该类的子类并不能访问，如下图所示：\n```typescript\nclass Father{\n    private name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nclass Son extends Father{\n    say(){\n        console.log(`my name is ${this.name}`)  //会报错，提示 \"属性name为私有属性，只能在Father类中访问\"\n    }\n}\n```\n### 受保护修饰符\n跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：\n```typescript\nclass Father{\n    protected name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错，提示 \"属性name受保护，只能在类Father及其子类中访问\"\n```\n有一点不同的是 `protected` 成员在子类中仍然可以访问\n```typescript\nclass Father{\n    protected name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nclass Son extends Father{\n    say(){\n        console.log(`my name is ${this.name}`)\n    }\n}\n```\n\n### 只读修饰符\n通过`readonly`关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：\n```typescript\nclass Father{\n    readonly name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错,提示\"无法分配到name，因为它是只读属性\"\n```\n\n### 静态属性\n这些属性存在于类本身上面而不是类的实例上，通过`static`进行定义，访问这些属性需要通过 `类型.静态属性` 的这种形式访问，如下所示：\n```typescript\nclass Square {\n    static width = '100px'\n}\n\nconsole.log(Square.width) // 100px\n```\n### 抽象类\n抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节\n`abstract`关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：\n```typescript\nabstract class Animal {\n    abstract makeSound(): void;\n    move(): void {\n        console.log('roaming the earch...');\n    }\n}\n```\n这种类并不能被实例化，通常需要我们创建子类去继承，如下：\n```typescript\nclass Cat extends Animal {\n\n    makeSound() {\n        console.log('miao miao')\n    }\n}\n\nconst cat = new Cat()\n\ncat.makeSound() // miao miao\ncat.move() // roaming the earch...\n```\n# 三、应用场景\n除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在`React` 工程中是很常用的，如下：\n```typescript\nexport default class Carousel extends React.Component<Props, State> {}\n```\n由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。\n\n先声明一个类，这个类包含组件 props 所需的类型和初始值：\n```typescript\n// props的类型\nexport default class Props {\n  public children: Array<React.ReactElement<any>> | React.ReactElement<any> | never[] = []\n  public speed: number = 500\n  public height: number = 160\n  public animation: string = 'easeInOutQuad'\n  public isAuto: boolean = true\n  public autoPlayInterval: number = 4500\n  public afterChange: () => {}\n  public beforeChange: () => {}\n  public selesctedColor: string\n  public showDots: boolean = true\n}\n```\n当我们需要传入 `props` 类型的时候直接将 `Props` 作为接口传入，此时 `Props` 的作用就是接口，而当需要我们设置`defaultProps`初始值的时候，我们只需要:\n```typescript\npublic static defaultProps = new Props()\n```\n`Props` 的实例就是 `defaultProps` 的初始值，这就是 `class`作为接口的实际应用，我们用一个 `class` 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量\n\n# 参考文章\n- https://www.tslang.cn/docs/handbook/classes.html\n- https://www.runoob.com/typescript/ts-class.html","source":"_posts/2021-09-09-TypeScript中类的理解.md","raw":"---\nlayout: tech\ntitle: TypeScript中类的理解\ndate: 2021-09-06 14:48:00\ntags: TypeScript\ncategories: 技术类-TypeScript\n---\n\n# 一、是什么\n\n类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础\n> ❝类是一种用户定义的引用数据类型，也称类类型❞\n\n传统的面向对象语言基本都是基于类的，`JavaScript` 基于原型的方式让开发者多了很多理解成本\n在 `ES6` 之后，`JavaScript` 拥有了 `class` 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多\n但是`JavaScript` 的`class`依然有一些特性还没有加入，比如修饰符和抽象类\n`TypeScript` 的 `class`  支持面向对象的所有特性，比如 类、接口等\n# 二、使用方式\n定义类的关键字为 `class`，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：\n\n「字段」：字段是类里面声明的变量。字段表示对象的有关数据。\n\n「构造函数」：类实例化时调用，可以为类的对象分配内存。\n\n「方法」：方法为对象要执行的操作\n如下例子：\n```typescript\nclass Car { \n    // 字段 \n    engine:string; \n \n    // 构造函数 \n    constructor(engine:string) { \n        this.engine = engine \n    }  \n \n    // 方法 \n    disp():void { \n        console.log(\"发动机为 :   \"+this.engine) \n    } \n}\n\n```\n\n## 继承\n类的继承使用过`extends`的关键字\n```typescript\nclass Animal {\n    move(distanceInMeters: number = 0) {\n        console.log(`Animal moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Dog extends Animal {\n    bark() {\n        console.log('Woof! Woof!');\n    }\n}\n\nconst dog = new Dog();\ndog.bark();\ndog.move(10);\ndog.bark();\n\n```\n\n`Dog`是一个 派生类，它派生自 `Animal` 基类，派生类通常被称作子类，基类通常被称作 **超类**。\n\n`Dog`类继承了`Animal`类，因此实例`dog`也能够使用`Animal`类`move`方法。\n同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。\n\n通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：\n```typescript\nclass PrinterClass { \n   doPrint():void {\n      console.log(\"父类的 doPrint() 方法。\") \n   } \n} \n \nclass StringPrinter extends PrinterClass { \n   doPrint():void { \n      super.doPrint() // 调用父类的函数\n      console.log(\"子类的 doPrint()方法。\")\n   } \n}\n\n```\n## 修饰符\n可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：\n\n- 公共 public：可以自由的访问类程序里定义的成员\n- 私有 private：只能够在该类的内部进行访问\n- 受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问\n\n### 私有修饰符\n只能够在该类的内部进行访问，实例对象并不能够访问\n```typescript\nclass Father{\n    private name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错，提示 \"属性name为私有属性，只能在Father类中访问\"\n```\n并且继承该类的子类并不能访问，如下图所示：\n```typescript\nclass Father{\n    private name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nclass Son extends Father{\n    say(){\n        console.log(`my name is ${this.name}`)  //会报错，提示 \"属性name为私有属性，只能在Father类中访问\"\n    }\n}\n```\n### 受保护修饰符\n跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：\n```typescript\nclass Father{\n    protected name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错，提示 \"属性name受保护，只能在类Father及其子类中访问\"\n```\n有一点不同的是 `protected` 成员在子类中仍然可以访问\n```typescript\nclass Father{\n    protected name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nclass Son extends Father{\n    say(){\n        console.log(`my name is ${this.name}`)\n    }\n}\n```\n\n### 只读修饰符\n通过`readonly`关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：\n```typescript\nclass Father{\n    readonly name:String\n    constructor(name:String){\n        this.name = name\n    }\n}\nconst father = new Father('zouHuaLu')\nfather.name //会报错,提示\"无法分配到name，因为它是只读属性\"\n```\n\n### 静态属性\n这些属性存在于类本身上面而不是类的实例上，通过`static`进行定义，访问这些属性需要通过 `类型.静态属性` 的这种形式访问，如下所示：\n```typescript\nclass Square {\n    static width = '100px'\n}\n\nconsole.log(Square.width) // 100px\n```\n### 抽象类\n抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节\n`abstract`关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：\n```typescript\nabstract class Animal {\n    abstract makeSound(): void;\n    move(): void {\n        console.log('roaming the earch...');\n    }\n}\n```\n这种类并不能被实例化，通常需要我们创建子类去继承，如下：\n```typescript\nclass Cat extends Animal {\n\n    makeSound() {\n        console.log('miao miao')\n    }\n}\n\nconst cat = new Cat()\n\ncat.makeSound() // miao miao\ncat.move() // roaming the earch...\n```\n# 三、应用场景\n除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在`React` 工程中是很常用的，如下：\n```typescript\nexport default class Carousel extends React.Component<Props, State> {}\n```\n由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。\n\n先声明一个类，这个类包含组件 props 所需的类型和初始值：\n```typescript\n// props的类型\nexport default class Props {\n  public children: Array<React.ReactElement<any>> | React.ReactElement<any> | never[] = []\n  public speed: number = 500\n  public height: number = 160\n  public animation: string = 'easeInOutQuad'\n  public isAuto: boolean = true\n  public autoPlayInterval: number = 4500\n  public afterChange: () => {}\n  public beforeChange: () => {}\n  public selesctedColor: string\n  public showDots: boolean = true\n}\n```\n当我们需要传入 `props` 类型的时候直接将 `Props` 作为接口传入，此时 `Props` 的作用就是接口，而当需要我们设置`defaultProps`初始值的时候，我们只需要:\n```typescript\npublic static defaultProps = new Props()\n```\n`Props` 的实例就是 `defaultProps` 的初始值，这就是 `class`作为接口的实际应用，我们用一个 `class` 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量\n\n# 参考文章\n- https://www.tslang.cn/docs/handbook/classes.html\n- https://www.runoob.com/typescript/ts-class.html","slug":"TypeScript中类的理解","published":1,"updated":"2021-09-09T07:35:00.949Z","comments":1,"photos":[],"link":"","_id":"ckywkno4p00017oo9hr9k8taw","content":"<h1 id=\"一、是什么\"><a href=\"#一、是什么\" class=\"headerlink\" title=\"一、是什么\"></a>一、是什么</h1><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p>\n<blockquote>\n<p>❝类是一种用户定义的引用数据类型，也称类类型❞</p>\n</blockquote>\n<p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本<br>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多<br>但是<code>JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类<br><code>TypeScript</code> 的 <code>class</code>  支持面向对象的所有特性，比如 类、接口等</p>\n<h1 id=\"二、使用方式\"><a href=\"#二、使用方式\" class=\"headerlink\" title=\"二、使用方式\"></a>二、使用方式</h1><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：</p>\n<p>「字段」：字段是类里面声明的变量。字段表示对象的有关数据。</p>\n<p>「构造函数」：类实例化时调用，可以为类的对象分配内存。</p>\n<p>「方法」：方法为对象要执行的操作<br>如下例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Car</span> </span>&#123; <br>    <span class=\"hljs-comment\">// 字段 </span><br>    <span class=\"hljs-attr\">engine</span>:<span class=\"hljs-built_in\">string</span>; <br> <br>    <span class=\"hljs-comment\">// 构造函数 </span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">engine:<span class=\"hljs-built_in\">string</span></span>)</span> &#123; <br>        <span class=\"hljs-built_in\">this</span>.engine = engine <br>    &#125;  <br> <br>    <span class=\"hljs-comment\">// 方法 </span><br>    disp():<span class=\"hljs-built_in\">void</span> &#123; <br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;发动机为 :   &quot;</span>+<span class=\"hljs-built_in\">this</span>.engine) <br>    &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>类的继承使用过<code>extends</code>的关键字</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">move</span>(<span class=\"hljs-params\">distanceInMeters: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0</span></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Animal moved <span class=\"hljs-subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">bark</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Woof! Woof!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> Dog();<br>dog.bark();<br>dog.move(<span class=\"hljs-number\">10</span>);<br>dog.bark();<br><br></code></pre></td></tr></table></figure>\n\n<p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 <strong>超类</strong>。</p>\n<p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法。<br>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。</p>\n<p>通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PrinterClass</span> </span>&#123; <br>   doPrint():<span class=\"hljs-built_in\">void</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;父类的 doPrint() 方法。&quot;</span>) <br>   &#125; <br>&#125; <br> <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StringPrinter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PrinterClass</span> </span>&#123; <br>   doPrint():<span class=\"hljs-built_in\">void</span> &#123; <br>      <span class=\"hljs-built_in\">super</span>.doPrint() <span class=\"hljs-comment\">// 调用父类的函数</span><br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;子类的 doPrint()方法。&quot;</span>)<br>   &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><p>可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：</p>\n<ul>\n<li>公共 public：可以自由的访问类程序里定义的成员</li>\n<li>私有 private：只能够在该类的内部进行访问</li>\n<li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li>\n</ul>\n<h3 id=\"私有修饰符\"><a href=\"#私有修饰符\" class=\"headerlink\" title=\"私有修饰符\"></a>私有修饰符</h3><p>只能够在该类的内部进行访问，实例对象并不能够访问</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br></code></pre></td></tr></table></figure>\n<p>并且继承该类的子类并不能访问，如下图所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>`</span>)  <span class=\"hljs-comment\">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"受保护修饰符\"><a href=\"#受保护修饰符\" class=\"headerlink\" title=\"受保护修饰符\"></a>受保护修饰符</h3><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">protected</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错，提示 &quot;属性name受保护，只能在类Father及其子类中访问&quot;</span><br></code></pre></td></tr></table></figure>\n<p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">protected</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>`</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"只读修饰符\"><a href=\"#只读修饰符\" class=\"headerlink\" title=\"只读修饰符\"></a>只读修饰符</h3><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">readonly</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错,提示&quot;无法分配到name，因为它是只读属性&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h3><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 <code>类型.静态属性</code> 的这种形式访问，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Square</span> </span>&#123;<br>    <span class=\"hljs-keyword\">static</span> width = <span class=\"hljs-string\">&#x27;100px&#x27;</span><br>&#125;<br><br><span class=\"hljs-built_in\">console</span>.log(Square.width) <span class=\"hljs-comment\">// 100px</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节<br><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-keyword\">abstract</span> makeSound(): <span class=\"hljs-built_in\">void</span>;<br>    move(): <span class=\"hljs-built_in\">void</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;roaming the earch...&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Cat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">makeSound</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;miao miao&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> cat = <span class=\"hljs-keyword\">new</span> Cat()<br><br>cat.makeSound() <span class=\"hljs-comment\">// miao miao</span><br>cat.move() <span class=\"hljs-comment\">// roaming the earch...</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"三、应用场景\"><a href=\"#三、应用场景\" class=\"headerlink\" title=\"三、应用场景\"></a>三、应用场景</h1><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在<code>React</code> 工程中是很常用的，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Carousel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>, <span class=\"hljs-title\">State</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。</p>\n<p>先声明一个类，这个类包含组件 props 所需的类型和初始值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// props的类型</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Props</span> </span>&#123;<br>  <span class=\"hljs-keyword\">public</span> children: <span class=\"hljs-built_in\">Array</span>&lt;React.ReactElement&lt;<span class=\"hljs-built_in\">any</span>&gt;&gt; | React.ReactElement&lt;<span class=\"hljs-built_in\">any</span>&gt; | <span class=\"hljs-built_in\">never</span>[] = []<br>  <span class=\"hljs-keyword\">public</span> speed: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">500</span><br>  <span class=\"hljs-keyword\">public</span> height: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">160</span><br>  <span class=\"hljs-keyword\">public</span> animation: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&#x27;easeInOutQuad&#x27;</span><br>  <span class=\"hljs-keyword\">public</span> isAuto: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-keyword\">public</span> autoPlayInterval: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">4500</span><br>  <span class=\"hljs-keyword\">public</span> afterChange: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<br>  <span class=\"hljs-keyword\">public</span> beforeChange: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<br>  <span class=\"hljs-keyword\">public</span> selesctedColor: <span class=\"hljs-built_in\">string</span><br>  <span class=\"hljs-keyword\">public</span> showDots: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> defaultProps = <span class=\"hljs-keyword\">new</span> Props()<br></code></pre></td></tr></table></figure>\n<p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class</code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/classes.html\">https://www.tslang.cn/docs/handbook/classes.html</a></li>\n<li><a href=\"https://www.runoob.com/typescript/ts-class.html\">https://www.runoob.com/typescript/ts-class.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、是什么\"><a href=\"#一、是什么\" class=\"headerlink\" title=\"一、是什么\"></a>一、是什么</h1><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p>\n<blockquote>\n<p>❝类是一种用户定义的引用数据类型，也称类类型❞</p>\n</blockquote>\n<p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本<br>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多<br>但是<code>JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类<br><code>TypeScript</code> 的 <code>class</code>  支持面向对象的所有特性，比如 类、接口等</p>\n<h1 id=\"二、使用方式\"><a href=\"#二、使用方式\" class=\"headerlink\" title=\"二、使用方式\"></a>二、使用方式</h1><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块(类的数据成员)：</p>\n<p>「字段」：字段是类里面声明的变量。字段表示对象的有关数据。</p>\n<p>「构造函数」：类实例化时调用，可以为类的对象分配内存。</p>\n<p>「方法」：方法为对象要执行的操作<br>如下例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Car</span> </span>&#123; <br>    <span class=\"hljs-comment\">// 字段 </span><br>    <span class=\"hljs-attr\">engine</span>:<span class=\"hljs-built_in\">string</span>; <br> <br>    <span class=\"hljs-comment\">// 构造函数 </span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">engine:<span class=\"hljs-built_in\">string</span></span>)</span> &#123; <br>        <span class=\"hljs-built_in\">this</span>.engine = engine <br>    &#125;  <br> <br>    <span class=\"hljs-comment\">// 方法 </span><br>    disp():<span class=\"hljs-built_in\">void</span> &#123; <br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;发动机为 :   &quot;</span>+<span class=\"hljs-built_in\">this</span>.engine) <br>    &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>类的继承使用过<code>extends</code>的关键字</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">move</span>(<span class=\"hljs-params\">distanceInMeters: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0</span></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Animal moved <span class=\"hljs-subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">bark</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Woof! Woof!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> Dog();<br>dog.bark();<br>dog.move(<span class=\"hljs-number\">10</span>);<br>dog.bark();<br><br></code></pre></td></tr></table></figure>\n\n<p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 <strong>超类</strong>。</p>\n<p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法。<br>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。</p>\n<p>通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PrinterClass</span> </span>&#123; <br>   doPrint():<span class=\"hljs-built_in\">void</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;父类的 doPrint() 方法。&quot;</span>) <br>   &#125; <br>&#125; <br> <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StringPrinter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PrinterClass</span> </span>&#123; <br>   doPrint():<span class=\"hljs-built_in\">void</span> &#123; <br>      <span class=\"hljs-built_in\">super</span>.doPrint() <span class=\"hljs-comment\">// 调用父类的函数</span><br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;子类的 doPrint()方法。&quot;</span>)<br>   &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><p>可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：</p>\n<ul>\n<li>公共 public：可以自由的访问类程序里定义的成员</li>\n<li>私有 private：只能够在该类的内部进行访问</li>\n<li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li>\n</ul>\n<h3 id=\"私有修饰符\"><a href=\"#私有修饰符\" class=\"headerlink\" title=\"私有修饰符\"></a>私有修饰符</h3><p>只能够在该类的内部进行访问，实例对象并不能够访问</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br></code></pre></td></tr></table></figure>\n<p>并且继承该类的子类并不能访问，如下图所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>`</span>)  <span class=\"hljs-comment\">//会报错，提示 &quot;属性name为私有属性，只能在Father类中访问&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"受保护修饰符\"><a href=\"#受保护修饰符\" class=\"headerlink\" title=\"受保护修饰符\"></a>受保护修饰符</h3><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">protected</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错，提示 &quot;属性name受保护，只能在类Father及其子类中访问&quot;</span><br></code></pre></td></tr></table></figure>\n<p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">protected</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">say</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.name&#125;</span>`</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"只读修饰符\"><a href=\"#只读修饰符\" class=\"headerlink\" title=\"只读修饰符\"></a>只读修饰符</h3><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>&#123;<br>    <span class=\"hljs-keyword\">readonly</span> name:<span class=\"hljs-built_in\">String</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">String</span></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.name = name<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> father = <span class=\"hljs-keyword\">new</span> Father(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>father.name <span class=\"hljs-comment\">//会报错,提示&quot;无法分配到name，因为它是只读属性&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h3><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 <code>类型.静态属性</code> 的这种形式访问，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Square</span> </span>&#123;<br>    <span class=\"hljs-keyword\">static</span> width = <span class=\"hljs-string\">&#x27;100px&#x27;</span><br>&#125;<br><br><span class=\"hljs-built_in\">console</span>.log(Square.width) <span class=\"hljs-comment\">// 100px</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节<br><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>    <span class=\"hljs-keyword\">abstract</span> makeSound(): <span class=\"hljs-built_in\">void</span>;<br>    move(): <span class=\"hljs-built_in\">void</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;roaming the earch...&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Cat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">makeSound</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;miao miao&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> cat = <span class=\"hljs-keyword\">new</span> Cat()<br><br>cat.makeSound() <span class=\"hljs-comment\">// miao miao</span><br>cat.move() <span class=\"hljs-comment\">// roaming the earch...</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"三、应用场景\"><a href=\"#三、应用场景\" class=\"headerlink\" title=\"三、应用场景\"></a>三、应用场景</h1><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在<code>React</code> 工程中是很常用的，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Carousel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>, <span class=\"hljs-title\">State</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口。</p>\n<p>先声明一个类，这个类包含组件 props 所需的类型和初始值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// props的类型</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Props</span> </span>&#123;<br>  <span class=\"hljs-keyword\">public</span> children: <span class=\"hljs-built_in\">Array</span>&lt;React.ReactElement&lt;<span class=\"hljs-built_in\">any</span>&gt;&gt; | React.ReactElement&lt;<span class=\"hljs-built_in\">any</span>&gt; | <span class=\"hljs-built_in\">never</span>[] = []<br>  <span class=\"hljs-keyword\">public</span> speed: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">500</span><br>  <span class=\"hljs-keyword\">public</span> height: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">160</span><br>  <span class=\"hljs-keyword\">public</span> animation: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&#x27;easeInOutQuad&#x27;</span><br>  <span class=\"hljs-keyword\">public</span> isAuto: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-keyword\">public</span> autoPlayInterval: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">4500</span><br>  <span class=\"hljs-keyword\">public</span> afterChange: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<br>  <span class=\"hljs-keyword\">public</span> beforeChange: <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<br>  <span class=\"hljs-keyword\">public</span> selesctedColor: <span class=\"hljs-built_in\">string</span><br>  <span class=\"hljs-keyword\">public</span> showDots: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> defaultProps = <span class=\"hljs-keyword\">new</span> Props()<br></code></pre></td></tr></table></figure>\n<p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class</code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/classes.html\">https://www.tslang.cn/docs/handbook/classes.html</a></li>\n<li><a href=\"https://www.runoob.com/typescript/ts-class.html\">https://www.runoob.com/typescript/ts-class.html</a></li>\n</ul>\n"},{"title":"TypeScript中函数的理解","date":"2021-09-10T08:55:32.000Z","_content":"# 使用方式\n和JavaScript使用方式类似，可以通过`funciton`关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：\n```typescript\nconst add = (a:number,b:number)=> a+b\n```\n上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：\n![TypeScript编译器的提示](https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg)\n当鼠标放置在第三行 `add` 函数名的时候，会出现完整的函数定义类型，通过 `:` 的形式来定义参数类型，通过 `=>` 连接参数和返回值类型\n\n我们也可以显式地写上返回类型，如下：\n```typescript\nconst add = (a:number,b:number):number=> a+b\n```\n\n当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：\n```typescript\n// 方式一\ntype LongHand = {\n  (a: number): number;\n};\n\n// 方式二\ntype ShortHand = (a: number) => number;\n\n```\n当存在函数重载时，只能使用方式一的形式\n\n## 可选参数\n当函数的参数可能是不存在的，只需要在参数后面加上 `?` 代表参数可能不存在，如下：\n```typescript\nconst add = (a: number, b?: number) => a + (b ? b : 0)\n```\n这时候参数`b`可以是`number类型`或者`undefined类型`，即可以传一个`number类型`或者不传都可以\n\n## 剩余类型\n剩余参数与JavaScript的语法类似，需要用 `...` 来表示剩余参数\n\n如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：\n```typescript\nconst add = (a: number, ...rest: number[]) => rest.reduce(((a, b) => a + b), a)\n```\n\n## 函数重载\n允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力\n\n关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 `|操作符`或者`?操作符`，把所有可能的输入类型全部包含进去，用于具体实现\n\n这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并\n\n例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：\n```typescript\n// 上边是声明\nfunction add (arg1: string, arg2: string): string\nfunction add (arg1: number, arg2: number): number\n// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字\n\n// 下边是实现\nfunction add (arg1: string | number, arg2: string | number) {\n  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2\n  if (typeof arg1 === 'string' && typeof arg2 === 'string') {\n    return arg1 + arg2\n  } else if (typeof arg1 === 'number' && typeof arg2 === 'number') {\n    return arg1 + arg2\n  }\n}\n```\n# 区别\n从上面可以看到：\n\n- 从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型\n- typescript 在参数中，添加可选参数供使用者选择\n- typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型\n# 参考文章\n- https://www.tslang.cn/docs/handbook/functions.html\n- https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\n- https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD","source":"_posts/2021-09-10-TypeScript中函数的理解.md","raw":"---\ntitle: TypeScript中函数的理解\ndate: 2021-09-10 16:55:32\ntags: TypeScript\ncategories: 技术类-TypeScript\n---\n# 使用方式\n和JavaScript使用方式类似，可以通过`funciton`关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：\n```typescript\nconst add = (a:number,b:number)=> a+b\n```\n上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：\n![TypeScript编译器的提示](https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg)\n当鼠标放置在第三行 `add` 函数名的时候，会出现完整的函数定义类型，通过 `:` 的形式来定义参数类型，通过 `=>` 连接参数和返回值类型\n\n我们也可以显式地写上返回类型，如下：\n```typescript\nconst add = (a:number,b:number):number=> a+b\n```\n\n当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：\n```typescript\n// 方式一\ntype LongHand = {\n  (a: number): number;\n};\n\n// 方式二\ntype ShortHand = (a: number) => number;\n\n```\n当存在函数重载时，只能使用方式一的形式\n\n## 可选参数\n当函数的参数可能是不存在的，只需要在参数后面加上 `?` 代表参数可能不存在，如下：\n```typescript\nconst add = (a: number, b?: number) => a + (b ? b : 0)\n```\n这时候参数`b`可以是`number类型`或者`undefined类型`，即可以传一个`number类型`或者不传都可以\n\n## 剩余类型\n剩余参数与JavaScript的语法类似，需要用 `...` 来表示剩余参数\n\n如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：\n```typescript\nconst add = (a: number, ...rest: number[]) => rest.reduce(((a, b) => a + b), a)\n```\n\n## 函数重载\n允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力\n\n关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 `|操作符`或者`?操作符`，把所有可能的输入类型全部包含进去，用于具体实现\n\n这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并\n\n例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：\n```typescript\n// 上边是声明\nfunction add (arg1: string, arg2: string): string\nfunction add (arg1: number, arg2: number): number\n// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字\n\n// 下边是实现\nfunction add (arg1: string | number, arg2: string | number) {\n  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2\n  if (typeof arg1 === 'string' && typeof arg2 === 'string') {\n    return arg1 + arg2\n  } else if (typeof arg1 === 'number' && typeof arg2 === 'number') {\n    return arg1 + arg2\n  }\n}\n```\n# 区别\n从上面可以看到：\n\n- 从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型\n- typescript 在参数中，添加可选参数供使用者选择\n- typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型\n# 参考文章\n- https://www.tslang.cn/docs/handbook/functions.html\n- https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\n- https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD","slug":"TypeScript中函数的理解","published":1,"updated":"2021-09-10T09:03:27.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno4s00037oo9abho6k3y","content":"<h1 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h1><p>和JavaScript使用方式类似，可以通过<code>funciton</code>关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a:<span class=\"hljs-built_in\">number</span>,b:<span class=\"hljs-built_in\">number</span></span>)=&gt;</span> a+b<br></code></pre></td></tr></table></figure>\n<p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：<br><img src=\"https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg\" alt=\"TypeScript编译器的提示\"><br>当鼠标放置在第三行 <code>add</code> 函数名的时候，会出现完整的函数定义类型，通过 <code>:</code> 的形式来定义参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p>\n<p>我们也可以显式地写上返回类型，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = (a:<span class=\"hljs-built_in\">number</span>,<span class=\"hljs-attr\">b</span>:<span class=\"hljs-built_in\">number</span>):<span class=\"hljs-function\"><span class=\"hljs-params\">number</span>=&gt;</span> a+b<br></code></pre></td></tr></table></figure>\n\n<p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 方式一</span><br><span class=\"hljs-keyword\">type</span> LongHand = &#123;<br>  (a: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;<br>&#125;;<br><br><span class=\"hljs-comment\">// 方式二</span><br><span class=\"hljs-keyword\">type</span> ShortHand = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span>;<br><br></code></pre></td></tr></table></figure>\n<p>当存在函数重载时，只能使用方式一的形式</p>\n<h2 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h2><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b?: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> a + (b ? b : <span class=\"hljs-number\">0</span>)<br></code></pre></td></tr></table></figure>\n<p>这时候参数<code>b</code>可以是<code>number类型</code>或者<code>undefined类型</code>，即可以传一个<code>number类型</code>或者不传都可以</p>\n<h2 id=\"剩余类型\"><a href=\"#剩余类型\" class=\"headerlink\" title=\"剩余类型\"></a>剩余类型</h2><p>剩余参数与JavaScript的语法类似，需要用 <code>...</code> 来表示剩余参数</p>\n<p>如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, ...rest: <span class=\"hljs-built_in\">number</span>[]</span>) =&gt;</span> rest.reduce((<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a + b), a)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p>\n<p>关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|操作符</code>或者<code>?操作符</code>，把所有可能的输入类型全部包含进去，用于具体实现</p>\n<p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并</p>\n<p>例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 上边是声明</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span>, arg2: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">string</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 <span class=\"hljs-title\">declare</span> 关键字</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">// 下边是实现</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>) </span>&#123;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">  <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;string&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;string&#x27;</span></span>) </span>&#123;</span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">return</span> <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span><br><span class=\"hljs-function\">  &#125; <span class=\"hljs-title\">else</span> <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;number&#x27;</span></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> arg1 + arg2<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p>从上面可以看到：</p>\n<ul>\n<li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li>\n<li>typescript 在参数中，添加可选参数供使用者选择</li>\n<li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1></li>\n<li><a href=\"https://www.tslang.cn/docs/handbook/functions.html\">https://www.tslang.cn/docs/handbook/functions.html</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\">https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD</a></li>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD\">https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h1><p>和JavaScript使用方式类似，可以通过<code>funciton</code>关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a:<span class=\"hljs-built_in\">number</span>,b:<span class=\"hljs-built_in\">number</span></span>)=&gt;</span> a+b<br></code></pre></td></tr></table></figure>\n<p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：<br><img src=\"https://i.loli.net/2021/09/10/jzWf3SXsP4UqLpY.jpg\" alt=\"TypeScript编译器的提示\"><br>当鼠标放置在第三行 <code>add</code> 函数名的时候，会出现完整的函数定义类型，通过 <code>:</code> 的形式来定义参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p>\n<p>我们也可以显式地写上返回类型，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = (a:<span class=\"hljs-built_in\">number</span>,<span class=\"hljs-attr\">b</span>:<span class=\"hljs-built_in\">number</span>):<span class=\"hljs-function\"><span class=\"hljs-params\">number</span>=&gt;</span> a+b<br></code></pre></td></tr></table></figure>\n\n<p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 方式一</span><br><span class=\"hljs-keyword\">type</span> LongHand = &#123;<br>  (a: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;<br>&#125;;<br><br><span class=\"hljs-comment\">// 方式二</span><br><span class=\"hljs-keyword\">type</span> ShortHand = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span>;<br><br></code></pre></td></tr></table></figure>\n<p>当存在函数重载时，只能使用方式一的形式</p>\n<h2 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h2><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b?: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> a + (b ? b : <span class=\"hljs-number\">0</span>)<br></code></pre></td></tr></table></figure>\n<p>这时候参数<code>b</code>可以是<code>number类型</code>或者<code>undefined类型</code>，即可以传一个<code>number类型</code>或者不传都可以</p>\n<h2 id=\"剩余类型\"><a href=\"#剩余类型\" class=\"headerlink\" title=\"剩余类型\"></a>剩余类型</h2><p>剩余参数与JavaScript的语法类似，需要用 <code>...</code> 来表示剩余参数</p>\n<p>如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, ...rest: <span class=\"hljs-built_in\">number</span>[]</span>) =&gt;</span> rest.reduce((<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a + b), a)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p>\n<p>关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|操作符</code>或者<code>?操作符</code>，把所有可能的输入类型全部包含进去，用于具体实现</p>\n<p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并</p>\n<p>例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 上边是声明</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span>, arg2: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">string</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 <span class=\"hljs-title\">declare</span> 关键字</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">// 下边是实现</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>) </span>&#123;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span></span><br><span class=\"hljs-function\"><span class=\"hljs-function\">  <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;string&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;string&#x27;</span></span>) </span>&#123;</span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">return</span> <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span><br><span class=\"hljs-function\">  &#125; <span class=\"hljs-title\">else</span> <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;number&#x27;</span></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> arg1 + arg2<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p>从上面可以看到：</p>\n<ul>\n<li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li>\n<li>typescript 在参数中，添加可选参数供使用者选择</li>\n<li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1></li>\n<li><a href=\"https://www.tslang.cn/docs/handbook/functions.html\">https://www.tslang.cn/docs/handbook/functions.html</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\">https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD</a></li>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD\">https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD</a></li>\n</ul>\n"},{"title":"浮生一日(20210911)","date":"2021-09-11T10:44:58.000Z","_content":"今天老妈的生日🎂\n\n猝不及防的狗粮\n\n![老妈的朋友圈](/img/20210911/pic1.jpeg)\n![老妈的朋友圈](/img/20210911/pic2.jpeg)\n\n---\n\n苹果的售后真的好，耳机检测了一下就说直接换新的\n\n![苹果售后](/img/20210911/AirPods.jpeg)\n","source":"_posts/2021-09-11-浮生一日.md","raw":"---\ntitle: 浮生一日(20210911)\ndate: 2021-09-11 18:44:58\ntags: \n  - [日常]\ncategories: \n  - [日常]\n---\n今天老妈的生日🎂\n\n猝不及防的狗粮\n\n![老妈的朋友圈](/img/20210911/pic1.jpeg)\n![老妈的朋友圈](/img/20210911/pic2.jpeg)\n\n---\n\n苹果的售后真的好，耳机检测了一下就说直接换新的\n\n![苹果售后](/img/20210911/AirPods.jpeg)\n","slug":"浮生一日","published":1,"updated":"2021-11-18T09:00:56.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno4x00067oo9a4973xps","content":"<p>今天老妈的生日🎂</p>\n<p>猝不及防的狗粮</p>\n<p><img src=\"/img/20210911/pic1.jpeg\" alt=\"老妈的朋友圈\"><br><img src=\"/img/20210911/pic2.jpeg\" alt=\"老妈的朋友圈\"></p>\n<hr>\n<p>苹果的售后真的好，耳机检测了一下就说直接换新的</p>\n<p><img src=\"/img/20210911/AirPods.jpeg\" alt=\"苹果售后\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天老妈的生日🎂</p>\n<p>猝不及防的狗粮</p>\n<p><img src=\"/img/20210911/pic1.jpeg\" alt=\"老妈的朋友圈\"><br><img src=\"/img/20210911/pic2.jpeg\" alt=\"老妈的朋友圈\"></p>\n<hr>\n<p>苹果的售后真的好，耳机检测了一下就说直接换新的</p>\n<p><img src=\"/img/20210911/AirPods.jpeg\" alt=\"苹果售后\"></p>\n"},{"layout":"zhuawa","title":"web设计模式解析与实战（一）","date":"2021-09-12T05:31:57.000Z","_content":"今天课程主要是讲前端设计模式，早上一节，晚上一节。\n\n---\n\n# 设计模式 \n有利于\n\n1. 组织模块\n\n2. 设计沟通\n\n3. 代码质量\n\n\n\n# 五大设计原则：\n\n1. 开闭原则（OCP：open close principle）\n    - 开-对拓展开放，对修改关闭\n2. 单一职责原则（SRP）\n    - 岗位职责单一，互不重叠\n3. 依赖倒置原则（DIP）\n    - 上层不应该依赖下层实现\n4. 接口隔离原则（ISP）\n    - 多个专业的接口比单个胖借口好用\n5. 里氏替换原则（LSP：the Lxxxx substitution principle）\n    - 子类能够覆盖父类\n    - 父类能够出现的地方子类就能出现\n---\n今天老师给的课后题：\n- 某个**停车场**，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开，\n- 车辆进入前，显示每层的空余车辆数量\n- 车辆进入时，摄像头可识别车牌号和时间\n- 车辆出来时，出口显示器显示车牌号和停车时长\n请设计一套系统。","source":"_posts/2021-09-12-web设计模式解析与实战.md","raw":"---\nlayout: zhuawa\ntitle: web设计模式解析与实战（一）\ndate: 2021-09-12 13:31:57\ntags: 课程\ncategories: 技术类-前端\n---\n今天课程主要是讲前端设计模式，早上一节，晚上一节。\n\n---\n\n# 设计模式 \n有利于\n\n1. 组织模块\n\n2. 设计沟通\n\n3. 代码质量\n\n\n\n# 五大设计原则：\n\n1. 开闭原则（OCP：open close principle）\n    - 开-对拓展开放，对修改关闭\n2. 单一职责原则（SRP）\n    - 岗位职责单一，互不重叠\n3. 依赖倒置原则（DIP）\n    - 上层不应该依赖下层实现\n4. 接口隔离原则（ISP）\n    - 多个专业的接口比单个胖借口好用\n5. 里氏替换原则（LSP：the Lxxxx substitution principle）\n    - 子类能够覆盖父类\n    - 父类能够出现的地方子类就能出现\n---\n今天老师给的课后题：\n- 某个**停车场**，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开，\n- 车辆进入前，显示每层的空余车辆数量\n- 车辆进入时，摄像头可识别车牌号和时间\n- 车辆出来时，出口显示器显示车牌号和停车时长\n请设计一套系统。","slug":"web设计模式解析与实战","published":1,"updated":"2021-10-08T03:11:05.384Z","comments":1,"photos":[],"link":"","_id":"ckywkno4z00077oo9ecqr3akw","content":"<p>今天课程主要是讲前端设计模式，早上一节，晚上一节。</p>\n<hr>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><p>有利于</p>\n<ol>\n<li><p>组织模块</p>\n</li>\n<li><p>设计沟通</p>\n</li>\n<li><p>代码质量</p>\n</li>\n</ol>\n<h1 id=\"五大设计原则：\"><a href=\"#五大设计原则：\" class=\"headerlink\" title=\"五大设计原则：\"></a>五大设计原则：</h1><ol>\n<li>开闭原则（OCP：open close principle）<ul>\n<li>开-对拓展开放，对修改关闭</li>\n</ul>\n</li>\n<li>单一职责原则（SRP）<ul>\n<li>岗位职责单一，互不重叠</li>\n</ul>\n</li>\n<li>依赖倒置原则（DIP）<ul>\n<li>上层不应该依赖下层实现</li>\n</ul>\n</li>\n<li>接口隔离原则（ISP）<ul>\n<li>多个专业的接口比单个胖借口好用</li>\n</ul>\n</li>\n<li>里氏替换原则（LSP：the Lxxxx substitution principle）<ul>\n<li>子类能够覆盖父类</li>\n<li>父类能够出现的地方子类就能出现</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>今天老师给的课后题：</p>\n<ul>\n<li>某个<strong>停车场</strong>，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开，</li>\n<li>车辆进入前，显示每层的空余车辆数量</li>\n<li>车辆进入时，摄像头可识别车牌号和时间</li>\n<li>车辆出来时，出口显示器显示车牌号和停车时长<br>请设计一套系统。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>今天课程主要是讲前端设计模式，早上一节，晚上一节。</p>\n<hr>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><p>有利于</p>\n<ol>\n<li><p>组织模块</p>\n</li>\n<li><p>设计沟通</p>\n</li>\n<li><p>代码质量</p>\n</li>\n</ol>\n<h1 id=\"五大设计原则：\"><a href=\"#五大设计原则：\" class=\"headerlink\" title=\"五大设计原则：\"></a>五大设计原则：</h1><ol>\n<li>开闭原则（OCP：open close principle）<ul>\n<li>开-对拓展开放，对修改关闭</li>\n</ul>\n</li>\n<li>单一职责原则（SRP）<ul>\n<li>岗位职责单一，互不重叠</li>\n</ul>\n</li>\n<li>依赖倒置原则（DIP）<ul>\n<li>上层不应该依赖下层实现</li>\n</ul>\n</li>\n<li>接口隔离原则（ISP）<ul>\n<li>多个专业的接口比单个胖借口好用</li>\n</ul>\n</li>\n<li>里氏替换原则（LSP：the Lxxxx substitution principle）<ul>\n<li>子类能够覆盖父类</li>\n<li>父类能够出现的地方子类就能出现</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>今天老师给的课后题：</p>\n<ul>\n<li>某个<strong>停车场</strong>，分为三层，每层100个车位，每个车位都能监控到车辆的驶入和离开，</li>\n<li>车辆进入前，显示每层的空余车辆数量</li>\n<li>车辆进入时，摄像头可识别车牌号和时间</li>\n<li>车辆出来时，出口显示器显示车牌号和停车时长<br>请设计一套系统。</li>\n</ul>\n"},{"title":"通读vue3文档记录","date":"2021-09-15T11:03:11.000Z","_content":"之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是`Object.defineProperty()`，vue3用的是`Proxy`。vue3还新增了`组合式API`等等。\n\n这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。\n\n持续更新ing\n\n# 应用&组件实例\n## 应用实例\n每个 Vue 应用都是通过用 createApp 函数创建一个新的**应用实例**开始的：\n\n```js\nconst app = Vue.createApp({ /* 选项 */ })\n```\n\n该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：\n```js\nconst app = Vue.createApp({})\napp.component('SearchInput', SearchInputComponent)\napp.directive('focus', FocusDirective)\napp.use(LocalePlugin)\n```\n应用实例暴露的大多数方法都会返回该同一实例，允许链式：\n```js\nVue.createApp({})\n  .component('SearchInput', SearchInputComponent)\n  .directive('focus', FocusDirective)\n  .use(LocalePlugin)\n```\n\n## 根组件实例\n传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。\n\n一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 `<div id=\"app\"></div>`，我们应该传递 `#app`：\n```js\nconst RootComponent = { /* 选项 */ }\nconst app = Vue.createApp(RootComponent)\nconst vm = app.mount('#app')\n```\n与大多数应用方法不同的是，`mount` 不返回应用本身。相反，它返回的是**根组件实例**。\n\n虽然没有完全遵循 `MVVM` 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。\n\n# 计算属性&侦听器\n## 计算属性缓存 vs 方法\n    \n你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：\n```html\n<p>{{ calculateBooksMessage() }}</p>\n```\n```js\n// 在组件中\nmethods: {\n  calculateBooksMessage() {\n    return this.author.books.length > 0 ? 'Yes' : 'No'\n  }\n}\n```\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要`author.books` 还没有发生改变，多次访问 `publishedBookMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。 \n\n这也同样意味着下面的计算属性将不再更新，因为 **Date.now () 不是响应式依赖**：\n```js\ncomputed: {\n  now() {\n    return Date.now()\n  }\n}\n```\n相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。\n\n我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 `list`，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 `list`。如果没有缓存，我们将不可避免的多次执行 `list` 的 getter！如果你不希望有缓存，请用 method 来替代\n\n---\n以下为2021.09.16更新\n---\n## 计算属性的 Setter\n计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：\n```js\n// ...\ncomputed: {\n  fullName: {\n    // getter\n    get() {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set(newValue) {\n      const names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n// ...\n```\n现在再运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应地被更新。\n\n# Class与Style绑定\n如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作：\n```js\n<div id=\"app\">\n  <my-component class=\"baz\"></my-component>\n</div>\nconst app = Vue.createApp({})\n\napp.component('my-component', {\n  template: `\n    <p :class=\"$attrs.class\">Hi!</p>\n    <span>This is a child component</span>\n  `\n})\n```\n\n# 条件渲染\n\n## `v-if` vs `v-show`\n`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n`v-if` 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好\n\n## v-if 与 v-for 一起使用\n> 提示 不推荐同时使用 v-if 和 v-for\n\n当 `v-if` 与 `v-for` 一起使用时，`v-if` 具有比 `v-for` 更高的优先级。请查阅列表渲染指南以获取详细信息。\n\n当它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量：\n```js\n<!-- This will throw an error because property \"todo\" is not defined on instance. -->\n\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n  {{ todo }}\n</li>\n```\n可以把 v-for 移动到`<template>` 标签中来修正：\n```js\n<template v-for=\"todo in todos\">\n  <li v-if=\"!todo.isComplete\">\n    {{ todo }}\n  </li>\n</template>\n```\n# 表单绑定输入\n## 基础用法\n`v-model` 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：\n\n- text 和 textarea 元素使用 value property 和 input 事件；\n- checkbox 和 radio 使用 checked property 和 change 事件；\n- select 字段将 value 作为 prop 并将 change 作为事件。\n\n# 组件基础\n## 基本实例\n这里有一个 Vue 组件的示例：\n```js\n// 创建一个Vue 应用\nconst app = Vue.createApp({})\n\n// 定义一个名为 button-counter 的新全局组件\napp.component('button-counter', {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n})\n```\n## 组件的复用\n你可以将组件进行任意次数的复用\n每个组件都会各自独立维护它的`data`。因为你每用一次组件，就会有一个它的新组件实例被创建\n\n## 在组件上使用 v-model\n自定义事件也可以用于创建支持 `v-model` 的自定义输入组件。记住：\n```js\n<input v-model=\"searchText\" />\n等价于：\n\n<input :value=\"searchText\" @input=\"searchText = $event.target.value\" />\n当用在组件上时，v-model 则会这样：\n\n<custom-input\n  :model-value=\"searchText\"\n  @update:model-value=\"searchText = $event\"\n></custom-input>\n```\n为了让它正常工作，这个组件内的 `<input>` 必须：\n\n将其 `value` attribute 绑定到一个名叫 `modelValue` 的 prop 上\n在其 `input` 事件被触发时，将新的值通过自定义的 `update:modelValue` 事件抛出\n写成代码之后是这样的：\n```js\napp.component('custom-input', {\n  props: ['modelValue'],\n  template: `\n    <input\n      :value=\"modelValue\"\n      @input=\"$emit('update:modelValue', $event.target.value)\"\n    >\n  `\n})\n```\n现在 `v-model` 就应该可以在这个组件上完美地工作起来了：\n```html\n<custom-input v-model=\"searchText\"></custom-input>\n```\n# 深入组件\n## 非 Prop 的 Attribute\n### Attribute 继承\n当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 `<date-picker>` 组件的实例中：\n```js\napp.component('date-picker', {\n  template: `\n    <div class=\"date-picker\">\n      <input type=\"datetime\" />\n    </div>\n  `\n})\n```\n如果我们需要通过 `data status` property 定义 `<date-picker>` 组件的状态，它将应用于根节点 (即 `div.date-picker`)。\n```html\n<!-- 具有非prop attribute的Date-picker组件-->\n<date-picker data-status=\"activated\"></date-picker>\n\n<!-- 渲染 date-picker 组件 -->\n<div class=\"date-picker\" data-status=\"activated\">\n  <input type=\"datetime\" />\n</div>\n```\n\n同样的规则适用于事件监听器：\n```html\n<date-picker @change=\"submitChange\"></date-picker>\n```\n```js\napp.component('date-picker', {\n  created() {\n    console.log(this.$attrs) // { onChange: () => {}  }\n  }\n})\n```\n当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。\n```js\napp.component('date-picker', {\n  template: `\n    <select>\n      <option value=\"1\">Yesterday</option>\n      <option value=\"2\">Today</option>\n      <option value=\"3\">Tomorrow</option>\n    </select>\n  `\n})\n```\n在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件：\n```html\n<div id=\"date-picker\" class=\"demo\">\n  <date-picker @change=\"showChange\"></date-picker>\n</div>\n```\n```js\nconst app = Vue.createApp({\n  methods: {\n    showChange(event) {\n      console.log(event.target.value) // 将记录所选选项的值\n    }\n  }\n})\n```\n\n### 禁用 Attribute 继承\n如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 `inheritAttrs: false`。例如：\n\n禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。\n\n通过将 `inheritAttrs` 选项设置为 `false`，你可以访问组件的 `$attrs` property，该 property 包括组件 `props` 和 `emits` property 中未包含的所有属性 (例如，`class`、`style`、`v-on` 监听器等)。\n```js\napp.component('date-picker', {\n  inheritAttrs: false,\n  template: `\n    <div class=\"date-picker\">\n      <input type=\"datetime\" v-bind=\"$attrs\" />\n    </div>\n  `\n})\n```\n有了这个新配置，`data status` attribute 将应用于 `input` 元素！\n```html\n<!-- Date-picker 组件 使用非 prop attribute -->\n<date-picker data-status=\"activated\"></date-picker>\n\n<!-- 渲染 date-picker 组件 -->\n<div class=\"date-picker\">\n  <input type=\"datetime\" data-status=\"activated\" />\n</div>\n```\n\n### 多个根节点上的 Attribute 继承\n与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。\n```html\n<custom-layout id=\"custom-layout\" @click=\"changeValue\"></custom-layout>\n```\n```js\n// 这将发出警告\napp.component('custom-layout', {\n  template: `\n    <header>...</header>\n    <main>...</main>\n    <footer>...</footer>\n  `\n})\n\n// 没有警告，$attrs被传递到<main>元素\napp.component('custom-layout', {\n  template: `\n    <header>...</header>\n    <main v-bind=\"$attrs\">...</main>\n    <footer>...</footer>\n  `\n})\n```\n## 自定义事件\n### 处理 v-model 修饰符\n在 2.x 中，我们对组件 `v-model` 上的 `.trim` 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 `v-model` 的修饰符将通过 `modelModifiers` prop 提供给组件：\n\n让我们创建一个示例自定义修饰符 `capitalize`，它将 `v-model` 绑定提供的字符串的第一个字母大写。\n\n添加到组件 `v-model` 的修饰符将通过 `modelModifiers` prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 `modelModifiers` prop。\n\n请注意，当组件的 `created` 生命周期钩子触发时，`modelModifiers` prop 包含 `capitalize`，其值为 `true`——因为它被设置在 `v-model` 绑定 `v-model.capitalize=\"bar\"`。\n```html\n<my-component v-model.capitalize=\"bar\"></my-component>\n```\n\n```js\napp.component('my-component', {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  template: `\n    <input type=\"text\" \n      :value=\"modelValue\"\n      @input=\"$emit('update:modelValue', $event.target.value)\">\n  `,\n  created() {\n    console.log(this.modelModifiers) // { capitalize: true }\n  }\n})\n```\n现在我们已经设置了 prop，我们可以检查 `modelModifiers` 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 `<input/>` 元素触发 `input` 事件时，我们都将字符串大写。\n```html\n<div id=\"app\">\n  <my-component v-model.capitalize=\"myText\"></my-component>\n  {{ myText }}\n</div>\n```\n```js\nconst app = Vue.createApp({\n  data() {\n    return {\n      myText: ''\n    }\n  }\n})\n\napp.component('my-component', {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  methods: {\n    emitValue(e) {\n      let value = e.target.value\n      if (this.modelModifiers.capitalize) {\n        value = value.charAt(0).toUpperCase() + value.slice(1)\n      }\n      this.$emit('update:modelValue', value)\n    }\n  },\n  template: `<input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"emitValue\">`\n})\n\napp.mount('#app')\n```\n对于带参数的 `v-model` 绑定，生成的 prop 名称将为 `arg + \"Modifiers\"`：\n```html\n<my-component v-model:foo.capitalize=\"bar\"></my-component>\n```\n```js\napp.component('my-component', {\n  props: ['foo', 'fooModifiers'],\n  template: `\n    <input type=\"text\" \n      :value=\"foo\"\n      @input=\"$emit('update:foo', $event.target.value)\">\n  `,\n  created() {\n    console.log(this.fooModifiers) // { capitalize: true }\n  }\n})\n```\n---\n2021.09.17更新\n---\n## 提供/注入\n通常，当我们需要将数据从父组件传递到子组件时，我们使用`props`。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。\n\n对于这种情况，我们可以使用 `provide` 和 `inject` 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 `provide` 选项来提供数据，子组件有一个 `inject` 选项来开始使用这个数据。\n\n# 可复用&组合\n## 渲染函数\n### 虚拟DOM树\nVue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：\n```js\nreturn Vue.h('h1', {}, this.blogTitle)\n```\n`h()` 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 **VNode**。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。\n\n### h()参数\nh() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：\n\n```js\nh(\n  // {String | Object | Function | null} tag\n  // 一个 HTML 标签名、一个组件、一个异步组件，或者 null。\n  // 使用 null 将会渲染一个注释。\n  //\n  // 必需的。\n  'div',\n\n  // {Object} props\n  // 与 attribute、prop 和事件相对应的对象。\n  // 我们会在模板中使用。\n  //\n  // 可选的。\n  {},\n\n  // {String | Array | Object} children\n  // 子 VNodes, 使用 `h()` 构建,\n  // 或使用字符串获取 \"文本 Vnode\" 或者\n  // 有 slot 的对象。\n  //\n  // 可选的。\n  [\n    'Some text comes first.',\n    h('h1', 'A headline'),\n    h(MyComponent, {\n      someProp: 'foobar'\n    })\n  ]\n)\n```\n\n### 完整实例\n有了这些知识，我们现在可以完成我们最开始想实现的组件：\n```js\nconst app = Vue.createApp({})\n\n/** Recursively get text from children nodes */\nfunction getChildrenTextContent(children) {\n  return children\n    .map(node => {\n      return typeof node.children === 'string'\n        ? node.children\n        : Array.isArray(node.children)\n        ? getChildrenTextContent(node.children)\n        : ''\n    })\n    .join('')\n}\n\napp.component('anchored-heading', {\n  render() {\n    // create kebab-case id from the text contents of the children\n    const headingId = getChildrenTextContent(this.$slots.default())\n      .toLowerCase()\n      .replace(/\\W+/g, '-') // replace non-word characters with dash\n      .replace(/(^-|-$)/g, '') // remove leading and trailing dashes\n\n    return Vue.h('h' + this.level, [\n      Vue.h(\n        'a',\n        {\n          name: headingId,\n          href: '#' + headingId\n        },\n        this.$slots.default()\n      )\n    ])\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```","source":"_posts/2021-09-15-vue3文档记录.md","raw":"---\ntitle: 通读vue3文档记录\ndate: 2021-09-15 19:03:11\ntags: Vue3\ncategories: 技术类-Vue\n---\n之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是`Object.defineProperty()`，vue3用的是`Proxy`。vue3还新增了`组合式API`等等。\n\n这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。\n\n持续更新ing\n\n# 应用&组件实例\n## 应用实例\n每个 Vue 应用都是通过用 createApp 函数创建一个新的**应用实例**开始的：\n\n```js\nconst app = Vue.createApp({ /* 选项 */ })\n```\n\n该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：\n```js\nconst app = Vue.createApp({})\napp.component('SearchInput', SearchInputComponent)\napp.directive('focus', FocusDirective)\napp.use(LocalePlugin)\n```\n应用实例暴露的大多数方法都会返回该同一实例，允许链式：\n```js\nVue.createApp({})\n  .component('SearchInput', SearchInputComponent)\n  .directive('focus', FocusDirective)\n  .use(LocalePlugin)\n```\n\n## 根组件实例\n传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。\n\n一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 `<div id=\"app\"></div>`，我们应该传递 `#app`：\n```js\nconst RootComponent = { /* 选项 */ }\nconst app = Vue.createApp(RootComponent)\nconst vm = app.mount('#app')\n```\n与大多数应用方法不同的是，`mount` 不返回应用本身。相反，它返回的是**根组件实例**。\n\n虽然没有完全遵循 `MVVM` 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。\n\n# 计算属性&侦听器\n## 计算属性缓存 vs 方法\n    \n你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：\n```html\n<p>{{ calculateBooksMessage() }}</p>\n```\n```js\n// 在组件中\nmethods: {\n  calculateBooksMessage() {\n    return this.author.books.length > 0 ? 'Yes' : 'No'\n  }\n}\n```\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要`author.books` 还没有发生改变，多次访问 `publishedBookMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。 \n\n这也同样意味着下面的计算属性将不再更新，因为 **Date.now () 不是响应式依赖**：\n```js\ncomputed: {\n  now() {\n    return Date.now()\n  }\n}\n```\n相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。\n\n我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 `list`，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 `list`。如果没有缓存，我们将不可避免的多次执行 `list` 的 getter！如果你不希望有缓存，请用 method 来替代\n\n---\n以下为2021.09.16更新\n---\n## 计算属性的 Setter\n计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：\n```js\n// ...\ncomputed: {\n  fullName: {\n    // getter\n    get() {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set(newValue) {\n      const names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n// ...\n```\n现在再运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应地被更新。\n\n# Class与Style绑定\n如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作：\n```js\n<div id=\"app\">\n  <my-component class=\"baz\"></my-component>\n</div>\nconst app = Vue.createApp({})\n\napp.component('my-component', {\n  template: `\n    <p :class=\"$attrs.class\">Hi!</p>\n    <span>This is a child component</span>\n  `\n})\n```\n\n# 条件渲染\n\n## `v-if` vs `v-show`\n`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n`v-if` 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好\n\n## v-if 与 v-for 一起使用\n> 提示 不推荐同时使用 v-if 和 v-for\n\n当 `v-if` 与 `v-for` 一起使用时，`v-if` 具有比 `v-for` 更高的优先级。请查阅列表渲染指南以获取详细信息。\n\n当它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量：\n```js\n<!-- This will throw an error because property \"todo\" is not defined on instance. -->\n\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n  {{ todo }}\n</li>\n```\n可以把 v-for 移动到`<template>` 标签中来修正：\n```js\n<template v-for=\"todo in todos\">\n  <li v-if=\"!todo.isComplete\">\n    {{ todo }}\n  </li>\n</template>\n```\n# 表单绑定输入\n## 基础用法\n`v-model` 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：\n\n- text 和 textarea 元素使用 value property 和 input 事件；\n- checkbox 和 radio 使用 checked property 和 change 事件；\n- select 字段将 value 作为 prop 并将 change 作为事件。\n\n# 组件基础\n## 基本实例\n这里有一个 Vue 组件的示例：\n```js\n// 创建一个Vue 应用\nconst app = Vue.createApp({})\n\n// 定义一个名为 button-counter 的新全局组件\napp.component('button-counter', {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n})\n```\n## 组件的复用\n你可以将组件进行任意次数的复用\n每个组件都会各自独立维护它的`data`。因为你每用一次组件，就会有一个它的新组件实例被创建\n\n## 在组件上使用 v-model\n自定义事件也可以用于创建支持 `v-model` 的自定义输入组件。记住：\n```js\n<input v-model=\"searchText\" />\n等价于：\n\n<input :value=\"searchText\" @input=\"searchText = $event.target.value\" />\n当用在组件上时，v-model 则会这样：\n\n<custom-input\n  :model-value=\"searchText\"\n  @update:model-value=\"searchText = $event\"\n></custom-input>\n```\n为了让它正常工作，这个组件内的 `<input>` 必须：\n\n将其 `value` attribute 绑定到一个名叫 `modelValue` 的 prop 上\n在其 `input` 事件被触发时，将新的值通过自定义的 `update:modelValue` 事件抛出\n写成代码之后是这样的：\n```js\napp.component('custom-input', {\n  props: ['modelValue'],\n  template: `\n    <input\n      :value=\"modelValue\"\n      @input=\"$emit('update:modelValue', $event.target.value)\"\n    >\n  `\n})\n```\n现在 `v-model` 就应该可以在这个组件上完美地工作起来了：\n```html\n<custom-input v-model=\"searchText\"></custom-input>\n```\n# 深入组件\n## 非 Prop 的 Attribute\n### Attribute 继承\n当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 `<date-picker>` 组件的实例中：\n```js\napp.component('date-picker', {\n  template: `\n    <div class=\"date-picker\">\n      <input type=\"datetime\" />\n    </div>\n  `\n})\n```\n如果我们需要通过 `data status` property 定义 `<date-picker>` 组件的状态，它将应用于根节点 (即 `div.date-picker`)。\n```html\n<!-- 具有非prop attribute的Date-picker组件-->\n<date-picker data-status=\"activated\"></date-picker>\n\n<!-- 渲染 date-picker 组件 -->\n<div class=\"date-picker\" data-status=\"activated\">\n  <input type=\"datetime\" />\n</div>\n```\n\n同样的规则适用于事件监听器：\n```html\n<date-picker @change=\"submitChange\"></date-picker>\n```\n```js\napp.component('date-picker', {\n  created() {\n    console.log(this.$attrs) // { onChange: () => {}  }\n  }\n})\n```\n当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。\n```js\napp.component('date-picker', {\n  template: `\n    <select>\n      <option value=\"1\">Yesterday</option>\n      <option value=\"2\">Today</option>\n      <option value=\"3\">Tomorrow</option>\n    </select>\n  `\n})\n```\n在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件：\n```html\n<div id=\"date-picker\" class=\"demo\">\n  <date-picker @change=\"showChange\"></date-picker>\n</div>\n```\n```js\nconst app = Vue.createApp({\n  methods: {\n    showChange(event) {\n      console.log(event.target.value) // 将记录所选选项的值\n    }\n  }\n})\n```\n\n### 禁用 Attribute 继承\n如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 `inheritAttrs: false`。例如：\n\n禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。\n\n通过将 `inheritAttrs` 选项设置为 `false`，你可以访问组件的 `$attrs` property，该 property 包括组件 `props` 和 `emits` property 中未包含的所有属性 (例如，`class`、`style`、`v-on` 监听器等)。\n```js\napp.component('date-picker', {\n  inheritAttrs: false,\n  template: `\n    <div class=\"date-picker\">\n      <input type=\"datetime\" v-bind=\"$attrs\" />\n    </div>\n  `\n})\n```\n有了这个新配置，`data status` attribute 将应用于 `input` 元素！\n```html\n<!-- Date-picker 组件 使用非 prop attribute -->\n<date-picker data-status=\"activated\"></date-picker>\n\n<!-- 渲染 date-picker 组件 -->\n<div class=\"date-picker\">\n  <input type=\"datetime\" data-status=\"activated\" />\n</div>\n```\n\n### 多个根节点上的 Attribute 继承\n与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。\n```html\n<custom-layout id=\"custom-layout\" @click=\"changeValue\"></custom-layout>\n```\n```js\n// 这将发出警告\napp.component('custom-layout', {\n  template: `\n    <header>...</header>\n    <main>...</main>\n    <footer>...</footer>\n  `\n})\n\n// 没有警告，$attrs被传递到<main>元素\napp.component('custom-layout', {\n  template: `\n    <header>...</header>\n    <main v-bind=\"$attrs\">...</main>\n    <footer>...</footer>\n  `\n})\n```\n## 自定义事件\n### 处理 v-model 修饰符\n在 2.x 中，我们对组件 `v-model` 上的 `.trim` 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 `v-model` 的修饰符将通过 `modelModifiers` prop 提供给组件：\n\n让我们创建一个示例自定义修饰符 `capitalize`，它将 `v-model` 绑定提供的字符串的第一个字母大写。\n\n添加到组件 `v-model` 的修饰符将通过 `modelModifiers` prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 `modelModifiers` prop。\n\n请注意，当组件的 `created` 生命周期钩子触发时，`modelModifiers` prop 包含 `capitalize`，其值为 `true`——因为它被设置在 `v-model` 绑定 `v-model.capitalize=\"bar\"`。\n```html\n<my-component v-model.capitalize=\"bar\"></my-component>\n```\n\n```js\napp.component('my-component', {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  template: `\n    <input type=\"text\" \n      :value=\"modelValue\"\n      @input=\"$emit('update:modelValue', $event.target.value)\">\n  `,\n  created() {\n    console.log(this.modelModifiers) // { capitalize: true }\n  }\n})\n```\n现在我们已经设置了 prop，我们可以检查 `modelModifiers` 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 `<input/>` 元素触发 `input` 事件时，我们都将字符串大写。\n```html\n<div id=\"app\">\n  <my-component v-model.capitalize=\"myText\"></my-component>\n  {{ myText }}\n</div>\n```\n```js\nconst app = Vue.createApp({\n  data() {\n    return {\n      myText: ''\n    }\n  }\n})\n\napp.component('my-component', {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  methods: {\n    emitValue(e) {\n      let value = e.target.value\n      if (this.modelModifiers.capitalize) {\n        value = value.charAt(0).toUpperCase() + value.slice(1)\n      }\n      this.$emit('update:modelValue', value)\n    }\n  },\n  template: `<input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"emitValue\">`\n})\n\napp.mount('#app')\n```\n对于带参数的 `v-model` 绑定，生成的 prop 名称将为 `arg + \"Modifiers\"`：\n```html\n<my-component v-model:foo.capitalize=\"bar\"></my-component>\n```\n```js\napp.component('my-component', {\n  props: ['foo', 'fooModifiers'],\n  template: `\n    <input type=\"text\" \n      :value=\"foo\"\n      @input=\"$emit('update:foo', $event.target.value)\">\n  `,\n  created() {\n    console.log(this.fooModifiers) // { capitalize: true }\n  }\n})\n```\n---\n2021.09.17更新\n---\n## 提供/注入\n通常，当我们需要将数据从父组件传递到子组件时，我们使用`props`。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。\n\n对于这种情况，我们可以使用 `provide` 和 `inject` 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 `provide` 选项来提供数据，子组件有一个 `inject` 选项来开始使用这个数据。\n\n# 可复用&组合\n## 渲染函数\n### 虚拟DOM树\nVue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：\n```js\nreturn Vue.h('h1', {}, this.blogTitle)\n```\n`h()` 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 **VNode**。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。\n\n### h()参数\nh() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：\n\n```js\nh(\n  // {String | Object | Function | null} tag\n  // 一个 HTML 标签名、一个组件、一个异步组件，或者 null。\n  // 使用 null 将会渲染一个注释。\n  //\n  // 必需的。\n  'div',\n\n  // {Object} props\n  // 与 attribute、prop 和事件相对应的对象。\n  // 我们会在模板中使用。\n  //\n  // 可选的。\n  {},\n\n  // {String | Array | Object} children\n  // 子 VNodes, 使用 `h()` 构建,\n  // 或使用字符串获取 \"文本 Vnode\" 或者\n  // 有 slot 的对象。\n  //\n  // 可选的。\n  [\n    'Some text comes first.',\n    h('h1', 'A headline'),\n    h(MyComponent, {\n      someProp: 'foobar'\n    })\n  ]\n)\n```\n\n### 完整实例\n有了这些知识，我们现在可以完成我们最开始想实现的组件：\n```js\nconst app = Vue.createApp({})\n\n/** Recursively get text from children nodes */\nfunction getChildrenTextContent(children) {\n  return children\n    .map(node => {\n      return typeof node.children === 'string'\n        ? node.children\n        : Array.isArray(node.children)\n        ? getChildrenTextContent(node.children)\n        : ''\n    })\n    .join('')\n}\n\napp.component('anchored-heading', {\n  render() {\n    // create kebab-case id from the text contents of the children\n    const headingId = getChildrenTextContent(this.$slots.default())\n      .toLowerCase()\n      .replace(/\\W+/g, '-') // replace non-word characters with dash\n      .replace(/(^-|-$)/g, '') // remove leading and trailing dashes\n\n    return Vue.h('h' + this.level, [\n      Vue.h(\n        'a',\n        {\n          name: headingId,\n          href: '#' + headingId\n        },\n        this.$slots.default()\n      )\n    ])\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```","slug":"vue3文档记录","published":1,"updated":"2021-09-17T10:41:59.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5000087oo9g07l47k3","content":"<p>之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是<code>Object.defineProperty()</code>，vue3用的是<code>Proxy</code>。vue3还新增了<code>组合式API</code>等等。</p>\n<p>这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。</p>\n<p>持续更新ing</p>\n<h1 id=\"应用-amp-组件实例\"><a href=\"#应用-amp-组件实例\" class=\"headerlink\" title=\"应用&amp;组件实例\"></a>应用&amp;组件实例</h1><h2 id=\"应用实例\"><a href=\"#应用实例\" class=\"headerlink\" title=\"应用实例\"></a>应用实例</h2><p>每个 Vue 应用都是通过用 createApp 函数创建一个新的<strong>应用实例</strong>开始的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123; <span class=\"hljs-comment\">/* 选项 */</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n<p>该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br>app.component(<span class=\"hljs-string\">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>app.directive(<span class=\"hljs-string\">&#x27;focus&#x27;</span>, FocusDirective)<br>app.use(LocalePlugin)<br></code></pre></td></tr></table></figure>\n<p>应用实例暴露的大多数方法都会返回该同一实例，允许链式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">Vue.createApp(&#123;&#125;)<br>  .component(<span class=\"hljs-string\">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>  .directive(<span class=\"hljs-string\">&#x27;focus&#x27;</span>, FocusDirective)<br>  .use(LocalePlugin)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"根组件实例\"><a href=\"#根组件实例\" class=\"headerlink\" title=\"根组件实例\"></a>根组件实例</h2><p>传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。</p>\n<p>一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，我们应该传递 <code>#app</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> RootComponent = &#123; <span class=\"hljs-comment\">/* 选项 */</span> &#125;<br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(RootComponent)<br><span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>与大多数应用方法不同的是，<code>mount</code> 不返回应用本身。相反，它返回的是<strong>根组件实例</strong>。</p>\n<p>虽然没有完全遵循 <code>MVVM</code> 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。</p>\n<h1 id=\"计算属性-amp-侦听器\"><a href=\"#计算属性-amp-侦听器\" class=\"headerlink\" title=\"计算属性&amp;侦听器\"></a>计算属性&amp;侦听器</h1><h2 id=\"计算属性缓存-vs-方法\"><a href=\"#计算属性缓存-vs-方法\" class=\"headerlink\" title=\"计算属性缓存 vs 方法\"></a>计算属性缓存 vs 方法</h2><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123; calculateBooksMessage() &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 在组件中</span><br><span class=\"hljs-attr\">methods</span>: &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">calculateBooksMessage</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.author.books.length &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-string\">&#x27;Yes&#x27;</span> : <span class=\"hljs-string\">&#x27;No&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要<code>author.books</code> 还没有发生改变，多次访问 <code>publishedBookMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。 </p>\n<p>这也同样意味着下面的计算属性将不再更新，因为 <strong>Date.now () 不是响应式依赖</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">computed: &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">now</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Date</span>.now()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p>\n<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <code>list</code>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <code>list</code>。如果没有缓存，我们将不可避免的多次执行 <code>list</code> 的 getter！如果你不希望有缓存，请用 method 来替代</p>\n<hr>\n<h2 id=\"以下为2021-09-16更新\"><a href=\"#以下为2021-09-16更新\" class=\"headerlink\" title=\"以下为2021.09.16更新\"></a>以下为2021.09.16更新</h2><h2 id=\"计算属性的-Setter\"><a href=\"#计算属性的-Setter\" class=\"headerlink\" title=\"计算属性的 Setter\"></a>计算属性的 Setter</h2><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// ...</span><br><span class=\"hljs-attr\">computed</span>: &#123;<br>  <span class=\"hljs-attr\">fullName</span>: &#123;<br>    <span class=\"hljs-comment\">// getter</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.firstName + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-built_in\">this</span>.lastName<br>    &#125;,<br>    <span class=\"hljs-comment\">// setter</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\">newValue</span>)</span> &#123;<br>      <span class=\"hljs-keyword\">const</span> names = newValue.split(<span class=\"hljs-string\">&#x27; &#x27;</span>)<br>      <span class=\"hljs-built_in\">this</span>.firstName = names[<span class=\"hljs-number\">0</span>]<br>      <span class=\"hljs-built_in\">this</span>.lastName = names[names.length - <span class=\"hljs-number\">1</span>]<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// ...</span><br></code></pre></td></tr></table></figure>\n<p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p>\n<h1 id=\"Class与Style绑定\"><a href=\"#Class与Style绑定\" class=\"headerlink\" title=\"Class与Style绑定\"></a>Class与Style绑定</h1><p>如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;div id=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;baz&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></span><br>&lt;/div&gt;<br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br>app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;</span><br><span class=\"hljs-string\">    &lt;span&gt;This is a child component&lt;/span&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h1><h2 id=\"v-if-vs-v-show\"><a href=\"#v-if-vs-v-show\" class=\"headerlink\" title=\"v-if vs v-show\"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>\n<p><code>v-if</code> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>\n<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>\n<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好</p>\n<h2 id=\"v-if-与-v-for-一起使用\"><a href=\"#v-if-与-v-for-一起使用\" class=\"headerlink\" title=\"v-if 与 v-for 一起使用\"></a>v-if 与 v-for 一起使用</h2><blockquote>\n<p>提示 不推荐同时使用 v-if 和 v-for</p>\n</blockquote>\n<p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-if</code> 具有比 <code>v-for</code> 更高的优先级。请查阅列表渲染指南以获取详细信息。</p>\n<p>当它们处于同一节点，<code>v-if</code> 的优先级比 <code>v-for</code> 更高，这意味着 <code>v-if</code> 将没有权限访问 <code>v-for</code> 里的变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;!-- This will <span class=\"hljs-keyword\">throw</span> an error because property <span class=\"hljs-string\">&quot;todo&quot;</span> is not defined on instance. --&gt;<br><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;todo in todos&quot;</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class=\"xml\">  &#123;&#123; todo &#125;&#125;</span><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>可以把 v-for 移动到<code>&lt;template&gt;</code> 标签中来修正：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;template v-<span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">&quot;todo in todos&quot;</span>&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class=\"xml\">    &#123;&#123; todo &#125;&#125;</span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n<h1 id=\"表单绑定输入\"><a href=\"#表单绑定输入\" class=\"headerlink\" title=\"表单绑定输入\"></a>表单绑定输入</h1><h2 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h2><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>\n<ul>\n<li>text 和 textarea 元素使用 value property 和 input 事件；</li>\n<li>checkbox 和 radio 使用 checked property 和 change 事件；</li>\n<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>\n</ul>\n<h1 id=\"组件基础\"><a href=\"#组件基础\" class=\"headerlink\" title=\"组件基础\"></a>组件基础</h1><h2 id=\"基本实例\"><a href=\"#基本实例\" class=\"headerlink\" title=\"基本实例\"></a>基本实例</h2><p>这里有一个 Vue 组件的示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 创建一个Vue 应用</span><br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class=\"hljs-comment\">// 定义一个名为 button-counter 的新全局组件</span><br>app.component(<span class=\"hljs-string\">&#x27;button-counter&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span><br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;button @click=&quot;count++&quot;&gt;</span><br><span class=\"hljs-string\">      You clicked me &#123;&#123; count &#125;&#125; times.</span><br><span class=\"hljs-string\">    &lt;/button&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<h2 id=\"组件的复用\"><a href=\"#组件的复用\" class=\"headerlink\" title=\"组件的复用\"></a>组件的复用</h2><p>你可以将组件进行任意次数的复用<br>每个组件都会各自独立维护它的<code>data</code>。因为你每用一次组件，就会有一个它的新组件实例被创建</p>\n<h2 id=\"在组件上使用-v-model\"><a href=\"#在组件上使用-v-model\" class=\"headerlink\" title=\"在组件上使用 v-model\"></a>在组件上使用 v-model</h2><p>自定义事件也可以用于创建支持 <code>v-model</code> 的自定义输入组件。记住：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;input v-model=<span class=\"hljs-string\">&quot;searchText&quot;</span> /&gt;<br>等价于：<br><br>&lt;input :value=<span class=\"hljs-string\">&quot;searchText&quot;</span> @input=<span class=\"hljs-string\">&quot;searchText = $event.target.value&quot;</span> /&gt;<br>当用在组件上时，v-model 则会这样：<br><br>&lt;custom-input<br>  :model-value=<span class=\"hljs-string\">&quot;searchText&quot;</span><br>  @update:model-value=<span class=\"hljs-string\">&quot;searchText = $event&quot;</span><br>&gt;&lt;/custom-input&gt;<br></code></pre></td></tr></table></figure>\n<p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code> 必须：</p>\n<p>将其 <code>value</code> attribute 绑定到一个名叫 <code>modelValue</code> 的 prop 上<br>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>update:modelValue</code> 事件抛出<br>写成代码之后是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;custom-input&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;modelValue&#x27;</span>],<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input</span><br><span class=\"hljs-string\">      :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span><br><span class=\"hljs-string\">    &gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>现在 <code>v-model</code> 就应该可以在这个组件上完美地工作起来了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;searchText&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-input</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"深入组件\"><a href=\"#深入组件\" class=\"headerlink\" title=\"深入组件\"></a>深入组件</h1><h2 id=\"非-Prop-的-Attribute\"><a href=\"#非-Prop-的-Attribute\" class=\"headerlink\" title=\"非 Prop 的 Attribute\"></a>非 Prop 的 Attribute</h2><h3 id=\"Attribute-继承\"><a href=\"#Attribute-继承\" class=\"headerlink\" title=\"Attribute 继承\"></a>Attribute 继承</h3><p>当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 <code>&lt;date-picker&gt;</code> 组件的实例中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class=\"hljs-string\">      &lt;input type=&quot;datetime&quot; /&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>如果我们需要通过 <code>data status</code> property 定义 <code>&lt;date-picker&gt;</code> 组件的状态，它将应用于根节点 (即 <code>div.date-picker</code>)。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 具有非prop attribute的Date-picker组件--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;datetime&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>同样的规则适用于事件监听器：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">&quot;submitChange&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.$attrs) <span class=\"hljs-comment\">// &#123; onChange: () =&gt; &#123;&#125;  &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;select&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;1&quot;&gt;Yesterday&lt;/option&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;2&quot;&gt;Today&lt;/option&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;3&quot;&gt;Tomorrow&lt;/option&gt;</span><br><span class=\"hljs-string\">    &lt;/select&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;demo&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">&quot;showChange&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">showChange</span>(<span class=\"hljs-params\">event</span>)</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(event.target.value) <span class=\"hljs-comment\">// 将记录所选选项的值</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"禁用-Attribute-继承\"><a href=\"#禁用-Attribute-继承\" class=\"headerlink\" title=\"禁用 Attribute 继承\"></a>禁用 Attribute 继承</h3><p>如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p>\n<p>禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。</p>\n<p>通过将 <code>inheritAttrs</code> 选项设置为 <code>false</code>，你可以访问组件的 <code>$attrs</code> property，该 property 包括组件 <code>props</code> 和 <code>emits</code> property 中未包含的所有属性 (例如，<code>class</code>、<code>style</code>、<code>v-on</code> 监听器等)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class=\"hljs-string\">      &lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>有了这个新配置，<code>data status</code> attribute 将应用于 <code>input</code> 元素！</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Date-picker 组件 使用非 prop attribute --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;datetime&quot;</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"多个根节点上的-Attribute-继承\"><a href=\"#多个根节点上的-Attribute-继承\" class=\"headerlink\" title=\"多个根节点上的 Attribute 继承\"></a>多个根节点上的 Attribute 继承</h3><p>与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-layout</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;custom-layout&quot;</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;changeValue&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-layout</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 这将发出警告</span><br>app.component(<span class=\"hljs-string\">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;header&gt;...&lt;/header&gt;</span><br><span class=\"hljs-string\">    &lt;main&gt;...&lt;/main&gt;</span><br><span class=\"hljs-string\">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 没有警告，$attrs被传递到&lt;main&gt;元素</span><br>app.component(<span class=\"hljs-string\">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;header&gt;...&lt;/header&gt;</span><br><span class=\"hljs-string\">    &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class=\"hljs-string\">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<h2 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h2><h3 id=\"处理-v-model-修饰符\"><a href=\"#处理-v-model-修饰符\" class=\"headerlink\" title=\"处理 v-model 修饰符\"></a>处理 v-model 修饰符</h3><p>在 2.x 中，我们对组件 <code>v-model</code> 上的 <code>.trim</code> 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件：</p>\n<p>让我们创建一个示例自定义修饰符 <code>capitalize</code>，它将 <code>v-model</code> 绑定提供的字符串的第一个字母大写。</p>\n<p>添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 <code>modelModifiers</code> prop。</p>\n<p>请注意，当组件的 <code>created</code> 生命周期钩子触发时，<code>modelModifiers</code> prop 包含 <code>capitalize</code>，其值为 <code>true</code>——因为它被设置在 <code>v-model</code> 绑定 <code>v-model.capitalize=&quot;bar&quot;</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model.capitalize</span>=<span class=\"hljs-string\">&quot;bar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">modelValue</span>: <span class=\"hljs-built_in\">String</span>,<br>    <span class=\"hljs-attr\">modelModifiers</span>: &#123;<br>      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input type=&quot;text&quot; </span><br><span class=\"hljs-string\">      :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;&gt;</span><br><span class=\"hljs-string\">  `</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.modelModifiers) <span class=\"hljs-comment\">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>现在我们已经设置了 prop，我们可以检查 <code>modelModifiers</code> 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 <code>&lt;input/&gt;</code> 元素触发 <code>input</code> 事件时，我们都将字符串大写。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model.capitalize</span>=<span class=\"hljs-string\">&quot;myText&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br>  &#123;&#123; myText &#125;&#125;<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-attr\">myText</span>: <span class=\"hljs-string\">&#x27;&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br><br>app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">modelValue</span>: <span class=\"hljs-built_in\">String</span>,<br>    <span class=\"hljs-attr\">modelModifiers</span>: &#123;<br>      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">emitValue</span>(<span class=\"hljs-params\">e</span>)</span> &#123;<br>      <span class=\"hljs-keyword\">let</span> value = e.target.value<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.modelModifiers.capitalize) &#123;<br>        value = value.charAt(<span class=\"hljs-number\">0</span>).toUpperCase() + value.slice(<span class=\"hljs-number\">1</span>)<br>      &#125;<br>      <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&#x27;update:modelValue&#x27;</span>, value)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;input</span><br><span class=\"hljs-string\">    type=&quot;text&quot;</span><br><span class=\"hljs-string\">    :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">    @input=&quot;emitValue&quot;&gt;`</span><br>&#125;)<br><br>app.mount(<span class=\"hljs-string\">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>对于带参数的 <code>v-model</code> 绑定，生成的 prop 名称将为 <code>arg + &quot;Modifiers&quot;</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model:foo.capitalize</span>=<span class=\"hljs-string\">&quot;bar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;foo&#x27;</span>, <span class=\"hljs-string\">&#x27;fooModifiers&#x27;</span>],<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input type=&quot;text&quot; </span><br><span class=\"hljs-string\">      :value=&quot;foo&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:foo&#x27;, $event.target.value)&quot;&gt;</span><br><span class=\"hljs-string\">  `</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.fooModifiers) <span class=\"hljs-comment\">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"2021-09-17更新\"><a href=\"#2021-09-17更新\" class=\"headerlink\" title=\"2021.09.17更新\"></a>2021.09.17更新</h2><h2 id=\"提供-注入\"><a href=\"#提供-注入\" class=\"headerlink\" title=\"提供/注入\"></a>提供/注入</h2><p>通常，当我们需要将数据从父组件传递到子组件时，我们使用<code>props</code>。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。</p>\n<p>对于这种情况，我们可以使用 <code>provide</code> 和 <code>inject</code> 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这个数据。</p>\n<h1 id=\"可复用-amp-组合\"><a href=\"#可复用-amp-组合\" class=\"headerlink\" title=\"可复用&amp;组合\"></a>可复用&amp;组合</h1><h2 id=\"渲染函数\"><a href=\"#渲染函数\" class=\"headerlink\" title=\"渲染函数\"></a>渲染函数</h2><h3 id=\"虚拟DOM树\"><a href=\"#虚拟DOM树\" class=\"headerlink\" title=\"虚拟DOM树\"></a>虚拟DOM树</h3><p>Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">return</span> Vue.h(<span class=\"hljs-string\">&#x27;h1&#x27;</span>, &#123;&#125;, <span class=\"hljs-built_in\">this</span>.blogTitle)<br></code></pre></td></tr></table></figure>\n<p><code>h()</code> 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 <strong>VNode</strong>。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p>\n<h3 id=\"h-参数\"><a href=\"#h-参数\" class=\"headerlink\" title=\"h()参数\"></a>h()参数</h3><p>h() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">h(<br>  <span class=\"hljs-comment\">// &#123;String | Object | Function | null&#125; tag</span><br>  <span class=\"hljs-comment\">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span><br>  <span class=\"hljs-comment\">// 使用 null 将会渲染一个注释。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 必需的。</span><br>  <span class=\"hljs-string\">&#x27;div&#x27;</span>,<br><br>  <span class=\"hljs-comment\">// &#123;Object&#125; props</span><br>  <span class=\"hljs-comment\">// 与 attribute、prop 和事件相对应的对象。</span><br>  <span class=\"hljs-comment\">// 我们会在模板中使用。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 可选的。</span><br>  &#123;&#125;,<br><br>  <span class=\"hljs-comment\">// &#123;String | Array | Object&#125; children</span><br>  <span class=\"hljs-comment\">// 子 VNodes, 使用 `h()` 构建,</span><br>  <span class=\"hljs-comment\">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span><br>  <span class=\"hljs-comment\">// 有 slot 的对象。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 可选的。</span><br>  [<br>    <span class=\"hljs-string\">&#x27;Some text comes first.&#x27;</span>,<br>    h(<span class=\"hljs-string\">&#x27;h1&#x27;</span>, <span class=\"hljs-string\">&#x27;A headline&#x27;</span>),<br>    h(MyComponent, &#123;<br>      <span class=\"hljs-attr\">someProp</span>: <span class=\"hljs-string\">&#x27;foobar&#x27;</span><br>    &#125;)<br>  ]<br>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"完整实例\"><a href=\"#完整实例\" class=\"headerlink\" title=\"完整实例\"></a>完整实例</h3><p>有了这些知识，我们现在可以完成我们最开始想实现的组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class=\"hljs-comment\">/** Recursively get text from children nodes */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getChildrenTextContent</span>(<span class=\"hljs-params\">children</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> children<br>    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">node</span> =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> node.children === <span class=\"hljs-string\">&#x27;string&#x27;</span><br>        ? node.children<br>        : <span class=\"hljs-built_in\">Array</span>.isArray(node.children)<br>        ? getChildrenTextContent(node.children)<br>        : <span class=\"hljs-string\">&#x27;&#x27;</span><br>    &#125;)<br>    .join(<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>&#125;<br><br>app.component(<span class=\"hljs-string\">&#x27;anchored-heading&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-comment\">// create kebab-case id from the text contents of the children</span><br>    <span class=\"hljs-keyword\">const</span> headingId = getChildrenTextContent(<span class=\"hljs-built_in\">this</span>.$slots.default())<br>      .toLowerCase()<br>      .replace(<span class=\"hljs-regexp\">/\\W+/g</span>, <span class=\"hljs-string\">&#x27;-&#x27;</span>) <span class=\"hljs-comment\">// replace non-word characters with dash</span><br>      .replace(<span class=\"hljs-regexp\">/(^-|-$)/g</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-comment\">// remove leading and trailing dashes</span><br><br>    <span class=\"hljs-keyword\">return</span> Vue.h(<span class=\"hljs-string\">&#x27;h&#x27;</span> + <span class=\"hljs-built_in\">this</span>.level, [<br>      Vue.h(<br>        <span class=\"hljs-string\">&#x27;a&#x27;</span>,<br>        &#123;<br>          <span class=\"hljs-attr\">name</span>: headingId,<br>          <span class=\"hljs-attr\">href</span>: <span class=\"hljs-string\">&#x27;#&#x27;</span> + headingId<br>        &#125;,<br>        <span class=\"hljs-built_in\">this</span>.$slots.default()<br>      )<br>    ])<br>  &#125;,<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">level</span>: &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,<br>      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>之前学习过vue2，这次项目使用vue3我只是快速粗略的看过改变的部分。今天有空就把vue3文档从头到尾看了一遍。就当做对vue从头开始的学习和补漏，理解了一些用法改变的原理。最明显的地方就是响应式的改变，vue2用的是<code>Object.defineProperty()</code>，vue3用的是<code>Proxy</code>。vue3还新增了<code>组合式API</code>等等。</p>\n<p>这次记录主要是记录一些基础的，面试常被问到的，查漏补缺。</p>\n<p>持续更新ing</p>\n<h1 id=\"应用-amp-组件实例\"><a href=\"#应用-amp-组件实例\" class=\"headerlink\" title=\"应用&amp;组件实例\"></a>应用&amp;组件实例</h1><h2 id=\"应用实例\"><a href=\"#应用实例\" class=\"headerlink\" title=\"应用实例\"></a>应用实例</h2><p>每个 Vue 应用都是通过用 createApp 函数创建一个新的<strong>应用实例</strong>开始的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123; <span class=\"hljs-comment\">/* 选项 */</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n<p>该应用实例是用来在应用中注册“全局”组件的。我们将在后面的指南中详细讨论，简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br>app.component(<span class=\"hljs-string\">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>app.directive(<span class=\"hljs-string\">&#x27;focus&#x27;</span>, FocusDirective)<br>app.use(LocalePlugin)<br></code></pre></td></tr></table></figure>\n<p>应用实例暴露的大多数方法都会返回该同一实例，允许链式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">Vue.createApp(&#123;&#125;)<br>  .component(<span class=\"hljs-string\">&#x27;SearchInput&#x27;</span>, SearchInputComponent)<br>  .directive(<span class=\"hljs-string\">&#x27;focus&#x27;</span>, FocusDirective)<br>  .use(LocalePlugin)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"根组件实例\"><a href=\"#根组件实例\" class=\"headerlink\" title=\"根组件实例\"></a>根组件实例</h2><p>传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。</p>\n<p>一个应用需要被挂载到一个 DOM 元素中。例如，如果我们想把一个 Vue 应用挂载到 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，我们应该传递 <code>#app</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> RootComponent = &#123; <span class=\"hljs-comment\">/* 选项 */</span> &#125;<br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(RootComponent)<br><span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>与大多数应用方法不同的是，<code>mount</code> 不返回应用本身。相反，它返回的是<strong>根组件实例</strong>。</p>\n<p>虽然没有完全遵循 <code>MVVM</code> 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。</p>\n<h1 id=\"计算属性-amp-侦听器\"><a href=\"#计算属性-amp-侦听器\" class=\"headerlink\" title=\"计算属性&amp;侦听器\"></a>计算属性&amp;侦听器</h1><h2 id=\"计算属性缓存-vs-方法\"><a href=\"#计算属性缓存-vs-方法\" class=\"headerlink\" title=\"计算属性缓存 vs 方法\"></a>计算属性缓存 vs 方法</h2><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123; calculateBooksMessage() &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 在组件中</span><br><span class=\"hljs-attr\">methods</span>: &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">calculateBooksMessage</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.author.books.length &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-string\">&#x27;Yes&#x27;</span> : <span class=\"hljs-string\">&#x27;No&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要<code>author.books</code> 还没有发生改变，多次访问 <code>publishedBookMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。 </p>\n<p>这也同样意味着下面的计算属性将不再更新，因为 <strong>Date.now () 不是响应式依赖</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">computed: &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">now</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Date</span>.now()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p>\n<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <code>list</code>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <code>list</code>。如果没有缓存，我们将不可避免的多次执行 <code>list</code> 的 getter！如果你不希望有缓存，请用 method 来替代</p>\n<hr>\n<h2 id=\"以下为2021-09-16更新\"><a href=\"#以下为2021-09-16更新\" class=\"headerlink\" title=\"以下为2021.09.16更新\"></a>以下为2021.09.16更新</h2><h2 id=\"计算属性的-Setter\"><a href=\"#计算属性的-Setter\" class=\"headerlink\" title=\"计算属性的 Setter\"></a>计算属性的 Setter</h2><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// ...</span><br><span class=\"hljs-attr\">computed</span>: &#123;<br>  <span class=\"hljs-attr\">fullName</span>: &#123;<br>    <span class=\"hljs-comment\">// getter</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.firstName + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-built_in\">this</span>.lastName<br>    &#125;,<br>    <span class=\"hljs-comment\">// setter</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\">newValue</span>)</span> &#123;<br>      <span class=\"hljs-keyword\">const</span> names = newValue.split(<span class=\"hljs-string\">&#x27; &#x27;</span>)<br>      <span class=\"hljs-built_in\">this</span>.firstName = names[<span class=\"hljs-number\">0</span>]<br>      <span class=\"hljs-built_in\">this</span>.lastName = names[names.length - <span class=\"hljs-number\">1</span>]<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// ...</span><br></code></pre></td></tr></table></figure>\n<p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p>\n<h1 id=\"Class与Style绑定\"><a href=\"#Class与Style绑定\" class=\"headerlink\" title=\"Class与Style绑定\"></a>Class与Style绑定</h1><p>如果你的组件有多个根元素，你需要定义哪些部分将接收这个类。可以使用 $attrs 组件属性执行此操作：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;div id=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;baz&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></span><br>&lt;/div&gt;<br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br>app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;</span><br><span class=\"hljs-string\">    &lt;span&gt;This is a child component&lt;/span&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h1><h2 id=\"v-if-vs-v-show\"><a href=\"#v-if-vs-v-show\" class=\"headerlink\" title=\"v-if vs v-show\"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>\n<p><code>v-if</code> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>\n<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>\n<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好</p>\n<h2 id=\"v-if-与-v-for-一起使用\"><a href=\"#v-if-与-v-for-一起使用\" class=\"headerlink\" title=\"v-if 与 v-for 一起使用\"></a>v-if 与 v-for 一起使用</h2><blockquote>\n<p>提示 不推荐同时使用 v-if 和 v-for</p>\n</blockquote>\n<p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-if</code> 具有比 <code>v-for</code> 更高的优先级。请查阅列表渲染指南以获取详细信息。</p>\n<p>当它们处于同一节点，<code>v-if</code> 的优先级比 <code>v-for</code> 更高，这意味着 <code>v-if</code> 将没有权限访问 <code>v-for</code> 里的变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;!-- This will <span class=\"hljs-keyword\">throw</span> an error because property <span class=\"hljs-string\">&quot;todo&quot;</span> is not defined on instance. --&gt;<br><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;todo in todos&quot;</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class=\"xml\">  &#123;&#123; todo &#125;&#125;</span><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>可以把 v-for 移动到<code>&lt;template&gt;</code> 标签中来修正：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;template v-<span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">&quot;todo in todos&quot;</span>&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class=\"xml\">    &#123;&#123; todo &#125;&#125;</span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n<h1 id=\"表单绑定输入\"><a href=\"#表单绑定输入\" class=\"headerlink\" title=\"表单绑定输入\"></a>表单绑定输入</h1><h2 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h2><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>\n<ul>\n<li>text 和 textarea 元素使用 value property 和 input 事件；</li>\n<li>checkbox 和 radio 使用 checked property 和 change 事件；</li>\n<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>\n</ul>\n<h1 id=\"组件基础\"><a href=\"#组件基础\" class=\"headerlink\" title=\"组件基础\"></a>组件基础</h1><h2 id=\"基本实例\"><a href=\"#基本实例\" class=\"headerlink\" title=\"基本实例\"></a>基本实例</h2><p>这里有一个 Vue 组件的示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 创建一个Vue 应用</span><br><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class=\"hljs-comment\">// 定义一个名为 button-counter 的新全局组件</span><br>app.component(<span class=\"hljs-string\">&#x27;button-counter&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span><br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;button @click=&quot;count++&quot;&gt;</span><br><span class=\"hljs-string\">      You clicked me &#123;&#123; count &#125;&#125; times.</span><br><span class=\"hljs-string\">    &lt;/button&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<h2 id=\"组件的复用\"><a href=\"#组件的复用\" class=\"headerlink\" title=\"组件的复用\"></a>组件的复用</h2><p>你可以将组件进行任意次数的复用<br>每个组件都会各自独立维护它的<code>data</code>。因为你每用一次组件，就会有一个它的新组件实例被创建</p>\n<h2 id=\"在组件上使用-v-model\"><a href=\"#在组件上使用-v-model\" class=\"headerlink\" title=\"在组件上使用 v-model\"></a>在组件上使用 v-model</h2><p>自定义事件也可以用于创建支持 <code>v-model</code> 的自定义输入组件。记住：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;input v-model=<span class=\"hljs-string\">&quot;searchText&quot;</span> /&gt;<br>等价于：<br><br>&lt;input :value=<span class=\"hljs-string\">&quot;searchText&quot;</span> @input=<span class=\"hljs-string\">&quot;searchText = $event.target.value&quot;</span> /&gt;<br>当用在组件上时，v-model 则会这样：<br><br>&lt;custom-input<br>  :model-value=<span class=\"hljs-string\">&quot;searchText&quot;</span><br>  @update:model-value=<span class=\"hljs-string\">&quot;searchText = $event&quot;</span><br>&gt;&lt;/custom-input&gt;<br></code></pre></td></tr></table></figure>\n<p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code> 必须：</p>\n<p>将其 <code>value</code> attribute 绑定到一个名叫 <code>modelValue</code> 的 prop 上<br>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>update:modelValue</code> 事件抛出<br>写成代码之后是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;custom-input&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;modelValue&#x27;</span>],<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input</span><br><span class=\"hljs-string\">      :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span><br><span class=\"hljs-string\">    &gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>现在 <code>v-model</code> 就应该可以在这个组件上完美地工作起来了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;searchText&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-input</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"深入组件\"><a href=\"#深入组件\" class=\"headerlink\" title=\"深入组件\"></a>深入组件</h1><h2 id=\"非-Prop-的-Attribute\"><a href=\"#非-Prop-的-Attribute\" class=\"headerlink\" title=\"非 Prop 的 Attribute\"></a>非 Prop 的 Attribute</h2><h3 id=\"Attribute-继承\"><a href=\"#Attribute-继承\" class=\"headerlink\" title=\"Attribute 继承\"></a>Attribute 继承</h3><p>当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 <code>&lt;date-picker&gt;</code> 组件的实例中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class=\"hljs-string\">      &lt;input type=&quot;datetime&quot; /&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>如果我们需要通过 <code>data status</code> property 定义 <code>&lt;date-picker&gt;</code> 组件的状态，它将应用于根节点 (即 <code>div.date-picker</code>)。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 具有非prop attribute的Date-picker组件--&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;datetime&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>同样的规则适用于事件监听器：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">&quot;submitChange&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.$attrs) <span class=\"hljs-comment\">// &#123; onChange: () =&gt; &#123;&#125;  &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>当有一个 HTML 元素将 change 事件作为 date-picker 的根元素时，这可能会有帮助。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;select&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;1&quot;&gt;Yesterday&lt;/option&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;2&quot;&gt;Today&lt;/option&gt;</span><br><span class=\"hljs-string\">      &lt;option value=&quot;3&quot;&gt;Tomorrow&lt;/option&gt;</span><br><span class=\"hljs-string\">    &lt;/select&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>在这种情况下，change 事件监听器从父组件传递到子组件，它将在原生 select 的 change 事件上触发。我们不需要显式地从 date-picker 发出事件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;demo&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">&quot;showChange&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">showChange</span>(<span class=\"hljs-params\">event</span>)</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(event.target.value) <span class=\"hljs-comment\">// 将记录所选选项的值</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"禁用-Attribute-继承\"><a href=\"#禁用-Attribute-继承\" class=\"headerlink\" title=\"禁用 Attribute 继承\"></a>禁用 Attribute 继承</h3><p>如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p>\n<p>禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。</p>\n<p>通过将 <code>inheritAttrs</code> 选项设置为 <code>false</code>，你可以访问组件的 <code>$attrs</code> property，该 property 包括组件 <code>props</code> 和 <code>emits</code> property 中未包含的所有属性 (例如，<code>class</code>、<code>style</code>、<code>v-on</code> 监听器等)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;date-picker&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div class=&quot;date-picker&quot;&gt;</span><br><span class=\"hljs-string\">      &lt;input type=&quot;datetime&quot; v-bind=&quot;$attrs&quot; /&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>有了这个新配置，<code>data status</code> attribute 将应用于 <code>input</code> 元素！</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Date-picker 组件 使用非 prop attribute --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">date-picker</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">date-picker</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 渲染 date-picker 组件 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;date-picker&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;datetime&quot;</span> <span class=\"hljs-attr\">data-status</span>=<span class=\"hljs-string\">&quot;activated&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"多个根节点上的-Attribute-继承\"><a href=\"#多个根节点上的-Attribute-继承\" class=\"headerlink\" title=\"多个根节点上的 Attribute 继承\"></a>多个根节点上的 Attribute 继承</h3><p>与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-layout</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;custom-layout&quot;</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;changeValue&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-layout</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 这将发出警告</span><br>app.component(<span class=\"hljs-string\">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;header&gt;...&lt;/header&gt;</span><br><span class=\"hljs-string\">    &lt;main&gt;...&lt;/main&gt;</span><br><span class=\"hljs-string\">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 没有警告，$attrs被传递到&lt;main&gt;元素</span><br>app.component(<span class=\"hljs-string\">&#x27;custom-layout&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;header&gt;...&lt;/header&gt;</span><br><span class=\"hljs-string\">    &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class=\"hljs-string\">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<h2 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h2><h3 id=\"处理-v-model-修饰符\"><a href=\"#处理-v-model-修饰符\" class=\"headerlink\" title=\"处理 v-model 修饰符\"></a>处理 v-model 修饰符</h3><p>在 2.x 中，我们对组件 <code>v-model</code> 上的 <code>.trim</code> 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件：</p>\n<p>让我们创建一个示例自定义修饰符 <code>capitalize</code>，它将 <code>v-model</code> 绑定提供的字符串的第一个字母大写。</p>\n<p>添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 <code>modelModifiers</code> prop。</p>\n<p>请注意，当组件的 <code>created</code> 生命周期钩子触发时，<code>modelModifiers</code> prop 包含 <code>capitalize</code>，其值为 <code>true</code>——因为它被设置在 <code>v-model</code> 绑定 <code>v-model.capitalize=&quot;bar&quot;</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model.capitalize</span>=<span class=\"hljs-string\">&quot;bar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">modelValue</span>: <span class=\"hljs-built_in\">String</span>,<br>    <span class=\"hljs-attr\">modelModifiers</span>: &#123;<br>      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input type=&quot;text&quot; </span><br><span class=\"hljs-string\">      :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;&gt;</span><br><span class=\"hljs-string\">  `</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.modelModifiers) <span class=\"hljs-comment\">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>现在我们已经设置了 prop，我们可以检查 <code>modelModifiers</code> 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 <code>&lt;input/&gt;</code> 元素触发 <code>input</code> 事件时，我们都将字符串大写。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model.capitalize</span>=<span class=\"hljs-string\">&quot;myText&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br>  &#123;&#123; myText &#125;&#125;<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-attr\">myText</span>: <span class=\"hljs-string\">&#x27;&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br><br>app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">modelValue</span>: <span class=\"hljs-built_in\">String</span>,<br>    <span class=\"hljs-attr\">modelModifiers</span>: &#123;<br>      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =&gt;</span> (&#123;&#125;)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">emitValue</span>(<span class=\"hljs-params\">e</span>)</span> &#123;<br>      <span class=\"hljs-keyword\">let</span> value = e.target.value<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.modelModifiers.capitalize) &#123;<br>        value = value.charAt(<span class=\"hljs-number\">0</span>).toUpperCase() + value.slice(<span class=\"hljs-number\">1</span>)<br>      &#125;<br>      <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&#x27;update:modelValue&#x27;</span>, value)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;input</span><br><span class=\"hljs-string\">    type=&quot;text&quot;</span><br><span class=\"hljs-string\">    :value=&quot;modelValue&quot;</span><br><span class=\"hljs-string\">    @input=&quot;emitValue&quot;&gt;`</span><br>&#125;)<br><br>app.mount(<span class=\"hljs-string\">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>对于带参数的 <code>v-model</code> 绑定，生成的 prop 名称将为 <code>arg + &quot;Modifiers&quot;</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-model:foo.capitalize</span>=<span class=\"hljs-string\">&quot;bar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">app.component(<span class=\"hljs-string\">&#x27;my-component&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">&#x27;foo&#x27;</span>, <span class=\"hljs-string\">&#x27;fooModifiers&#x27;</span>],<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;input type=&quot;text&quot; </span><br><span class=\"hljs-string\">      :value=&quot;foo&quot;</span><br><span class=\"hljs-string\">      @input=&quot;$emit(&#x27;update:foo&#x27;, $event.target.value)&quot;&gt;</span><br><span class=\"hljs-string\">  `</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.fooModifiers) <span class=\"hljs-comment\">// &#123; capitalize: true &#125;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"2021-09-17更新\"><a href=\"#2021-09-17更新\" class=\"headerlink\" title=\"2021.09.17更新\"></a>2021.09.17更新</h2><h2 id=\"提供-注入\"><a href=\"#提供-注入\" class=\"headerlink\" title=\"提供/注入\"></a>提供/注入</h2><p>通常，当我们需要将数据从父组件传递到子组件时，我们使用<code>props</code>。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。</p>\n<p>对于这种情况，我们可以使用 <code>provide</code> 和 <code>inject</code> 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这个数据。</p>\n<h1 id=\"可复用-amp-组合\"><a href=\"#可复用-amp-组合\" class=\"headerlink\" title=\"可复用&amp;组合\"></a>可复用&amp;组合</h1><h2 id=\"渲染函数\"><a href=\"#渲染函数\" class=\"headerlink\" title=\"渲染函数\"></a>渲染函数</h2><h3 id=\"虚拟DOM树\"><a href=\"#虚拟DOM树\" class=\"headerlink\" title=\"虚拟DOM树\"></a>虚拟DOM树</h3><p>Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">return</span> Vue.h(<span class=\"hljs-string\">&#x27;h1&#x27;</span>, &#123;&#125;, <span class=\"hljs-built_in\">this</span>.blogTitle)<br></code></pre></td></tr></table></figure>\n<p><code>h()</code> 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 <strong>VNode</strong>。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p>\n<h3 id=\"h-参数\"><a href=\"#h-参数\" class=\"headerlink\" title=\"h()参数\"></a>h()参数</h3><p>h() 函数是一个用于创建 vnode 的实用程序。也许可以更准确地将其命名为 createVNode()，但由于频繁使用和简洁，它被称为 h() 。它接受三个参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">h(<br>  <span class=\"hljs-comment\">// &#123;String | Object | Function | null&#125; tag</span><br>  <span class=\"hljs-comment\">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span><br>  <span class=\"hljs-comment\">// 使用 null 将会渲染一个注释。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 必需的。</span><br>  <span class=\"hljs-string\">&#x27;div&#x27;</span>,<br><br>  <span class=\"hljs-comment\">// &#123;Object&#125; props</span><br>  <span class=\"hljs-comment\">// 与 attribute、prop 和事件相对应的对象。</span><br>  <span class=\"hljs-comment\">// 我们会在模板中使用。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 可选的。</span><br>  &#123;&#125;,<br><br>  <span class=\"hljs-comment\">// &#123;String | Array | Object&#125; children</span><br>  <span class=\"hljs-comment\">// 子 VNodes, 使用 `h()` 构建,</span><br>  <span class=\"hljs-comment\">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span><br>  <span class=\"hljs-comment\">// 有 slot 的对象。</span><br>  <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-comment\">// 可选的。</span><br>  [<br>    <span class=\"hljs-string\">&#x27;Some text comes first.&#x27;</span>,<br>    h(<span class=\"hljs-string\">&#x27;h1&#x27;</span>, <span class=\"hljs-string\">&#x27;A headline&#x27;</span>),<br>    h(MyComponent, &#123;<br>      <span class=\"hljs-attr\">someProp</span>: <span class=\"hljs-string\">&#x27;foobar&#x27;</span><br>    &#125;)<br>  ]<br>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"完整实例\"><a href=\"#完整实例\" class=\"headerlink\" title=\"完整实例\"></a>完整实例</h3><p>有了这些知识，我们现在可以完成我们最开始想实现的组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp(&#123;&#125;)<br><br><span class=\"hljs-comment\">/** Recursively get text from children nodes */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getChildrenTextContent</span>(<span class=\"hljs-params\">children</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> children<br>    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">node</span> =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> node.children === <span class=\"hljs-string\">&#x27;string&#x27;</span><br>        ? node.children<br>        : <span class=\"hljs-built_in\">Array</span>.isArray(node.children)<br>        ? getChildrenTextContent(node.children)<br>        : <span class=\"hljs-string\">&#x27;&#x27;</span><br>    &#125;)<br>    .join(<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>&#125;<br><br>app.component(<span class=\"hljs-string\">&#x27;anchored-heading&#x27;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-comment\">// create kebab-case id from the text contents of the children</span><br>    <span class=\"hljs-keyword\">const</span> headingId = getChildrenTextContent(<span class=\"hljs-built_in\">this</span>.$slots.default())<br>      .toLowerCase()<br>      .replace(<span class=\"hljs-regexp\">/\\W+/g</span>, <span class=\"hljs-string\">&#x27;-&#x27;</span>) <span class=\"hljs-comment\">// replace non-word characters with dash</span><br>      .replace(<span class=\"hljs-regexp\">/(^-|-$)/g</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-comment\">// remove leading and trailing dashes</span><br><br>    <span class=\"hljs-keyword\">return</span> Vue.h(<span class=\"hljs-string\">&#x27;h&#x27;</span> + <span class=\"hljs-built_in\">this</span>.level, [<br>      Vue.h(<br>        <span class=\"hljs-string\">&#x27;a&#x27;</span>,<br>        &#123;<br>          <span class=\"hljs-attr\">name</span>: headingId,<br>          <span class=\"hljs-attr\">href</span>: <span class=\"hljs-string\">&#x27;#&#x27;</span> + headingId<br>        &#125;,<br>        <span class=\"hljs-built_in\">this</span>.$slots.default()<br>      )<br>    ])<br>  &#125;,<br>  <span class=\"hljs-attr\">props</span>: &#123;<br>    <span class=\"hljs-attr\">level</span>: &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,<br>      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>"},{"title":"JavaScript中的堆栈以及数据类型","date":"2021-06-17T07:08:21.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# JavaScript 的堆栈以及数据类型\n\n[本文参考此链接](https://www.jianshu.com/p/5e0e8d183102)\n\n## 堆\n\n- 是堆内存的简称。\n\n- 需要程序员自己申请空间，内存大小不一，也不会自动释放。\n\n- 堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大\n\n- 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片\n\n## 栈\n\n- 是栈内存的简称。\n\n- 是自动分配相对固定大小的内存空间，并由系统自动释放，所以生命周期只在函数的运行过程中。\n\n- 后进先出\n\n- 栈是向低地址扩展的数据结构，是一块连续的内存的区域\n\n![栈](https://upload-images.jianshu.io/upload_images/4037795-707975f1f45a6a0d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1136/format/webp)\n\n## 队列\n\n- 是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。\n\n- 先进先出\n\n### 基本数据类型\n\n`javascript`的**基本类型**就 5 种:`Undefined`、`Null`、`Boolean`、`Number`和`String`，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是**确定**的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。\n\n### 引用数据类型\n\n`javascript`中其他类型的数据被称为**引用类型**的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和 new 出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。\n\n### 传值与传址\n\n```javascript\nvar arr1 = [1, 2, 5, 8];\nvar arr2 = arr1;\nvar str1 = arr1[2];\nconsole.log(arr2); //1,2,5,8\nconsole.log(str1); //5\narr2[4] = 99;\nstr1 = 6;\nconsole.log(arr1); //1,2,5,8,99\nconsole.log(arr1[2]); //5\n```\n\n当我改变 arr2 中的数据时，arr1 中数据也发生了变化，当改变 str1 的数据值时，arr1 却没有发生改变。为什么？这就是**传值与传址**的区别。\n\n因为 arr1 是数组，属于引用类型，所以它赋予给 arr2 的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1 得到的是一个基本类型的赋值，因此，str1 仅仅是从 arr1 堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2 都指向同一块堆内存，arr2 修改的堆内存的时候，也就会影响到 arr1，str1 是直接在栈中修改，并且不能影响到 arr1 堆内存中的数据。\n\n![img](https://images2018.cnblogs.com/blog/1402663/201808/1402663-20180802132101478-2092833591.png)\n\n### 深拷贝和浅拷贝\n\n上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将 arr1 的每个基本类型的数据都遍历一遍，依次的赋值给 arr2 的对应字段。避免产生因为地址引用带来的问题。\n\n```javascript\nvar arr1 = [1, 2, 5, 8];\nvar arr2 = [];\nfor (var i = 0; i < arr1.length; i++) {\n  arr2[i] = arr1[i];\n}\nconsole.log(arr2); //1,2,5,8\narr2[4] = 99;\nconsole.log(arr2); //1,2,5,8,99\nconsole.log(arr1); //1,2,5,8\n```\n\njavascript 面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。\n\n# 完~\n","source":"_posts/2021-09-23-JavaScript中的堆栈以及数据类型.md","raw":"---\ntitle: JavaScript中的堆栈以及数据类型\ndate: 2021-06-17 15:08:21\ntags: JavaScript\ncategories: 技术类-前端\n---\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# JavaScript 的堆栈以及数据类型\n\n[本文参考此链接](https://www.jianshu.com/p/5e0e8d183102)\n\n## 堆\n\n- 是堆内存的简称。\n\n- 需要程序员自己申请空间，内存大小不一，也不会自动释放。\n\n- 堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大\n\n- 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片\n\n## 栈\n\n- 是栈内存的简称。\n\n- 是自动分配相对固定大小的内存空间，并由系统自动释放，所以生命周期只在函数的运行过程中。\n\n- 后进先出\n\n- 栈是向低地址扩展的数据结构，是一块连续的内存的区域\n\n![栈](https://upload-images.jianshu.io/upload_images/4037795-707975f1f45a6a0d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1136/format/webp)\n\n## 队列\n\n- 是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。\n\n- 先进先出\n\n### 基本数据类型\n\n`javascript`的**基本类型**就 5 种:`Undefined`、`Null`、`Boolean`、`Number`和`String`，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是**确定**的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。\n\n### 引用数据类型\n\n`javascript`中其他类型的数据被称为**引用类型**的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和 new 出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。\n\n### 传值与传址\n\n```javascript\nvar arr1 = [1, 2, 5, 8];\nvar arr2 = arr1;\nvar str1 = arr1[2];\nconsole.log(arr2); //1,2,5,8\nconsole.log(str1); //5\narr2[4] = 99;\nstr1 = 6;\nconsole.log(arr1); //1,2,5,8,99\nconsole.log(arr1[2]); //5\n```\n\n当我改变 arr2 中的数据时，arr1 中数据也发生了变化，当改变 str1 的数据值时，arr1 却没有发生改变。为什么？这就是**传值与传址**的区别。\n\n因为 arr1 是数组，属于引用类型，所以它赋予给 arr2 的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1 得到的是一个基本类型的赋值，因此，str1 仅仅是从 arr1 堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2 都指向同一块堆内存，arr2 修改的堆内存的时候，也就会影响到 arr1，str1 是直接在栈中修改，并且不能影响到 arr1 堆内存中的数据。\n\n![img](https://images2018.cnblogs.com/blog/1402663/201808/1402663-20180802132101478-2092833591.png)\n\n### 深拷贝和浅拷贝\n\n上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将 arr1 的每个基本类型的数据都遍历一遍，依次的赋值给 arr2 的对应字段。避免产生因为地址引用带来的问题。\n\n```javascript\nvar arr1 = [1, 2, 5, 8];\nvar arr2 = [];\nfor (var i = 0; i < arr1.length; i++) {\n  arr2[i] = arr1[i];\n}\nconsole.log(arr2); //1,2,5,8\narr2[4] = 99;\nconsole.log(arr2); //1,2,5,8,99\nconsole.log(arr1); //1,2,5,8\n```\n\njavascript 面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。\n\n# 完~\n","slug":"JavaScript中的堆栈以及数据类型","published":1,"updated":"2022-01-25T05:00:10.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno55000c7oo92bw51y8h","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"JavaScript-的堆栈以及数据类型\"><a href=\"#JavaScript-的堆栈以及数据类型\" class=\"headerlink\" title=\"JavaScript 的堆栈以及数据类型\"></a>JavaScript 的堆栈以及数据类型</h1><p><a href=\"https://www.jianshu.com/p/5e0e8d183102\">本文参考此链接</a></p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><ul>\n<li><p>是堆内存的简称。</p>\n</li>\n<li><p>需要程序员自己申请空间，内存大小不一，也不会自动释放。</p>\n</li>\n<li><p>堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大</p>\n</li>\n<li><p>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片</p>\n</li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li><p>是栈内存的简称。</p>\n</li>\n<li><p>是自动分配相对固定大小的内存空间，并由系统自动释放，所以生命周期只在函数的运行过程中。</p>\n</li>\n<li><p>后进先出</p>\n</li>\n<li><p>栈是向低地址扩展的数据结构，是一块连续的内存的区域</p>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4037795-707975f1f45a6a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1136/format/webp\" alt=\"栈\"></p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li><p>是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。</p>\n</li>\n<li><p>先进先出</p>\n</li>\n</ul>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p><code>javascript</code>的<strong>基本类型</strong>就 5 种:<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是<strong>确定</strong>的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。</p>\n<h3 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h3><p><code>javascript</code>中其他类型的数据被称为<strong>引用类型</strong>的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和 new 出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。</p>\n<h3 id=\"传值与传址\"><a href=\"#传值与传址\" class=\"headerlink\" title=\"传值与传址\"></a>传值与传址</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>];<br><span class=\"hljs-keyword\">var</span> arr2 = arr1;<br><span class=\"hljs-keyword\">var</span> str1 = arr1[<span class=\"hljs-number\">2</span>];<br><span class=\"hljs-built_in\">console</span>.log(arr2); <span class=\"hljs-comment\">//1,2,5,8</span><br><span class=\"hljs-built_in\">console</span>.log(str1); <span class=\"hljs-comment\">//5</span><br>arr2[<span class=\"hljs-number\">4</span>] = <span class=\"hljs-number\">99</span>;<br>str1 = <span class=\"hljs-number\">6</span>;<br><span class=\"hljs-built_in\">console</span>.log(arr1); <span class=\"hljs-comment\">//1,2,5,8,99</span><br><span class=\"hljs-built_in\">console</span>.log(arr1[<span class=\"hljs-number\">2</span>]); <span class=\"hljs-comment\">//5</span><br></code></pre></td></tr></table></figure>\n\n<p>当我改变 arr2 中的数据时，arr1 中数据也发生了变化，当改变 str1 的数据值时，arr1 却没有发生改变。为什么？这就是<strong>传值与传址</strong>的区别。</p>\n<p>因为 arr1 是数组，属于引用类型，所以它赋予给 arr2 的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1 得到的是一个基本类型的赋值，因此，str1 仅仅是从 arr1 堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2 都指向同一块堆内存，arr2 修改的堆内存的时候，也就会影响到 arr1，str1 是直接在栈中修改，并且不能影响到 arr1 堆内存中的数据。</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/1402663/201808/1402663-20180802132101478-2092833591.png\" alt=\"img\"></p>\n<h3 id=\"深拷贝和浅拷贝\"><a href=\"#深拷贝和浅拷贝\" class=\"headerlink\" title=\"深拷贝和浅拷贝\"></a>深拷贝和浅拷贝</h3><p>上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将 arr1 的每个基本类型的数据都遍历一遍，依次的赋值给 arr2 的对应字段。避免产生因为地址引用带来的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>];<br><span class=\"hljs-keyword\">var</span> arr2 = [];<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr1.length; i++) &#123;<br>  arr2[i] = arr1[i];<br>&#125;<br><span class=\"hljs-built_in\">console</span>.log(arr2); <span class=\"hljs-comment\">//1,2,5,8</span><br>arr2[<span class=\"hljs-number\">4</span>] = <span class=\"hljs-number\">99</span>;<br><span class=\"hljs-built_in\">console</span>.log(arr2); <span class=\"hljs-comment\">//1,2,5,8,99</span><br><span class=\"hljs-built_in\">console</span>.log(arr1); <span class=\"hljs-comment\">//1,2,5,8</span><br></code></pre></td></tr></table></figure>\n\n<p>javascript 面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。</p>\n<h1 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完~\"></a>完~</h1>","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"JavaScript-的堆栈以及数据类型\"><a href=\"#JavaScript-的堆栈以及数据类型\" class=\"headerlink\" title=\"JavaScript 的堆栈以及数据类型\"></a>JavaScript 的堆栈以及数据类型</h1><p><a href=\"https://www.jianshu.com/p/5e0e8d183102\">本文参考此链接</a></p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><ul>\n<li><p>是堆内存的简称。</p>\n</li>\n<li><p>需要程序员自己申请空间，内存大小不一，也不会自动释放。</p>\n</li>\n<li><p>堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大</p>\n</li>\n<li><p>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片</p>\n</li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li><p>是栈内存的简称。</p>\n</li>\n<li><p>是自动分配相对固定大小的内存空间，并由系统自动释放，所以生命周期只在函数的运行过程中。</p>\n</li>\n<li><p>后进先出</p>\n</li>\n<li><p>栈是向低地址扩展的数据结构，是一块连续的内存的区域</p>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4037795-707975f1f45a6a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1136/format/webp\" alt=\"栈\"></p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li><p>是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。</p>\n</li>\n<li><p>先进先出</p>\n</li>\n</ul>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p><code>javascript</code>的<strong>基本类型</strong>就 5 种:<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是<strong>确定</strong>的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。</p>\n<h3 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h3><p><code>javascript</code>中其他类型的数据被称为<strong>引用类型</strong>的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和 new 出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。</p>\n<h3 id=\"传值与传址\"><a href=\"#传值与传址\" class=\"headerlink\" title=\"传值与传址\"></a>传值与传址</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>];<br><span class=\"hljs-keyword\">var</span> arr2 = arr1;<br><span class=\"hljs-keyword\">var</span> str1 = arr1[<span class=\"hljs-number\">2</span>];<br><span class=\"hljs-built_in\">console</span>.log(arr2); <span class=\"hljs-comment\">//1,2,5,8</span><br><span class=\"hljs-built_in\">console</span>.log(str1); <span class=\"hljs-comment\">//5</span><br>arr2[<span class=\"hljs-number\">4</span>] = <span class=\"hljs-number\">99</span>;<br>str1 = <span class=\"hljs-number\">6</span>;<br><span class=\"hljs-built_in\">console</span>.log(arr1); <span class=\"hljs-comment\">//1,2,5,8,99</span><br><span class=\"hljs-built_in\">console</span>.log(arr1[<span class=\"hljs-number\">2</span>]); <span class=\"hljs-comment\">//5</span><br></code></pre></td></tr></table></figure>\n\n<p>当我改变 arr2 中的数据时，arr1 中数据也发生了变化，当改变 str1 的数据值时，arr1 却没有发生改变。为什么？这就是<strong>传值与传址</strong>的区别。</p>\n<p>因为 arr1 是数组，属于引用类型，所以它赋予给 arr2 的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1 得到的是一个基本类型的赋值，因此，str1 仅仅是从 arr1 堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2 都指向同一块堆内存，arr2 修改的堆内存的时候，也就会影响到 arr1，str1 是直接在栈中修改，并且不能影响到 arr1 堆内存中的数据。</p>\n<p><img src=\"https://images2018.cnblogs.com/blog/1402663/201808/1402663-20180802132101478-2092833591.png\" alt=\"img\"></p>\n<h3 id=\"深拷贝和浅拷贝\"><a href=\"#深拷贝和浅拷贝\" class=\"headerlink\" title=\"深拷贝和浅拷贝\"></a>深拷贝和浅拷贝</h3><p>上边说到的赋值方式就是浅拷贝，那么什么叫作深拷贝呢？就是要将 arr1 的每个基本类型的数据都遍历一遍，依次的赋值给 arr2 的对应字段。避免产生因为地址引用带来的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>];<br><span class=\"hljs-keyword\">var</span> arr2 = [];<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr1.length; i++) &#123;<br>  arr2[i] = arr1[i];<br>&#125;<br><span class=\"hljs-built_in\">console</span>.log(arr2); <span class=\"hljs-comment\">//1,2,5,8</span><br>arr2[<span class=\"hljs-number\">4</span>] = <span class=\"hljs-number\">99</span>;<br><span class=\"hljs-built_in\">console</span>.log(arr2); <span class=\"hljs-comment\">//1,2,5,8,99</span><br><span class=\"hljs-built_in\">console</span>.log(arr1); <span class=\"hljs-comment\">//1,2,5,8</span><br></code></pre></td></tr></table></figure>\n\n<p>javascript 面向对象的语言本身在处理对象和非对象上就进行了划分，从数据结构的角度来讲，对象就是栈的指针和堆中的数值。</p>\n<h1 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完~\"></a>完~</h1>"},{"title":"Vue自定义全局组件","date":"2021-06-18T07:15:40.000Z","_content":"# vue自定义全局弹框组件\n\n1. 在components文件夹下新增一个组件文件夹Dialog，新建一个模板组件Dialog.vue\n\n   ```vue\n   <template>\n     <div class=\"u_dialog_panel\" @touchmove.stop=\"noop\">\n       <div class=\"mask\" v-if=\"visible\" @click=\"handleClose\"></div>\n       <transition name=\"open\">\n         <div v-if=\"visible\" class=\"dialog_body\">\n           <slot></slot>\n           <div class=\"btns\" v-if=\"confirmText || cancleText\">\n             <div class=\"cancle btn\" v-if=\"cancleText\" @click=\"handleCancle\">{{cancleText}}</div>\n             <div class=\"confirm btn\" :style=\"confirmStyle\" v-if=\"confirmText\" @click=\"handleConfirm\">{{confirmText}}</div>\n           </div>\n         </div>\n       </transition>\n     </div>\n   </template>\n   <script>\n   export default {\n     name: 'UDialog',\n     props: {\n       visible: { type: Boolean, default: false, required: true },\n       // 确定按钮的文案\n       confirmText: { type: String, default: '确定' },\n       confirmStyle: { type: String, default: '' },\n       // 取消按钮的文案\n       cancleText: { type: String, default: '取消' },\n       cancleStyle: { type: String, default: '' },\n     },\n     created () {\n       this.$nextTick(() => {\n         document.body.insertBefore(this.$el, document.body.lastChild)\n       })\n     },\n     beforeDestroy () {\n       document.body.removeChild(this.$el)\n     },\n     methods: {\n       // 关闭弹窗\n       handleClose () { this.$emit('close') },\n       // 确定按钮\n       handleConfirm () { this.$emit('confirm') },\n       // 取消按钮\n       handleCancle () { this.$emit('cancle') },\n       noop () {}\n     }\n   }\n   </script>\n   \n   <style lang=\"less\" scoped>\n   .u_dialog_panel {\n     .mask {\n       width: 100vw;\n       height: 100vh;\n       background-color: rgba(0, 0, 0, 0.5);\n       position: fixed;\n       left: 0;\n       top: 0;\n       z-index: 100;\n       backdrop-filter: blur(5px);\n     }\n     .dialog_body{\n       width: 80vw;\n       background-color: #fff;\n       position: fixed;\n       left: 50vw;\n       top: 50vh;\n       z-index: 100;\n       transform: translate(-50%, -50%);\n       transform-origin: 0 0;\n       border-radius: .875rem;\n       &.open-enter {\n         opacity: 0;\n         transform: scale(0.7) translate(-50%, -50%);\n         transition: all 0.3s;\n       }\n       &.open-enter-to {\n         opacity: 1;\n         transform: scale(1) translate(-50%, -50%);\n         transition: all 0.3s;\n       }\n       .btns {\n         display: flex;\n         justify-content: space-between;\n         align-items: center;\n         .btn {\n           display: flex;\n           justify-content: center;\n           align-items: center;\n           flex-grow: 1;\n           width: 50%;\n           height: 2.875rem;\n           border-top: 1px solid #ddd;\n           box-sizing: border-box;\n           display: flex;\n           justify-content: center;\n           align-items: center;\n           font-size: .875rem;\n           & + .btn {\n             border-left: 1px solid #ddd;\n           }\n           &.cancle {\n             color: #666666;\n           }\n           &.confirm {\n             color: #FF5883;\n           }\n         }\n       }\n     }\n   }\n   </style>\n   \n   ```\n\n2. 在此文件夹再新建一个index.js\n\n   ```vue\n   import Dialog from './Dialog'\n   \n   Dialog.install = function (Vue, options) {\n     Vue.component(`${Dialog.name}`, Dialog)\n   }\n   \n   export default Dialog\n   \n   ```\n\n3. 最后再main.js里注册为全局组件\n\n   ```vue\n   import Dialog from './components/Dialog/index.js'\n   \n   Vue.use(Dialog)\n   ```\n\n\n\n## 这样就可以在其他组件里无需声明而使用此组件\n\n\n\n","source":"_posts/2021-09-23-Vue自定义全局组件.md","raw":"---\ntitle: Vue自定义全局组件\ndate: 2021-06-18 15:15:40\ntags: Vue3\ncategories: 技术类-Vue\n---\n# vue自定义全局弹框组件\n\n1. 在components文件夹下新增一个组件文件夹Dialog，新建一个模板组件Dialog.vue\n\n   ```vue\n   <template>\n     <div class=\"u_dialog_panel\" @touchmove.stop=\"noop\">\n       <div class=\"mask\" v-if=\"visible\" @click=\"handleClose\"></div>\n       <transition name=\"open\">\n         <div v-if=\"visible\" class=\"dialog_body\">\n           <slot></slot>\n           <div class=\"btns\" v-if=\"confirmText || cancleText\">\n             <div class=\"cancle btn\" v-if=\"cancleText\" @click=\"handleCancle\">{{cancleText}}</div>\n             <div class=\"confirm btn\" :style=\"confirmStyle\" v-if=\"confirmText\" @click=\"handleConfirm\">{{confirmText}}</div>\n           </div>\n         </div>\n       </transition>\n     </div>\n   </template>\n   <script>\n   export default {\n     name: 'UDialog',\n     props: {\n       visible: { type: Boolean, default: false, required: true },\n       // 确定按钮的文案\n       confirmText: { type: String, default: '确定' },\n       confirmStyle: { type: String, default: '' },\n       // 取消按钮的文案\n       cancleText: { type: String, default: '取消' },\n       cancleStyle: { type: String, default: '' },\n     },\n     created () {\n       this.$nextTick(() => {\n         document.body.insertBefore(this.$el, document.body.lastChild)\n       })\n     },\n     beforeDestroy () {\n       document.body.removeChild(this.$el)\n     },\n     methods: {\n       // 关闭弹窗\n       handleClose () { this.$emit('close') },\n       // 确定按钮\n       handleConfirm () { this.$emit('confirm') },\n       // 取消按钮\n       handleCancle () { this.$emit('cancle') },\n       noop () {}\n     }\n   }\n   </script>\n   \n   <style lang=\"less\" scoped>\n   .u_dialog_panel {\n     .mask {\n       width: 100vw;\n       height: 100vh;\n       background-color: rgba(0, 0, 0, 0.5);\n       position: fixed;\n       left: 0;\n       top: 0;\n       z-index: 100;\n       backdrop-filter: blur(5px);\n     }\n     .dialog_body{\n       width: 80vw;\n       background-color: #fff;\n       position: fixed;\n       left: 50vw;\n       top: 50vh;\n       z-index: 100;\n       transform: translate(-50%, -50%);\n       transform-origin: 0 0;\n       border-radius: .875rem;\n       &.open-enter {\n         opacity: 0;\n         transform: scale(0.7) translate(-50%, -50%);\n         transition: all 0.3s;\n       }\n       &.open-enter-to {\n         opacity: 1;\n         transform: scale(1) translate(-50%, -50%);\n         transition: all 0.3s;\n       }\n       .btns {\n         display: flex;\n         justify-content: space-between;\n         align-items: center;\n         .btn {\n           display: flex;\n           justify-content: center;\n           align-items: center;\n           flex-grow: 1;\n           width: 50%;\n           height: 2.875rem;\n           border-top: 1px solid #ddd;\n           box-sizing: border-box;\n           display: flex;\n           justify-content: center;\n           align-items: center;\n           font-size: .875rem;\n           & + .btn {\n             border-left: 1px solid #ddd;\n           }\n           &.cancle {\n             color: #666666;\n           }\n           &.confirm {\n             color: #FF5883;\n           }\n         }\n       }\n     }\n   }\n   </style>\n   \n   ```\n\n2. 在此文件夹再新建一个index.js\n\n   ```vue\n   import Dialog from './Dialog'\n   \n   Dialog.install = function (Vue, options) {\n     Vue.component(`${Dialog.name}`, Dialog)\n   }\n   \n   export default Dialog\n   \n   ```\n\n3. 最后再main.js里注册为全局组件\n\n   ```vue\n   import Dialog from './components/Dialog/index.js'\n   \n   Vue.use(Dialog)\n   ```\n\n\n\n## 这样就可以在其他组件里无需声明而使用此组件\n\n\n\n","slug":"Vue自定义全局组件","published":1,"updated":"2021-09-23T02:26:35.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno57000d7oo99f5x0hsh","content":"<h1 id=\"vue自定义全局弹框组件\"><a href=\"#vue自定义全局弹框组件\" class=\"headerlink\" title=\"vue自定义全局弹框组件\"></a>vue自定义全局弹框组件</h1><ol>\n<li><p>在components文件夹下新增一个组件文件夹Dialog，新建一个模板组件Dialog.vue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;template&gt;<br>  &lt;div class=&quot;u_dialog_panel&quot; @touchmove.stop=&quot;noop&quot;&gt;<br>    &lt;div class=&quot;mask&quot; v-if=&quot;visible&quot; @click=&quot;handleClose&quot;&gt;&lt;/div&gt;<br>    &lt;transition name=&quot;open&quot;&gt;<br>      &lt;div v-if=&quot;visible&quot; class=&quot;dialog_body&quot;&gt;<br>        &lt;slot&gt;&lt;/slot&gt;<br>        &lt;div class=&quot;btns&quot; v-if=&quot;confirmText || cancleText&quot;&gt;<br>          &lt;div class=&quot;cancle btn&quot; v-if=&quot;cancleText&quot; @click=&quot;handleCancle&quot;&gt;&#123;&#123;cancleText&#125;&#125;&lt;/div&gt;<br>          &lt;div class=&quot;confirm btn&quot; :style=&quot;confirmStyle&quot; v-if=&quot;confirmText&quot; @click=&quot;handleConfirm&quot;&gt;&#123;&#123;confirmText&#125;&#125;&lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/transition&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  name: &#x27;UDialog&#x27;,<br>  props: &#123;<br>    visible: &#123; type: Boolean, default: false, required: true &#125;,<br>    // 确定按钮的文案<br>    confirmText: &#123; type: String, default: &#x27;确定&#x27; &#125;,<br>    confirmStyle: &#123; type: String, default: &#x27;&#x27; &#125;,<br>    // 取消按钮的文案<br>    cancleText: &#123; type: String, default: &#x27;取消&#x27; &#125;,<br>    cancleStyle: &#123; type: String, default: &#x27;&#x27; &#125;,<br>  &#125;,<br>  created () &#123;<br>    this.$nextTick(() =&gt; &#123;<br>      document.body.insertBefore(this.$el, document.body.lastChild)<br>    &#125;)<br>  &#125;,<br>  beforeDestroy () &#123;<br>    document.body.removeChild(this.$el)<br>  &#125;,<br>  methods: &#123;<br>    // 关闭弹窗<br>    handleClose () &#123; this.$emit(&#x27;close&#x27;) &#125;,<br>    // 确定按钮<br>    handleConfirm () &#123; this.$emit(&#x27;confirm&#x27;) &#125;,<br>    // 取消按钮<br>    handleCancle () &#123; this.$emit(&#x27;cancle&#x27;) &#125;,<br>    noop () &#123;&#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;<br>.u_dialog_panel &#123;<br>  .mask &#123;<br>    width: 100vw;<br>    height: 100vh;<br>    background-color: rgba(0, 0, 0, 0.5);<br>    position: fixed;<br>    left: 0;<br>    top: 0;<br>    z-index: 100;<br>    backdrop-filter: blur(5px);<br>  &#125;<br>  .dialog_body&#123;<br>    width: 80vw;<br>    background-color: #fff;<br>    position: fixed;<br>    left: 50vw;<br>    top: 50vh;<br>    z-index: 100;<br>    transform: translate(-50%, -50%);<br>    transform-origin: 0 0;<br>    border-radius: .875rem;<br>    &amp;.open-enter &#123;<br>      opacity: 0;<br>      transform: scale(0.7) translate(-50%, -50%);<br>      transition: all 0.3s;<br>    &#125;<br>    &amp;.open-enter-to &#123;<br>      opacity: 1;<br>      transform: scale(1) translate(-50%, -50%);<br>      transition: all 0.3s;<br>    &#125;<br>    .btns &#123;<br>      display: flex;<br>      justify-content: space-between;<br>      align-items: center;<br>      .btn &#123;<br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br>        flex-grow: 1;<br>        width: 50%;<br>        height: 2.875rem;<br>        border-top: 1px solid #ddd;<br>        box-sizing: border-box;<br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br>        font-size: .875rem;<br>        &amp; + .btn &#123;<br>          border-left: 1px solid #ddd;<br>        &#125;<br>        &amp;.cancle &#123;<br>          color: #666666;<br>        &#125;<br>        &amp;.confirm &#123;<br>          color: #FF5883;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure></li>\n<li><p>在此文件夹再新建一个index.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">import Dialog from &#x27;./Dialog&#x27;<br><br>Dialog.install = function (Vue, options) &#123;<br>  Vue.component(`$&#123;Dialog.name&#125;`, Dialog)<br>&#125;<br><br>export default Dialog<br><br></code></pre></td></tr></table></figure></li>\n<li><p>最后再main.js里注册为全局组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">import Dialog from &#x27;./components/Dialog/index.js&#x27;<br><br>Vue.use(Dialog)<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"这样就可以在其他组件里无需声明而使用此组件\"><a href=\"#这样就可以在其他组件里无需声明而使用此组件\" class=\"headerlink\" title=\"这样就可以在其他组件里无需声明而使用此组件\"></a>这样就可以在其他组件里无需声明而使用此组件</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"vue自定义全局弹框组件\"><a href=\"#vue自定义全局弹框组件\" class=\"headerlink\" title=\"vue自定义全局弹框组件\"></a>vue自定义全局弹框组件</h1><ol>\n<li><p>在components文件夹下新增一个组件文件夹Dialog，新建一个模板组件Dialog.vue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;template&gt;<br>  &lt;div class=&quot;u_dialog_panel&quot; @touchmove.stop=&quot;noop&quot;&gt;<br>    &lt;div class=&quot;mask&quot; v-if=&quot;visible&quot; @click=&quot;handleClose&quot;&gt;&lt;/div&gt;<br>    &lt;transition name=&quot;open&quot;&gt;<br>      &lt;div v-if=&quot;visible&quot; class=&quot;dialog_body&quot;&gt;<br>        &lt;slot&gt;&lt;/slot&gt;<br>        &lt;div class=&quot;btns&quot; v-if=&quot;confirmText || cancleText&quot;&gt;<br>          &lt;div class=&quot;cancle btn&quot; v-if=&quot;cancleText&quot; @click=&quot;handleCancle&quot;&gt;&#123;&#123;cancleText&#125;&#125;&lt;/div&gt;<br>          &lt;div class=&quot;confirm btn&quot; :style=&quot;confirmStyle&quot; v-if=&quot;confirmText&quot; @click=&quot;handleConfirm&quot;&gt;&#123;&#123;confirmText&#125;&#125;&lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/transition&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  name: &#x27;UDialog&#x27;,<br>  props: &#123;<br>    visible: &#123; type: Boolean, default: false, required: true &#125;,<br>    // 确定按钮的文案<br>    confirmText: &#123; type: String, default: &#x27;确定&#x27; &#125;,<br>    confirmStyle: &#123; type: String, default: &#x27;&#x27; &#125;,<br>    // 取消按钮的文案<br>    cancleText: &#123; type: String, default: &#x27;取消&#x27; &#125;,<br>    cancleStyle: &#123; type: String, default: &#x27;&#x27; &#125;,<br>  &#125;,<br>  created () &#123;<br>    this.$nextTick(() =&gt; &#123;<br>      document.body.insertBefore(this.$el, document.body.lastChild)<br>    &#125;)<br>  &#125;,<br>  beforeDestroy () &#123;<br>    document.body.removeChild(this.$el)<br>  &#125;,<br>  methods: &#123;<br>    // 关闭弹窗<br>    handleClose () &#123; this.$emit(&#x27;close&#x27;) &#125;,<br>    // 确定按钮<br>    handleConfirm () &#123; this.$emit(&#x27;confirm&#x27;) &#125;,<br>    // 取消按钮<br>    handleCancle () &#123; this.$emit(&#x27;cancle&#x27;) &#125;,<br>    noop () &#123;&#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;<br>.u_dialog_panel &#123;<br>  .mask &#123;<br>    width: 100vw;<br>    height: 100vh;<br>    background-color: rgba(0, 0, 0, 0.5);<br>    position: fixed;<br>    left: 0;<br>    top: 0;<br>    z-index: 100;<br>    backdrop-filter: blur(5px);<br>  &#125;<br>  .dialog_body&#123;<br>    width: 80vw;<br>    background-color: #fff;<br>    position: fixed;<br>    left: 50vw;<br>    top: 50vh;<br>    z-index: 100;<br>    transform: translate(-50%, -50%);<br>    transform-origin: 0 0;<br>    border-radius: .875rem;<br>    &amp;.open-enter &#123;<br>      opacity: 0;<br>      transform: scale(0.7) translate(-50%, -50%);<br>      transition: all 0.3s;<br>    &#125;<br>    &amp;.open-enter-to &#123;<br>      opacity: 1;<br>      transform: scale(1) translate(-50%, -50%);<br>      transition: all 0.3s;<br>    &#125;<br>    .btns &#123;<br>      display: flex;<br>      justify-content: space-between;<br>      align-items: center;<br>      .btn &#123;<br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br>        flex-grow: 1;<br>        width: 50%;<br>        height: 2.875rem;<br>        border-top: 1px solid #ddd;<br>        box-sizing: border-box;<br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br>        font-size: .875rem;<br>        &amp; + .btn &#123;<br>          border-left: 1px solid #ddd;<br>        &#125;<br>        &amp;.cancle &#123;<br>          color: #666666;<br>        &#125;<br>        &amp;.confirm &#123;<br>          color: #FF5883;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure></li>\n<li><p>在此文件夹再新建一个index.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">import Dialog from &#x27;./Dialog&#x27;<br><br>Dialog.install = function (Vue, options) &#123;<br>  Vue.component(`$&#123;Dialog.name&#125;`, Dialog)<br>&#125;<br><br>export default Dialog<br><br></code></pre></td></tr></table></figure></li>\n<li><p>最后再main.js里注册为全局组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">import Dialog from &#x27;./components/Dialog/index.js&#x27;<br><br>Vue.use(Dialog)<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"这样就可以在其他组件里无需声明而使用此组件\"><a href=\"#这样就可以在其他组件里无需声明而使用此组件\" class=\"headerlink\" title=\"这样就可以在其他组件里无需声明而使用此组件\"></a>这样就可以在其他组件里无需声明而使用此组件</h2>"},{"title":"export与export default的区别","date":"2021-07-01T06:21:44.000Z","_content":"\nnode中导入模块：var 名称 = require('模块标识符')\n\nnode中向外暴露成员的形式：module.exports = {}\n\n在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块\n\nES6中导入模块，使用 import 模块名称 from '模块标识符'    import '表示路径'\n\nimport * from * 是ES6中导入模块的方式\n\n### 在ES6中，使用export default 和 export 向外暴露成员\n\n例如：\n\n```javascript\n// test.js\nexport default {\n    name: 'zs',\n    age: 20\n}\n```\n\n或是\n\n```javascript\n// test.js\nvar info = {\n    name: 'zs',\n    age: 20\n}\nexport default info\n```\n\n在main.js中接收，test.js使用export default 向外暴露的成员\n\n```javascript\nimport person from './test.js'\nconsole.log(person);\n```\n\n### 注意：\n\n1、export default 向外暴露的成员，可以使用任意变量来接收\n\n2、在一个模块中，export default 只允许向外暴露一次\n\n3、在一个模块中，可以同时使用export default 和export 向外暴露成员\n\n4、使用export向外暴露的成员，只能使用{  }的形式来接收，这种形式，叫做【按需导出】\n\n5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义\n\n6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收\n\n7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名\n\n例如：\n\n```javascript\n// test.js\nvar info = {\n    name: 'zs',\n    age: 20\n}\nexport default info\n\nexport var title = '小星星'\n\nexport var content = '哈哈哈'\n```\n\n在main.js中接收，test.js使用export default 和 export 向外暴露的成员\n\n```javascript\nimport person, {title, content as content1} from './test.js'\nconsole.log(person);\nconsole.log(title + '=======' + content1);\n```\n\n","source":"_posts/2021-09-23-export与export-default的区别.md","raw":"---\ntitle: export与export default的区别\ndate: 2021-07-1 14:21:44\ntags: \n    - [JavaScript]\n    - [ES6]\ncategories: 技术类-前端\n---\n\nnode中导入模块：var 名称 = require('模块标识符')\n\nnode中向外暴露成员的形式：module.exports = {}\n\n在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块\n\nES6中导入模块，使用 import 模块名称 from '模块标识符'    import '表示路径'\n\nimport * from * 是ES6中导入模块的方式\n\n### 在ES6中，使用export default 和 export 向外暴露成员\n\n例如：\n\n```javascript\n// test.js\nexport default {\n    name: 'zs',\n    age: 20\n}\n```\n\n或是\n\n```javascript\n// test.js\nvar info = {\n    name: 'zs',\n    age: 20\n}\nexport default info\n```\n\n在main.js中接收，test.js使用export default 向外暴露的成员\n\n```javascript\nimport person from './test.js'\nconsole.log(person);\n```\n\n### 注意：\n\n1、export default 向外暴露的成员，可以使用任意变量来接收\n\n2、在一个模块中，export default 只允许向外暴露一次\n\n3、在一个模块中，可以同时使用export default 和export 向外暴露成员\n\n4、使用export向外暴露的成员，只能使用{  }的形式来接收，这种形式，叫做【按需导出】\n\n5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义\n\n6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收\n\n7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名\n\n例如：\n\n```javascript\n// test.js\nvar info = {\n    name: 'zs',\n    age: 20\n}\nexport default info\n\nexport var title = '小星星'\n\nexport var content = '哈哈哈'\n```\n\n在main.js中接收，test.js使用export default 和 export 向外暴露的成员\n\n```javascript\nimport person, {title, content as content1} from './test.js'\nconsole.log(person);\nconsole.log(title + '=======' + content1);\n```\n\n","slug":"export与export-default的区别","published":1,"updated":"2021-10-08T03:11:22.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno59000i7oo9chpd277w","content":"<p>node中导入模块：var 名称 = require(‘模块标识符’)</p>\n<p>node中向外暴露成员的形式：module.exports = {}</p>\n<p>在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块</p>\n<p>ES6中导入模块，使用 import 模块名称 from ‘模块标识符’    import ‘表示路径’</p>\n<p>import * from * 是ES6中导入模块的方式</p>\n<h3 id=\"在ES6中，使用export-default-和-export-向外暴露成员\"><a href=\"#在ES6中，使用export-default-和-export-向外暴露成员\" class=\"headerlink\" title=\"在ES6中，使用export default 和 export 向外暴露成员\"></a>在ES6中，使用export default 和 export 向外暴露成员</h3><p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zs&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>或是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span><br><span class=\"hljs-keyword\">var</span> info = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zs&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span><br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> info<br></code></pre></td></tr></table></figure>\n\n<p>在main.js中接收，test.js使用export default 向外暴露的成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> person <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./test.js&#x27;</span><br><span class=\"hljs-built_in\">console</span>.log(person);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>1、export default 向外暴露的成员，可以使用任意变量来接收</p>\n<p>2、在一个模块中，export default 只允许向外暴露一次</p>\n<p>3、在一个模块中，可以同时使用export default 和export 向外暴露成员</p>\n<p>4、使用export向外暴露的成员，只能使用{  }的形式来接收，这种形式，叫做【按需导出】</p>\n<p>5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义</p>\n<p>6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收</p>\n<p>7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名</p>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span><br><span class=\"hljs-keyword\">var</span> info = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zs&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span><br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> info<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> title = <span class=\"hljs-string\">&#x27;小星星&#x27;</span><br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> content = <span class=\"hljs-string\">&#x27;哈哈哈&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>在main.js中接收，test.js使用export default 和 export 向外暴露的成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> person, &#123;title, content <span class=\"hljs-keyword\">as</span> content1&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./test.js&#x27;</span><br><span class=\"hljs-built_in\">console</span>.log(person);<br><span class=\"hljs-built_in\">console</span>.log(title + <span class=\"hljs-string\">&#x27;=======&#x27;</span> + content1);<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>node中导入模块：var 名称 = require(‘模块标识符’)</p>\n<p>node中向外暴露成员的形式：module.exports = {}</p>\n<p>在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块</p>\n<p>ES6中导入模块，使用 import 模块名称 from ‘模块标识符’    import ‘表示路径’</p>\n<p>import * from * 是ES6中导入模块的方式</p>\n<h3 id=\"在ES6中，使用export-default-和-export-向外暴露成员\"><a href=\"#在ES6中，使用export-default-和-export-向外暴露成员\" class=\"headerlink\" title=\"在ES6中，使用export default 和 export 向外暴露成员\"></a>在ES6中，使用export default 和 export 向外暴露成员</h3><p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zs&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>或是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span><br><span class=\"hljs-keyword\">var</span> info = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zs&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span><br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> info<br></code></pre></td></tr></table></figure>\n\n<p>在main.js中接收，test.js使用export default 向外暴露的成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> person <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./test.js&#x27;</span><br><span class=\"hljs-built_in\">console</span>.log(person);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>1、export default 向外暴露的成员，可以使用任意变量来接收</p>\n<p>2、在一个模块中，export default 只允许向外暴露一次</p>\n<p>3、在一个模块中，可以同时使用export default 和export 向外暴露成员</p>\n<p>4、使用export向外暴露的成员，只能使用{  }的形式来接收，这种形式，叫做【按需导出】</p>\n<p>5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义</p>\n<p>6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收</p>\n<p>7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名</p>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span><br><span class=\"hljs-keyword\">var</span> info = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zs&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span><br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> info<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> title = <span class=\"hljs-string\">&#x27;小星星&#x27;</span><br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> content = <span class=\"hljs-string\">&#x27;哈哈哈&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>在main.js中接收，test.js使用export default 和 export 向外暴露的成员</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> person, &#123;title, content <span class=\"hljs-keyword\">as</span> content1&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./test.js&#x27;</span><br><span class=\"hljs-built_in\">console</span>.log(person);<br><span class=\"hljs-built_in\">console</span>.log(title + <span class=\"hljs-string\">&#x27;=======&#x27;</span> + content1);<br></code></pre></td></tr></table></figure>\n\n"},{"title":"原型与原型链与constructor","date":"2021-06-18T07:16:53.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 原型与原型链与constructor\n\n本文参考自：[https://blog.csdn.net/cc18868876837/article/details/81211729](https://blog.csdn.net/cc18868876837/article/details/81211729)\n\n## 先来个总结：\n\n1.  我们需要牢记两点：①`__proto__`和`constructor`属性是对象所独有的；② `prototype`属性是函数所独有的，因为函数也是一种对象，所以函数也拥有`__proto__`和`constructor`属性。\n\n2.  __`proto__`属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的`__proto__`属性所指向的那个对象（父对象）里找，一直找，直到`__proto__`属性的终点null，再往上找就相当于在null上取值，会报错。通过`__proto__`属性将对象连接起来的这条链路即我们所谓的原型链。\n\n3.  `prototype`属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即`f1.__proto__ === Foo.prototype`。\n\n4.  `constructor`属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向`Function`。\n\n![整体的联系](https://upload-images.jianshu.io/upload_images/13931286-5467dbdb42fd91ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n## 基础知识\n\n`__proto__`翻译为**原型**，多个`__proto__`串连起来的叫做**原型链**。\n\n`prototype`翻译为**原型对象**。\n\n## Object.getPrototypeOf()\n\n`Object.getPrototypeOf()` 方法返回指定对象的原型（内部`[[Prototype]]`属性的值）。\n\n### 示例\n```\nconst prototype1 = {};\nconst object1 = Object.create(prototype1);\n\nconsole.log(Object.getPrototypeOf(object1) === prototype1);\n// expected output: true\nObject.getPrototypeOf(object1) === object1.__proto__\n```\n\n## 正式开始\n\n```\nfunction Foo() {...};\nlet f1 = new Foo();\n```\n\n以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：**函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。**\n\n## `__proto__`属性\n\n首先要记住两点：\n\n1.  `__proto__`和`constructor`是对象才有的属性，在JavaScript中函数也是一种对象。\n\n2.  `prototype`是函数才有的属性。\n\n![__proto__](https://upload-images.jianshu.io/upload_images/13931286-9355e730b53d1879?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n这里我们仅留下 `__proto__` 属性，它是对象所独有的，可以看到`__proto__`属性都是由**一个对象指向一个对象**，即指向它们构造函数的**原型对象**（也可以理解为父对象），那么这个属性的作用是什么呢？它的**作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的`__proto__`属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的`__proto__`属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点）**，由以上这种通过`__proto__`属性来连接对象直到null的一条链即为我们所谓的原型链。    其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠`__proto__`继承而来的。\n\n## `prototype`属性\n\n![prototype属性](https://upload-images.jianshu.io/upload_images/13931286-a68d7e7851adf580?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n`prototype`属性是函数独有的。他是从一个函数指向一个对象，他的含义是函数的原型对象\n\n`f1.__proto__ === Foo.prototype`，它们两个完全一样。那prototype属性的作用又是什么呢？**它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。**任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。\n\n## constructor属性\n\n![constructor属性](https://upload-images.jianshu.io/upload_images/13931286-8de481f4fbc04fee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n`constructor`属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合`__proto__`属性查看会更清楚点，如下图所示），从上图中可以看出`Function`这个对象比较特殊，它的构造函数就是它自己（因为`Function`可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由`Function`构造函数得来，所以`constructor`属性的终点就是`Function`这个函数。\n\n`函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身`\n\n## 完~\n\n","source":"_posts/2021-09-23-原型与原型链与constructor.md","raw":"---\ntitle: 原型与原型链与constructor\ndate: 2021-06-18 15:16:53\ntags: \n    - [JavaScript]\n    - [面试]\ncategories: 技术类-前端\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 原型与原型链与constructor\n\n本文参考自：[https://blog.csdn.net/cc18868876837/article/details/81211729](https://blog.csdn.net/cc18868876837/article/details/81211729)\n\n## 先来个总结：\n\n1.  我们需要牢记两点：①`__proto__`和`constructor`属性是对象所独有的；② `prototype`属性是函数所独有的，因为函数也是一种对象，所以函数也拥有`__proto__`和`constructor`属性。\n\n2.  __`proto__`属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的`__proto__`属性所指向的那个对象（父对象）里找，一直找，直到`__proto__`属性的终点null，再往上找就相当于在null上取值，会报错。通过`__proto__`属性将对象连接起来的这条链路即我们所谓的原型链。\n\n3.  `prototype`属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即`f1.__proto__ === Foo.prototype`。\n\n4.  `constructor`属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向`Function`。\n\n![整体的联系](https://upload-images.jianshu.io/upload_images/13931286-5467dbdb42fd91ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n## 基础知识\n\n`__proto__`翻译为**原型**，多个`__proto__`串连起来的叫做**原型链**。\n\n`prototype`翻译为**原型对象**。\n\n## Object.getPrototypeOf()\n\n`Object.getPrototypeOf()` 方法返回指定对象的原型（内部`[[Prototype]]`属性的值）。\n\n### 示例\n```\nconst prototype1 = {};\nconst object1 = Object.create(prototype1);\n\nconsole.log(Object.getPrototypeOf(object1) === prototype1);\n// expected output: true\nObject.getPrototypeOf(object1) === object1.__proto__\n```\n\n## 正式开始\n\n```\nfunction Foo() {...};\nlet f1 = new Foo();\n```\n\n以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：**函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。**\n\n## `__proto__`属性\n\n首先要记住两点：\n\n1.  `__proto__`和`constructor`是对象才有的属性，在JavaScript中函数也是一种对象。\n\n2.  `prototype`是函数才有的属性。\n\n![__proto__](https://upload-images.jianshu.io/upload_images/13931286-9355e730b53d1879?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n这里我们仅留下 `__proto__` 属性，它是对象所独有的，可以看到`__proto__`属性都是由**一个对象指向一个对象**，即指向它们构造函数的**原型对象**（也可以理解为父对象），那么这个属性的作用是什么呢？它的**作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的`__proto__`属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的`__proto__`属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点）**，由以上这种通过`__proto__`属性来连接对象直到null的一条链即为我们所谓的原型链。    其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠`__proto__`继承而来的。\n\n## `prototype`属性\n\n![prototype属性](https://upload-images.jianshu.io/upload_images/13931286-a68d7e7851adf580?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n`prototype`属性是函数独有的。他是从一个函数指向一个对象，他的含义是函数的原型对象\n\n`f1.__proto__ === Foo.prototype`，它们两个完全一样。那prototype属性的作用又是什么呢？**它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。**任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。\n\n## constructor属性\n\n![constructor属性](https://upload-images.jianshu.io/upload_images/13931286-8de481f4fbc04fee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n`constructor`属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合`__proto__`属性查看会更清楚点，如下图所示），从上图中可以看出`Function`这个对象比较特殊，它的构造函数就是它自己（因为`Function`可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由`Function`构造函数得来，所以`constructor`属性的终点就是`Function`这个函数。\n\n`函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身`\n\n## 完~\n\n","slug":"原型与原型链与constructor","published":1,"updated":"2021-10-13T08:45:46.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5a000j7oo90m6thr49","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"原型与原型链与constructor\"><a href=\"#原型与原型链与constructor\" class=\"headerlink\" title=\"原型与原型链与constructor\"></a>原型与原型链与constructor</h1><p>本文参考自：<a href=\"https://blog.csdn.net/cc18868876837/article/details/81211729\">https://blog.csdn.net/cc18868876837/article/details/81211729</a></p>\n<h2 id=\"先来个总结：\"><a href=\"#先来个总结：\" class=\"headerlink\" title=\"先来个总结：\"></a>先来个总结：</h2><ol>\n<li><p> 我们需要牢记两点：①<code>__proto__</code>和<code>constructor</code>属性是对象所独有的；② <code>prototype</code>属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性。</p>\n</li>\n<li><p> __<code>proto__</code>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（父对象）里找，一直找，直到<code>__proto__</code>属性的终点null，再往上找就相当于在null上取值，会报错。通过<code>__proto__</code>属性将对象连接起来的这条链路即我们所谓的原型链。</p>\n</li>\n<li><p> <code>prototype</code>属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即<code>f1.__proto__ === Foo.prototype</code>。</p>\n</li>\n<li><p> <code>constructor</code>属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向<code>Function</code>。</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-5467dbdb42fd91ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"整体的联系\"> </p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p><code>__proto__</code>翻译为<strong>原型</strong>，多个<code>__proto__</code>串连起来的叫做<strong>原型链</strong>。</p>\n<p><code>prototype</code>翻译为<strong>原型对象</strong>。</p>\n<h2 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf()\"></a>Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf()</code> 方法返回指定对象的原型（内部<code>[[Prototype]]</code>属性的值）。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">const prototype1 = &#123;&#125;;<br>const object1 = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>create(prototype1);<br><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>get<span class=\"hljs-constructor\">PrototypeOf(<span class=\"hljs-params\">object1</span>)</span><span class=\"hljs-operator\"> === </span>prototype1);<br><span class=\"hljs-comment\">// expected output: true</span><br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>get<span class=\"hljs-constructor\">PrototypeOf(<span class=\"hljs-params\">object1</span>)</span><span class=\"hljs-operator\"> === </span>object1.__proto__<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"正式开始\"><a href=\"#正式开始\" class=\"headerlink\" title=\"正式开始\"></a>正式开始</h2><figure class=\"highlight nim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nim\">function <span class=\"hljs-type\">Foo</span>() <span class=\"hljs-meta\">&#123;...&#125;</span>;<br><span class=\"hljs-keyword\">let</span> f1 = new <span class=\"hljs-type\">Foo</span>();<br></code></pre></td></tr></table></figure>\n\n<p>以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：<strong>函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。</strong></p>\n<h2 id=\"proto-属性\"><a href=\"#proto-属性\" class=\"headerlink\" title=\"__proto__属性\"></a><code>__proto__</code>属性</h2><p>首先要记住两点：</p>\n<ol>\n<li><p> <code>__proto__</code>和<code>constructor</code>是对象才有的属性，在JavaScript中函数也是一种对象。</p>\n</li>\n<li><p> <code>prototype</code>是函数才有的属性。</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-9355e730b53d1879?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"__proto__\"> </p>\n<p>这里我们仅留下 <code>__proto__</code> 属性，它是对象所独有的，可以看到<code>__proto__</code>属性都是由<strong>一个对象指向一个对象</strong>，即指向它们构造函数的<strong>原型对象</strong>（也可以理解为父对象），那么这个属性的作用是什么呢？它的<strong>作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的<code>__proto__</code>属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点）</strong>，由以上这种通过<code>__proto__</code>属性来连接对象直到null的一条链即为我们所谓的原型链。    其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠<code>__proto__</code>继承而来的。</p>\n<h2 id=\"prototype属性\"><a href=\"#prototype属性\" class=\"headerlink\" title=\"prototype属性\"></a><code>prototype</code>属性</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-a68d7e7851adf580?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"prototype属性\"> </p>\n<p><code>prototype</code>属性是函数独有的。他是从一个函数指向一个对象，他的含义是函数的原型对象</p>\n<p><code>f1.__proto__ === Foo.prototype</code>，它们两个完全一样。那prototype属性的作用又是什么呢？<strong>它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。</strong>任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。</p>\n<h2 id=\"constructor属性\"><a href=\"#constructor属性\" class=\"headerlink\" title=\"constructor属性\"></a>constructor属性</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-8de481f4fbc04fee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"constructor属性\"> </p>\n<p><code>constructor</code>属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合<code>__proto__</code>属性查看会更清楚点，如下图所示），从上图中可以看出<code>Function</code>这个对象比较特殊，它的构造函数就是它自己（因为<code>Function</code>可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由<code>Function</code>构造函数得来，所以<code>constructor</code>属性的终点就是<code>Function</code>这个函数。</p>\n<p><code>函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身</code></p>\n<h2 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完~\"></a>完~</h2>","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"原型与原型链与constructor\"><a href=\"#原型与原型链与constructor\" class=\"headerlink\" title=\"原型与原型链与constructor\"></a>原型与原型链与constructor</h1><p>本文参考自：<a href=\"https://blog.csdn.net/cc18868876837/article/details/81211729\">https://blog.csdn.net/cc18868876837/article/details/81211729</a></p>\n<h2 id=\"先来个总结：\"><a href=\"#先来个总结：\" class=\"headerlink\" title=\"先来个总结：\"></a>先来个总结：</h2><ol>\n<li><p> 我们需要牢记两点：①<code>__proto__</code>和<code>constructor</code>属性是对象所独有的；② <code>prototype</code>属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性。</p>\n</li>\n<li><p> __<code>proto__</code>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（父对象）里找，一直找，直到<code>__proto__</code>属性的终点null，再往上找就相当于在null上取值，会报错。通过<code>__proto__</code>属性将对象连接起来的这条链路即我们所谓的原型链。</p>\n</li>\n<li><p> <code>prototype</code>属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即<code>f1.__proto__ === Foo.prototype</code>。</p>\n</li>\n<li><p> <code>constructor</code>属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向<code>Function</code>。</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-5467dbdb42fd91ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"整体的联系\"> </p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p><code>__proto__</code>翻译为<strong>原型</strong>，多个<code>__proto__</code>串连起来的叫做<strong>原型链</strong>。</p>\n<p><code>prototype</code>翻译为<strong>原型对象</strong>。</p>\n<h2 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf()\"></a>Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf()</code> 方法返回指定对象的原型（内部<code>[[Prototype]]</code>属性的值）。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">const prototype1 = &#123;&#125;;<br>const object1 = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>create(prototype1);<br><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>get<span class=\"hljs-constructor\">PrototypeOf(<span class=\"hljs-params\">object1</span>)</span><span class=\"hljs-operator\"> === </span>prototype1);<br><span class=\"hljs-comment\">// expected output: true</span><br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>get<span class=\"hljs-constructor\">PrototypeOf(<span class=\"hljs-params\">object1</span>)</span><span class=\"hljs-operator\"> === </span>object1.__proto__<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"正式开始\"><a href=\"#正式开始\" class=\"headerlink\" title=\"正式开始\"></a>正式开始</h2><figure class=\"highlight nim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nim\">function <span class=\"hljs-type\">Foo</span>() <span class=\"hljs-meta\">&#123;...&#125;</span>;<br><span class=\"hljs-keyword\">let</span> f1 = new <span class=\"hljs-type\">Foo</span>();<br></code></pre></td></tr></table></figure>\n\n<p>以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：<strong>函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。</strong></p>\n<h2 id=\"proto-属性\"><a href=\"#proto-属性\" class=\"headerlink\" title=\"__proto__属性\"></a><code>__proto__</code>属性</h2><p>首先要记住两点：</p>\n<ol>\n<li><p> <code>__proto__</code>和<code>constructor</code>是对象才有的属性，在JavaScript中函数也是一种对象。</p>\n</li>\n<li><p> <code>prototype</code>是函数才有的属性。</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-9355e730b53d1879?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"__proto__\"> </p>\n<p>这里我们仅留下 <code>__proto__</code> 属性，它是对象所独有的，可以看到<code>__proto__</code>属性都是由<strong>一个对象指向一个对象</strong>，即指向它们构造函数的<strong>原型对象</strong>（也可以理解为父对象），那么这个属性的作用是什么呢？它的<strong>作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的<code>__proto__</code>属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点）</strong>，由以上这种通过<code>__proto__</code>属性来连接对象直到null的一条链即为我们所谓的原型链。    其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠<code>__proto__</code>继承而来的。</p>\n<h2 id=\"prototype属性\"><a href=\"#prototype属性\" class=\"headerlink\" title=\"prototype属性\"></a><code>prototype</code>属性</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-a68d7e7851adf580?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"prototype属性\"> </p>\n<p><code>prototype</code>属性是函数独有的。他是从一个函数指向一个对象，他的含义是函数的原型对象</p>\n<p><code>f1.__proto__ === Foo.prototype</code>，它们两个完全一样。那prototype属性的作用又是什么呢？<strong>它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。</strong>任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。</p>\n<h2 id=\"constructor属性\"><a href=\"#constructor属性\" class=\"headerlink\" title=\"constructor属性\"></a>constructor属性</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-8de481f4fbc04fee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"constructor属性\"> </p>\n<p><code>constructor</code>属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合<code>__proto__</code>属性查看会更清楚点，如下图所示），从上图中可以看出<code>Function</code>这个对象比较特殊，它的构造函数就是它自己（因为<code>Function</code>可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由<code>Function</code>构造函数得来，所以<code>constructor</code>属性的终点就是<code>Function</code>这个函数。</p>\n<p><code>函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身</code></p>\n<h2 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完~\"></a>完~</h2>"},{"title":"new操作符的实现","date":"2021-06-18T21:23:44.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# JavaScript中的new操作符的原理\n\n## 例子\n\n```\nfunction Person (name, age) {\n this.name = name\n this.age = age\n}\nconst person1 = new Person('走花路的长颈鹿', 26)\nconsole.log(person1) //Person{name:'走花路的长颈鹿',age:26}\n```\n\n先定义了一个构造函数`Person`，然后通过`new`操作符生成Person构造函数的一个实例并将其引用赋值给变量`person1`。然后控制台打印出`person1`的内容，可以看到该实例对象具有`name`和`age`属性，它们的值就是我们在调用构造函数时传入的值。\n\n## new关键字进行的操作\n\n1.  先创建一个空对象`obj={}`\n\n2.  将obj的`__proto__`原型指向构造函数Person的`prototype`原型对象，即`obj.__proto__ = Person.prototype`\n\n3.  将构造函数Person内部的this指向obj，然后执行构造函数`Person()`（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象`obj`而已，就好像执行`obj.Person()`一样）\n\n4.  若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象`obj`（默认会添加`return this`）。否则，返回引用类型的值。\n\n![new操作符的执行过程](https://upload-images.jianshu.io/upload_images/13931286-2638e8196f6e699b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n## 自己实现一个new操作符\n\n```\nfunction myNew (constr, ...args) {\n // 1,2 创建一个对象obj，将obj的__proto__属性指向构造函数的原型对象\n // 即实现：obj.__proto__ === constructor.prototype\n var obj = Object.create(constr.prototype)\n // 3.将constrc内部的this（即执行上下文）指向obj，并执行\n var result = constr.apply(obj, args)\n // 4\\. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象\n return result instanceof Object ? result : obj\n}\n\n// 使用的例子：\nfunction Person(name, age){\n this.name = name;\n this.age = age;\n}\nconst person1 = myNew(Person, 'Tom', 20)\nconsole.log(person1)  // Person {name: \"Tom\", age: 20}\n```\n\n## 关键点\n\n1.  将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。\n\n2.  将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。\n\n<hr>\n\n## 2021年7月1日补充\n\n看一个例子\n```\nfunction Player(color) {\n  this.color = color\n}\nPlayer.prototype.start = function() {}\n\nconst white = new Player('white')\nconst black = new Player('black')\n\nconsole.log(black.__proto__)  // start()\nconsole.log(Object.getPrototypeOf(black)) // start()\nconsole.log(Player.prototype) // start()\nconsole.log(Player.__proto__) // {}\n```\n根据反推可以写一下思路\n1. 一个继承自`Player.prototype`的新对象 p1/p2被创建\n2. `p1.__proto__ === Player.prototype`，`p1.__proto__`指向`Player.prototype`\n3. 将this指向新创建的对象p1/p2\n4. 返回一个新对象：\n    1. 如果构造函数没有显示的返回值，那么返回this\n    2. 如果有显式的返回值，是基本类型，那么还是返回this\n    3. 如果构造函数有显式的返回值，是对象类型，比如是{a:1}，那么就返回{a:1}\n现在我们再来实现一个new指令的功能\n```\nfunction Player(name){\n  this.name = name\n}\n\nfunction objectFactory() {\n  let o = new Object()\n  let FunctionConstructor = [].shift.call(arguments)\n  o.__proto__ = FunctionConstructor.prototype\n  let resultObj = FunctionConstructor.apply(o, arguments) \n  return typeof resultObj === 'object' ? resultObj : o\n}\nconst p1 = objectFactory(Player, '花鹿')\nconsole.log(p1) // 花鹿\n``` \n## 完~\n","source":"_posts/2021-09-23-new操作符的实现.md","raw":"---\ntitle: new操作符的实现\ndate: 2021-06-19 05:23:44\ntags: [JavaScript,面试]\ncategories: 技术类-前端\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# JavaScript中的new操作符的原理\n\n## 例子\n\n```\nfunction Person (name, age) {\n this.name = name\n this.age = age\n}\nconst person1 = new Person('走花路的长颈鹿', 26)\nconsole.log(person1) //Person{name:'走花路的长颈鹿',age:26}\n```\n\n先定义了一个构造函数`Person`，然后通过`new`操作符生成Person构造函数的一个实例并将其引用赋值给变量`person1`。然后控制台打印出`person1`的内容，可以看到该实例对象具有`name`和`age`属性，它们的值就是我们在调用构造函数时传入的值。\n\n## new关键字进行的操作\n\n1.  先创建一个空对象`obj={}`\n\n2.  将obj的`__proto__`原型指向构造函数Person的`prototype`原型对象，即`obj.__proto__ = Person.prototype`\n\n3.  将构造函数Person内部的this指向obj，然后执行构造函数`Person()`（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象`obj`而已，就好像执行`obj.Person()`一样）\n\n4.  若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象`obj`（默认会添加`return this`）。否则，返回引用类型的值。\n\n![new操作符的执行过程](https://upload-images.jianshu.io/upload_images/13931286-2638e8196f6e699b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n## 自己实现一个new操作符\n\n```\nfunction myNew (constr, ...args) {\n // 1,2 创建一个对象obj，将obj的__proto__属性指向构造函数的原型对象\n // 即实现：obj.__proto__ === constructor.prototype\n var obj = Object.create(constr.prototype)\n // 3.将constrc内部的this（即执行上下文）指向obj，并执行\n var result = constr.apply(obj, args)\n // 4\\. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象\n return result instanceof Object ? result : obj\n}\n\n// 使用的例子：\nfunction Person(name, age){\n this.name = name;\n this.age = age;\n}\nconst person1 = myNew(Person, 'Tom', 20)\nconsole.log(person1)  // Person {name: \"Tom\", age: 20}\n```\n\n## 关键点\n\n1.  将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。\n\n2.  将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。\n\n<hr>\n\n## 2021年7月1日补充\n\n看一个例子\n```\nfunction Player(color) {\n  this.color = color\n}\nPlayer.prototype.start = function() {}\n\nconst white = new Player('white')\nconst black = new Player('black')\n\nconsole.log(black.__proto__)  // start()\nconsole.log(Object.getPrototypeOf(black)) // start()\nconsole.log(Player.prototype) // start()\nconsole.log(Player.__proto__) // {}\n```\n根据反推可以写一下思路\n1. 一个继承自`Player.prototype`的新对象 p1/p2被创建\n2. `p1.__proto__ === Player.prototype`，`p1.__proto__`指向`Player.prototype`\n3. 将this指向新创建的对象p1/p2\n4. 返回一个新对象：\n    1. 如果构造函数没有显示的返回值，那么返回this\n    2. 如果有显式的返回值，是基本类型，那么还是返回this\n    3. 如果构造函数有显式的返回值，是对象类型，比如是{a:1}，那么就返回{a:1}\n现在我们再来实现一个new指令的功能\n```\nfunction Player(name){\n  this.name = name\n}\n\nfunction objectFactory() {\n  let o = new Object()\n  let FunctionConstructor = [].shift.call(arguments)\n  o.__proto__ = FunctionConstructor.prototype\n  let resultObj = FunctionConstructor.apply(o, arguments) \n  return typeof resultObj === 'object' ? resultObj : o\n}\nconst p1 = objectFactory(Player, '花鹿')\nconsole.log(p1) // 花鹿\n``` \n## 完~\n","slug":"new操作符的实现","published":1,"updated":"2021-10-13T08:42:09.247Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5c000n7oo9gbca4y5m","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"JavaScript中的new操作符的原理\"><a href=\"#JavaScript中的new操作符的原理\" class=\"headerlink\" title=\"JavaScript中的new操作符的原理\"></a>JavaScript中的new操作符的原理</h1><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span> (<span class=\"hljs-params\">name, age</span>) </span>&#123;<br> <span class=\"hljs-built_in\">this</span>.name = name<br> <span class=\"hljs-built_in\">this</span>.age = age<br>&#125;<br><span class=\"hljs-keyword\">const</span> person1 = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">&#x27;走花路的长颈鹿&#x27;</span>, <span class=\"hljs-number\">26</span>)<br><span class=\"hljs-built_in\">console</span>.log(person1) <span class=\"hljs-comment\">//Person&#123;name:&#x27;走花路的长颈鹿&#x27;,age:26&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>先定义了一个构造函数<code>Person</code>，然后通过<code>new</code>操作符生成Person构造函数的一个实例并将其引用赋值给变量<code>person1</code>。然后控制台打印出<code>person1</code>的内容，可以看到该实例对象具有<code>name</code>和<code>age</code>属性，它们的值就是我们在调用构造函数时传入的值。</p>\n<h2 id=\"new关键字进行的操作\"><a href=\"#new关键字进行的操作\" class=\"headerlink\" title=\"new关键字进行的操作\"></a>new关键字进行的操作</h2><ol>\n<li><p> 先创建一个空对象<code>obj=&#123;&#125;</code></p>\n</li>\n<li><p> 将obj的<code>__proto__</code>原型指向构造函数Person的<code>prototype</code>原型对象，即<code>obj.__proto__ = Person.prototype</code></p>\n</li>\n<li><p> 将构造函数Person内部的this指向obj，然后执行构造函数<code>Person()</code>（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象<code>obj</code>而已，就好像执行<code>obj.Person()</code>一样）</p>\n</li>\n<li><p> 若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象<code>obj</code>（默认会添加<code>return this</code>）。否则，返回引用类型的值。</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-2638e8196f6e699b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"new操作符的执行过程\"> </p>\n<h2 id=\"自己实现一个new操作符\"><a href=\"#自己实现一个new操作符\" class=\"headerlink\" title=\"自己实现一个new操作符\"></a>自己实现一个new操作符</h2><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myNew</span> <span class=\"hljs-params\">(constr, <span class=\"hljs-rest_arg\">...args</span>)</span> </span>&#123;<br> <span class=\"hljs-comment\">// 1,2 创建一个对象obj，将obj的__proto__属性指向构造函数的原型对象</span><br> <span class=\"hljs-comment\">// 即实现：obj.__proto__ === constructor.prototype</span><br> <span class=\"hljs-keyword\">var</span> obj = Object.create(constr.prototype)<br> <span class=\"hljs-comment\">// 3.将constrc内部的this（即执行上下文）指向obj，并执行</span><br> <span class=\"hljs-keyword\">var</span> result = constr.apply(obj, args)<br> <span class=\"hljs-comment\">// 4\\. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象</span><br> <span class=\"hljs-keyword\">return</span> result <span class=\"hljs-keyword\">instanceof</span> Object ? result : obj<br>&#125;<br><br><span class=\"hljs-comment\">// 使用的例子：</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">(name, age)</span></span>&#123;<br> <span class=\"hljs-keyword\">this</span>.name = name;<br> <span class=\"hljs-keyword\">this</span>.age = age;<br>&#125;<br><span class=\"hljs-keyword\">const</span> person1 = myNew(Person, <span class=\"hljs-string\">&#x27;Tom&#x27;</span>, <span class=\"hljs-number\">20</span>)<br>console.log(person1)  <span class=\"hljs-comment\">// Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h2><ol>\n<li><p> 将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。</p>\n</li>\n<li><p> 将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。</p>\n</li>\n</ol>\n<hr>\n\n<h2 id=\"2021年7月1日补充\"><a href=\"#2021年7月1日补充\" class=\"headerlink\" title=\"2021年7月1日补充\"></a>2021年7月1日补充</h2><p>看一个例子</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-constructor\">Player(<span class=\"hljs-params\">color</span>)</span> &#123;<br>  this.color = color<br>&#125;<br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Player</span>.</span></span>prototype.start = <span class=\"hljs-keyword\">function</span><span class=\"hljs-literal\">()</span> &#123;&#125;<br><br>const white = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Player(&#x27;<span class=\"hljs-params\">white</span>&#x27;)</span><br>const black = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Player(&#x27;<span class=\"hljs-params\">black</span>&#x27;)</span><br><br>console.log(black.__proto__)  <span class=\"hljs-comment\">// start()</span><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>get<span class=\"hljs-constructor\">PrototypeOf(<span class=\"hljs-params\">black</span>)</span>) <span class=\"hljs-comment\">// start()</span><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Player</span>.</span></span>prototype) <span class=\"hljs-comment\">// start()</span><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Player</span>.</span><span class=\"hljs-module\"><span class=\"hljs-identifier\">__proto__</span>)</span></span> <span class=\"hljs-comment\">// &#123;&#125;</span><br></code></pre></td></tr></table></figure>\n<p>根据反推可以写一下思路</p>\n<ol>\n<li>一个继承自<code>Player.prototype</code>的新对象 p1/p2被创建</li>\n<li><code>p1.__proto__ === Player.prototype</code>，<code>p1.__proto__</code>指向<code>Player.prototype</code></li>\n<li>将this指向新创建的对象p1/p2</li>\n<li>返回一个新对象：<ol>\n<li>如果构造函数没有显示的返回值，那么返回this</li>\n<li>如果有显式的返回值，是基本类型，那么还是返回this</li>\n<li>如果构造函数有显式的返回值，是对象类型，比如是{a:1}，那么就返回{a:1}<br>现在我们再来实现一个new指令的功能<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Player</span>(<span class=\"hljs-params\">name</span>)</span>&#123;<br>  <span class=\"hljs-built_in\">this</span>.name = name<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">objectFactory</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> o = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>()<br>  <span class=\"hljs-keyword\">let</span> FunctionConstructor = [].shift.call(<span class=\"hljs-built_in\">arguments</span>)<br>  o.__proto__ = FunctionConstructor.prototype<br>  <span class=\"hljs-keyword\">let</span> resultObj = FunctionConstructor.apply(o, <span class=\"hljs-built_in\">arguments</span>) <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> resultObj === <span class=\"hljs-string\">&#x27;object&#x27;</span> ? resultObj : o<br>&#125;<br><span class=\"hljs-keyword\">const</span> p1 = objectFactory(Player, <span class=\"hljs-string\">&#x27;花鹿&#x27;</span>)<br><span class=\"hljs-built_in\">console</span>.log(p1) <span class=\"hljs-comment\">// 花鹿</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完~\"></a>完~</h2></li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"JavaScript中的new操作符的原理\"><a href=\"#JavaScript中的new操作符的原理\" class=\"headerlink\" title=\"JavaScript中的new操作符的原理\"></a>JavaScript中的new操作符的原理</h1><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span> (<span class=\"hljs-params\">name, age</span>) </span>&#123;<br> <span class=\"hljs-built_in\">this</span>.name = name<br> <span class=\"hljs-built_in\">this</span>.age = age<br>&#125;<br><span class=\"hljs-keyword\">const</span> person1 = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">&#x27;走花路的长颈鹿&#x27;</span>, <span class=\"hljs-number\">26</span>)<br><span class=\"hljs-built_in\">console</span>.log(person1) <span class=\"hljs-comment\">//Person&#123;name:&#x27;走花路的长颈鹿&#x27;,age:26&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>先定义了一个构造函数<code>Person</code>，然后通过<code>new</code>操作符生成Person构造函数的一个实例并将其引用赋值给变量<code>person1</code>。然后控制台打印出<code>person1</code>的内容，可以看到该实例对象具有<code>name</code>和<code>age</code>属性，它们的值就是我们在调用构造函数时传入的值。</p>\n<h2 id=\"new关键字进行的操作\"><a href=\"#new关键字进行的操作\" class=\"headerlink\" title=\"new关键字进行的操作\"></a>new关键字进行的操作</h2><ol>\n<li><p> 先创建一个空对象<code>obj=&#123;&#125;</code></p>\n</li>\n<li><p> 将obj的<code>__proto__</code>原型指向构造函数Person的<code>prototype</code>原型对象，即<code>obj.__proto__ = Person.prototype</code></p>\n</li>\n<li><p> 将构造函数Person内部的this指向obj，然后执行构造函数<code>Person()</code>（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象<code>obj</code>而已，就好像执行<code>obj.Person()</code>一样）</p>\n</li>\n<li><p> 若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象<code>obj</code>（默认会添加<code>return this</code>）。否则，返回引用类型的值。</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-2638e8196f6e699b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"new操作符的执行过程\"> </p>\n<h2 id=\"自己实现一个new操作符\"><a href=\"#自己实现一个new操作符\" class=\"headerlink\" title=\"自己实现一个new操作符\"></a>自己实现一个new操作符</h2><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myNew</span> <span class=\"hljs-params\">(constr, <span class=\"hljs-rest_arg\">...args</span>)</span> </span>&#123;<br> <span class=\"hljs-comment\">// 1,2 创建一个对象obj，将obj的__proto__属性指向构造函数的原型对象</span><br> <span class=\"hljs-comment\">// 即实现：obj.__proto__ === constructor.prototype</span><br> <span class=\"hljs-keyword\">var</span> obj = Object.create(constr.prototype)<br> <span class=\"hljs-comment\">// 3.将constrc内部的this（即执行上下文）指向obj，并执行</span><br> <span class=\"hljs-keyword\">var</span> result = constr.apply(obj, args)<br> <span class=\"hljs-comment\">// 4\\. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象</span><br> <span class=\"hljs-keyword\">return</span> result <span class=\"hljs-keyword\">instanceof</span> Object ? result : obj<br>&#125;<br><br><span class=\"hljs-comment\">// 使用的例子：</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">(name, age)</span></span>&#123;<br> <span class=\"hljs-keyword\">this</span>.name = name;<br> <span class=\"hljs-keyword\">this</span>.age = age;<br>&#125;<br><span class=\"hljs-keyword\">const</span> person1 = myNew(Person, <span class=\"hljs-string\">&#x27;Tom&#x27;</span>, <span class=\"hljs-number\">20</span>)<br>console.log(person1)  <span class=\"hljs-comment\">// Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h2><ol>\n<li><p> 将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。</p>\n</li>\n<li><p> 将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。</p>\n</li>\n</ol>\n<hr>\n\n<h2 id=\"2021年7月1日补充\"><a href=\"#2021年7月1日补充\" class=\"headerlink\" title=\"2021年7月1日补充\"></a>2021年7月1日补充</h2><p>看一个例子</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-constructor\">Player(<span class=\"hljs-params\">color</span>)</span> &#123;<br>  this.color = color<br>&#125;<br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Player</span>.</span></span>prototype.start = <span class=\"hljs-keyword\">function</span><span class=\"hljs-literal\">()</span> &#123;&#125;<br><br>const white = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Player(&#x27;<span class=\"hljs-params\">white</span>&#x27;)</span><br>const black = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Player(&#x27;<span class=\"hljs-params\">black</span>&#x27;)</span><br><br>console.log(black.__proto__)  <span class=\"hljs-comment\">// start()</span><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Object</span>.</span></span>get<span class=\"hljs-constructor\">PrototypeOf(<span class=\"hljs-params\">black</span>)</span>) <span class=\"hljs-comment\">// start()</span><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Player</span>.</span></span>prototype) <span class=\"hljs-comment\">// start()</span><br>console.log(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Player</span>.</span><span class=\"hljs-module\"><span class=\"hljs-identifier\">__proto__</span>)</span></span> <span class=\"hljs-comment\">// &#123;&#125;</span><br></code></pre></td></tr></table></figure>\n<p>根据反推可以写一下思路</p>\n<ol>\n<li>一个继承自<code>Player.prototype</code>的新对象 p1/p2被创建</li>\n<li><code>p1.__proto__ === Player.prototype</code>，<code>p1.__proto__</code>指向<code>Player.prototype</code></li>\n<li>将this指向新创建的对象p1/p2</li>\n<li>返回一个新对象：<ol>\n<li>如果构造函数没有显示的返回值，那么返回this</li>\n<li>如果有显式的返回值，是基本类型，那么还是返回this</li>\n<li>如果构造函数有显式的返回值，是对象类型，比如是{a:1}，那么就返回{a:1}<br>现在我们再来实现一个new指令的功能<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Player</span>(<span class=\"hljs-params\">name</span>)</span>&#123;<br>  <span class=\"hljs-built_in\">this</span>.name = name<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">objectFactory</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> o = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>()<br>  <span class=\"hljs-keyword\">let</span> FunctionConstructor = [].shift.call(<span class=\"hljs-built_in\">arguments</span>)<br>  o.__proto__ = FunctionConstructor.prototype<br>  <span class=\"hljs-keyword\">let</span> resultObj = FunctionConstructor.apply(o, <span class=\"hljs-built_in\">arguments</span>) <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> resultObj === <span class=\"hljs-string\">&#x27;object&#x27;</span> ? resultObj : o<br>&#125;<br><span class=\"hljs-keyword\">const</span> p1 = objectFactory(Player, <span class=\"hljs-string\">&#x27;花鹿&#x27;</span>)<br><span class=\"hljs-built_in\">console</span>.log(p1) <span class=\"hljs-comment\">// 花鹿</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完~\"></a>完~</h2></li>\n</ol>\n</li>\n</ol>\n"},{"title":"Vue3(一)","date":"2021-09-16T09:39:17.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n今天上课内容是 vue 3,共有两节课，一节讲基础，一节讲原理。\n\n以下是课堂笔记：\n\n![上课笔记](https://upload-images.jianshu.io/upload_images/13931286-4c145b32d10b1824.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n![上课笔记](https://upload-images.jianshu.io/upload_images/13931286-3e37e261f17cbf13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n![上课笔记](https://upload-images.jianshu.io/upload_images/13931286-673deca33d797bcb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ","source":"_posts/2021-09-25-Vue3-一.md","raw":"---\ntitle: Vue3(一)\ndate: 2021-09-16 17:39:17\ntags: Vue3\ncategories: 技术类-Vue\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n今天上课内容是 vue 3,共有两节课，一节讲基础，一节讲原理。\n\n以下是课堂笔记：\n\n![上课笔记](https://upload-images.jianshu.io/upload_images/13931286-4c145b32d10b1824.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n![上课笔记](https://upload-images.jianshu.io/upload_images/13931286-3e37e261f17cbf13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n![上课笔记](https://upload-images.jianshu.io/upload_images/13931286-673deca33d797bcb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ","slug":"Vue3-一","published":1,"updated":"2021-09-26T02:16:38.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5d000p7oo956m1euwl","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p>今天上课内容是 vue 3,共有两节课，一节讲基础，一节讲原理。</p>\n<p>以下是课堂笔记：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-4c145b32d10b1824.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"上课笔记\"> </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-3e37e261f17cbf13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"上课笔记\"> </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-673deca33d797bcb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"上课笔记\"> </p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p>今天上课内容是 vue 3,共有两节课，一节讲基础，一节讲原理。</p>\n<p>以下是课堂笔记：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-4c145b32d10b1824.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"上课笔记\"> </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-3e37e261f17cbf13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"上课笔记\"> </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-673deca33d797bcb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"上课笔记\"> </p>\n"},{"title":"栈与队列的理解以及应用场景","date":"2021-09-23T06:00:28.000Z","_content":"\n# 1.栈\n\n**栈（stack）**又名堆栈，它是一种运算受限的线性表，**限定仅在表尾进行插入和删除操作的线性表**。\n\n表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈\n\n所以其按照**先进后出**的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用\n\n实现一个栈：\n\n```js\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n\n  /**\n   * 添加一个（或几个）新元素到栈顶\n   * @param {*} element 新元素\n   */\n  push(element) {\n    this.items.push(element);\n  }\n\n  /**\n   * 移除栈顶的元素，同时返回被移除的元素\n   */\n  pop() {\n    return this.items.pop();\n  }\n\n  /**\n   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）\n   */\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n\n  /**\n   * 如果栈里没有任何元素就返回true,否则返回false\n   */\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  /**\n   * 移除栈里的所有元素\n   */\n  clear() {\n    this.items = [];\n  }\n\n  /**\n   * 返回栈里的元素个数。这个方法和数组的length属性很类似\n   */\n  size() {\n    return this.items.length;\n  }\n}\n```\n\n关于栈的操作主要的方法如下：\n\n- push：入栈操作\n- pop：出栈操作\n\n# 二.队列\n\n跟栈十分相似，队列是一种特殊的线性表，特殊之处在于**它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作**。\n\n进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列\n\n在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为**先进先出**\n\n简单实现一个队列，如下：\n\n```js\nclass Queue {\n  constructor() {\n    this.list = [];\n    this.frontIndex = 0;\n    this.tailIndex = 0;\n  }\n  enqueue(item) {\n    this.list[this.tailIndex++] = item;\n  }\n  unqueue() {\n    const item = this.list[this.frontIndex];\n    this.frontIndex++;\n    return item;\n  }\n}\n```\n\n# 三.应用场景\n\n## 栈\n\n借助栈的先进后出的特性，可以简单实现一个逆序输出的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出\n\n包括编译器的在对输入的语法进行分析的时候，例如\"()\"、\"{}\"、\"[]\"这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错\n\n包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值\n\n生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型\n\n## 队列\n\n当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题\n\n队列的使用广泛应用在广度优先搜索中，例如层次遍历一个二叉树的节点值\n\n生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型\n\n参考文献\n\n- https://baike.baidu.com/item/%E6%A0%88/12808149\n- https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481\n","source":"_posts/2021-09-23-栈与队列的理解以及应用场景.md","raw":"---\ntitle: 栈与队列的理解以及应用场景\ndate: 2021-09-23 14:00:28\ntags: 计算机基础\ncategories: 计算机基础\n---\n\n# 1.栈\n\n**栈（stack）**又名堆栈，它是一种运算受限的线性表，**限定仅在表尾进行插入和删除操作的线性表**。\n\n表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈\n\n所以其按照**先进后出**的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用\n\n实现一个栈：\n\n```js\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n\n  /**\n   * 添加一个（或几个）新元素到栈顶\n   * @param {*} element 新元素\n   */\n  push(element) {\n    this.items.push(element);\n  }\n\n  /**\n   * 移除栈顶的元素，同时返回被移除的元素\n   */\n  pop() {\n    return this.items.pop();\n  }\n\n  /**\n   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）\n   */\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n\n  /**\n   * 如果栈里没有任何元素就返回true,否则返回false\n   */\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  /**\n   * 移除栈里的所有元素\n   */\n  clear() {\n    this.items = [];\n  }\n\n  /**\n   * 返回栈里的元素个数。这个方法和数组的length属性很类似\n   */\n  size() {\n    return this.items.length;\n  }\n}\n```\n\n关于栈的操作主要的方法如下：\n\n- push：入栈操作\n- pop：出栈操作\n\n# 二.队列\n\n跟栈十分相似，队列是一种特殊的线性表，特殊之处在于**它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作**。\n\n进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列\n\n在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为**先进先出**\n\n简单实现一个队列，如下：\n\n```js\nclass Queue {\n  constructor() {\n    this.list = [];\n    this.frontIndex = 0;\n    this.tailIndex = 0;\n  }\n  enqueue(item) {\n    this.list[this.tailIndex++] = item;\n  }\n  unqueue() {\n    const item = this.list[this.frontIndex];\n    this.frontIndex++;\n    return item;\n  }\n}\n```\n\n# 三.应用场景\n\n## 栈\n\n借助栈的先进后出的特性，可以简单实现一个逆序输出的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出\n\n包括编译器的在对输入的语法进行分析的时候，例如\"()\"、\"{}\"、\"[]\"这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错\n\n包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值\n\n生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型\n\n## 队列\n\n当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题\n\n队列的使用广泛应用在广度优先搜索中，例如层次遍历一个二叉树的节点值\n\n生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型\n\n参考文献\n\n- https://baike.baidu.com/item/%E6%A0%88/12808149\n- https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481\n","slug":"栈与队列的理解以及应用场景","published":1,"updated":"2022-01-25T03:33:45.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5f000s7oo92ddcdynl","content":"<h1 id=\"1-栈\"><a href=\"#1-栈\" class=\"headerlink\" title=\"1.栈\"></a>1.栈</h1><p><strong>栈（stack）</strong>又名堆栈，它是一种运算受限的线性表，<strong>限定仅在表尾进行插入和删除操作的线性表</strong>。</p>\n<p>表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈</p>\n<p>所以其按照<strong>先进后出</strong>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用</p>\n<p>实现一个栈：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Stack</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.items = [];<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 添加一个（或几个）新元素到栈顶</span><br><span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;*&#125;</span> </span>element 新元素</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">push</span>(<span class=\"hljs-params\">element</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.items.push(element);<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 移除栈顶的元素，同时返回被移除的元素</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">pop</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items.pop();<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">peek</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items[<span class=\"hljs-built_in\">this</span>.items.length - <span class=\"hljs-number\">1</span>];<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 如果栈里没有任何元素就返回true,否则返回false</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">isEmpty</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items.length === <span class=\"hljs-number\">0</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 移除栈里的所有元素</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">clear</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.items = [];<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 返回栈里的元素个数。这个方法和数组的length属性很类似</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">size</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items.length;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>关于栈的操作主要的方法如下：</p>\n<ul>\n<li>push：入栈操作</li>\n<li>pop：出栈操作</li>\n</ul>\n<h1 id=\"二-队列\"><a href=\"#二-队列\" class=\"headerlink\" title=\"二.队列\"></a>二.队列</h1><p>跟栈十分相似，队列是一种特殊的线性表，特殊之处在于<strong>它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</strong>。</p>\n<p>进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列</p>\n<p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为<strong>先进先出</strong></p>\n<p>简单实现一个队列，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Queue</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.list = [];<br>    <span class=\"hljs-built_in\">this</span>.frontIndex = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-built_in\">this</span>.tailIndex = <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">enqueue</span>(<span class=\"hljs-params\">item</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.list[<span class=\"hljs-built_in\">this</span>.tailIndex++] = item;<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">unqueue</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> item = <span class=\"hljs-built_in\">this</span>.list[<span class=\"hljs-built_in\">this</span>.frontIndex];<br>    <span class=\"hljs-built_in\">this</span>.frontIndex++;<br>    <span class=\"hljs-keyword\">return</span> item;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"三-应用场景\"><a href=\"#三-应用场景\" class=\"headerlink\" title=\"三.应用场景\"></a>三.应用场景</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>借助栈的先进后出的特性，可以简单实现一个逆序输出的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出</p>\n<p>包括编译器的在对输入的语法进行分析的时候，例如”()”、”{}”、”[]”这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p>\n<p>包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值</p>\n<p>生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题</p>\n<p>队列的使用广泛应用在广度优先搜索中，例如层次遍历一个二叉树的节点值</p>\n<p>生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型</p>\n<p>参考文献</p>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E6%A0%88/12808149\">https://baike.baidu.com/item/%E6%A0%88/12808149</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481\">https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-栈\"><a href=\"#1-栈\" class=\"headerlink\" title=\"1.栈\"></a>1.栈</h1><p><strong>栈（stack）</strong>又名堆栈，它是一种运算受限的线性表，<strong>限定仅在表尾进行插入和删除操作的线性表</strong>。</p>\n<p>表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈</p>\n<p>所以其按照<strong>先进后出</strong>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用</p>\n<p>实现一个栈：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Stack</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.items = [];<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 添加一个（或几个）新元素到栈顶</span><br><span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;*&#125;</span> </span>element 新元素</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">push</span>(<span class=\"hljs-params\">element</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.items.push(element);<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 移除栈顶的元素，同时返回被移除的元素</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">pop</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items.pop();<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">peek</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items[<span class=\"hljs-built_in\">this</span>.items.length - <span class=\"hljs-number\">1</span>];<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 如果栈里没有任何元素就返回true,否则返回false</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">isEmpty</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items.length === <span class=\"hljs-number\">0</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 移除栈里的所有元素</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">clear</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.items = [];<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * 返回栈里的元素个数。这个方法和数组的length属性很类似</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">size</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.items.length;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>关于栈的操作主要的方法如下：</p>\n<ul>\n<li>push：入栈操作</li>\n<li>pop：出栈操作</li>\n</ul>\n<h1 id=\"二-队列\"><a href=\"#二-队列\" class=\"headerlink\" title=\"二.队列\"></a>二.队列</h1><p>跟栈十分相似，队列是一种特殊的线性表，特殊之处在于<strong>它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</strong>。</p>\n<p>进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列</p>\n<p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为<strong>先进先出</strong></p>\n<p>简单实现一个队列，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Queue</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.list = [];<br>    <span class=\"hljs-built_in\">this</span>.frontIndex = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-built_in\">this</span>.tailIndex = <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">enqueue</span>(<span class=\"hljs-params\">item</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.list[<span class=\"hljs-built_in\">this</span>.tailIndex++] = item;<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">unqueue</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> item = <span class=\"hljs-built_in\">this</span>.list[<span class=\"hljs-built_in\">this</span>.frontIndex];<br>    <span class=\"hljs-built_in\">this</span>.frontIndex++;<br>    <span class=\"hljs-keyword\">return</span> item;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"三-应用场景\"><a href=\"#三-应用场景\" class=\"headerlink\" title=\"三.应用场景\"></a>三.应用场景</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>借助栈的先进后出的特性，可以简单实现一个逆序输出的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出</p>\n<p>包括编译器的在对输入的语法进行分析的时候，例如”()”、”{}”、”[]”这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p>\n<p>包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值</p>\n<p>生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题</p>\n<p>队列的使用广泛应用在广度优先搜索中，例如层次遍历一个二叉树的节点值</p>\n<p>生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型</p>\n<p>参考文献</p>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E6%A0%88/12808149\">https://baike.baidu.com/item/%E6%A0%88/12808149</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481\">https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481</a></li>\n</ul>\n"},{"title":"日常-最爱的电影","date":"2021-09-25T10:07:53.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n![第六感海报](https://img9.doubanio.com/view/photo/l/public/p2220184425.webp)\n今天重温了电影《第六感》，一部披着灵异外皮的心灵治愈电影。\n\n有些电影无论第几遍看还是让人感动\n![第六感剧照](https://img2.doubanio.com/view/photo/l/public/p2351243392.webp)\n![第六感剧照](https://img1.doubanio.com/view/photo/l/public/p2356175109.webp)\n","source":"_posts/2021-09-25-浮生一日-最爱的电影.md","raw":"---\ntitle: 日常-最爱的电影\ndate: 2021-09-25 18:07:53\ntags: \n  - [日常]\ncategories: \n  - [日常]\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n![第六感海报](https://img9.doubanio.com/view/photo/l/public/p2220184425.webp)\n今天重温了电影《第六感》，一部披着灵异外皮的心灵治愈电影。\n\n有些电影无论第几遍看还是让人感动\n![第六感剧照](https://img2.doubanio.com/view/photo/l/public/p2351243392.webp)\n![第六感剧照](https://img1.doubanio.com/view/photo/l/public/p2356175109.webp)\n","slug":"浮生一日-最爱的电影","published":1,"updated":"2021-11-18T09:00:36.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5g000v7oo90czsc7bl","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p><img src=\"https://img9.doubanio.com/view/photo/l/public/p2220184425.webp\" alt=\"第六感海报\"><br>今天重温了电影《第六感》，一部披着灵异外皮的心灵治愈电影。</p>\n<p>有些电影无论第几遍看还是让人感动<br><img src=\"https://img2.doubanio.com/view/photo/l/public/p2351243392.webp\" alt=\"第六感剧照\"><br><img src=\"https://img1.doubanio.com/view/photo/l/public/p2356175109.webp\" alt=\"第六感剧照\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p><img src=\"https://img9.doubanio.com/view/photo/l/public/p2220184425.webp\" alt=\"第六感海报\"><br>今天重温了电影《第六感》，一部披着灵异外皮的心灵治愈电影。</p>\n<p>有些电影无论第几遍看还是让人感动<br><img src=\"https://img2.doubanio.com/view/photo/l/public/p2351243392.webp\" alt=\"第六感剧照\"><br><img src=\"https://img1.doubanio.com/view/photo/l/public/p2356175109.webp\" alt=\"第六感剧照\"></p>\n"},{"title":"leetcode每日算法（2021-09-27）","date":"2021-09-27T03:06:43.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 1.两数之和\n![两数之和](https://upload-images.jianshu.io/upload_images/13931286-470a4c38230853eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 解题\n我首先想到的是暴力解法，就是对数组嵌套循环（时间复杂度是 O(n²)）：\n![我首先想到的方法](https://upload-images.jianshu.io/upload_images/13931286-efa42480453cddb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n肯定有更好的办法\n看到评论区有人说用逆向解法，用target减去数组中的一个数，然后判断得到的结果是否在数组中\n```js\nvar twoSum = function(nums, target) {\n    map = new Map()\n    for(let i = 0; i < nums.length; i++) {\n        x = target - nums[i]\n        if(map.has(x)) {\n            return [map.get(x),i]\n        }\n        map.set(nums[i],i)\n    }\n};\n```\n```js\nvar twoSum = function (nums, target) {\n  let hash = {};\n  for (let i = 0; i < nums.length; i++) {\n    if (hash[target - nums[i]] !== undefined) {\n      return [i, hash[target - nums[i]]];\n    }\n    hash[nums[i]] = i;\n  }\n  return [];\n};\n```\n\n\n","source":"_posts/2021-09-27-leetcode每日算法（2021-09-27）.md","raw":"---\ntitle: leetcode每日算法（2021-09-27）\ndate: 2021-09-27 11:06:43\ntags: [算法,leetcode]\ncategories: 算法类\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 1.两数之和\n![两数之和](https://upload-images.jianshu.io/upload_images/13931286-470a4c38230853eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 解题\n我首先想到的是暴力解法，就是对数组嵌套循环（时间复杂度是 O(n²)）：\n![我首先想到的方法](https://upload-images.jianshu.io/upload_images/13931286-efa42480453cddb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n肯定有更好的办法\n看到评论区有人说用逆向解法，用target减去数组中的一个数，然后判断得到的结果是否在数组中\n```js\nvar twoSum = function(nums, target) {\n    map = new Map()\n    for(let i = 0; i < nums.length; i++) {\n        x = target - nums[i]\n        if(map.has(x)) {\n            return [map.get(x),i]\n        }\n        map.set(nums[i],i)\n    }\n};\n```\n```js\nvar twoSum = function (nums, target) {\n  let hash = {};\n  for (let i = 0; i < nums.length; i++) {\n    if (hash[target - nums[i]] !== undefined) {\n      return [i, hash[target - nums[i]]];\n    }\n    hash[nums[i]] = i;\n  }\n  return [];\n};\n```\n\n\n","slug":"leetcode每日算法（2021-09-27）","published":1,"updated":"2021-09-28T02:24:12.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5h000z7oo94ndvgwtc","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1.两数之和\"></a>1.两数之和</h1><p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-470a4c38230853eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"两数之和\"></p>\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><p>我首先想到的是暴力解法，就是对数组嵌套循环（时间复杂度是 O(n²)）：<br><img src=\"https://upload-images.jianshu.io/upload_images/13931286-efa42480453cddb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"我首先想到的方法\"><br>肯定有更好的办法<br>看到评论区有人说用逆向解法，用target减去数组中的一个数，然后判断得到的结果是否在数组中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> twoSum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums, target</span>) </span>&#123;<br>    map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.length; i++) &#123;<br>        x = target - nums[i]<br>        <span class=\"hljs-keyword\">if</span>(map.has(x)) &#123;<br>            <span class=\"hljs-keyword\">return</span> [map.get(x),i]<br>        &#125;<br>        map.set(nums[i],i)<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> twoSum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums, target</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> hash = &#123;&#125;;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class=\"hljs-keyword\">if</span> (hash[target - nums[i]] !== <span class=\"hljs-literal\">undefined</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> [i, hash[target - nums[i]]];<br>    &#125;<br>    hash[nums[i]] = i;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> [];<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1.两数之和\"></a>1.两数之和</h1><p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-470a4c38230853eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"两数之和\"></p>\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><p>我首先想到的是暴力解法，就是对数组嵌套循环（时间复杂度是 O(n²)）：<br><img src=\"https://upload-images.jianshu.io/upload_images/13931286-efa42480453cddb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"我首先想到的方法\"><br>肯定有更好的办法<br>看到评论区有人说用逆向解法，用target减去数组中的一个数，然后判断得到的结果是否在数组中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> twoSum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">nums, target</span>) </span>&#123;<br>    map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.length; i++) &#123;<br>        x = target - nums[i]<br>        <span class=\"hljs-keyword\">if</span>(map.has(x)) &#123;<br>            <span class=\"hljs-keyword\">return</span> [map.get(x),i]<br>        &#125;<br>        map.set(nums[i],i)<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> twoSum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums, target</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> hash = &#123;&#125;;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class=\"hljs-keyword\">if</span> (hash[target - nums[i]] !== <span class=\"hljs-literal\">undefined</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> [i, hash[target - nums[i]]];<br>    &#125;<br>    hash[nums[i]] = i;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> [];<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n\n"},{"title":"互联网是如何运作的","date":"2021-10-07T03:04:56.000Z","_content":"原文：[互联网是如何运作的](https://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm)\n\n以下是我的总结,更好的学习建议阅读原文。\n# 介绍\n\n互联网所有的传输都通过TCP/IP协议族来传输，TCP/IP是**面向连接**的**可靠**字节流服务协议\n\n# TCP/IP协议栈\n您的计算机已连接到 Internet 并具有唯一的地址。它如何与连接到 Internet 的其他计算机“交谈”？\n\n这里应该有一个例子：假设您的 IP 地址是 1.2.3.4，并且您想向计算机 5.6.7.8 发送一条消息。您要发送的消息是“Hello computer 5.6.7.8!”。显然，消息必须通过将您的计算机连接到 Internet 的任何类型的线路传输。假设您已从家里拨入您的 ISP，并且消息必须通过电话线传输。必须将消息从字母文本翻译成电子信号，通过互联网传输，然后再翻译回字母文本。 这是如何实现的？\n**通过使用协议栈**。每台计算机都需要一台在 Internet 上进行通信，它通常内置于计算机的操作系统（即 Windows、Unix 等）中。由于使用了两种主要的通信协议，Internet 上使用的协议栈被称为 **TCP/IP 协议栈**。TCP/IP 堆栈如下所示：\n- 应用层：提供特定于应用程序的协议  HTTP   FTP   IMAP(邮件)\n- 网络控制层(TCP)：发送数据包到计算机上使用特定的端口号的应用程序\n- 网络层(IP)：使用IP地址将数据包发送到特定的计算\n- 链路层：将二进制数据包与网络信号相互之间转换（例如以太网网卡、电话线调制解调器等）\n\n# HTTP\nHTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中 TCP 层的顶部，并被特定应用程序用于相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。\n\nHTTP是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送对 Web 元素（例如网页和图像）的请求。请求被服务器服务后，客户端和服务器之间通过 Internet 的连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端发出 HTTP 请求之前，必须建立到服务器的新连接。\n\n当您在 Web 浏览器中键入 URL 时，会发生以下情况：\n\n1. 如果 URL 包含域名，则浏览器首先连接到域名服务器并为 Web 服务器检索相应的 IP 地址。\n2. Web 浏览器连接到 Web 服务器并为所需的网页发送 HTTP 请求（通过协议栈）。\n3. Web 服务器接收请求并检查所需页面。如果页面存在，则 Web 服务器发送它。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。（404 的意思是“找不到页面”，任何浏览过网络的人都可能知道。）\n4. Web 浏览器接收回页面并关闭连接。\n4. 然后浏览器解析页面并查找完成网页所需的其他页面元素。这些通常包括图像、小程序等。\n6. 对于每个需要的元素，浏览器会为每个元素向服务器发出额外的连接和 HTTP 请求。\n7. 当浏览器加载完所有图像、小程序等后，页面将完全加载到浏览器窗口中。\n\n# TCP（传输控制协议）\n在协议栈的应用层之下是TCP层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）会沿堆栈向下传递到 TCP 层。**TCP 负责将应用程序协议路由到目标计算机上的正确应用程序。** 为此，使用端口号。端口可以​​被认为是每台计算机上的独立通道。例如，您可以在阅读电子邮件时上网。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上时，TCP 层根据端口号决定哪个应用程序接收数据包。\nTCP 是这样工作的：\n\n- 当 TCP 层从上面接收到应用层协议数据时，它会将其分段为可管理的“块”，然后将带有特定 TCP 信息的 TCP 标头添加到每个“块”。TCP 头中包含的信息包括数据需要发送到的应用程序的端口号。\n- 当 TCP 层接收到来自其下方 IP 层的数据包时，TCP 层会从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。\n\n这就是 TCP 将通过协议栈移动的数据路由到正确应用程序的方式。\n\nTCP 不是文本协议。**TCP 是面向连接的、可靠的字节流服务。**面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于收到的每个数据包，都会向发送方发送确认以确认交付。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。\ntcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功\n\n# IP（互联网协议）\n与 TCP 不同，**IP 是一种不可靠的无连接协议。**IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 IP 的工作也是将数据包发送和路由到其他计算机。IP 数据包是独立的实体，可能无序到达或根本没有到达。TCP 的工作是确保数据包到达并以正确的顺序。IP 与 TCP 的唯一共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据。\n\nIP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP\n\nIp是一种协议  有两种标准  IPv4 2^32次方和IPv6  2^128\n\n# TCP传输的质量和顺序\n\n当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送\n\n#网络传输\n\n1. 个人电脑\n2. 猫（调制解调器）\n3. local ISP   互联网服务提供商\n4. regional ISP   经过多个主干网络\n5. NSP   网络服务提供商  大型网络  卖带宽给ISP\n6. NAP   每个NSP连接到至少三个网络访问点\n7. ISP  NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。\n\n# DNS服务\n\n存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系","source":"_posts/2021-10-08-互联网是如何运作的.md","raw":"---\ntitle: 互联网是如何运作的\ndate: 2021-10-07 11:04:56\ntags: [计算机基础]\ncategories: 计算机基础\n---\n原文：[互联网是如何运作的](https://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm)\n\n以下是我的总结,更好的学习建议阅读原文。\n# 介绍\n\n互联网所有的传输都通过TCP/IP协议族来传输，TCP/IP是**面向连接**的**可靠**字节流服务协议\n\n# TCP/IP协议栈\n您的计算机已连接到 Internet 并具有唯一的地址。它如何与连接到 Internet 的其他计算机“交谈”？\n\n这里应该有一个例子：假设您的 IP 地址是 1.2.3.4，并且您想向计算机 5.6.7.8 发送一条消息。您要发送的消息是“Hello computer 5.6.7.8!”。显然，消息必须通过将您的计算机连接到 Internet 的任何类型的线路传输。假设您已从家里拨入您的 ISP，并且消息必须通过电话线传输。必须将消息从字母文本翻译成电子信号，通过互联网传输，然后再翻译回字母文本。 这是如何实现的？\n**通过使用协议栈**。每台计算机都需要一台在 Internet 上进行通信，它通常内置于计算机的操作系统（即 Windows、Unix 等）中。由于使用了两种主要的通信协议，Internet 上使用的协议栈被称为 **TCP/IP 协议栈**。TCP/IP 堆栈如下所示：\n- 应用层：提供特定于应用程序的协议  HTTP   FTP   IMAP(邮件)\n- 网络控制层(TCP)：发送数据包到计算机上使用特定的端口号的应用程序\n- 网络层(IP)：使用IP地址将数据包发送到特定的计算\n- 链路层：将二进制数据包与网络信号相互之间转换（例如以太网网卡、电话线调制解调器等）\n\n# HTTP\nHTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中 TCP 层的顶部，并被特定应用程序用于相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。\n\nHTTP是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送对 Web 元素（例如网页和图像）的请求。请求被服务器服务后，客户端和服务器之间通过 Internet 的连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端发出 HTTP 请求之前，必须建立到服务器的新连接。\n\n当您在 Web 浏览器中键入 URL 时，会发生以下情况：\n\n1. 如果 URL 包含域名，则浏览器首先连接到域名服务器并为 Web 服务器检索相应的 IP 地址。\n2. Web 浏览器连接到 Web 服务器并为所需的网页发送 HTTP 请求（通过协议栈）。\n3. Web 服务器接收请求并检查所需页面。如果页面存在，则 Web 服务器发送它。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。（404 的意思是“找不到页面”，任何浏览过网络的人都可能知道。）\n4. Web 浏览器接收回页面并关闭连接。\n4. 然后浏览器解析页面并查找完成网页所需的其他页面元素。这些通常包括图像、小程序等。\n6. 对于每个需要的元素，浏览器会为每个元素向服务器发出额外的连接和 HTTP 请求。\n7. 当浏览器加载完所有图像、小程序等后，页面将完全加载到浏览器窗口中。\n\n# TCP（传输控制协议）\n在协议栈的应用层之下是TCP层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）会沿堆栈向下传递到 TCP 层。**TCP 负责将应用程序协议路由到目标计算机上的正确应用程序。** 为此，使用端口号。端口可以​​被认为是每台计算机上的独立通道。例如，您可以在阅读电子邮件时上网。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上时，TCP 层根据端口号决定哪个应用程序接收数据包。\nTCP 是这样工作的：\n\n- 当 TCP 层从上面接收到应用层协议数据时，它会将其分段为可管理的“块”，然后将带有特定 TCP 信息的 TCP 标头添加到每个“块”。TCP 头中包含的信息包括数据需要发送到的应用程序的端口号。\n- 当 TCP 层接收到来自其下方 IP 层的数据包时，TCP 层会从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。\n\n这就是 TCP 将通过协议栈移动的数据路由到正确应用程序的方式。\n\nTCP 不是文本协议。**TCP 是面向连接的、可靠的字节流服务。**面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于收到的每个数据包，都会向发送方发送确认以确认交付。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。\ntcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功\n\n# IP（互联网协议）\n与 TCP 不同，**IP 是一种不可靠的无连接协议。**IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 IP 的工作也是将数据包发送和路由到其他计算机。IP 数据包是独立的实体，可能无序到达或根本没有到达。TCP 的工作是确保数据包到达并以正确的顺序。IP 与 TCP 的唯一共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据。\n\nIP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP\n\nIp是一种协议  有两种标准  IPv4 2^32次方和IPv6  2^128\n\n# TCP传输的质量和顺序\n\n当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送\n\n#网络传输\n\n1. 个人电脑\n2. 猫（调制解调器）\n3. local ISP   互联网服务提供商\n4. regional ISP   经过多个主干网络\n5. NSP   网络服务提供商  大型网络  卖带宽给ISP\n6. NAP   每个NSP连接到至少三个网络访问点\n7. ISP  NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。\n\n# DNS服务\n\n存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系","slug":"互联网是如何运作的","published":1,"updated":"2021-10-13T08:46:52.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5i00127oo95herfmr0","content":"<p>原文：<a href=\"https://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm\">互联网是如何运作的</a></p>\n<p>以下是我的总结,更好的学习建议阅读原文。</p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>互联网所有的传输都通过TCP/IP协议族来传输，TCP/IP是<strong>面向连接</strong>的<strong>可靠</strong>字节流服务协议</p>\n<h1 id=\"TCP-IP协议栈\"><a href=\"#TCP-IP协议栈\" class=\"headerlink\" title=\"TCP/IP协议栈\"></a>TCP/IP协议栈</h1><p>您的计算机已连接到 Internet 并具有唯一的地址。它如何与连接到 Internet 的其他计算机“交谈”？</p>\n<p>这里应该有一个例子：假设您的 IP 地址是 1.2.3.4，并且您想向计算机 5.6.7.8 发送一条消息。您要发送的消息是“Hello computer 5.6.7.8!”。显然，消息必须通过将您的计算机连接到 Internet 的任何类型的线路传输。假设您已从家里拨入您的 ISP，并且消息必须通过电话线传输。必须将消息从字母文本翻译成电子信号，通过互联网传输，然后再翻译回字母文本。 这是如何实现的？<br><strong>通过使用协议栈</strong>。每台计算机都需要一台在 Internet 上进行通信，它通常内置于计算机的操作系统（即 Windows、Unix 等）中。由于使用了两种主要的通信协议，Internet 上使用的协议栈被称为 <strong>TCP/IP 协议栈</strong>。TCP/IP 堆栈如下所示：</p>\n<ul>\n<li>应用层：提供特定于应用程序的协议  HTTP   FTP   IMAP(邮件)</li>\n<li>网络控制层(TCP)：发送数据包到计算机上使用特定的端口号的应用程序</li>\n<li>网络层(IP)：使用IP地址将数据包发送到特定的计算</li>\n<li>链路层：将二进制数据包与网络信号相互之间转换（例如以太网网卡、电话线调制解调器等）</li>\n</ul>\n<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><p>HTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中 TCP 层的顶部，并被特定应用程序用于相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。</p>\n<p>HTTP是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送对 Web 元素（例如网页和图像）的请求。请求被服务器服务后，客户端和服务器之间通过 Internet 的连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端发出 HTTP 请求之前，必须建立到服务器的新连接。</p>\n<p>当您在 Web 浏览器中键入 URL 时，会发生以下情况：</p>\n<ol>\n<li>如果 URL 包含域名，则浏览器首先连接到域名服务器并为 Web 服务器检索相应的 IP 地址。</li>\n<li>Web 浏览器连接到 Web 服务器并为所需的网页发送 HTTP 请求（通过协议栈）。</li>\n<li>Web 服务器接收请求并检查所需页面。如果页面存在，则 Web 服务器发送它。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。（404 的意思是“找不到页面”，任何浏览过网络的人都可能知道。）</li>\n<li>Web 浏览器接收回页面并关闭连接。</li>\n<li>然后浏览器解析页面并查找完成网页所需的其他页面元素。这些通常包括图像、小程序等。</li>\n<li>对于每个需要的元素，浏览器会为每个元素向服务器发出额外的连接和 HTTP 请求。</li>\n<li>当浏览器加载完所有图像、小程序等后，页面将完全加载到浏览器窗口中。</li>\n</ol>\n<h1 id=\"TCP（传输控制协议）\"><a href=\"#TCP（传输控制协议）\" class=\"headerlink\" title=\"TCP（传输控制协议）\"></a>TCP（传输控制协议）</h1><p>在协议栈的应用层之下是TCP层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）会沿堆栈向下传递到 TCP 层。<strong>TCP 负责将应用程序协议路由到目标计算机上的正确应用程序。</strong> 为此，使用端口号。端口可以​​被认为是每台计算机上的独立通道。例如，您可以在阅读电子邮件时上网。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上时，TCP 层根据端口号决定哪个应用程序接收数据包。<br>TCP 是这样工作的：</p>\n<ul>\n<li>当 TCP 层从上面接收到应用层协议数据时，它会将其分段为可管理的“块”，然后将带有特定 TCP 信息的 TCP 标头添加到每个“块”。TCP 头中包含的信息包括数据需要发送到的应用程序的端口号。</li>\n<li>当 TCP 层接收到来自其下方 IP 层的数据包时，TCP 层会从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。</li>\n</ul>\n<p>这就是 TCP 将通过协议栈移动的数据路由到正确应用程序的方式。</p>\n<p>TCP 不是文本协议。<strong>TCP 是面向连接的、可靠的字节流服务。</strong>面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于收到的每个数据包，都会向发送方发送确认以确认交付。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。<br>tcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功</p>\n<h1 id=\"IP（互联网协议）\"><a href=\"#IP（互联网协议）\" class=\"headerlink\" title=\"IP（互联网协议）\"></a>IP（互联网协议）</h1><p>与 TCP 不同，<strong>IP 是一种不可靠的无连接协议。</strong>IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 IP 的工作也是将数据包发送和路由到其他计算机。IP 数据包是独立的实体，可能无序到达或根本没有到达。TCP 的工作是确保数据包到达并以正确的顺序。IP 与 TCP 的唯一共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据。</p>\n<p>IP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP</p>\n<p>Ip是一种协议  有两种标准  IPv4 2^32次方和IPv6  2^128</p>\n<h1 id=\"TCP传输的质量和顺序\"><a href=\"#TCP传输的质量和顺序\" class=\"headerlink\" title=\"TCP传输的质量和顺序\"></a>TCP传输的质量和顺序</h1><p>当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送</p>\n<p>#网络传输</p>\n<ol>\n<li>个人电脑</li>\n<li>猫（调制解调器）</li>\n<li>local ISP   互联网服务提供商</li>\n<li>regional ISP   经过多个主干网络</li>\n<li>NSP   网络服务提供商  大型网络  卖带宽给ISP</li>\n<li>NAP   每个NSP连接到至少三个网络访问点</li>\n<li>ISP  NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。</li>\n</ol>\n<h1 id=\"DNS服务\"><a href=\"#DNS服务\" class=\"headerlink\" title=\"DNS服务\"></a>DNS服务</h1><p>存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系</p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文：<a href=\"https://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm\">互联网是如何运作的</a></p>\n<p>以下是我的总结,更好的学习建议阅读原文。</p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>互联网所有的传输都通过TCP/IP协议族来传输，TCP/IP是<strong>面向连接</strong>的<strong>可靠</strong>字节流服务协议</p>\n<h1 id=\"TCP-IP协议栈\"><a href=\"#TCP-IP协议栈\" class=\"headerlink\" title=\"TCP/IP协议栈\"></a>TCP/IP协议栈</h1><p>您的计算机已连接到 Internet 并具有唯一的地址。它如何与连接到 Internet 的其他计算机“交谈”？</p>\n<p>这里应该有一个例子：假设您的 IP 地址是 1.2.3.4，并且您想向计算机 5.6.7.8 发送一条消息。您要发送的消息是“Hello computer 5.6.7.8!”。显然，消息必须通过将您的计算机连接到 Internet 的任何类型的线路传输。假设您已从家里拨入您的 ISP，并且消息必须通过电话线传输。必须将消息从字母文本翻译成电子信号，通过互联网传输，然后再翻译回字母文本。 这是如何实现的？<br><strong>通过使用协议栈</strong>。每台计算机都需要一台在 Internet 上进行通信，它通常内置于计算机的操作系统（即 Windows、Unix 等）中。由于使用了两种主要的通信协议，Internet 上使用的协议栈被称为 <strong>TCP/IP 协议栈</strong>。TCP/IP 堆栈如下所示：</p>\n<ul>\n<li>应用层：提供特定于应用程序的协议  HTTP   FTP   IMAP(邮件)</li>\n<li>网络控制层(TCP)：发送数据包到计算机上使用特定的端口号的应用程序</li>\n<li>网络层(IP)：使用IP地址将数据包发送到特定的计算</li>\n<li>链路层：将二进制数据包与网络信号相互之间转换（例如以太网网卡、电话线调制解调器等）</li>\n</ul>\n<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><p>HTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中 TCP 层的顶部，并被特定应用程序用于相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。</p>\n<p>HTTP是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送对 Web 元素（例如网页和图像）的请求。请求被服务器服务后，客户端和服务器之间通过 Internet 的连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端发出 HTTP 请求之前，必须建立到服务器的新连接。</p>\n<p>当您在 Web 浏览器中键入 URL 时，会发生以下情况：</p>\n<ol>\n<li>如果 URL 包含域名，则浏览器首先连接到域名服务器并为 Web 服务器检索相应的 IP 地址。</li>\n<li>Web 浏览器连接到 Web 服务器并为所需的网页发送 HTTP 请求（通过协议栈）。</li>\n<li>Web 服务器接收请求并检查所需页面。如果页面存在，则 Web 服务器发送它。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。（404 的意思是“找不到页面”，任何浏览过网络的人都可能知道。）</li>\n<li>Web 浏览器接收回页面并关闭连接。</li>\n<li>然后浏览器解析页面并查找完成网页所需的其他页面元素。这些通常包括图像、小程序等。</li>\n<li>对于每个需要的元素，浏览器会为每个元素向服务器发出额外的连接和 HTTP 请求。</li>\n<li>当浏览器加载完所有图像、小程序等后，页面将完全加载到浏览器窗口中。</li>\n</ol>\n<h1 id=\"TCP（传输控制协议）\"><a href=\"#TCP（传输控制协议）\" class=\"headerlink\" title=\"TCP（传输控制协议）\"></a>TCP（传输控制协议）</h1><p>在协议栈的应用层之下是TCP层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）会沿堆栈向下传递到 TCP 层。<strong>TCP 负责将应用程序协议路由到目标计算机上的正确应用程序。</strong> 为此，使用端口号。端口可以​​被认为是每台计算机上的独立通道。例如，您可以在阅读电子邮件时上网。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上时，TCP 层根据端口号决定哪个应用程序接收数据包。<br>TCP 是这样工作的：</p>\n<ul>\n<li>当 TCP 层从上面接收到应用层协议数据时，它会将其分段为可管理的“块”，然后将带有特定 TCP 信息的 TCP 标头添加到每个“块”。TCP 头中包含的信息包括数据需要发送到的应用程序的端口号。</li>\n<li>当 TCP 层接收到来自其下方 IP 层的数据包时，TCP 层会从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。</li>\n</ul>\n<p>这就是 TCP 将通过协议栈移动的数据路由到正确应用程序的方式。</p>\n<p>TCP 不是文本协议。<strong>TCP 是面向连接的、可靠的字节流服务。</strong>面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于收到的每个数据包，都会向发送方发送确认以确认交付。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。<br>tcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功</p>\n<h1 id=\"IP（互联网协议）\"><a href=\"#IP（互联网协议）\" class=\"headerlink\" title=\"IP（互联网协议）\"></a>IP（互联网协议）</h1><p>与 TCP 不同，<strong>IP 是一种不可靠的无连接协议。</strong>IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 IP 的工作也是将数据包发送和路由到其他计算机。IP 数据包是独立的实体，可能无序到达或根本没有到达。TCP 的工作是确保数据包到达并以正确的顺序。IP 与 TCP 的唯一共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据。</p>\n<p>IP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP</p>\n<p>Ip是一种协议  有两种标准  IPv4 2^32次方和IPv6  2^128</p>\n<h1 id=\"TCP传输的质量和顺序\"><a href=\"#TCP传输的质量和顺序\" class=\"headerlink\" title=\"TCP传输的质量和顺序\"></a>TCP传输的质量和顺序</h1><p>当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送</p>\n<p>#网络传输</p>\n<ol>\n<li>个人电脑</li>\n<li>猫（调制解调器）</li>\n<li>local ISP   互联网服务提供商</li>\n<li>regional ISP   经过多个主干网络</li>\n<li>NSP   网络服务提供商  大型网络  卖带宽给ISP</li>\n<li>NAP   每个NSP连接到至少三个网络访问点</li>\n<li>ISP  NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。</li>\n</ol>\n<h1 id=\"DNS服务\"><a href=\"#DNS服务\" class=\"headerlink\" title=\"DNS服务\"></a>DNS服务</h1><p>存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系</p>\n"},{"title":"深入理解javascript之typeof和instanceof","date":"2021-10-13T08:41:28.000Z","_content":"\n# typeof\n\ntypeof方法**返回一个字符串**，来表示**数据的类型**。\n\n各个数据类型对应typeof的值：\n\n| **数据类型**                       | **Type**                 |\n| ---------------------------------- | ------------------------ |\n| Undefined                          | “undefined”              |\n| Null                               | \"object\"                 |\n| Boolean                            | “boolean”                |\n| Number                             | \"number\"                 |\n| String                             | \"string\"                 |\n| Symbol                             | \"symbol\"                 |\n| 宿主对象(JS环境提供的，比如浏览器) | Implementation-dependent |\n| 函数对象Function                   | \"function\"               |\n| 任何其他对象Object                 | \"object\"                 |\n\n下面是代码示例：\n\n```js\n// Numbers\ntypeof 37 === 'number';\ntypeof 3.14 === 'number';\ntypeof Math.LN2 === 'number';\ntypeof Infinity === 'number';\ntypeof NaN === 'number'; // 尽管NaN是\"Not-A-Number\"的缩写,意思是\"不是一个数字\"\ntypeof Number(1) === 'number'; // 不要这样使用!\n\n// Strings\ntypeof \"\" === 'string';\ntypeof \"bla\" === 'string';\ntypeof (typeof 1) === 'string'; // typeof返回的肯定是一个字符串\ntypeof String(\"abc\") === 'string'; // 不要这样使用!\n\n// Booleans\ntypeof true === 'boolean';\ntypeof false === 'boolean';\ntypeof Boolean(true) === 'boolean'; // 不要这样使用!\n\n// Symbols\ntypeof Symbol() === 'symbol';\ntypeof Symbol('foo') === 'symbol';\ntypeof Symbol.iterator === 'symbol';\n\n// Undefined\ntypeof undefined === 'undefined';\ntypeof blabla === 'undefined'; // 一个未定义的变量,或者一个定义了却未赋初值的变量\n\n// Objects\ntypeof {a:1} === 'object';\n\n// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型\ntypeof [1, 2, 4] === 'object';\n\ntypeof new Date() === 'object';\n\n// 下面的容易令人迷惑，不要这样使用！\ntypeof new Boolean(true) === 'object';\ntypeof new Number(1) ==== 'object';\ntypeof new String(\"abc\") === 'object';\n\n// 函数\ntypeof function(){} === 'function';\ntypeof Math.sin === 'function';\n```\n\n发现typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象hj的typeof返回值都是object\n\n# instanceof\n\ninstanceof运算符可以用来判断某个构造函数的prototype属性**是否存在于另外一个**要检测对象**的原型链上**。\n\n```js\n// 定义构造函数\nfunction C(){} \nfunction D(){} \n\nvar o = new C();\n\n// true，因为 Object.getPrototypeOf(o) === C.prototype\no instanceof C; \n\n// false，因为 D.prototype不在o的原型链上\no instanceof D; \n\no instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回true\nC.prototype instanceof Object // true,同上\n\nC.prototype = {};\nvar o2 = new C();\n\no2 instanceof C; // true\n\no instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.\n\nD.prototype = new C(); // 继承\nvar o3 = new D();\no3 instanceof D; // true\no3 instanceof C; // true\n```\n\n\n","source":"_posts/2021-10-13-深入理解javascript之typeof和instanceof.md","raw":"---\ntitle: 深入理解javascript之typeof和instanceof\ndate: 2021-10-13 16:41:28\ntags: [JavaScript,面试]\ncategories: 技术类-前端\n---\n\n# typeof\n\ntypeof方法**返回一个字符串**，来表示**数据的类型**。\n\n各个数据类型对应typeof的值：\n\n| **数据类型**                       | **Type**                 |\n| ---------------------------------- | ------------------------ |\n| Undefined                          | “undefined”              |\n| Null                               | \"object\"                 |\n| Boolean                            | “boolean”                |\n| Number                             | \"number\"                 |\n| String                             | \"string\"                 |\n| Symbol                             | \"symbol\"                 |\n| 宿主对象(JS环境提供的，比如浏览器) | Implementation-dependent |\n| 函数对象Function                   | \"function\"               |\n| 任何其他对象Object                 | \"object\"                 |\n\n下面是代码示例：\n\n```js\n// Numbers\ntypeof 37 === 'number';\ntypeof 3.14 === 'number';\ntypeof Math.LN2 === 'number';\ntypeof Infinity === 'number';\ntypeof NaN === 'number'; // 尽管NaN是\"Not-A-Number\"的缩写,意思是\"不是一个数字\"\ntypeof Number(1) === 'number'; // 不要这样使用!\n\n// Strings\ntypeof \"\" === 'string';\ntypeof \"bla\" === 'string';\ntypeof (typeof 1) === 'string'; // typeof返回的肯定是一个字符串\ntypeof String(\"abc\") === 'string'; // 不要这样使用!\n\n// Booleans\ntypeof true === 'boolean';\ntypeof false === 'boolean';\ntypeof Boolean(true) === 'boolean'; // 不要这样使用!\n\n// Symbols\ntypeof Symbol() === 'symbol';\ntypeof Symbol('foo') === 'symbol';\ntypeof Symbol.iterator === 'symbol';\n\n// Undefined\ntypeof undefined === 'undefined';\ntypeof blabla === 'undefined'; // 一个未定义的变量,或者一个定义了却未赋初值的变量\n\n// Objects\ntypeof {a:1} === 'object';\n\n// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型\ntypeof [1, 2, 4] === 'object';\n\ntypeof new Date() === 'object';\n\n// 下面的容易令人迷惑，不要这样使用！\ntypeof new Boolean(true) === 'object';\ntypeof new Number(1) ==== 'object';\ntypeof new String(\"abc\") === 'object';\n\n// 函数\ntypeof function(){} === 'function';\ntypeof Math.sin === 'function';\n```\n\n发现typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象hj的typeof返回值都是object\n\n# instanceof\n\ninstanceof运算符可以用来判断某个构造函数的prototype属性**是否存在于另外一个**要检测对象**的原型链上**。\n\n```js\n// 定义构造函数\nfunction C(){} \nfunction D(){} \n\nvar o = new C();\n\n// true，因为 Object.getPrototypeOf(o) === C.prototype\no instanceof C; \n\n// false，因为 D.prototype不在o的原型链上\no instanceof D; \n\no instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回true\nC.prototype instanceof Object // true,同上\n\nC.prototype = {};\nvar o2 = new C();\n\no2 instanceof C; // true\n\no instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.\n\nD.prototype = new C(); // 继承\nvar o3 = new D();\no3 instanceof D; // true\no3 instanceof C; // true\n```\n\n\n","slug":"深入理解javascript之typeof和instanceof","published":1,"updated":"2021-10-13T08:43:13.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5k00167oo9a0ka4xyu","content":"<h1 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h1><p>typeof方法<strong>返回一个字符串</strong>，来表示<strong>数据的类型</strong>。</p>\n<p>各个数据类型对应typeof的值：</p>\n<table>\n<thead>\n<tr>\n<th><strong>数据类型</strong></th>\n<th><strong>Type</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Undefined</td>\n<td>“undefined”</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>“object”</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>“boolean”</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>“number”</td>\n</tr>\n<tr>\n<td>String</td>\n<td>“string”</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>“symbol”</td>\n</tr>\n<tr>\n<td>宿主对象(JS环境提供的，比如浏览器)</td>\n<td>Implementation-dependent</td>\n</tr>\n<tr>\n<td>函数对象Function</td>\n<td>“function”</td>\n</tr>\n<tr>\n<td>任何其他对象Object</td>\n<td>“object”</td>\n</tr>\n</tbody></table>\n<p>下面是代码示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Numbers</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">37</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">3.14</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Math</span>.LN2 === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">Infinity</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">NaN</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>; <span class=\"hljs-comment\">// 尽管NaN是&quot;Not-A-Number&quot;的缩写,意思是&quot;不是一个数字&quot;</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-number\">1</span>) === <span class=\"hljs-string\">&#x27;number&#x27;</span>; <span class=\"hljs-comment\">// 不要这样使用!</span><br><br><span class=\"hljs-comment\">// Strings</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-string\">&quot;&quot;</span> === <span class=\"hljs-string\">&#x27;string&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-string\">&quot;bla&quot;</span> === <span class=\"hljs-string\">&#x27;string&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">1</span>) === <span class=\"hljs-string\">&#x27;string&#x27;</span>; <span class=\"hljs-comment\">// typeof返回的肯定是一个字符串</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>) === <span class=\"hljs-string\">&#x27;string&#x27;</span>; <span class=\"hljs-comment\">// 不要这样使用!</span><br><br><span class=\"hljs-comment\">// Booleans</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">true</span> === <span class=\"hljs-string\">&#x27;boolean&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">false</span> === <span class=\"hljs-string\">&#x27;boolean&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Boolean</span>(<span class=\"hljs-literal\">true</span>) === <span class=\"hljs-string\">&#x27;boolean&#x27;</span>; <span class=\"hljs-comment\">// 不要这样使用!</span><br><br><span class=\"hljs-comment\">// Symbols</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span>() === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>) === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span>.iterator === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>;<br><br><span class=\"hljs-comment\">// Undefined</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">undefined</span> === <span class=\"hljs-string\">&#x27;undefined&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> blabla === <span class=\"hljs-string\">&#x27;undefined&#x27;</span>; <span class=\"hljs-comment\">// 一个未定义的变量,或者一个定义了却未赋初值的变量</span><br><br><span class=\"hljs-comment\">// Objects</span><br><span class=\"hljs-keyword\">typeof</span> &#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>&#125; === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-comment\">// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型</span><br><span class=\"hljs-keyword\">typeof</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>] === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>() === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-comment\">// 下面的容易令人迷惑，不要这样使用！</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Boolean</span>(<span class=\"hljs-literal\">true</span>) === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-number\">1</span>) ==== <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>) === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-comment\">// 函数</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125; === <span class=\"hljs-string\">&#x27;function&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Math</span>.sin === <span class=\"hljs-string\">&#x27;function&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>发现typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象hj的typeof返回值都是object</p>\n<h1 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h1><p>instanceof运算符可以用来判断某个构造函数的prototype属性<strong>是否存在于另外一个</strong>要检测对象<strong>的原型链上</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 定义构造函数</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">C</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125; <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">D</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125; <br><br><span class=\"hljs-keyword\">var</span> o = <span class=\"hljs-keyword\">new</span> C();<br><br><span class=\"hljs-comment\">// true，因为 Object.getPrototypeOf(o) === C.prototype</span><br>o <span class=\"hljs-keyword\">instanceof</span> C; <br><br><span class=\"hljs-comment\">// false，因为 D.prototype不在o的原型链上</span><br>o <span class=\"hljs-keyword\">instanceof</span> D; <br><br>o <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Object</span>; <span class=\"hljs-comment\">// true,因为Object.prototype.isPrototypeOf(o)返回true</span><br>C.prototype <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Object</span> <span class=\"hljs-comment\">// true,同上</span><br><br>C.prototype = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> o2 = <span class=\"hljs-keyword\">new</span> C();<br><br>o2 <span class=\"hljs-keyword\">instanceof</span> C; <span class=\"hljs-comment\">// true</span><br><br>o <span class=\"hljs-keyword\">instanceof</span> C; <span class=\"hljs-comment\">// false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.</span><br><br>D.prototype = <span class=\"hljs-keyword\">new</span> C(); <span class=\"hljs-comment\">// 继承</span><br><span class=\"hljs-keyword\">var</span> o3 = <span class=\"hljs-keyword\">new</span> D();<br>o3 <span class=\"hljs-keyword\">instanceof</span> D; <span class=\"hljs-comment\">// true</span><br>o3 <span class=\"hljs-keyword\">instanceof</span> C; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h1><p>typeof方法<strong>返回一个字符串</strong>，来表示<strong>数据的类型</strong>。</p>\n<p>各个数据类型对应typeof的值：</p>\n<table>\n<thead>\n<tr>\n<th><strong>数据类型</strong></th>\n<th><strong>Type</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Undefined</td>\n<td>“undefined”</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>“object”</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>“boolean”</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>“number”</td>\n</tr>\n<tr>\n<td>String</td>\n<td>“string”</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>“symbol”</td>\n</tr>\n<tr>\n<td>宿主对象(JS环境提供的，比如浏览器)</td>\n<td>Implementation-dependent</td>\n</tr>\n<tr>\n<td>函数对象Function</td>\n<td>“function”</td>\n</tr>\n<tr>\n<td>任何其他对象Object</td>\n<td>“object”</td>\n</tr>\n</tbody></table>\n<p>下面是代码示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Numbers</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">37</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">3.14</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Math</span>.LN2 === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">Infinity</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">NaN</span> === <span class=\"hljs-string\">&#x27;number&#x27;</span>; <span class=\"hljs-comment\">// 尽管NaN是&quot;Not-A-Number&quot;的缩写,意思是&quot;不是一个数字&quot;</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-number\">1</span>) === <span class=\"hljs-string\">&#x27;number&#x27;</span>; <span class=\"hljs-comment\">// 不要这样使用!</span><br><br><span class=\"hljs-comment\">// Strings</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-string\">&quot;&quot;</span> === <span class=\"hljs-string\">&#x27;string&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-string\">&quot;bla&quot;</span> === <span class=\"hljs-string\">&#x27;string&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">1</span>) === <span class=\"hljs-string\">&#x27;string&#x27;</span>; <span class=\"hljs-comment\">// typeof返回的肯定是一个字符串</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>) === <span class=\"hljs-string\">&#x27;string&#x27;</span>; <span class=\"hljs-comment\">// 不要这样使用!</span><br><br><span class=\"hljs-comment\">// Booleans</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">true</span> === <span class=\"hljs-string\">&#x27;boolean&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">false</span> === <span class=\"hljs-string\">&#x27;boolean&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Boolean</span>(<span class=\"hljs-literal\">true</span>) === <span class=\"hljs-string\">&#x27;boolean&#x27;</span>; <span class=\"hljs-comment\">// 不要这样使用!</span><br><br><span class=\"hljs-comment\">// Symbols</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span>() === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>) === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span>.iterator === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>;<br><br><span class=\"hljs-comment\">// Undefined</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">undefined</span> === <span class=\"hljs-string\">&#x27;undefined&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> blabla === <span class=\"hljs-string\">&#x27;undefined&#x27;</span>; <span class=\"hljs-comment\">// 一个未定义的变量,或者一个定义了却未赋初值的变量</span><br><br><span class=\"hljs-comment\">// Objects</span><br><span class=\"hljs-keyword\">typeof</span> &#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>&#125; === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-comment\">// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型</span><br><span class=\"hljs-keyword\">typeof</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>] === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>() === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-comment\">// 下面的容易令人迷惑，不要这样使用！</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Boolean</span>(<span class=\"hljs-literal\">true</span>) === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-number\">1</span>) ==== <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>) === <span class=\"hljs-string\">&#x27;object&#x27;</span>;<br><br><span class=\"hljs-comment\">// 函数</span><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125; === <span class=\"hljs-string\">&#x27;function&#x27;</span>;<br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Math</span>.sin === <span class=\"hljs-string\">&#x27;function&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>发现typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象hj的typeof返回值都是object</p>\n<h1 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h1><p>instanceof运算符可以用来判断某个构造函数的prototype属性<strong>是否存在于另外一个</strong>要检测对象<strong>的原型链上</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 定义构造函数</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">C</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125; <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">D</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125; <br><br><span class=\"hljs-keyword\">var</span> o = <span class=\"hljs-keyword\">new</span> C();<br><br><span class=\"hljs-comment\">// true，因为 Object.getPrototypeOf(o) === C.prototype</span><br>o <span class=\"hljs-keyword\">instanceof</span> C; <br><br><span class=\"hljs-comment\">// false，因为 D.prototype不在o的原型链上</span><br>o <span class=\"hljs-keyword\">instanceof</span> D; <br><br>o <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Object</span>; <span class=\"hljs-comment\">// true,因为Object.prototype.isPrototypeOf(o)返回true</span><br>C.prototype <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Object</span> <span class=\"hljs-comment\">// true,同上</span><br><br>C.prototype = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> o2 = <span class=\"hljs-keyword\">new</span> C();<br><br>o2 <span class=\"hljs-keyword\">instanceof</span> C; <span class=\"hljs-comment\">// true</span><br><br>o <span class=\"hljs-keyword\">instanceof</span> C; <span class=\"hljs-comment\">// false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.</span><br><br>D.prototype = <span class=\"hljs-keyword\">new</span> C(); <span class=\"hljs-comment\">// 继承</span><br><span class=\"hljs-keyword\">var</span> o3 = <span class=\"hljs-keyword\">new</span> D();<br>o3 <span class=\"hljs-keyword\">instanceof</span> D; <span class=\"hljs-comment\">// true</span><br>o3 <span class=\"hljs-keyword\">instanceof</span> C; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n"},{"title":"JavaScript事件循环","date":"2021-10-14T03:17:45.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n这一篇讲的也特别清楚，建议看看：[这一次，彻底弄懂 JavaScript 执行机制](https://juejin.cn/post/6844903512845860872)\n\n## 一、是什么\n\n`JavaScript` 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事\n\n为什么要这么设计，跟`JavaScript`的应用场景有关\n\n`JavaScript` 初期作为一门浏览器脚本语言，通常用于操作 `DOM` ，如果是多线程，一个线程进行了删除 `DOM` ，另一个添加 `DOM`，此时浏览器该如何处理？\n\n为了解决单线程运行阻塞问题，`JavaScript`用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）\n\n#### 事件循环（Event Loop）\n\n在`JavaScript`中，所有的任务都可以分为\n\n- 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行\n- 异步任务：异步执行的任务，比如`ajax`网络请求，`setTimeout`定时函数等\n\n同步任务与异步任务的运行流程图如下：\n\n![image](https://upload-images.jianshu.io/upload_images/13931286-a4cefb0d8aa74774?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环\n\n## 二、宏任务与微任务\n\n如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：\n\n```\nconsole.log(1)\n\nsetTimeout(()=>{\n    console.log(2)\n}, 0)\n\nnew Promise((resolve, reject)=>{\n    console.log('new Promise')\n    resolve()\n}).then(()=>{\n    console.log('then')\n})\n\nconsole.log(3)\n```\n\n如果按照上面流程图来分析代码，我们会得到下面的执行步骤：\n\n- `console.log(1)`，同步任务，主线程中执行\n- `setTimeout()` ，异步任务，放到 `Event Table`，0 毫秒后`console.log(2)`回调推入 `Event Queue` 中\n- `new Promise` ，同步任务，主线程直接执行\n- `.then` ，异步任务，放到 `Event Table`\n- `console.log(3)`，同步任务，主线程执行\n\n所以按照分析，它的结果应该是 `1` => `'new Promise'` => `3` => `2` => `'then'`\n\n但是实际结果是：`1`=>`'new Promise'`=> `3` => `'then'` => `2`\n\n出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取\n\n例子中 `setTimeout`回调事件是先进入队列中的，按理说应该先于 `.then` 中的执行，但是结果却偏偏相反\n\n原因在于异步任务还可以细分为微任务与宏任务\n\n### 微任务\n\n一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前\n\n常见的微任务有：\n\n- Promise.then\n- MutaionObserver\n- Object.observe（已废弃；Proxy 对象替代）\n- process.nextTick（Node.js）\n\n### 宏任务\n\n宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合\n\n常见的宏任务有：\n\n- script (可以理解为外层同步代码)\n- setTimeout/setInterval\n- UI rendering/UI事件\n- postMessage、MessageChannel\n- setImmediate、I/O（Node.js）\n\n这时候，事件循环，宏任务，微任务的关系如图所示\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibSNwS2EBDtHnxMysjAib2yvIh75NUHZic4J4n5mPSe5jcMcWtsO0LuhRDuqdHVWicqejmPAI8NLLjuKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n按照这个流程，它的执行机制是：\n\n- 执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中\n- 当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完\n\n回到上面的题目\n\n```\nconsole.log(1)\nsetTimeout(()=>{\n    console.log(2)\n}, 0)\nnew Promise((resolve, reject)=>{\n    console.log('new Promise')\n    resolve()\n}).then(()=>{\n    console.log('then')\n})\nconsole.log(3)\n```\n\n流程如下\n\n```\n// 遇到 console.log(1) ，直接打印 1\n// 遇到定时器，属于新的宏任务，留着后面执行\n// 遇到 new Promise，这个是直接执行的，打印 'new Promise'\n// .then 属于微任务，放入微任务队列，后面再执行\n// 遇到 console.log(3) 直接打印 3\n// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 'then'\n// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2\n```\n\n## 三、async与await\n\n`async` 是异步的意思，`await`则可以理解为等待\n\n放到一起可以理解`async`就是用来声明一个异步方法，而 `await`是用来等待异步方法执行\n\n### async\n\n`async`函数返回一个`promise`对象，下面两种方法是等效的\n\n```\nfunction f() {\n    return Promise.resolve('TEST');\n}\n\n// asyncF is equivalent to f!\nasync function asyncF() {\n    return 'TEST';\n}\n```\n\n### await\n\n正常情况下，`await`命令后面是一个 `Promise`对象，返回该对象的结果。如果不是 `Promise`对象，就直接返回对应的值\n\n```\nasync function f(){\n    // 等同于\n    // return 123\n    return await 123\n}\nf().then(v => console.log(v)) // 123\n```\n\n不管`await`后面跟着的是什么，`await`都会阻塞后面的代码\n\n```\nasync function fn1 (){\n    console.log(1)\n    await fn2()\n    console.log(2) // 阻塞\n}\n\nasync function fn2 (){\n    console.log('fn2')\n}\n\nfn1()\nconsole.log(3)\n```\n\n上面的例子中，`await` 会阻塞下面的代码（即加入微任务队列），先执行 `async`外面的同步代码，同步代码执行完，再回到 `async` 函数中，再执行之前阻塞的代码\n\n所以上述输出结果为：`1`，`fn2`，`3`，`2`\n\n## 四、流程分析\n\n通过对上面的了解，我们对`JavaScript`对各种场景的执行顺序有了大致的了解\n\n这里直接上代码：\n\n```\nasync function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\nasync function async2() {\n    console.log('async2')\n}\nconsole.log('script start')\nsetTimeout(function () {\n    console.log('settimeout')\n})\nasync1()\nnew Promise(function (resolve) {\n    console.log('promise1')\n    resolve()\n}).then(function () {\n    console.log('promise2')\n})\nconsole.log('script end')\n```\n\n分析过程：\n\n1. 执行整段代码，遇到 `console.log('script start')` 直接打印结果，输出 `script start`\n2. 遇到定时器了，它是宏任务，先放着不执行\n3. 遇到 `async1()`，执行 `async1` 函数，先打印 `async1 start`，下面遇到`await`怎么办？先执行 `async2`，打印 `async2`，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码\n4. 跳到 `new Promise` 这里，直接执行，打印 `promise1`，下面遇到 `.then()`，它是微任务，放到微任务列表等待执行\n5. 最后一行直接打印 `script end`，现在同步代码执行完了，开始执行微任务，即 `await`下面的代码，打印 `async1 end`\n6. 继续执行下一个微任务，即执行 `then` 的回调，打印 `promise2`\n7. 上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 `settimeout`\n\n所以最后的结果是：`script start`、`async1 start`、`async2`、`promise1`、`script end`、`async1 end`、`promise2`、`settimeout`","source":"_posts/2021-10-14-JavaScript事件循环.md","raw":"---\ntitle: JavaScript事件循环\ndate: 2021-10-14 11:17:45\ntags: [JavaScript,面试]\ncategories: 技术类-前端\n---\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n这一篇讲的也特别清楚，建议看看：[这一次，彻底弄懂 JavaScript 执行机制](https://juejin.cn/post/6844903512845860872)\n\n## 一、是什么\n\n`JavaScript` 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事\n\n为什么要这么设计，跟`JavaScript`的应用场景有关\n\n`JavaScript` 初期作为一门浏览器脚本语言，通常用于操作 `DOM` ，如果是多线程，一个线程进行了删除 `DOM` ，另一个添加 `DOM`，此时浏览器该如何处理？\n\n为了解决单线程运行阻塞问题，`JavaScript`用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）\n\n#### 事件循环（Event Loop）\n\n在`JavaScript`中，所有的任务都可以分为\n\n- 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行\n- 异步任务：异步执行的任务，比如`ajax`网络请求，`setTimeout`定时函数等\n\n同步任务与异步任务的运行流程图如下：\n\n![image](https://upload-images.jianshu.io/upload_images/13931286-a4cefb0d8aa74774?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环\n\n## 二、宏任务与微任务\n\n如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：\n\n```\nconsole.log(1)\n\nsetTimeout(()=>{\n    console.log(2)\n}, 0)\n\nnew Promise((resolve, reject)=>{\n    console.log('new Promise')\n    resolve()\n}).then(()=>{\n    console.log('then')\n})\n\nconsole.log(3)\n```\n\n如果按照上面流程图来分析代码，我们会得到下面的执行步骤：\n\n- `console.log(1)`，同步任务，主线程中执行\n- `setTimeout()` ，异步任务，放到 `Event Table`，0 毫秒后`console.log(2)`回调推入 `Event Queue` 中\n- `new Promise` ，同步任务，主线程直接执行\n- `.then` ，异步任务，放到 `Event Table`\n- `console.log(3)`，同步任务，主线程执行\n\n所以按照分析，它的结果应该是 `1` => `'new Promise'` => `3` => `2` => `'then'`\n\n但是实际结果是：`1`=>`'new Promise'`=> `3` => `'then'` => `2`\n\n出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取\n\n例子中 `setTimeout`回调事件是先进入队列中的，按理说应该先于 `.then` 中的执行，但是结果却偏偏相反\n\n原因在于异步任务还可以细分为微任务与宏任务\n\n### 微任务\n\n一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前\n\n常见的微任务有：\n\n- Promise.then\n- MutaionObserver\n- Object.observe（已废弃；Proxy 对象替代）\n- process.nextTick（Node.js）\n\n### 宏任务\n\n宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合\n\n常见的宏任务有：\n\n- script (可以理解为外层同步代码)\n- setTimeout/setInterval\n- UI rendering/UI事件\n- postMessage、MessageChannel\n- setImmediate、I/O（Node.js）\n\n这时候，事件循环，宏任务，微任务的关系如图所示\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibSNwS2EBDtHnxMysjAib2yvIh75NUHZic4J4n5mPSe5jcMcWtsO0LuhRDuqdHVWicqejmPAI8NLLjuKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n按照这个流程，它的执行机制是：\n\n- 执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中\n- 当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完\n\n回到上面的题目\n\n```\nconsole.log(1)\nsetTimeout(()=>{\n    console.log(2)\n}, 0)\nnew Promise((resolve, reject)=>{\n    console.log('new Promise')\n    resolve()\n}).then(()=>{\n    console.log('then')\n})\nconsole.log(3)\n```\n\n流程如下\n\n```\n// 遇到 console.log(1) ，直接打印 1\n// 遇到定时器，属于新的宏任务，留着后面执行\n// 遇到 new Promise，这个是直接执行的，打印 'new Promise'\n// .then 属于微任务，放入微任务队列，后面再执行\n// 遇到 console.log(3) 直接打印 3\n// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 'then'\n// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2\n```\n\n## 三、async与await\n\n`async` 是异步的意思，`await`则可以理解为等待\n\n放到一起可以理解`async`就是用来声明一个异步方法，而 `await`是用来等待异步方法执行\n\n### async\n\n`async`函数返回一个`promise`对象，下面两种方法是等效的\n\n```\nfunction f() {\n    return Promise.resolve('TEST');\n}\n\n// asyncF is equivalent to f!\nasync function asyncF() {\n    return 'TEST';\n}\n```\n\n### await\n\n正常情况下，`await`命令后面是一个 `Promise`对象，返回该对象的结果。如果不是 `Promise`对象，就直接返回对应的值\n\n```\nasync function f(){\n    // 等同于\n    // return 123\n    return await 123\n}\nf().then(v => console.log(v)) // 123\n```\n\n不管`await`后面跟着的是什么，`await`都会阻塞后面的代码\n\n```\nasync function fn1 (){\n    console.log(1)\n    await fn2()\n    console.log(2) // 阻塞\n}\n\nasync function fn2 (){\n    console.log('fn2')\n}\n\nfn1()\nconsole.log(3)\n```\n\n上面的例子中，`await` 会阻塞下面的代码（即加入微任务队列），先执行 `async`外面的同步代码，同步代码执行完，再回到 `async` 函数中，再执行之前阻塞的代码\n\n所以上述输出结果为：`1`，`fn2`，`3`，`2`\n\n## 四、流程分析\n\n通过对上面的了解，我们对`JavaScript`对各种场景的执行顺序有了大致的了解\n\n这里直接上代码：\n\n```\nasync function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\nasync function async2() {\n    console.log('async2')\n}\nconsole.log('script start')\nsetTimeout(function () {\n    console.log('settimeout')\n})\nasync1()\nnew Promise(function (resolve) {\n    console.log('promise1')\n    resolve()\n}).then(function () {\n    console.log('promise2')\n})\nconsole.log('script end')\n```\n\n分析过程：\n\n1. 执行整段代码，遇到 `console.log('script start')` 直接打印结果，输出 `script start`\n2. 遇到定时器了，它是宏任务，先放着不执行\n3. 遇到 `async1()`，执行 `async1` 函数，先打印 `async1 start`，下面遇到`await`怎么办？先执行 `async2`，打印 `async2`，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码\n4. 跳到 `new Promise` 这里，直接执行，打印 `promise1`，下面遇到 `.then()`，它是微任务，放到微任务列表等待执行\n5. 最后一行直接打印 `script end`，现在同步代码执行完了，开始执行微任务，即 `await`下面的代码，打印 `async1 end`\n6. 继续执行下一个微任务，即执行 `then` 的回调，打印 `promise2`\n7. 上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 `settimeout`\n\n所以最后的结果是：`script start`、`async1 start`、`async2`、`promise1`、`script end`、`async1 end`、`promise2`、`settimeout`","slug":"JavaScript事件循环","published":1,"updated":"2021-10-14T03:51:19.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5l00197oo950j6deow","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p>这一篇讲的也特别清楚，建议看看：<a href=\"https://juejin.cn/post/6844903512845860872\">这一次，彻底弄懂 JavaScript 执行机制</a></p>\n<h2 id=\"一、是什么\"><a href=\"#一、是什么\" class=\"headerlink\" title=\"一、是什么\"></a>一、是什么</h2><p><code>JavaScript</code> 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事</p>\n<p>为什么要这么设计，跟<code>JavaScript</code>的应用场景有关</p>\n<p><code>JavaScript</code> 初期作为一门浏览器脚本语言，通常用于操作 <code>DOM</code> ，如果是多线程，一个线程进行了删除 <code>DOM</code> ，另一个添加 <code>DOM</code>，此时浏览器该如何处理？</p>\n<p>为了解决单线程运行阻塞问题，<code>JavaScript</code>用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）</p>\n<h4 id=\"事件循环（Event-Loop）\"><a href=\"#事件循环（Event-Loop）\" class=\"headerlink\" title=\"事件循环（Event Loop）\"></a>事件循环（Event Loop）</h4><p>在<code>JavaScript</code>中，所有的任务都可以分为</p>\n<ul>\n<li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</li>\n<li>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等</li>\n</ul>\n<p>同步任务与异步任务的运行流程图如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-a4cefb0d8aa74774?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环</p>\n<h2 id=\"二、宏任务与微任务\"><a href=\"#二、宏任务与微任务\" class=\"headerlink\" title=\"二、宏任务与微任务\"></a>二、宏任务与微任务</h2><p>如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)<br><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>)<br>&#125;, <span class=\"hljs-number\">0</span>)<br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(resolve, reject)</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;new Promise&#x27;</span>)<br>    resolve()<br>&#125;).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;then&#x27;</span>)<br>&#125;)<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<p>如果按照上面流程图来分析代码，我们会得到下面的执行步骤：</p>\n<ul>\n<li><code>console.log(1)</code>，同步任务，主线程中执行</li>\n<li><code>setTimeout()</code> ，异步任务，放到 <code>Event Table</code>，0 毫秒后<code>console.log(2)</code>回调推入 <code>Event Queue</code> 中</li>\n<li><code>new Promise</code> ，同步任务，主线程直接执行</li>\n<li><code>.then</code> ，异步任务，放到 <code>Event Table</code></li>\n<li><code>console.log(3)</code>，同步任务，主线程执行</li>\n</ul>\n<p>所以按照分析，它的结果应该是 <code>1</code> =&gt; <code>&#39;new Promise&#39;</code> =&gt; <code>3</code> =&gt; <code>2</code> =&gt; <code>&#39;then&#39;</code></p>\n<p>但是实际结果是：<code>1</code>=&gt;<code>&#39;new Promise&#39;</code>=&gt; <code>3</code> =&gt; <code>&#39;then&#39;</code> =&gt; <code>2</code></p>\n<p>出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取</p>\n<p>例子中 <code>setTimeout</code>回调事件是先进入队列中的，按理说应该先于 <code>.then</code> 中的执行，但是结果却偏偏相反</p>\n<p>原因在于异步任务还可以细分为微任务与宏任务</p>\n<h3 id=\"微任务\"><a href=\"#微任务\" class=\"headerlink\" title=\"微任务\"></a>微任务</h3><p>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p>\n<p>常见的微任务有：</p>\n<ul>\n<li>Promise.then</li>\n<li>MutaionObserver</li>\n<li>Object.observe（已废弃；Proxy 对象替代）</li>\n<li>process.nextTick（Node.js）</li>\n</ul>\n<h3 id=\"宏任务\"><a href=\"#宏任务\" class=\"headerlink\" title=\"宏任务\"></a>宏任务</h3><p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p>\n<p>常见的宏任务有：</p>\n<ul>\n<li>script (可以理解为外层同步代码)</li>\n<li>setTimeout/setInterval</li>\n<li>UI rendering/UI事件</li>\n<li>postMessage、MessageChannel</li>\n<li>setImmediate、I/O（Node.js）</li>\n</ul>\n<p>这时候，事件循环，宏任务，微任务的关系如图所示</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibSNwS2EBDtHnxMysjAib2yvIh75NUHZic4J4n5mPSe5jcMcWtsO0LuhRDuqdHVWicqejmPAI8NLLjuKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>按照这个流程，它的执行机制是：</p>\n<ul>\n<li>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中</li>\n<li>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</li>\n</ul>\n<p>回到上面的题目</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>)<br>&#125;, <span class=\"hljs-number\">0</span>)<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(resolve, reject)</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;new Promise&#x27;</span>)<br>    resolve()<br>&#125;).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;then&#x27;</span>)<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<p>流程如下</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 遇到 console.log(<span class=\"hljs-number\">1</span>) ，直接打印 <span class=\"hljs-number\">1</span><br><span class=\"hljs-regexp\">//</span> 遇到定时器，属于新的宏任务，留着后面执行<br><span class=\"hljs-regexp\">//</span> 遇到 new Promise，这个是直接执行的，打印 <span class=\"hljs-string\">&#x27;new Promise&#x27;</span><br><span class=\"hljs-regexp\">//</span> .then 属于微任务，放入微任务队列，后面再执行<br><span class=\"hljs-regexp\">//</span> 遇到 console.log(<span class=\"hljs-number\">3</span>) 直接打印 <span class=\"hljs-number\">3</span><br><span class=\"hljs-regexp\">//</span> 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 <span class=\"hljs-string\">&#x27;then&#x27;</span><br><span class=\"hljs-regexp\">//</span> 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、async与await\"><a href=\"#三、async与await\" class=\"headerlink\" title=\"三、async与await\"></a>三、async与await</h2><p><code>async</code> 是异步的意思，<code>await</code>则可以理解为等待</p>\n<p>放到一起可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await</code>是用来等待异步方法执行</p>\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p><code>async</code>函数返回一个<code>promise</code>对象，下面两种方法是等效的</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">Promise.resolve(&#x27;TEST&#x27;)</span>;<br>&#125;<br><br>// asyncF <span class=\"hljs-keyword\">is</span> equivalent to f!<br>async <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncF</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">&#x27;TEST&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await\"></a>await</h3><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code>对象，返回该对象的结果。如果不是 <code>Promise</code>对象，就直接返回对应的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-comment\">// 等同于</span><br>    <span class=\"hljs-comment\">// return 123</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-number\">123</span><br>&#125;<br>f().then(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(v)) <span class=\"hljs-comment\">// 123</span><br></code></pre></td></tr></table></figure>\n\n<p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span> (<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">await</span> fn2()<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 阻塞</span><br>&#125;<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn2</span> (<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;fn2&#x27;</span>)<br>&#125;<br><br>fn1()<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async</code>外面的同步代码，同步代码执行完，再回到 <code>async</code> 函数中，再执行之前阻塞的代码</p>\n<p>所以上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p>\n<h2 id=\"四、流程分析\"><a href=\"#四、流程分析\" class=\"headerlink\" title=\"四、流程分析\"></a>四、流程分析</h2><p>通过对上面的了解，我们对<code>JavaScript</code>对各种场景的执行顺序有了大致的了解</p>\n<p>这里直接上代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">async1</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;async1 start&#x27;</span>)<br>    <span class=\"hljs-keyword\">await</span> async2()<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">async2</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;async2&#x27;</span>)<br>&#125;<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script start&#x27;</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;settimeout&#x27;</span>)<br>&#125;)<br>async1()<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise1&#x27;</span>)<br>    resolve()<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>分析过程：</p>\n<ol>\n<li>执行整段代码，遇到 <code>console.log(&#39;script start&#39;)</code> 直接打印结果，输出 <code>script start</code></li>\n<li>遇到定时器了，它是宏任务，先放着不执行</li>\n<li>遇到 <code>async1()</code>，执行 <code>async1</code> 函数，先打印 <code>async1 start</code>，下面遇到<code>await</code>怎么办？先执行 <code>async2</code>，打印 <code>async2</code>，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码</li>\n<li>跳到 <code>new Promise</code> 这里，直接执行，打印 <code>promise1</code>，下面遇到 <code>.then()</code>，它是微任务，放到微任务列表等待执行</li>\n<li>最后一行直接打印 <code>script end</code>，现在同步代码执行完了，开始执行微任务，即 <code>await</code>下面的代码，打印 <code>async1 end</code></li>\n<li>继续执行下一个微任务，即执行 <code>then</code> 的回调，打印 <code>promise2</code></li>\n<li>上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 <code>settimeout</code></li>\n</ol>\n<p>所以最后的结果是：<code>script start</code>、<code>async1 start</code>、<code>async2</code>、<code>promise1</code>、<code>script end</code>、<code>async1 end</code>、<code>promise2</code>、<code>settimeout</code></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<p>这一篇讲的也特别清楚，建议看看：<a href=\"https://juejin.cn/post/6844903512845860872\">这一次，彻底弄懂 JavaScript 执行机制</a></p>\n<h2 id=\"一、是什么\"><a href=\"#一、是什么\" class=\"headerlink\" title=\"一、是什么\"></a>一、是什么</h2><p><code>JavaScript</code> 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事</p>\n<p>为什么要这么设计，跟<code>JavaScript</code>的应用场景有关</p>\n<p><code>JavaScript</code> 初期作为一门浏览器脚本语言，通常用于操作 <code>DOM</code> ，如果是多线程，一个线程进行了删除 <code>DOM</code> ，另一个添加 <code>DOM</code>，此时浏览器该如何处理？</p>\n<p>为了解决单线程运行阻塞问题，<code>JavaScript</code>用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）</p>\n<h4 id=\"事件循环（Event-Loop）\"><a href=\"#事件循环（Event-Loop）\" class=\"headerlink\" title=\"事件循环（Event Loop）\"></a>事件循环（Event Loop）</h4><p>在<code>JavaScript</code>中，所有的任务都可以分为</p>\n<ul>\n<li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</li>\n<li>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等</li>\n</ul>\n<p>同步任务与异步任务的运行流程图如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-a4cefb0d8aa74774?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环</p>\n<h2 id=\"二、宏任务与微任务\"><a href=\"#二、宏任务与微任务\" class=\"headerlink\" title=\"二、宏任务与微任务\"></a>二、宏任务与微任务</h2><p>如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)<br><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>)<br>&#125;, <span class=\"hljs-number\">0</span>)<br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(resolve, reject)</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;new Promise&#x27;</span>)<br>    resolve()<br>&#125;).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;then&#x27;</span>)<br>&#125;)<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<p>如果按照上面流程图来分析代码，我们会得到下面的执行步骤：</p>\n<ul>\n<li><code>console.log(1)</code>，同步任务，主线程中执行</li>\n<li><code>setTimeout()</code> ，异步任务，放到 <code>Event Table</code>，0 毫秒后<code>console.log(2)</code>回调推入 <code>Event Queue</code> 中</li>\n<li><code>new Promise</code> ，同步任务，主线程直接执行</li>\n<li><code>.then</code> ，异步任务，放到 <code>Event Table</code></li>\n<li><code>console.log(3)</code>，同步任务，主线程执行</li>\n</ul>\n<p>所以按照分析，它的结果应该是 <code>1</code> =&gt; <code>&#39;new Promise&#39;</code> =&gt; <code>3</code> =&gt; <code>2</code> =&gt; <code>&#39;then&#39;</code></p>\n<p>但是实际结果是：<code>1</code>=&gt;<code>&#39;new Promise&#39;</code>=&gt; <code>3</code> =&gt; <code>&#39;then&#39;</code> =&gt; <code>2</code></p>\n<p>出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取</p>\n<p>例子中 <code>setTimeout</code>回调事件是先进入队列中的，按理说应该先于 <code>.then</code> 中的执行，但是结果却偏偏相反</p>\n<p>原因在于异步任务还可以细分为微任务与宏任务</p>\n<h3 id=\"微任务\"><a href=\"#微任务\" class=\"headerlink\" title=\"微任务\"></a>微任务</h3><p>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p>\n<p>常见的微任务有：</p>\n<ul>\n<li>Promise.then</li>\n<li>MutaionObserver</li>\n<li>Object.observe（已废弃；Proxy 对象替代）</li>\n<li>process.nextTick（Node.js）</li>\n</ul>\n<h3 id=\"宏任务\"><a href=\"#宏任务\" class=\"headerlink\" title=\"宏任务\"></a>宏任务</h3><p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p>\n<p>常见的宏任务有：</p>\n<ul>\n<li>script (可以理解为外层同步代码)</li>\n<li>setTimeout/setInterval</li>\n<li>UI rendering/UI事件</li>\n<li>postMessage、MessageChannel</li>\n<li>setImmediate、I/O（Node.js）</li>\n</ul>\n<p>这时候，事件循环，宏任务，微任务的关系如图所示</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibSNwS2EBDtHnxMysjAib2yvIh75NUHZic4J4n5mPSe5jcMcWtsO0LuhRDuqdHVWicqejmPAI8NLLjuKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>按照这个流程，它的执行机制是：</p>\n<ul>\n<li>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中</li>\n<li>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</li>\n</ul>\n<p>回到上面的题目</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>)<br>&#125;, <span class=\"hljs-number\">0</span>)<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(resolve, reject)</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;new Promise&#x27;</span>)<br>    resolve()<br>&#125;).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;then&#x27;</span>)<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<p>流程如下</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 遇到 console.log(<span class=\"hljs-number\">1</span>) ，直接打印 <span class=\"hljs-number\">1</span><br><span class=\"hljs-regexp\">//</span> 遇到定时器，属于新的宏任务，留着后面执行<br><span class=\"hljs-regexp\">//</span> 遇到 new Promise，这个是直接执行的，打印 <span class=\"hljs-string\">&#x27;new Promise&#x27;</span><br><span class=\"hljs-regexp\">//</span> .then 属于微任务，放入微任务队列，后面再执行<br><span class=\"hljs-regexp\">//</span> 遇到 console.log(<span class=\"hljs-number\">3</span>) 直接打印 <span class=\"hljs-number\">3</span><br><span class=\"hljs-regexp\">//</span> 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 <span class=\"hljs-string\">&#x27;then&#x27;</span><br><span class=\"hljs-regexp\">//</span> 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、async与await\"><a href=\"#三、async与await\" class=\"headerlink\" title=\"三、async与await\"></a>三、async与await</h2><p><code>async</code> 是异步的意思，<code>await</code>则可以理解为等待</p>\n<p>放到一起可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await</code>是用来等待异步方法执行</p>\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p><code>async</code>函数返回一个<code>promise</code>对象，下面两种方法是等效的</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">Promise.resolve(&#x27;TEST&#x27;)</span>;<br>&#125;<br><br>// asyncF <span class=\"hljs-keyword\">is</span> equivalent to f!<br>async <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncF</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">&#x27;TEST&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await\"></a>await</h3><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code>对象，返回该对象的结果。如果不是 <code>Promise</code>对象，就直接返回对应的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-comment\">// 等同于</span><br>    <span class=\"hljs-comment\">// return 123</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-number\">123</span><br>&#125;<br>f().then(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(v)) <span class=\"hljs-comment\">// 123</span><br></code></pre></td></tr></table></figure>\n\n<p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span> (<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">await</span> fn2()<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 阻塞</span><br>&#125;<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn2</span> (<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;fn2&#x27;</span>)<br>&#125;<br><br>fn1()<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n\n<p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async</code>外面的同步代码，同步代码执行完，再回到 <code>async</code> 函数中，再执行之前阻塞的代码</p>\n<p>所以上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p>\n<h2 id=\"四、流程分析\"><a href=\"#四、流程分析\" class=\"headerlink\" title=\"四、流程分析\"></a>四、流程分析</h2><p>通过对上面的了解，我们对<code>JavaScript</code>对各种场景的执行顺序有了大致的了解</p>\n<p>这里直接上代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">async1</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;async1 start&#x27;</span>)<br>    <span class=\"hljs-keyword\">await</span> async2()<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">async2</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;async2&#x27;</span>)<br>&#125;<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script start&#x27;</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;settimeout&#x27;</span>)<br>&#125;)<br>async1()<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise1&#x27;</span>)<br>    resolve()<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>分析过程：</p>\n<ol>\n<li>执行整段代码，遇到 <code>console.log(&#39;script start&#39;)</code> 直接打印结果，输出 <code>script start</code></li>\n<li>遇到定时器了，它是宏任务，先放着不执行</li>\n<li>遇到 <code>async1()</code>，执行 <code>async1</code> 函数，先打印 <code>async1 start</code>，下面遇到<code>await</code>怎么办？先执行 <code>async2</code>，打印 <code>async2</code>，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码</li>\n<li>跳到 <code>new Promise</code> 这里，直接执行，打印 <code>promise1</code>，下面遇到 <code>.then()</code>，它是微任务，放到微任务列表等待执行</li>\n<li>最后一行直接打印 <code>script end</code>，现在同步代码执行完了，开始执行微任务，即 <code>await</code>下面的代码，打印 <code>async1 end</code></li>\n<li>继续执行下一个微任务，即执行 <code>then</code> 的回调，打印 <code>promise2</code></li>\n<li>上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 <code>settimeout</code></li>\n</ol>\n<p>所以最后的结果是：<code>script start</code>、<code>async1 start</code>、<code>async2</code>、<code>promise1</code>、<code>script end</code>、<code>async1 end</code>、<code>promise2</code>、<code>settimeout</code></p>\n"},{"title":"Array数组的一些发现","date":"2021-10-20T05:49:22.000Z","_content":"今天对一些元素都是纯数字的数组做`forEach`遍历操作，发现无法改变原数组，查找了一些资料发现，`forEach`只能处理数组中的引用类型，元素为基础类型的需要另外的写法。如下：\n```js\nlet arr = [1, 2, 3, 4, 5]\nlet arr1 = [1, 2, 3, 4, 5]\nlet arr2 = [{a:1,b:2}]\n\n// 元素为基础类型number，原数组不变\narr.forEach(item => {\n    item += 1\n})\n\n// 这种写法可行\narr1.forEach((item, index) => {\n    arr1[index] += 1\n})\n\n// 元素为引用类型的，原数组会改变\narr2.forEach(item=>{\n    item.a = 66\n})\nconsole.log(arr);\nconsole.log(arr1);\nconsole.log(arr2);\n```\n\n这主要是和计算机的堆栈有关。基础类型是存储在栈中，`forEach`中得到item也是存储于栈中，所以它就和数组中的元素毫无关系了；而对象是存储于堆中，遍历的时候item虽然在栈中但是它的指针会指向堆中的位置，所以可以直接修改原数组。\n","source":"_posts/2021-10-20-Array数组的一些发现.md","raw":"---\ntitle: Array数组的一些发现\ndate: 2021-10-20 13:49:22\ntags: [JavaScript]\ncategories: 技术类-前端\n---\n今天对一些元素都是纯数字的数组做`forEach`遍历操作，发现无法改变原数组，查找了一些资料发现，`forEach`只能处理数组中的引用类型，元素为基础类型的需要另外的写法。如下：\n```js\nlet arr = [1, 2, 3, 4, 5]\nlet arr1 = [1, 2, 3, 4, 5]\nlet arr2 = [{a:1,b:2}]\n\n// 元素为基础类型number，原数组不变\narr.forEach(item => {\n    item += 1\n})\n\n// 这种写法可行\narr1.forEach((item, index) => {\n    arr1[index] += 1\n})\n\n// 元素为引用类型的，原数组会改变\narr2.forEach(item=>{\n    item.a = 66\n})\nconsole.log(arr);\nconsole.log(arr1);\nconsole.log(arr2);\n```\n\n这主要是和计算机的堆栈有关。基础类型是存储在栈中，`forEach`中得到item也是存储于栈中，所以它就和数组中的元素毫无关系了；而对象是存储于堆中，遍历的时候item虽然在栈中但是它的指针会指向堆中的位置，所以可以直接修改原数组。\n","slug":"Array数组的一些发现","published":1,"updated":"2021-10-20T06:13:41.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5m001c7oo98td05663","content":"<p>今天对一些元素都是纯数字的数组做<code>forEach</code>遍历操作，发现无法改变原数组，查找了一些资料发现，<code>forEach</code>只能处理数组中的引用类型，元素为基础类型的需要另外的写法。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> arr2 = [&#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-attr\">b</span>:<span class=\"hljs-number\">2</span>&#125;]<br><br><span class=\"hljs-comment\">// 元素为基础类型number，原数组不变</span><br>arr.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> &#123;<br>    item += <span class=\"hljs-number\">1</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 这种写法可行</span><br>arr1.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, index</span>) =&gt;</span> &#123;<br>    arr1[index] += <span class=\"hljs-number\">1</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 元素为引用类型的，原数组会改变</span><br>arr2.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>=&gt;</span>&#123;<br>    item.a = <span class=\"hljs-number\">66</span><br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(arr);<br><span class=\"hljs-built_in\">console</span>.log(arr1);<br><span class=\"hljs-built_in\">console</span>.log(arr2);<br></code></pre></td></tr></table></figure>\n\n<p>这主要是和计算机的堆栈有关。基础类型是存储在栈中，<code>forEach</code>中得到item也是存储于栈中，所以它就和数组中的元素毫无关系了；而对象是存储于堆中，遍历的时候item虽然在栈中但是它的指针会指向堆中的位置，所以可以直接修改原数组。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天对一些元素都是纯数字的数组做<code>forEach</code>遍历操作，发现无法改变原数组，查找了一些资料发现，<code>forEach</code>只能处理数组中的引用类型，元素为基础类型的需要另外的写法。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> arr2 = [&#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-attr\">b</span>:<span class=\"hljs-number\">2</span>&#125;]<br><br><span class=\"hljs-comment\">// 元素为基础类型number，原数组不变</span><br>arr.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> &#123;<br>    item += <span class=\"hljs-number\">1</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 这种写法可行</span><br>arr1.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, index</span>) =&gt;</span> &#123;<br>    arr1[index] += <span class=\"hljs-number\">1</span><br>&#125;)<br><br><span class=\"hljs-comment\">// 元素为引用类型的，原数组会改变</span><br>arr2.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>=&gt;</span>&#123;<br>    item.a = <span class=\"hljs-number\">66</span><br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(arr);<br><span class=\"hljs-built_in\">console</span>.log(arr1);<br><span class=\"hljs-built_in\">console</span>.log(arr2);<br></code></pre></td></tr></table></figure>\n\n<p>这主要是和计算机的堆栈有关。基础类型是存储在栈中，<code>forEach</code>中得到item也是存储于栈中，所以它就和数组中的元素毫无关系了；而对象是存储于堆中，遍历的时候item虽然在栈中但是它的指针会指向堆中的位置，所以可以直接修改原数组。</p>\n"},{"title":"call,apply和bind","date":"2021-10-21T03:18:44.000Z","_content":"`call`，`apply`和`bind`都是用来改变this的指向，但是他们在使用和功能上各有区别。\n# call() 方法\n## call() 方法的作用\ncall() 方法的作用：可以**调用**一个函数，与此同时，它还可以改变这个函数内部的 this 指向。\n\ncall() 方法的另一个应用：**可以实现继承**。之所以能实现继承，其实是利用了上面的作用。\n\n## 语法\n```js\nfn1.call(想要将this指向哪里, 函数实参1, 函数实参2);\n```\n备注：第一个参数中，如果不需要改变 this 指向，则传 null。\n\n## call() 方法举例\n举例 1、通过 call() 调用函数：\n```js\nconst obj1 = {\n    nickName: '走花鹿',\n    age: 26,\n};\nfunction fn1() {\n    console.log(this);\n    console.log(this.nickName);\n}\nfn1.call(this); // this的指向并没有被改变，此时相当于 fn1();\n```\n上方代码的打印结果：\n```js\nwindow\nundefined\n```\n上面的代码，跟普通的函数调用 `fn1()` 没有区别。\n\n举例 2、通过 call() 改变 this 指向：\n```js\nvar obj1 = {\n    nickName: '走花鹿',\n    age: 26,\n};\n\nfunction fn1(a, b) {\n    console.log(this);\n    console.log(this.nickName);\n    console.log(a + b);\n}\n\nfn1.call(obj1, 2, 4); // 先将 this 指向 obj1，然后执行 fn1() 函数\n```\n上方代码的打印结果：\n```js\nobj1\n走花鹿\n6\n```\n举例 3、通过 call() 实现继承：\n```js\n// 给 Father 增加 name 和 age 属性\nfunction Father(myName, myAge) {\n    this.name = myName;\n    this.age = myAge;\n}\n\nfunction Son(myName, myAge) {\n    // 【下面这一行，重要代码】\n    // 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承\n    Father.call(this, myName, myAge);\n}\n\nconst son1 = new Son('走花鹿', 26);\nconsole.log(JSON.stringify(son1));\n```\n上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。\n\n打印结果：\n```\n{\"myName\":\"走花鹿\",\"myAge\":26}\n```\n# apply() 方法\n## apply() 方法的作用\napply() 方法的作用：可以**调用**一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。\n\napply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。\n\n## 语法\n```js\nfn1.apply(想要将this指向哪里, [函数实参1, 函数实参2]);\n```\n备注：第一个参数中，如果不需要改变 this 指向，则传 null。\n\n到这里可以看出， **call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。**\n\n## apply() 方法举例\n举例、通过 apply() 改变 this 指向：\n```js\nvar obj1 = {\n    nickName: '走花鹿',\n    age: 26,\n};\n\nfunction fn1(a) {\n    console.log(this);\n    console.log(this.nickName);\n    console.log(a);\n}\n\nfn1.apply(obj1, ['hello']); // 先将 this 指向 obj1，然后执行 fn1() 函数\n```\n注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。\n\n打印结果：\n```js\nobj1\n走花鹿\nhello\n```\n## apply() 方法的巧妙应用：求数组的最大值\n我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？\n\n虽然数组里没有获取最大值的方法，但是数值里面有 `Math.max(数字1，数字2，数字3)` 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。\n\n举例：求数组中多个元素的最大值：\n```js\nconst arr1 = [3, 7, 10, 8];\n\n// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。\nconst maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值\nconsole.log(maxValue);\n\nconst minValue = Math.min.apply(Math, arr1); // 求数组 arr1 中元素的最小值\nconsole.log(minValue);\n```\n打印结果：\n```js\n10\n3\n```\n# bind() 方法\n## bind() 方法的作用\nbind() 方法**不会调用函数**，但是可以改变函数内部的 this 指向。\n\n把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。\n\n语法\n```js\n新函数 = fn1.bind(想要将this指向哪里, 函数实参1, 函数实参2);\n```\n参数：\n\n- 第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。\n\n- 其他参数：fn1 函数的实参。\n\n解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。","source":"_posts/2021-10-21-call-apply和bind.md","raw":"---\ntitle: 'call,apply和bind'\ndate: 2021-10-21 11:18:44\ntags: [JavaScript,面试]\ncategories: 技术类-前端\n---\n`call`，`apply`和`bind`都是用来改变this的指向，但是他们在使用和功能上各有区别。\n# call() 方法\n## call() 方法的作用\ncall() 方法的作用：可以**调用**一个函数，与此同时，它还可以改变这个函数内部的 this 指向。\n\ncall() 方法的另一个应用：**可以实现继承**。之所以能实现继承，其实是利用了上面的作用。\n\n## 语法\n```js\nfn1.call(想要将this指向哪里, 函数实参1, 函数实参2);\n```\n备注：第一个参数中，如果不需要改变 this 指向，则传 null。\n\n## call() 方法举例\n举例 1、通过 call() 调用函数：\n```js\nconst obj1 = {\n    nickName: '走花鹿',\n    age: 26,\n};\nfunction fn1() {\n    console.log(this);\n    console.log(this.nickName);\n}\nfn1.call(this); // this的指向并没有被改变，此时相当于 fn1();\n```\n上方代码的打印结果：\n```js\nwindow\nundefined\n```\n上面的代码，跟普通的函数调用 `fn1()` 没有区别。\n\n举例 2、通过 call() 改变 this 指向：\n```js\nvar obj1 = {\n    nickName: '走花鹿',\n    age: 26,\n};\n\nfunction fn1(a, b) {\n    console.log(this);\n    console.log(this.nickName);\n    console.log(a + b);\n}\n\nfn1.call(obj1, 2, 4); // 先将 this 指向 obj1，然后执行 fn1() 函数\n```\n上方代码的打印结果：\n```js\nobj1\n走花鹿\n6\n```\n举例 3、通过 call() 实现继承：\n```js\n// 给 Father 增加 name 和 age 属性\nfunction Father(myName, myAge) {\n    this.name = myName;\n    this.age = myAge;\n}\n\nfunction Son(myName, myAge) {\n    // 【下面这一行，重要代码】\n    // 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承\n    Father.call(this, myName, myAge);\n}\n\nconst son1 = new Son('走花鹿', 26);\nconsole.log(JSON.stringify(son1));\n```\n上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。\n\n打印结果：\n```\n{\"myName\":\"走花鹿\",\"myAge\":26}\n```\n# apply() 方法\n## apply() 方法的作用\napply() 方法的作用：可以**调用**一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。\n\napply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。\n\n## 语法\n```js\nfn1.apply(想要将this指向哪里, [函数实参1, 函数实参2]);\n```\n备注：第一个参数中，如果不需要改变 this 指向，则传 null。\n\n到这里可以看出， **call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。**\n\n## apply() 方法举例\n举例、通过 apply() 改变 this 指向：\n```js\nvar obj1 = {\n    nickName: '走花鹿',\n    age: 26,\n};\n\nfunction fn1(a) {\n    console.log(this);\n    console.log(this.nickName);\n    console.log(a);\n}\n\nfn1.apply(obj1, ['hello']); // 先将 this 指向 obj1，然后执行 fn1() 函数\n```\n注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。\n\n打印结果：\n```js\nobj1\n走花鹿\nhello\n```\n## apply() 方法的巧妙应用：求数组的最大值\n我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？\n\n虽然数组里没有获取最大值的方法，但是数值里面有 `Math.max(数字1，数字2，数字3)` 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。\n\n举例：求数组中多个元素的最大值：\n```js\nconst arr1 = [3, 7, 10, 8];\n\n// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。\nconst maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值\nconsole.log(maxValue);\n\nconst minValue = Math.min.apply(Math, arr1); // 求数组 arr1 中元素的最小值\nconsole.log(minValue);\n```\n打印结果：\n```js\n10\n3\n```\n# bind() 方法\n## bind() 方法的作用\nbind() 方法**不会调用函数**，但是可以改变函数内部的 this 指向。\n\n把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。\n\n语法\n```js\n新函数 = fn1.bind(想要将this指向哪里, 函数实参1, 函数实参2);\n```\n参数：\n\n- 第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。\n\n- 其他参数：fn1 函数的实参。\n\n解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。","slug":"call-apply和bind","published":1,"updated":"2021-10-21T03:37:52.895Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5n001g7oo948fjhel3","content":"<p><code>call</code>，<code>apply</code>和<code>bind</code>都是用来改变this的指向，但是他们在使用和功能上各有区别。</p>\n<h1 id=\"call-方法\"><a href=\"#call-方法\" class=\"headerlink\" title=\"call() 方法\"></a>call() 方法</h1><h2 id=\"call-方法的作用\"><a href=\"#call-方法的作用\" class=\"headerlink\" title=\"call() 方法的作用\"></a>call() 方法的作用</h2><p>call() 方法的作用：可以<strong>调用</strong>一个函数，与此同时，它还可以改变这个函数内部的 this 指向。</p>\n<p>call() 方法的另一个应用：<strong>可以实现继承</strong>。之所以能实现继承，其实是利用了上面的作用。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">fn1.call(想要将<span class=\"hljs-built_in\">this</span>指向哪里, 函数实参<span class=\"hljs-number\">1</span>, 函数实参<span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p>备注：第一个参数中，如果不需要改变 this 指向，则传 null。</p>\n<h2 id=\"call-方法举例\"><a href=\"#call-方法举例\" class=\"headerlink\" title=\"call() 方法举例\"></a>call() 方法举例</h2><p>举例 1、通过 call() 调用函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj1 = &#123;<br>    <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.nickName);<br>&#125;<br>fn1.call(<span class=\"hljs-built_in\">this</span>); <span class=\"hljs-comment\">// this的指向并没有被改变，此时相当于 fn1();</span><br></code></pre></td></tr></table></figure>\n<p>上方代码的打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">window</span><br><span class=\"hljs-literal\">undefined</span><br></code></pre></td></tr></table></figure>\n<p>上面的代码，跟普通的函数调用 <code>fn1()</code> 没有区别。</p>\n<p>举例 2、通过 call() 改变 this 指向：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>    <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\">a, b</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.nickName);<br>    <span class=\"hljs-built_in\">console</span>.log(a + b);<br>&#125;<br><br>fn1.call(obj1, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 先将 this 指向 obj1，然后执行 fn1() 函数</span><br></code></pre></td></tr></table></figure>\n<p>上方代码的打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">obj1<br>走花鹿<br><span class=\"hljs-number\">6</span><br></code></pre></td></tr></table></figure>\n<p>举例 3、通过 call() 实现继承：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 给 Father 增加 name 和 age 属性</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Father</span>(<span class=\"hljs-params\">myName, myAge</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.name = myName;<br>    <span class=\"hljs-built_in\">this</span>.age = myAge;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Son</span>(<span class=\"hljs-params\">myName, myAge</span>) </span>&#123;<br>    <span class=\"hljs-comment\">// 【下面这一行，重要代码】</span><br>    <span class=\"hljs-comment\">// 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承</span><br>    Father.call(<span class=\"hljs-built_in\">this</span>, myName, myAge);<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> son1 = <span class=\"hljs-keyword\">new</span> Son(<span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>, <span class=\"hljs-number\">26</span>);<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">JSON</span>.stringify(son1));<br></code></pre></td></tr></table></figure>\n<p>上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。</p>\n<p>打印结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<span class=\"hljs-attr\">&quot;myName&quot;</span>:<span class=\"hljs-string\">&quot;走花鹿&quot;</span>,<span class=\"hljs-attr\">&quot;myAge&quot;</span>:<span class=\"hljs-number\">26</span>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"apply-方法\"><a href=\"#apply-方法\" class=\"headerlink\" title=\"apply() 方法\"></a>apply() 方法</h1><h2 id=\"apply-方法的作用\"><a href=\"#apply-方法的作用\" class=\"headerlink\" title=\"apply() 方法的作用\"></a>apply() 方法的作用</h2><p>apply() 方法的作用：可以<strong>调用</strong>一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。</p>\n<p>apply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。</p>\n<h2 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">fn1.apply(想要将<span class=\"hljs-built_in\">this</span>指向哪里, [函数实参<span class=\"hljs-number\">1</span>, 函数实参<span class=\"hljs-number\">2</span>]);<br></code></pre></td></tr></table></figure>\n<p>备注：第一个参数中，如果不需要改变 this 指向，则传 null。</p>\n<p>到这里可以看出， <strong>call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。</strong></p>\n<h2 id=\"apply-方法举例\"><a href=\"#apply-方法举例\" class=\"headerlink\" title=\"apply() 方法举例\"></a>apply() 方法举例</h2><p>举例、通过 apply() 改变 this 指向：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>    <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\">a</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.nickName);<br>    <span class=\"hljs-built_in\">console</span>.log(a);<br>&#125;<br><br>fn1.apply(obj1, [<span class=\"hljs-string\">&#x27;hello&#x27;</span>]); <span class=\"hljs-comment\">// 先将 this 指向 obj1，然后执行 fn1() 函数</span><br></code></pre></td></tr></table></figure>\n<p>注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。</p>\n<p>打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">obj1<br>走花鹿<br>hello<br></code></pre></td></tr></table></figure>\n<h2 id=\"apply-方法的巧妙应用：求数组的最大值\"><a href=\"#apply-方法的巧妙应用：求数组的最大值\" class=\"headerlink\" title=\"apply() 方法的巧妙应用：求数组的最大值\"></a>apply() 方法的巧妙应用：求数组的最大值</h2><p>我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？</p>\n<p>虽然数组里没有获取最大值的方法，但是数值里面有 <code>Math.max(数字1，数字2，数字3)</code> 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。</p>\n<p>举例：求数组中多个元素的最大值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr1 = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">8</span>];<br><br><span class=\"hljs-comment\">// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。</span><br><span class=\"hljs-keyword\">const</span> maxValue = <span class=\"hljs-built_in\">Math</span>.max.apply(<span class=\"hljs-built_in\">Math</span>, arr1); <span class=\"hljs-comment\">// 求数组 arr1 中元素的最大值</span><br><span class=\"hljs-built_in\">console</span>.log(maxValue);<br><br><span class=\"hljs-keyword\">const</span> minValue = <span class=\"hljs-built_in\">Math</span>.min.apply(<span class=\"hljs-built_in\">Math</span>, arr1); <span class=\"hljs-comment\">// 求数组 arr1 中元素的最小值</span><br><span class=\"hljs-built_in\">console</span>.log(minValue);<br></code></pre></td></tr></table></figure>\n<p>打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-number\">10</span><br><span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind() 方法\"></a>bind() 方法</h1><h2 id=\"bind-方法的作用\"><a href=\"#bind-方法的作用\" class=\"headerlink\" title=\"bind() 方法的作用\"></a>bind() 方法的作用</h2><p>bind() 方法<strong>不会调用函数</strong>，但是可以改变函数内部的 this 指向。</p>\n<p>把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。</p>\n<p>语法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">新函数 = fn1.bind(想要将<span class=\"hljs-built_in\">this</span>指向哪里, 函数实参<span class=\"hljs-number\">1</span>, 函数实参<span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p>参数：</p>\n<ul>\n<li><p>第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。</p>\n</li>\n<li><p>其他参数：fn1 函数的实参。</p>\n</li>\n</ul>\n<p>解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>call</code>，<code>apply</code>和<code>bind</code>都是用来改变this的指向，但是他们在使用和功能上各有区别。</p>\n<h1 id=\"call-方法\"><a href=\"#call-方法\" class=\"headerlink\" title=\"call() 方法\"></a>call() 方法</h1><h2 id=\"call-方法的作用\"><a href=\"#call-方法的作用\" class=\"headerlink\" title=\"call() 方法的作用\"></a>call() 方法的作用</h2><p>call() 方法的作用：可以<strong>调用</strong>一个函数，与此同时，它还可以改变这个函数内部的 this 指向。</p>\n<p>call() 方法的另一个应用：<strong>可以实现继承</strong>。之所以能实现继承，其实是利用了上面的作用。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">fn1.call(想要将<span class=\"hljs-built_in\">this</span>指向哪里, 函数实参<span class=\"hljs-number\">1</span>, 函数实参<span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p>备注：第一个参数中，如果不需要改变 this 指向，则传 null。</p>\n<h2 id=\"call-方法举例\"><a href=\"#call-方法举例\" class=\"headerlink\" title=\"call() 方法举例\"></a>call() 方法举例</h2><p>举例 1、通过 call() 调用函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj1 = &#123;<br>    <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.nickName);<br>&#125;<br>fn1.call(<span class=\"hljs-built_in\">this</span>); <span class=\"hljs-comment\">// this的指向并没有被改变，此时相当于 fn1();</span><br></code></pre></td></tr></table></figure>\n<p>上方代码的打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">window</span><br><span class=\"hljs-literal\">undefined</span><br></code></pre></td></tr></table></figure>\n<p>上面的代码，跟普通的函数调用 <code>fn1()</code> 没有区别。</p>\n<p>举例 2、通过 call() 改变 this 指向：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>    <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\">a, b</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.nickName);<br>    <span class=\"hljs-built_in\">console</span>.log(a + b);<br>&#125;<br><br>fn1.call(obj1, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 先将 this 指向 obj1，然后执行 fn1() 函数</span><br></code></pre></td></tr></table></figure>\n<p>上方代码的打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">obj1<br>走花鹿<br><span class=\"hljs-number\">6</span><br></code></pre></td></tr></table></figure>\n<p>举例 3、通过 call() 实现继承：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 给 Father 增加 name 和 age 属性</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Father</span>(<span class=\"hljs-params\">myName, myAge</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.name = myName;<br>    <span class=\"hljs-built_in\">this</span>.age = myAge;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Son</span>(<span class=\"hljs-params\">myName, myAge</span>) </span>&#123;<br>    <span class=\"hljs-comment\">// 【下面这一行，重要代码】</span><br>    <span class=\"hljs-comment\">// 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承</span><br>    Father.call(<span class=\"hljs-built_in\">this</span>, myName, myAge);<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> son1 = <span class=\"hljs-keyword\">new</span> Son(<span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>, <span class=\"hljs-number\">26</span>);<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">JSON</span>.stringify(son1));<br></code></pre></td></tr></table></figure>\n<p>上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。</p>\n<p>打印结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<span class=\"hljs-attr\">&quot;myName&quot;</span>:<span class=\"hljs-string\">&quot;走花鹿&quot;</span>,<span class=\"hljs-attr\">&quot;myAge&quot;</span>:<span class=\"hljs-number\">26</span>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"apply-方法\"><a href=\"#apply-方法\" class=\"headerlink\" title=\"apply() 方法\"></a>apply() 方法</h1><h2 id=\"apply-方法的作用\"><a href=\"#apply-方法的作用\" class=\"headerlink\" title=\"apply() 方法的作用\"></a>apply() 方法的作用</h2><p>apply() 方法的作用：可以<strong>调用</strong>一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。</p>\n<p>apply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。</p>\n<h2 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">fn1.apply(想要将<span class=\"hljs-built_in\">this</span>指向哪里, [函数实参<span class=\"hljs-number\">1</span>, 函数实参<span class=\"hljs-number\">2</span>]);<br></code></pre></td></tr></table></figure>\n<p>备注：第一个参数中，如果不需要改变 this 指向，则传 null。</p>\n<p>到这里可以看出， <strong>call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。</strong></p>\n<h2 id=\"apply-方法举例\"><a href=\"#apply-方法举例\" class=\"headerlink\" title=\"apply() 方法举例\"></a>apply() 方法举例</h2><p>举例、通过 apply() 改变 this 指向：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>    <span class=\"hljs-attr\">nickName</span>: <span class=\"hljs-string\">&#x27;走花鹿&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn1</span>(<span class=\"hljs-params\">a</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.nickName);<br>    <span class=\"hljs-built_in\">console</span>.log(a);<br>&#125;<br><br>fn1.apply(obj1, [<span class=\"hljs-string\">&#x27;hello&#x27;</span>]); <span class=\"hljs-comment\">// 先将 this 指向 obj1，然后执行 fn1() 函数</span><br></code></pre></td></tr></table></figure>\n<p>注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。</p>\n<p>打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">obj1<br>走花鹿<br>hello<br></code></pre></td></tr></table></figure>\n<h2 id=\"apply-方法的巧妙应用：求数组的最大值\"><a href=\"#apply-方法的巧妙应用：求数组的最大值\" class=\"headerlink\" title=\"apply() 方法的巧妙应用：求数组的最大值\"></a>apply() 方法的巧妙应用：求数组的最大值</h2><p>我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？</p>\n<p>虽然数组里没有获取最大值的方法，但是数值里面有 <code>Math.max(数字1，数字2，数字3)</code> 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。</p>\n<p>举例：求数组中多个元素的最大值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr1 = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">8</span>];<br><br><span class=\"hljs-comment\">// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。</span><br><span class=\"hljs-keyword\">const</span> maxValue = <span class=\"hljs-built_in\">Math</span>.max.apply(<span class=\"hljs-built_in\">Math</span>, arr1); <span class=\"hljs-comment\">// 求数组 arr1 中元素的最大值</span><br><span class=\"hljs-built_in\">console</span>.log(maxValue);<br><br><span class=\"hljs-keyword\">const</span> minValue = <span class=\"hljs-built_in\">Math</span>.min.apply(<span class=\"hljs-built_in\">Math</span>, arr1); <span class=\"hljs-comment\">// 求数组 arr1 中元素的最小值</span><br><span class=\"hljs-built_in\">console</span>.log(minValue);<br></code></pre></td></tr></table></figure>\n<p>打印结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-number\">10</span><br><span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind() 方法\"></a>bind() 方法</h1><h2 id=\"bind-方法的作用\"><a href=\"#bind-方法的作用\" class=\"headerlink\" title=\"bind() 方法的作用\"></a>bind() 方法的作用</h2><p>bind() 方法<strong>不会调用函数</strong>，但是可以改变函数内部的 this 指向。</p>\n<p>把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。</p>\n<p>语法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">新函数 = fn1.bind(想要将<span class=\"hljs-built_in\">this</span>指向哪里, 函数实参<span class=\"hljs-number\">1</span>, 函数实参<span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p>参数：</p>\n<ul>\n<li><p>第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。</p>\n</li>\n<li><p>其他参数：fn1 函数的实参。</p>\n</li>\n</ul>\n<p>解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。</p>\n"},{"title":"Node.js学习记录","date":"2021-10-31T06:26:14.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n## 使用 exports 从 Node.js 文件中公开功能\n\n两种方式：\n\n1. 第一种方式是将对象赋值给 module.exports（这是模块系统提供的对象），这会使文件只导出该对象:\n\n   ```js\n   const car = {\n     brand: \"Ford\",\n     model: \"Fiesta\",\n   };\n\n   module.exports = car;\n\n   //在另一个文件中\n\n   const car = require(\"./car\");\n   ```\n\n2. 第二种方式是将要导出的对象添加为 exports 的属性。这种方式可以导出多个对象、函数或数据：\n\n   ```js\n   const car = {\n     brand: \"Ford\",\n     model: \"Fiesta\",\n   };\n\n   exports.car = car;\n   ```\n\n   或者直接\n\n   ```js\n   exports.car = {\n     brand: \"Ford\",\n     model: \"Fiesta\",\n   };\n   ```\n\n   在另一个文件中，则通过引用导入的属性来使用它：\n\n   ```js\n   const items = require(\"./items\");\n   items.car;\n   ```\n\n   或\n\n   ```js\n   const car = require(\"./items\").car;\n   ```\n\nmodule.exports 和 export 之间有什么区别？\n\n前者公开了它指向的对象。 后者公开了它指向的对象的属性。\n\n## package.json 指南\n\n`package.json` 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 `npm` 和 `yarn` 存储所有已安装软件包的名称和版本的地方。\n\n对于应用程序，`package.json` 文件中的内容没有固定的要求。 唯一的要求是必须遵守 `JSON 格式`，否则，尝试以编程的方式访问其属性的程序则无法读取它。\n\n例子：\n\n```json\n{\n  \"name\": \"test-project\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Vue.js project\",\n  \"main\": \"src/main.js\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\",\n    \"start\": \"npm run dev\",\n    \"unit\": \"jest --config test/unit/jest.conf.js --coverage\",\n    \"test\": \"npm run unit\",\n    \"lint\": \"eslint --ext .js,.vue src test/unit\",\n    \"build\": \"node build/build.js\"\n  },\n  \"dependencies\": {\n    \"vue\": \"^2.5.2\"\n  },\n  \"devDependencies\": {\n    \"autoprefixer\": \"^7.1.2\",\n    \"babel-core\": \"^6.22.1\",\n    \"babel-eslint\": \"^8.2.1\",\n    \"babel-helper-vue-jsx-merge-props\": \"^2.0.3\",\n    \"babel-jest\": \"^21.0.2\",\n    \"babel-loader\": \"^7.1.1\",\n    \"babel-plugin-dynamic-import-node\": \"^1.2.0\",\n    \"babel-plugin-syntax-jsx\": \"^6.18.0\",\n    \"babel-plugin-transform-es2015-modules-commonjs\": \"^6.26.0\",\n    \"babel-plugin-transform-runtime\": \"^6.22.0\",\n    \"babel-plugin-transform-vue-jsx\": \"^3.5.0\",\n    \"babel-preset-env\": \"^1.3.2\",\n    \"babel-preset-stage-2\": \"^6.22.0\",\n    \"chalk\": \"^2.0.1\",\n    \"copy-webpack-plugin\": \"^4.0.1\",\n    \"css-loader\": \"^0.28.0\",\n    \"eslint\": \"^4.15.0\",\n    \"eslint-config-airbnb-base\": \"^11.3.0\",\n    \"eslint-friendly-formatter\": \"^3.0.0\",\n    \"eslint-import-resolver-webpack\": \"^0.8.3\",\n    \"eslint-loader\": \"^1.7.1\",\n    \"eslint-plugin-import\": \"^2.7.0\",\n    \"eslint-plugin-vue\": \"^4.0.0\",\n    \"extract-text-webpack-plugin\": \"^3.0.0\",\n    \"file-loader\": \"^1.1.4\",\n    \"friendly-errors-webpack-plugin\": \"^1.6.1\",\n    \"html-webpack-plugin\": \"^2.30.1\",\n    \"jest\": \"^22.0.4\",\n    \"jest-serializer-vue\": \"^0.3.0\",\n    \"node-notifier\": \"^5.1.2\",\n    \"optimize-css-assets-webpack-plugin\": \"^3.2.0\",\n    \"ora\": \"^1.2.0\",\n    \"portfinder\": \"^1.0.13\",\n    \"postcss-import\": \"^11.0.0\",\n    \"postcss-loader\": \"^2.0.8\",\n    \"postcss-url\": \"^7.2.1\",\n    \"rimraf\": \"^2.6.0\",\n    \"semver\": \"^5.3.0\",\n    \"shelljs\": \"^0.7.6\",\n    \"uglifyjs-webpack-plugin\": \"^1.1.1\",\n    \"url-loader\": \"^0.5.8\",\n    \"vue-jest\": \"^1.0.2\",\n    \"vue-loader\": \"^13.3.0\",\n    \"vue-style-loader\": \"^3.0.1\",\n    \"vue-template-compiler\": \"^2.5.2\",\n    \"webpack\": \"^3.6.0\",\n    \"webpack-bundle-analyzer\": \"^2.9.0\",\n    \"webpack-dev-server\": \"^2.9.1\",\n    \"webpack-merge\": \"^4.1.0\"\n  },\n  \"engines\": {\n    \"node\": \">= 6.0.0\",\n    \"npm\": \">= 3.0.0\"\n  },\n  \"browserslist\": [\"> 1%\", \"last 2 versions\", \"not ie <= 8\"]\n}\n```\n\n这里有很多东西：\n\n- version 表明了当前的版本。\n- name 设置了应用程序/软件包的名称。\n- description 是应用程序/软件包的简短描述。\n- main 设置了应用程序的入口点。\n- private 如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。\n- scripts 定义了一组可以运行的 node 脚本。\n- dependencies 设置了作为依赖安装的 npm 软件包的列表。\n- devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。\n- engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。\n- browserslist 用于告知要支持哪些浏览器（及其版本）。\n  以上所有的这些属性都可被 npm 或其他工具使用。\n\n## package-lock.json 文件\n\n该文件旨在跟踪被安装的每个软件包的确切版本，以便产品可以以相同的方式被 100％ 复制（即使软件包的维护者更新了软件包）。\n\n## npm 依赖与开发依赖\n\n当使用 `npm install <package-name>` 安装 npm 软件包时，是将其安装为依赖项。\n\n该软件包会被自动地列出在 `package.json` 文件中的 `dependencies` 列表下（在 npm 5 之前：必须手动指定 `--save`）。\n\n当添加了 `-D` 或 `--save-dev` 标志时，则会将其安装为开发依赖项（会被添加到 `devDependencies` 列表）。\n\n开发依赖是仅用于开发的程序包，在生产环境中并不需要。 例如测试的软件包、webpack 或 Babel。\n\n当投入生产环境时，如果输入 `npm install` 且该文件夹包含 `package.json` 文件时，则会安装它们，因为 npm 会假定这是开发部署。\n\n## Node.js 包运行器 npxs\n\n- 轻松地运行本地命令\n\n  Node.js 开发者过去通常将大多数可执行命令发布为全局的软件包，以使它们处于路径中且可被立即地执行。\n\n  运行 `npx commandname` 会自动地在项目的 `node_modules` 文件夹中找到命令的正确引用，而无需知道确切的路径，也不需要在全局和用户路径中安装软件包。\n\n- 无需安装的命令执行\n\n  `npx` 的另一个重要的特性是，无需先安装命令即可运行命令。\n\n- 使用不同的 Node.js 版本运行代码\n\n- 直接从 URL 运行任意代码片段\n\n## Node.js 事件循环\n\n原文链接：[Node.js 事件循环](http://nodejs.cn/learn/the-nodejs-event-loop)\n\n### 一个简单的事件循环的阐释\n\n```js\nconst bar = () => console.log(\"bar\");\n\nconst baz = () => console.log(\"baz\");\n\nconst foo = () => {\n  console.log(\"foo\");\n  bar();\n  baz();\n};\n\nfoo();\n\n// 输出\n// foo\n// bar\n// baz\n```\n\n当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 bar()，然后调用 baz()。\n\n此时，调用堆栈如下所示：\n\n![调用堆栈](http://nodejs.cn/website2/static/270ebeb6dbfa7d613152b71257c72a9e/11a8f/call-stack-first-example.png)\n\n### 入队函数执行\n\n```js\nconst bar = () => console.log(\"bar\");\n\nconst baz = () => console.log(\"baz\");\n\nconst foo = () => {\n  console.log(\"foo\");\n  setTimeout(bar, 0);\n  baz();\n};\n\nfoo();\n\n/**\n * 打印输出：\n * foo\n * baz\n * bar\n */\n```\n\n当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 setTimeout，将 bar 作为参数传入，并传入 0 作为定时器指示它尽快运行。 然后调用 baz()。\n\n调用堆栈如图：\n![调用堆栈](http://nodejs.cn/website2/static/be55515b9343074d00b43de88c495331/966a0/call-stack-second-example.png)\n\n执行顺序是：\n![执行顺序](http://nodejs.cn/website2/static/585ff3207d814911a7e44d55fbde483b/f96db/execution-order-second-example.png)\n\n为什么会这样呢？\n\n### 消息队列\n\n当调用 `setTimeout()` 时，浏览器或 Node.js 会启动定时器。 **当定时器到期时（在此示例中会立即到期，因为将超时值设为 0），则回调函数会被放入“消息队列”中。**\n\n在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 onLoad 这样的 DOM 事件也如此。\n\n事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。\n\n我们不必等待诸如 `setTimeout`、`fetch`、或其他的函数来完成它们自身的工作，因为它们是由浏览器提供的，并且位于它们自身的线程中。 例如，如果将 setTimeout 的超时设置为 2 秒，但不必等待 2 秒，等待发生在其他地方。\n\n### ES6 作业队列\n\n`ECMAScript 2015` 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。\n\n在当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。\n\n有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。\n\n例子：\n\n```js\nconst bar = () => console.log('bar')\n\nconst baz = () => console.log('baz')\n\nconst foo = () => {\n  console.log('foo')\n  setTimeout(bar, 0)\n  new Promise((resolve, reject) =>\n    resolve('应该在 baz 之后、bar 之前')\n  ).then(resolve => console.log(resolve))\n  baz()\n}\n\nfoo()\n/**\n * 输出：\n *  foo\n *  baz\n *  应该在 baz 之后、bar 之前\n *  bar\n * /\n```\n\n这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。\n\n## 了解 process.nextTick()\n\n当尝试了解 Node.js 事件循环时，其中一个重要的部分就是 process.nextTick()。\n\n每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。\n\n当将一个函数传给 process.nextTick() 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数\n\n事件循环正在忙于处理当前的函数代码。\n\n当该操作结束时，JS 引擎会运行在该操作期间传给 nextTick 调用的所有函数。\n\n这是可以告诉 JS 引擎异步地（在当前函数之后）处理函数的方式，但是尽快执行而不是将其排入队列。\n\n调用 setTimeout(() => {}, 0) 会在下一个滴答结束时执行该函数，比使用 nextTick()（其会优先执行该调用并在下一个滴答开始之前执行该函数）晚得多。\n\n**也就是说在当前调用堆栈的执行完成后就开始执行`process.nextTick()`里面的函数**\n\n## 了解 setImmediate()\n\n作为 setImmediate() 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调。\n\n### setImmediate() 与 setTimeout(() => {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？\n\n传给 process.nextTick() 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 setTimeout 和 setImmediate 之前执行。\n\n延迟 0 毫秒的 setTimeout() 回调与 setImmediate() 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。\n","source":"_posts/2021-10-31-Node-js学习记录.md","raw":"---\ntitle: Node.js学习记录\ndate: 2021-10-31 14:26:14\ntags: [Node.js]\ncategories: 技术类-Node.js\n---\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n## 使用 exports 从 Node.js 文件中公开功能\n\n两种方式：\n\n1. 第一种方式是将对象赋值给 module.exports（这是模块系统提供的对象），这会使文件只导出该对象:\n\n   ```js\n   const car = {\n     brand: \"Ford\",\n     model: \"Fiesta\",\n   };\n\n   module.exports = car;\n\n   //在另一个文件中\n\n   const car = require(\"./car\");\n   ```\n\n2. 第二种方式是将要导出的对象添加为 exports 的属性。这种方式可以导出多个对象、函数或数据：\n\n   ```js\n   const car = {\n     brand: \"Ford\",\n     model: \"Fiesta\",\n   };\n\n   exports.car = car;\n   ```\n\n   或者直接\n\n   ```js\n   exports.car = {\n     brand: \"Ford\",\n     model: \"Fiesta\",\n   };\n   ```\n\n   在另一个文件中，则通过引用导入的属性来使用它：\n\n   ```js\n   const items = require(\"./items\");\n   items.car;\n   ```\n\n   或\n\n   ```js\n   const car = require(\"./items\").car;\n   ```\n\nmodule.exports 和 export 之间有什么区别？\n\n前者公开了它指向的对象。 后者公开了它指向的对象的属性。\n\n## package.json 指南\n\n`package.json` 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 `npm` 和 `yarn` 存储所有已安装软件包的名称和版本的地方。\n\n对于应用程序，`package.json` 文件中的内容没有固定的要求。 唯一的要求是必须遵守 `JSON 格式`，否则，尝试以编程的方式访问其属性的程序则无法读取它。\n\n例子：\n\n```json\n{\n  \"name\": \"test-project\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Vue.js project\",\n  \"main\": \"src/main.js\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\",\n    \"start\": \"npm run dev\",\n    \"unit\": \"jest --config test/unit/jest.conf.js --coverage\",\n    \"test\": \"npm run unit\",\n    \"lint\": \"eslint --ext .js,.vue src test/unit\",\n    \"build\": \"node build/build.js\"\n  },\n  \"dependencies\": {\n    \"vue\": \"^2.5.2\"\n  },\n  \"devDependencies\": {\n    \"autoprefixer\": \"^7.1.2\",\n    \"babel-core\": \"^6.22.1\",\n    \"babel-eslint\": \"^8.2.1\",\n    \"babel-helper-vue-jsx-merge-props\": \"^2.0.3\",\n    \"babel-jest\": \"^21.0.2\",\n    \"babel-loader\": \"^7.1.1\",\n    \"babel-plugin-dynamic-import-node\": \"^1.2.0\",\n    \"babel-plugin-syntax-jsx\": \"^6.18.0\",\n    \"babel-plugin-transform-es2015-modules-commonjs\": \"^6.26.0\",\n    \"babel-plugin-transform-runtime\": \"^6.22.0\",\n    \"babel-plugin-transform-vue-jsx\": \"^3.5.0\",\n    \"babel-preset-env\": \"^1.3.2\",\n    \"babel-preset-stage-2\": \"^6.22.0\",\n    \"chalk\": \"^2.0.1\",\n    \"copy-webpack-plugin\": \"^4.0.1\",\n    \"css-loader\": \"^0.28.0\",\n    \"eslint\": \"^4.15.0\",\n    \"eslint-config-airbnb-base\": \"^11.3.0\",\n    \"eslint-friendly-formatter\": \"^3.0.0\",\n    \"eslint-import-resolver-webpack\": \"^0.8.3\",\n    \"eslint-loader\": \"^1.7.1\",\n    \"eslint-plugin-import\": \"^2.7.0\",\n    \"eslint-plugin-vue\": \"^4.0.0\",\n    \"extract-text-webpack-plugin\": \"^3.0.0\",\n    \"file-loader\": \"^1.1.4\",\n    \"friendly-errors-webpack-plugin\": \"^1.6.1\",\n    \"html-webpack-plugin\": \"^2.30.1\",\n    \"jest\": \"^22.0.4\",\n    \"jest-serializer-vue\": \"^0.3.0\",\n    \"node-notifier\": \"^5.1.2\",\n    \"optimize-css-assets-webpack-plugin\": \"^3.2.0\",\n    \"ora\": \"^1.2.0\",\n    \"portfinder\": \"^1.0.13\",\n    \"postcss-import\": \"^11.0.0\",\n    \"postcss-loader\": \"^2.0.8\",\n    \"postcss-url\": \"^7.2.1\",\n    \"rimraf\": \"^2.6.0\",\n    \"semver\": \"^5.3.0\",\n    \"shelljs\": \"^0.7.6\",\n    \"uglifyjs-webpack-plugin\": \"^1.1.1\",\n    \"url-loader\": \"^0.5.8\",\n    \"vue-jest\": \"^1.0.2\",\n    \"vue-loader\": \"^13.3.0\",\n    \"vue-style-loader\": \"^3.0.1\",\n    \"vue-template-compiler\": \"^2.5.2\",\n    \"webpack\": \"^3.6.0\",\n    \"webpack-bundle-analyzer\": \"^2.9.0\",\n    \"webpack-dev-server\": \"^2.9.1\",\n    \"webpack-merge\": \"^4.1.0\"\n  },\n  \"engines\": {\n    \"node\": \">= 6.0.0\",\n    \"npm\": \">= 3.0.0\"\n  },\n  \"browserslist\": [\"> 1%\", \"last 2 versions\", \"not ie <= 8\"]\n}\n```\n\n这里有很多东西：\n\n- version 表明了当前的版本。\n- name 设置了应用程序/软件包的名称。\n- description 是应用程序/软件包的简短描述。\n- main 设置了应用程序的入口点。\n- private 如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。\n- scripts 定义了一组可以运行的 node 脚本。\n- dependencies 设置了作为依赖安装的 npm 软件包的列表。\n- devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。\n- engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。\n- browserslist 用于告知要支持哪些浏览器（及其版本）。\n  以上所有的这些属性都可被 npm 或其他工具使用。\n\n## package-lock.json 文件\n\n该文件旨在跟踪被安装的每个软件包的确切版本，以便产品可以以相同的方式被 100％ 复制（即使软件包的维护者更新了软件包）。\n\n## npm 依赖与开发依赖\n\n当使用 `npm install <package-name>` 安装 npm 软件包时，是将其安装为依赖项。\n\n该软件包会被自动地列出在 `package.json` 文件中的 `dependencies` 列表下（在 npm 5 之前：必须手动指定 `--save`）。\n\n当添加了 `-D` 或 `--save-dev` 标志时，则会将其安装为开发依赖项（会被添加到 `devDependencies` 列表）。\n\n开发依赖是仅用于开发的程序包，在生产环境中并不需要。 例如测试的软件包、webpack 或 Babel。\n\n当投入生产环境时，如果输入 `npm install` 且该文件夹包含 `package.json` 文件时，则会安装它们，因为 npm 会假定这是开发部署。\n\n## Node.js 包运行器 npxs\n\n- 轻松地运行本地命令\n\n  Node.js 开发者过去通常将大多数可执行命令发布为全局的软件包，以使它们处于路径中且可被立即地执行。\n\n  运行 `npx commandname` 会自动地在项目的 `node_modules` 文件夹中找到命令的正确引用，而无需知道确切的路径，也不需要在全局和用户路径中安装软件包。\n\n- 无需安装的命令执行\n\n  `npx` 的另一个重要的特性是，无需先安装命令即可运行命令。\n\n- 使用不同的 Node.js 版本运行代码\n\n- 直接从 URL 运行任意代码片段\n\n## Node.js 事件循环\n\n原文链接：[Node.js 事件循环](http://nodejs.cn/learn/the-nodejs-event-loop)\n\n### 一个简单的事件循环的阐释\n\n```js\nconst bar = () => console.log(\"bar\");\n\nconst baz = () => console.log(\"baz\");\n\nconst foo = () => {\n  console.log(\"foo\");\n  bar();\n  baz();\n};\n\nfoo();\n\n// 输出\n// foo\n// bar\n// baz\n```\n\n当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 bar()，然后调用 baz()。\n\n此时，调用堆栈如下所示：\n\n![调用堆栈](http://nodejs.cn/website2/static/270ebeb6dbfa7d613152b71257c72a9e/11a8f/call-stack-first-example.png)\n\n### 入队函数执行\n\n```js\nconst bar = () => console.log(\"bar\");\n\nconst baz = () => console.log(\"baz\");\n\nconst foo = () => {\n  console.log(\"foo\");\n  setTimeout(bar, 0);\n  baz();\n};\n\nfoo();\n\n/**\n * 打印输出：\n * foo\n * baz\n * bar\n */\n```\n\n当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 setTimeout，将 bar 作为参数传入，并传入 0 作为定时器指示它尽快运行。 然后调用 baz()。\n\n调用堆栈如图：\n![调用堆栈](http://nodejs.cn/website2/static/be55515b9343074d00b43de88c495331/966a0/call-stack-second-example.png)\n\n执行顺序是：\n![执行顺序](http://nodejs.cn/website2/static/585ff3207d814911a7e44d55fbde483b/f96db/execution-order-second-example.png)\n\n为什么会这样呢？\n\n### 消息队列\n\n当调用 `setTimeout()` 时，浏览器或 Node.js 会启动定时器。 **当定时器到期时（在此示例中会立即到期，因为将超时值设为 0），则回调函数会被放入“消息队列”中。**\n\n在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 onLoad 这样的 DOM 事件也如此。\n\n事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。\n\n我们不必等待诸如 `setTimeout`、`fetch`、或其他的函数来完成它们自身的工作，因为它们是由浏览器提供的，并且位于它们自身的线程中。 例如，如果将 setTimeout 的超时设置为 2 秒，但不必等待 2 秒，等待发生在其他地方。\n\n### ES6 作业队列\n\n`ECMAScript 2015` 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。\n\n在当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。\n\n有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。\n\n例子：\n\n```js\nconst bar = () => console.log('bar')\n\nconst baz = () => console.log('baz')\n\nconst foo = () => {\n  console.log('foo')\n  setTimeout(bar, 0)\n  new Promise((resolve, reject) =>\n    resolve('应该在 baz 之后、bar 之前')\n  ).then(resolve => console.log(resolve))\n  baz()\n}\n\nfoo()\n/**\n * 输出：\n *  foo\n *  baz\n *  应该在 baz 之后、bar 之前\n *  bar\n * /\n```\n\n这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。\n\n## 了解 process.nextTick()\n\n当尝试了解 Node.js 事件循环时，其中一个重要的部分就是 process.nextTick()。\n\n每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。\n\n当将一个函数传给 process.nextTick() 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数\n\n事件循环正在忙于处理当前的函数代码。\n\n当该操作结束时，JS 引擎会运行在该操作期间传给 nextTick 调用的所有函数。\n\n这是可以告诉 JS 引擎异步地（在当前函数之后）处理函数的方式，但是尽快执行而不是将其排入队列。\n\n调用 setTimeout(() => {}, 0) 会在下一个滴答结束时执行该函数，比使用 nextTick()（其会优先执行该调用并在下一个滴答开始之前执行该函数）晚得多。\n\n**也就是说在当前调用堆栈的执行完成后就开始执行`process.nextTick()`里面的函数**\n\n## 了解 setImmediate()\n\n作为 setImmediate() 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调。\n\n### setImmediate() 与 setTimeout(() => {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？\n\n传给 process.nextTick() 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 setTimeout 和 setImmediate 之前执行。\n\n延迟 0 毫秒的 setTimeout() 回调与 setImmediate() 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。\n","slug":"Node-js学习记录","published":1,"updated":"2021-12-22T08:10:56.079Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5o001k7oo9hbej736m","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h2 id=\"使用-exports-从-Node-js-文件中公开功能\"><a href=\"#使用-exports-从-Node-js-文件中公开功能\" class=\"headerlink\" title=\"使用 exports 从 Node.js 文件中公开功能\"></a>使用 exports 从 Node.js 文件中公开功能</h2><p>两种方式：</p>\n<ol>\n<li><p>第一种方式是将对象赋值给 module.exports（这是模块系统提供的对象），这会使文件只导出该对象:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> car = &#123;<br>  <span class=\"hljs-attr\">brand</span>: <span class=\"hljs-string\">&quot;Ford&quot;</span>,<br>  <span class=\"hljs-attr\">model</span>: <span class=\"hljs-string\">&quot;Fiesta&quot;</span>,<br>&#125;;<br><br><span class=\"hljs-built_in\">module</span>.exports = car;<br><br><span class=\"hljs-comment\">//在另一个文件中</span><br><br><span class=\"hljs-keyword\">const</span> car = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./car&quot;</span>);<br></code></pre></td></tr></table></figure></li>\n<li><p>第二种方式是将要导出的对象添加为 exports 的属性。这种方式可以导出多个对象、函数或数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> car = &#123;<br>  <span class=\"hljs-attr\">brand</span>: <span class=\"hljs-string\">&quot;Ford&quot;</span>,<br>  <span class=\"hljs-attr\">model</span>: <span class=\"hljs-string\">&quot;Fiesta&quot;</span>,<br>&#125;;<br><br><span class=\"hljs-built_in\">exports</span>.car = car;<br></code></pre></td></tr></table></figure>\n\n<p>或者直接</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">exports</span>.car = &#123;<br>  <span class=\"hljs-attr\">brand</span>: <span class=\"hljs-string\">&quot;Ford&quot;</span>,<br>  <span class=\"hljs-attr\">model</span>: <span class=\"hljs-string\">&quot;Fiesta&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>在另一个文件中，则通过引用导入的属性来使用它：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> items = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./items&quot;</span>);<br>items.car;<br></code></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> car = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./items&quot;</span>).car;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>module.exports 和 export 之间有什么区别？</p>\n<p>前者公开了它指向的对象。 后者公开了它指向的对象的属性。</p>\n<h2 id=\"package-json-指南\"><a href=\"#package-json-指南\" class=\"headerlink\" title=\"package.json 指南\"></a>package.json 指南</h2><p><code>package.json</code> 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 <code>npm</code> 和 <code>yarn</code> 存储所有已安装软件包的名称和版本的地方。</p>\n<p>对于应用程序，<code>package.json</code> 文件中的内容没有固定的要求。 唯一的要求是必须遵守 <code>JSON 格式</code>，否则，尝试以编程的方式访问其属性的程序则无法读取它。</p>\n<p>例子：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<br>  <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;test-project&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;A Vue.js project&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;main&quot;</span>: <span class=\"hljs-string\">&quot;src/main.js&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;private&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>  <span class=\"hljs-attr\">&quot;scripts&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;dev&quot;</span>: <span class=\"hljs-string\">&quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;start&quot;</span>: <span class=\"hljs-string\">&quot;npm run dev&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;unit&quot;</span>: <span class=\"hljs-string\">&quot;jest --config test/unit/jest.conf.js --coverage&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;test&quot;</span>: <span class=\"hljs-string\">&quot;npm run unit&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;lint&quot;</span>: <span class=\"hljs-string\">&quot;eslint --ext .js,.vue src test/unit&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;build&quot;</span>: <span class=\"hljs-string\">&quot;node build/build.js&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;dependencies&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;vue&quot;</span>: <span class=\"hljs-string\">&quot;^2.5.2&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;devDependencies&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;autoprefixer&quot;</span>: <span class=\"hljs-string\">&quot;^7.1.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-core&quot;</span>: <span class=\"hljs-string\">&quot;^6.22.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-eslint&quot;</span>: <span class=\"hljs-string\">&quot;^8.2.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-helper-vue-jsx-merge-props&quot;</span>: <span class=\"hljs-string\">&quot;^2.0.3&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-jest&quot;</span>: <span class=\"hljs-string\">&quot;^21.0.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-loader&quot;</span>: <span class=\"hljs-string\">&quot;^7.1.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-dynamic-import-node&quot;</span>: <span class=\"hljs-string\">&quot;^1.2.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-syntax-jsx&quot;</span>: <span class=\"hljs-string\">&quot;^6.18.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-transform-es2015-modules-commonjs&quot;</span>: <span class=\"hljs-string\">&quot;^6.26.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-transform-runtime&quot;</span>: <span class=\"hljs-string\">&quot;^6.22.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-transform-vue-jsx&quot;</span>: <span class=\"hljs-string\">&quot;^3.5.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-preset-env&quot;</span>: <span class=\"hljs-string\">&quot;^1.3.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-preset-stage-2&quot;</span>: <span class=\"hljs-string\">&quot;^6.22.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;chalk&quot;</span>: <span class=\"hljs-string\">&quot;^2.0.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;copy-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^4.0.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;css-loader&quot;</span>: <span class=\"hljs-string\">&quot;^0.28.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint&quot;</span>: <span class=\"hljs-string\">&quot;^4.15.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-config-airbnb-base&quot;</span>: <span class=\"hljs-string\">&quot;^11.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-friendly-formatter&quot;</span>: <span class=\"hljs-string\">&quot;^3.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-import-resolver-webpack&quot;</span>: <span class=\"hljs-string\">&quot;^0.8.3&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-loader&quot;</span>: <span class=\"hljs-string\">&quot;^1.7.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-plugin-import&quot;</span>: <span class=\"hljs-string\">&quot;^2.7.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-plugin-vue&quot;</span>: <span class=\"hljs-string\">&quot;^4.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;extract-text-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^3.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;file-loader&quot;</span>: <span class=\"hljs-string\">&quot;^1.1.4&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;friendly-errors-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^1.6.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;html-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^2.30.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;jest&quot;</span>: <span class=\"hljs-string\">&quot;^22.0.4&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;jest-serializer-vue&quot;</span>: <span class=\"hljs-string\">&quot;^0.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;node-notifier&quot;</span>: <span class=\"hljs-string\">&quot;^5.1.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;optimize-css-assets-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^3.2.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;ora&quot;</span>: <span class=\"hljs-string\">&quot;^1.2.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;portfinder&quot;</span>: <span class=\"hljs-string\">&quot;^1.0.13&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;postcss-import&quot;</span>: <span class=\"hljs-string\">&quot;^11.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;postcss-loader&quot;</span>: <span class=\"hljs-string\">&quot;^2.0.8&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;postcss-url&quot;</span>: <span class=\"hljs-string\">&quot;^7.2.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;rimraf&quot;</span>: <span class=\"hljs-string\">&quot;^2.6.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;semver&quot;</span>: <span class=\"hljs-string\">&quot;^5.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;shelljs&quot;</span>: <span class=\"hljs-string\">&quot;^0.7.6&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;uglifyjs-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^1.1.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;url-loader&quot;</span>: <span class=\"hljs-string\">&quot;^0.5.8&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-jest&quot;</span>: <span class=\"hljs-string\">&quot;^1.0.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-loader&quot;</span>: <span class=\"hljs-string\">&quot;^13.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-style-loader&quot;</span>: <span class=\"hljs-string\">&quot;^3.0.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-template-compiler&quot;</span>: <span class=\"hljs-string\">&quot;^2.5.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack&quot;</span>: <span class=\"hljs-string\">&quot;^3.6.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack-bundle-analyzer&quot;</span>: <span class=\"hljs-string\">&quot;^2.9.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack-dev-server&quot;</span>: <span class=\"hljs-string\">&quot;^2.9.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack-merge&quot;</span>: <span class=\"hljs-string\">&quot;^4.1.0&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;engines&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;node&quot;</span>: <span class=\"hljs-string\">&quot;&gt;= 6.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;npm&quot;</span>: <span class=\"hljs-string\">&quot;&gt;= 3.0.0&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;browserslist&quot;</span>: [<span class=\"hljs-string\">&quot;&gt; 1%&quot;</span>, <span class=\"hljs-string\">&quot;last 2 versions&quot;</span>, <span class=\"hljs-string\">&quot;not ie &lt;= 8&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里有很多东西：</p>\n<ul>\n<li>version 表明了当前的版本。</li>\n<li>name 设置了应用程序/软件包的名称。</li>\n<li>description 是应用程序/软件包的简短描述。</li>\n<li>main 设置了应用程序的入口点。</li>\n<li>private 如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。</li>\n<li>scripts 定义了一组可以运行的 node 脚本。</li>\n<li>dependencies 设置了作为依赖安装的 npm 软件包的列表。</li>\n<li>devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。</li>\n<li>engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。</li>\n<li>browserslist 用于告知要支持哪些浏览器（及其版本）。<br>以上所有的这些属性都可被 npm 或其他工具使用。</li>\n</ul>\n<h2 id=\"package-lock-json-文件\"><a href=\"#package-lock-json-文件\" class=\"headerlink\" title=\"package-lock.json 文件\"></a>package-lock.json 文件</h2><p>该文件旨在跟踪被安装的每个软件包的确切版本，以便产品可以以相同的方式被 100％ 复制（即使软件包的维护者更新了软件包）。</p>\n<h2 id=\"npm-依赖与开发依赖\"><a href=\"#npm-依赖与开发依赖\" class=\"headerlink\" title=\"npm 依赖与开发依赖\"></a>npm 依赖与开发依赖</h2><p>当使用 <code>npm install &lt;package-name&gt;</code> 安装 npm 软件包时，是将其安装为依赖项。</p>\n<p>该软件包会被自动地列出在 <code>package.json</code> 文件中的 <code>dependencies</code> 列表下（在 npm 5 之前：必须手动指定 <code>--save</code>）。</p>\n<p>当添加了 <code>-D</code> 或 <code>--save-dev</code> 标志时，则会将其安装为开发依赖项（会被添加到 <code>devDependencies</code> 列表）。</p>\n<p>开发依赖是仅用于开发的程序包，在生产环境中并不需要。 例如测试的软件包、webpack 或 Babel。</p>\n<p>当投入生产环境时，如果输入 <code>npm install</code> 且该文件夹包含 <code>package.json</code> 文件时，则会安装它们，因为 npm 会假定这是开发部署。</p>\n<h2 id=\"Node-js-包运行器-npxs\"><a href=\"#Node-js-包运行器-npxs\" class=\"headerlink\" title=\"Node.js 包运行器 npxs\"></a>Node.js 包运行器 npxs</h2><ul>\n<li><p>轻松地运行本地命令</p>\n<p>Node.js 开发者过去通常将大多数可执行命令发布为全局的软件包，以使它们处于路径中且可被立即地执行。</p>\n<p>运行 <code>npx commandname</code> 会自动地在项目的 <code>node_modules</code> 文件夹中找到命令的正确引用，而无需知道确切的路径，也不需要在全局和用户路径中安装软件包。</p>\n</li>\n<li><p>无需安装的命令执行</p>\n<p><code>npx</code> 的另一个重要的特性是，无需先安装命令即可运行命令。</p>\n</li>\n<li><p>使用不同的 Node.js 版本运行代码</p>\n</li>\n<li><p>直接从 URL 运行任意代码片段</p>\n</li>\n</ul>\n<h2 id=\"Node-js-事件循环\"><a href=\"#Node-js-事件循环\" class=\"headerlink\" title=\"Node.js 事件循环\"></a>Node.js 事件循环</h2><p>原文链接：<a href=\"http://nodejs.cn/learn/the-nodejs-event-loop\">Node.js 事件循环</a></p>\n<h3 id=\"一个简单的事件循环的阐释\"><a href=\"#一个简单的事件循环的阐释\" class=\"headerlink\" title=\"一个简单的事件循环的阐释\"></a>一个简单的事件循环的阐释</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;bar&quot;</span>);<br><br><span class=\"hljs-keyword\">const</span> baz = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;baz&quot;</span>);<br><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;foo&quot;</span>);<br>  bar();<br>  baz();<br>&#125;;<br><br>foo();<br><br><span class=\"hljs-comment\">// 输出</span><br><span class=\"hljs-comment\">// foo</span><br><span class=\"hljs-comment\">// bar</span><br><span class=\"hljs-comment\">// baz</span><br></code></pre></td></tr></table></figure>\n\n<p>当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 bar()，然后调用 baz()。</p>\n<p>此时，调用堆栈如下所示：</p>\n<p><img src=\"http://nodejs.cn/website2/static/270ebeb6dbfa7d613152b71257c72a9e/11a8f/call-stack-first-example.png\" alt=\"调用堆栈\"></p>\n<h3 id=\"入队函数执行\"><a href=\"#入队函数执行\" class=\"headerlink\" title=\"入队函数执行\"></a>入队函数执行</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;bar&quot;</span>);<br><br><span class=\"hljs-keyword\">const</span> baz = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;baz&quot;</span>);<br><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;foo&quot;</span>);<br>  <span class=\"hljs-built_in\">setTimeout</span>(bar, <span class=\"hljs-number\">0</span>);<br>  baz();<br>&#125;;<br><br>foo();<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 打印输出：</span><br><span class=\"hljs-comment\"> * foo</span><br><span class=\"hljs-comment\"> * baz</span><br><span class=\"hljs-comment\"> * bar</span><br><span class=\"hljs-comment\"> */</span><br></code></pre></td></tr></table></figure>\n\n<p>当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 setTimeout，将 bar 作为参数传入，并传入 0 作为定时器指示它尽快运行。 然后调用 baz()。</p>\n<p>调用堆栈如图：<br><img src=\"http://nodejs.cn/website2/static/be55515b9343074d00b43de88c495331/966a0/call-stack-second-example.png\" alt=\"调用堆栈\"></p>\n<p>执行顺序是：<br><img src=\"http://nodejs.cn/website2/static/585ff3207d814911a7e44d55fbde483b/f96db/execution-order-second-example.png\" alt=\"执行顺序\"></p>\n<p>为什么会这样呢？</p>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><p>当调用 <code>setTimeout()</code> 时，浏览器或 Node.js 会启动定时器。 <strong>当定时器到期时（在此示例中会立即到期，因为将超时值设为 0），则回调函数会被放入“消息队列”中。</strong></p>\n<p>在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 onLoad 这样的 DOM 事件也如此。</p>\n<p>事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。</p>\n<p>我们不必等待诸如 <code>setTimeout</code>、<code>fetch</code>、或其他的函数来完成它们自身的工作，因为它们是由浏览器提供的，并且位于它们自身的线程中。 例如，如果将 setTimeout 的超时设置为 2 秒，但不必等待 2 秒，等待发生在其他地方。</p>\n<h3 id=\"ES6-作业队列\"><a href=\"#ES6-作业队列\" class=\"headerlink\" title=\"ES6 作业队列\"></a>ES6 作业队列</h3><p><code>ECMAScript 2015</code> 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。</p>\n<p>在当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。</p>\n<p>有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。</p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;bar&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> baz = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;baz&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>  <span class=\"hljs-built_in\">setTimeout</span>(bar, <span class=\"hljs-number\">0</span>)<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span><br>    resolve(<span class=\"hljs-string\">&#x27;应该在 baz 之后、bar 之前&#x27;</span>)<br>  ).then(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(resolve))<br>  baz()<br>&#125;<br><br>foo()<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 输出：</span><br><span class=\"hljs-comment\"> *  foo</span><br><span class=\"hljs-comment\"> *  baz</span><br><span class=\"hljs-comment\"> *  应该在 baz 之后、bar 之前</span><br><span class=\"hljs-comment\"> *  bar</span><br><span class=\"hljs-comment\"> * /</span><br></code></pre></td></tr></table></figure>\n\n<p>这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。</p>\n<h2 id=\"了解-process-nextTick\"><a href=\"#了解-process-nextTick\" class=\"headerlink\" title=\"了解 process.nextTick()\"></a>了解 process.nextTick()</h2><p>当尝试了解 Node.js 事件循环时，其中一个重要的部分就是 process.nextTick()。</p>\n<p>每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。</p>\n<p>当将一个函数传给 process.nextTick() 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数</p>\n<p>事件循环正在忙于处理当前的函数代码。</p>\n<p>当该操作结束时，JS 引擎会运行在该操作期间传给 nextTick 调用的所有函数。</p>\n<p>这是可以告诉 JS 引擎异步地（在当前函数之后）处理函数的方式，但是尽快执行而不是将其排入队列。</p>\n<p>调用 setTimeout(() =&gt; {}, 0) 会在下一个滴答结束时执行该函数，比使用 nextTick()（其会优先执行该调用并在下一个滴答开始之前执行该函数）晚得多。</p>\n<p><strong>也就是说在当前调用堆栈的执行完成后就开始执行<code>process.nextTick()</code>里面的函数</strong></p>\n<h2 id=\"了解-setImmediate\"><a href=\"#了解-setImmediate\" class=\"headerlink\" title=\"了解 setImmediate()\"></a>了解 setImmediate()</h2><p>作为 setImmediate() 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调。</p>\n<h3 id=\"setImmediate-与-setTimeout-gt-0-（传入-0-毫秒的超时）、process-nextTick-有何不同？\"><a href=\"#setImmediate-与-setTimeout-gt-0-（传入-0-毫秒的超时）、process-nextTick-有何不同？\" class=\"headerlink\" title=\"setImmediate() 与 setTimeout(() =&gt; {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？\"></a>setImmediate() 与 setTimeout(() =&gt; {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？</h3><p>传给 process.nextTick() 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 setTimeout 和 setImmediate 之前执行。</p>\n<p>延迟 0 毫秒的 setTimeout() 回调与 setImmediate() 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h2 id=\"使用-exports-从-Node-js-文件中公开功能\"><a href=\"#使用-exports-从-Node-js-文件中公开功能\" class=\"headerlink\" title=\"使用 exports 从 Node.js 文件中公开功能\"></a>使用 exports 从 Node.js 文件中公开功能</h2><p>两种方式：</p>\n<ol>\n<li><p>第一种方式是将对象赋值给 module.exports（这是模块系统提供的对象），这会使文件只导出该对象:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> car = &#123;<br>  <span class=\"hljs-attr\">brand</span>: <span class=\"hljs-string\">&quot;Ford&quot;</span>,<br>  <span class=\"hljs-attr\">model</span>: <span class=\"hljs-string\">&quot;Fiesta&quot;</span>,<br>&#125;;<br><br><span class=\"hljs-built_in\">module</span>.exports = car;<br><br><span class=\"hljs-comment\">//在另一个文件中</span><br><br><span class=\"hljs-keyword\">const</span> car = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./car&quot;</span>);<br></code></pre></td></tr></table></figure></li>\n<li><p>第二种方式是将要导出的对象添加为 exports 的属性。这种方式可以导出多个对象、函数或数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> car = &#123;<br>  <span class=\"hljs-attr\">brand</span>: <span class=\"hljs-string\">&quot;Ford&quot;</span>,<br>  <span class=\"hljs-attr\">model</span>: <span class=\"hljs-string\">&quot;Fiesta&quot;</span>,<br>&#125;;<br><br><span class=\"hljs-built_in\">exports</span>.car = car;<br></code></pre></td></tr></table></figure>\n\n<p>或者直接</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">exports</span>.car = &#123;<br>  <span class=\"hljs-attr\">brand</span>: <span class=\"hljs-string\">&quot;Ford&quot;</span>,<br>  <span class=\"hljs-attr\">model</span>: <span class=\"hljs-string\">&quot;Fiesta&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>在另一个文件中，则通过引用导入的属性来使用它：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> items = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./items&quot;</span>);<br>items.car;<br></code></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> car = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./items&quot;</span>).car;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>module.exports 和 export 之间有什么区别？</p>\n<p>前者公开了它指向的对象。 后者公开了它指向的对象的属性。</p>\n<h2 id=\"package-json-指南\"><a href=\"#package-json-指南\" class=\"headerlink\" title=\"package.json 指南\"></a>package.json 指南</h2><p><code>package.json</code> 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 <code>npm</code> 和 <code>yarn</code> 存储所有已安装软件包的名称和版本的地方。</p>\n<p>对于应用程序，<code>package.json</code> 文件中的内容没有固定的要求。 唯一的要求是必须遵守 <code>JSON 格式</code>，否则，尝试以编程的方式访问其属性的程序则无法读取它。</p>\n<p>例子：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<br>  <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;test-project&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;A Vue.js project&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;main&quot;</span>: <span class=\"hljs-string\">&quot;src/main.js&quot;</span>,<br>  <span class=\"hljs-attr\">&quot;private&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>  <span class=\"hljs-attr\">&quot;scripts&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;dev&quot;</span>: <span class=\"hljs-string\">&quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;start&quot;</span>: <span class=\"hljs-string\">&quot;npm run dev&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;unit&quot;</span>: <span class=\"hljs-string\">&quot;jest --config test/unit/jest.conf.js --coverage&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;test&quot;</span>: <span class=\"hljs-string\">&quot;npm run unit&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;lint&quot;</span>: <span class=\"hljs-string\">&quot;eslint --ext .js,.vue src test/unit&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;build&quot;</span>: <span class=\"hljs-string\">&quot;node build/build.js&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;dependencies&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;vue&quot;</span>: <span class=\"hljs-string\">&quot;^2.5.2&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;devDependencies&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;autoprefixer&quot;</span>: <span class=\"hljs-string\">&quot;^7.1.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-core&quot;</span>: <span class=\"hljs-string\">&quot;^6.22.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-eslint&quot;</span>: <span class=\"hljs-string\">&quot;^8.2.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-helper-vue-jsx-merge-props&quot;</span>: <span class=\"hljs-string\">&quot;^2.0.3&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-jest&quot;</span>: <span class=\"hljs-string\">&quot;^21.0.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-loader&quot;</span>: <span class=\"hljs-string\">&quot;^7.1.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-dynamic-import-node&quot;</span>: <span class=\"hljs-string\">&quot;^1.2.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-syntax-jsx&quot;</span>: <span class=\"hljs-string\">&quot;^6.18.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-transform-es2015-modules-commonjs&quot;</span>: <span class=\"hljs-string\">&quot;^6.26.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-transform-runtime&quot;</span>: <span class=\"hljs-string\">&quot;^6.22.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-plugin-transform-vue-jsx&quot;</span>: <span class=\"hljs-string\">&quot;^3.5.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-preset-env&quot;</span>: <span class=\"hljs-string\">&quot;^1.3.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;babel-preset-stage-2&quot;</span>: <span class=\"hljs-string\">&quot;^6.22.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;chalk&quot;</span>: <span class=\"hljs-string\">&quot;^2.0.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;copy-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^4.0.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;css-loader&quot;</span>: <span class=\"hljs-string\">&quot;^0.28.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint&quot;</span>: <span class=\"hljs-string\">&quot;^4.15.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-config-airbnb-base&quot;</span>: <span class=\"hljs-string\">&quot;^11.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-friendly-formatter&quot;</span>: <span class=\"hljs-string\">&quot;^3.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-import-resolver-webpack&quot;</span>: <span class=\"hljs-string\">&quot;^0.8.3&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-loader&quot;</span>: <span class=\"hljs-string\">&quot;^1.7.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-plugin-import&quot;</span>: <span class=\"hljs-string\">&quot;^2.7.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;eslint-plugin-vue&quot;</span>: <span class=\"hljs-string\">&quot;^4.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;extract-text-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^3.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;file-loader&quot;</span>: <span class=\"hljs-string\">&quot;^1.1.4&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;friendly-errors-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^1.6.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;html-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^2.30.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;jest&quot;</span>: <span class=\"hljs-string\">&quot;^22.0.4&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;jest-serializer-vue&quot;</span>: <span class=\"hljs-string\">&quot;^0.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;node-notifier&quot;</span>: <span class=\"hljs-string\">&quot;^5.1.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;optimize-css-assets-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^3.2.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;ora&quot;</span>: <span class=\"hljs-string\">&quot;^1.2.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;portfinder&quot;</span>: <span class=\"hljs-string\">&quot;^1.0.13&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;postcss-import&quot;</span>: <span class=\"hljs-string\">&quot;^11.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;postcss-loader&quot;</span>: <span class=\"hljs-string\">&quot;^2.0.8&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;postcss-url&quot;</span>: <span class=\"hljs-string\">&quot;^7.2.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;rimraf&quot;</span>: <span class=\"hljs-string\">&quot;^2.6.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;semver&quot;</span>: <span class=\"hljs-string\">&quot;^5.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;shelljs&quot;</span>: <span class=\"hljs-string\">&quot;^0.7.6&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;uglifyjs-webpack-plugin&quot;</span>: <span class=\"hljs-string\">&quot;^1.1.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;url-loader&quot;</span>: <span class=\"hljs-string\">&quot;^0.5.8&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-jest&quot;</span>: <span class=\"hljs-string\">&quot;^1.0.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-loader&quot;</span>: <span class=\"hljs-string\">&quot;^13.3.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-style-loader&quot;</span>: <span class=\"hljs-string\">&quot;^3.0.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;vue-template-compiler&quot;</span>: <span class=\"hljs-string\">&quot;^2.5.2&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack&quot;</span>: <span class=\"hljs-string\">&quot;^3.6.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack-bundle-analyzer&quot;</span>: <span class=\"hljs-string\">&quot;^2.9.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack-dev-server&quot;</span>: <span class=\"hljs-string\">&quot;^2.9.1&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;webpack-merge&quot;</span>: <span class=\"hljs-string\">&quot;^4.1.0&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;engines&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;node&quot;</span>: <span class=\"hljs-string\">&quot;&gt;= 6.0.0&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;npm&quot;</span>: <span class=\"hljs-string\">&quot;&gt;= 3.0.0&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">&quot;browserslist&quot;</span>: [<span class=\"hljs-string\">&quot;&gt; 1%&quot;</span>, <span class=\"hljs-string\">&quot;last 2 versions&quot;</span>, <span class=\"hljs-string\">&quot;not ie &lt;= 8&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里有很多东西：</p>\n<ul>\n<li>version 表明了当前的版本。</li>\n<li>name 设置了应用程序/软件包的名称。</li>\n<li>description 是应用程序/软件包的简短描述。</li>\n<li>main 设置了应用程序的入口点。</li>\n<li>private 如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。</li>\n<li>scripts 定义了一组可以运行的 node 脚本。</li>\n<li>dependencies 设置了作为依赖安装的 npm 软件包的列表。</li>\n<li>devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。</li>\n<li>engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。</li>\n<li>browserslist 用于告知要支持哪些浏览器（及其版本）。<br>以上所有的这些属性都可被 npm 或其他工具使用。</li>\n</ul>\n<h2 id=\"package-lock-json-文件\"><a href=\"#package-lock-json-文件\" class=\"headerlink\" title=\"package-lock.json 文件\"></a>package-lock.json 文件</h2><p>该文件旨在跟踪被安装的每个软件包的确切版本，以便产品可以以相同的方式被 100％ 复制（即使软件包的维护者更新了软件包）。</p>\n<h2 id=\"npm-依赖与开发依赖\"><a href=\"#npm-依赖与开发依赖\" class=\"headerlink\" title=\"npm 依赖与开发依赖\"></a>npm 依赖与开发依赖</h2><p>当使用 <code>npm install &lt;package-name&gt;</code> 安装 npm 软件包时，是将其安装为依赖项。</p>\n<p>该软件包会被自动地列出在 <code>package.json</code> 文件中的 <code>dependencies</code> 列表下（在 npm 5 之前：必须手动指定 <code>--save</code>）。</p>\n<p>当添加了 <code>-D</code> 或 <code>--save-dev</code> 标志时，则会将其安装为开发依赖项（会被添加到 <code>devDependencies</code> 列表）。</p>\n<p>开发依赖是仅用于开发的程序包，在生产环境中并不需要。 例如测试的软件包、webpack 或 Babel。</p>\n<p>当投入生产环境时，如果输入 <code>npm install</code> 且该文件夹包含 <code>package.json</code> 文件时，则会安装它们，因为 npm 会假定这是开发部署。</p>\n<h2 id=\"Node-js-包运行器-npxs\"><a href=\"#Node-js-包运行器-npxs\" class=\"headerlink\" title=\"Node.js 包运行器 npxs\"></a>Node.js 包运行器 npxs</h2><ul>\n<li><p>轻松地运行本地命令</p>\n<p>Node.js 开发者过去通常将大多数可执行命令发布为全局的软件包，以使它们处于路径中且可被立即地执行。</p>\n<p>运行 <code>npx commandname</code> 会自动地在项目的 <code>node_modules</code> 文件夹中找到命令的正确引用，而无需知道确切的路径，也不需要在全局和用户路径中安装软件包。</p>\n</li>\n<li><p>无需安装的命令执行</p>\n<p><code>npx</code> 的另一个重要的特性是，无需先安装命令即可运行命令。</p>\n</li>\n<li><p>使用不同的 Node.js 版本运行代码</p>\n</li>\n<li><p>直接从 URL 运行任意代码片段</p>\n</li>\n</ul>\n<h2 id=\"Node-js-事件循环\"><a href=\"#Node-js-事件循环\" class=\"headerlink\" title=\"Node.js 事件循环\"></a>Node.js 事件循环</h2><p>原文链接：<a href=\"http://nodejs.cn/learn/the-nodejs-event-loop\">Node.js 事件循环</a></p>\n<h3 id=\"一个简单的事件循环的阐释\"><a href=\"#一个简单的事件循环的阐释\" class=\"headerlink\" title=\"一个简单的事件循环的阐释\"></a>一个简单的事件循环的阐释</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;bar&quot;</span>);<br><br><span class=\"hljs-keyword\">const</span> baz = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;baz&quot;</span>);<br><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;foo&quot;</span>);<br>  bar();<br>  baz();<br>&#125;;<br><br>foo();<br><br><span class=\"hljs-comment\">// 输出</span><br><span class=\"hljs-comment\">// foo</span><br><span class=\"hljs-comment\">// bar</span><br><span class=\"hljs-comment\">// baz</span><br></code></pre></td></tr></table></figure>\n\n<p>当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 bar()，然后调用 baz()。</p>\n<p>此时，调用堆栈如下所示：</p>\n<p><img src=\"http://nodejs.cn/website2/static/270ebeb6dbfa7d613152b71257c72a9e/11a8f/call-stack-first-example.png\" alt=\"调用堆栈\"></p>\n<h3 id=\"入队函数执行\"><a href=\"#入队函数执行\" class=\"headerlink\" title=\"入队函数执行\"></a>入队函数执行</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;bar&quot;</span>);<br><br><span class=\"hljs-keyword\">const</span> baz = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;baz&quot;</span>);<br><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;foo&quot;</span>);<br>  <span class=\"hljs-built_in\">setTimeout</span>(bar, <span class=\"hljs-number\">0</span>);<br>  baz();<br>&#125;;<br><br>foo();<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 打印输出：</span><br><span class=\"hljs-comment\"> * foo</span><br><span class=\"hljs-comment\"> * baz</span><br><span class=\"hljs-comment\"> * bar</span><br><span class=\"hljs-comment\"> */</span><br></code></pre></td></tr></table></figure>\n\n<p>当运行此代码时，会首先调用 foo()。 在 foo() 内部，会首先调用 setTimeout，将 bar 作为参数传入，并传入 0 作为定时器指示它尽快运行。 然后调用 baz()。</p>\n<p>调用堆栈如图：<br><img src=\"http://nodejs.cn/website2/static/be55515b9343074d00b43de88c495331/966a0/call-stack-second-example.png\" alt=\"调用堆栈\"></p>\n<p>执行顺序是：<br><img src=\"http://nodejs.cn/website2/static/585ff3207d814911a7e44d55fbde483b/f96db/execution-order-second-example.png\" alt=\"执行顺序\"></p>\n<p>为什么会这样呢？</p>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><p>当调用 <code>setTimeout()</code> 时，浏览器或 Node.js 会启动定时器。 <strong>当定时器到期时（在此示例中会立即到期，因为将超时值设为 0），则回调函数会被放入“消息队列”中。</strong></p>\n<p>在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 onLoad 这样的 DOM 事件也如此。</p>\n<p>事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。</p>\n<p>我们不必等待诸如 <code>setTimeout</code>、<code>fetch</code>、或其他的函数来完成它们自身的工作，因为它们是由浏览器提供的，并且位于它们自身的线程中。 例如，如果将 setTimeout 的超时设置为 2 秒，但不必等待 2 秒，等待发生在其他地方。</p>\n<h3 id=\"ES6-作业队列\"><a href=\"#ES6-作业队列\" class=\"headerlink\" title=\"ES6 作业队列\"></a>ES6 作业队列</h3><p><code>ECMAScript 2015</code> 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。</p>\n<p>在当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。</p>\n<p>有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。</p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;bar&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> baz = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;baz&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>  <span class=\"hljs-built_in\">setTimeout</span>(bar, <span class=\"hljs-number\">0</span>)<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span><br>    resolve(<span class=\"hljs-string\">&#x27;应该在 baz 之后、bar 之前&#x27;</span>)<br>  ).then(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(resolve))<br>  baz()<br>&#125;<br><br>foo()<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 输出：</span><br><span class=\"hljs-comment\"> *  foo</span><br><span class=\"hljs-comment\"> *  baz</span><br><span class=\"hljs-comment\"> *  应该在 baz 之后、bar 之前</span><br><span class=\"hljs-comment\"> *  bar</span><br><span class=\"hljs-comment\"> * /</span><br></code></pre></td></tr></table></figure>\n\n<p>这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。</p>\n<h2 id=\"了解-process-nextTick\"><a href=\"#了解-process-nextTick\" class=\"headerlink\" title=\"了解 process.nextTick()\"></a>了解 process.nextTick()</h2><p>当尝试了解 Node.js 事件循环时，其中一个重要的部分就是 process.nextTick()。</p>\n<p>每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。</p>\n<p>当将一个函数传给 process.nextTick() 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数</p>\n<p>事件循环正在忙于处理当前的函数代码。</p>\n<p>当该操作结束时，JS 引擎会运行在该操作期间传给 nextTick 调用的所有函数。</p>\n<p>这是可以告诉 JS 引擎异步地（在当前函数之后）处理函数的方式，但是尽快执行而不是将其排入队列。</p>\n<p>调用 setTimeout(() =&gt; {}, 0) 会在下一个滴答结束时执行该函数，比使用 nextTick()（其会优先执行该调用并在下一个滴答开始之前执行该函数）晚得多。</p>\n<p><strong>也就是说在当前调用堆栈的执行完成后就开始执行<code>process.nextTick()</code>里面的函数</strong></p>\n<h2 id=\"了解-setImmediate\"><a href=\"#了解-setImmediate\" class=\"headerlink\" title=\"了解 setImmediate()\"></a>了解 setImmediate()</h2><p>作为 setImmediate() 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调。</p>\n<h3 id=\"setImmediate-与-setTimeout-gt-0-（传入-0-毫秒的超时）、process-nextTick-有何不同？\"><a href=\"#setImmediate-与-setTimeout-gt-0-（传入-0-毫秒的超时）、process-nextTick-有何不同？\" class=\"headerlink\" title=\"setImmediate() 与 setTimeout(() =&gt; {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？\"></a>setImmediate() 与 setTimeout(() =&gt; {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？</h3><p>传给 process.nextTick() 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 setTimeout 和 setImmediate 之前执行。</p>\n<p>延迟 0 毫秒的 setTimeout() 回调与 setImmediate() 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。</p>\n"},{"title":"最近在忙什么","date":"2021-11-18T08:59:09.000Z","_content":"最近在做一个个人的全栈项目\n\n前端技术栈是：Vite+Vue3+TypeScript+Scss\n\n后端技术栈是：NodeJs+Express+MySQL\n\n已经上线一部分功能,部署在阿里云上了\n\n目前没啥功能。后续会慢慢完善优化\n\n地址在：www.hjzouhualu.com\n","source":"_posts/2021-11-18-最近在忙什么.md","raw":"---\ntitle: 最近在忙什么\ndate: 2021-11-18 16:59:09\ntags:\n- [日常]\ncategories:\n- [日常]\n---\n最近在做一个个人的全栈项目\n\n前端技术栈是：Vite+Vue3+TypeScript+Scss\n\n后端技术栈是：NodeJs+Express+MySQL\n\n已经上线一部分功能,部署在阿里云上了\n\n目前没啥功能。后续会慢慢完善优化\n\n地址在：www.hjzouhualu.com\n","slug":"最近在忙什么","published":1,"updated":"2021-11-18T09:06:06.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5q001n7oo9av9bc76h","content":"<p>最近在做一个个人的全栈项目</p>\n<p>前端技术栈是：Vite+Vue3+TypeScript+Scss</p>\n<p>后端技术栈是：NodeJs+Express+MySQL</p>\n<p>已经上线一部分功能,部署在阿里云上了</p>\n<p>目前没啥功能。后续会慢慢完善优化</p>\n<p>地址在：<a href=\"http://www.hjzouhualu.com/\">www.hjzouhualu.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在做一个个人的全栈项目</p>\n<p>前端技术栈是：Vite+Vue3+TypeScript+Scss</p>\n<p>后端技术栈是：NodeJs+Express+MySQL</p>\n<p>已经上线一部分功能,部署在阿里云上了</p>\n<p>目前没啥功能。后续会慢慢完善优化</p>\n<p>地址在：<a href=\"http://www.hjzouhualu.com/\">www.hjzouhualu.com</a></p>\n"},{"title":"create-react-app 搭建项目踩坑记录","date":"2021-11-29T11:44:25.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n\n# 中文说明\n\n## 搭建前端开发环境笔记\n\n由`npx create-react-app articles_published_system`创建的项目\n\n后来漏掉了`typescript`支持，原本可以由命令`npx create-react-app articles_published_system --template typescript`可以直接创建支持ts的应用\n\n后续要将ts添加到已有项目中，用以下命令：\n\n`npm install --save typescript @types/node @types/react @types/react-dom @types/jest`\n\n项目中配置`sass`:\n\n1. 执行`yarn add node-sass`下载包（按理说执行`npm install node-sass --save`也应该有用，但是我这边报错了）。\n\n    报错如下：\n\n    ![npm安装sass报错](https://upload-images.jianshu.io/upload_images/13931286-44bf5ea859ce44fd.png?imageMogr2/auto-orient/strip|imageView2/2/w/672/format/webp)\n\n    我的vscode和node版本都是最新的\n\n    建议大家用`yarn`来安装项目\n\n    **发现启动后sass会报错**\n\n    解决办法：sass指定版本为`^1.43.5`，postcss-pxtorem为`^5.1.1`，不要安装node-sass了\n\n    前端生态配置仍然复杂\n\n2. 将样式文件后缀改为`.scss`并在tsx或者js文件中引入，项目会自动编译。\n\n为了实现自适应，给项目配置postcss-pxtorem\n\n1. 执行`yarn add lib-flexible postcss-pxtorem`\n\n2. 在应用入口引入`import 'lib-flexible'`\n\n3. 执行`npm run eject`可以打开`create-react-app`应用的配置文件\n\n4. 在`config/webpack.config.js`文件中配置postcss，位置及方法如下图：\n\n![引入postcss](https://upload-images.jianshu.io/upload_images/13931286-da7732a5f0bf175d.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)\n\n![配置postcss](https://upload-images.jianshu.io/upload_images/13931286-7f538e5227508fa5.png?imageMogr2/auto-orient/strip|imageView2/2/w/630/format/webp)\n\nUI库使用antdesign\n\n1. 安装antd，`yarn add antd`\n\n2. 在App.css 中导入样式`@import '~antd/dist/antd.css'`，然后在组件中引入相应的ui组件就可以用了。\n\n---\n\n完~","source":"_posts/2021-11-29-create-react-app-搭建项目踩坑记录.md","raw":"---\ntitle: create-react-app 搭建项目踩坑记录\ndate: 2021-11-29 19:44:25\ntags: React\ncategories: 技术类-React\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n\n# 中文说明\n\n## 搭建前端开发环境笔记\n\n由`npx create-react-app articles_published_system`创建的项目\n\n后来漏掉了`typescript`支持，原本可以由命令`npx create-react-app articles_published_system --template typescript`可以直接创建支持ts的应用\n\n后续要将ts添加到已有项目中，用以下命令：\n\n`npm install --save typescript @types/node @types/react @types/react-dom @types/jest`\n\n项目中配置`sass`:\n\n1. 执行`yarn add node-sass`下载包（按理说执行`npm install node-sass --save`也应该有用，但是我这边报错了）。\n\n    报错如下：\n\n    ![npm安装sass报错](https://upload-images.jianshu.io/upload_images/13931286-44bf5ea859ce44fd.png?imageMogr2/auto-orient/strip|imageView2/2/w/672/format/webp)\n\n    我的vscode和node版本都是最新的\n\n    建议大家用`yarn`来安装项目\n\n    **发现启动后sass会报错**\n\n    解决办法：sass指定版本为`^1.43.5`，postcss-pxtorem为`^5.1.1`，不要安装node-sass了\n\n    前端生态配置仍然复杂\n\n2. 将样式文件后缀改为`.scss`并在tsx或者js文件中引入，项目会自动编译。\n\n为了实现自适应，给项目配置postcss-pxtorem\n\n1. 执行`yarn add lib-flexible postcss-pxtorem`\n\n2. 在应用入口引入`import 'lib-flexible'`\n\n3. 执行`npm run eject`可以打开`create-react-app`应用的配置文件\n\n4. 在`config/webpack.config.js`文件中配置postcss，位置及方法如下图：\n\n![引入postcss](https://upload-images.jianshu.io/upload_images/13931286-da7732a5f0bf175d.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)\n\n![配置postcss](https://upload-images.jianshu.io/upload_images/13931286-7f538e5227508fa5.png?imageMogr2/auto-orient/strip|imageView2/2/w/630/format/webp)\n\nUI库使用antdesign\n\n1. 安装antd，`yarn add antd`\n\n2. 在App.css 中导入样式`@import '~antd/dist/antd.css'`，然后在组件中引入相应的ui组件就可以用了。\n\n---\n\n完~","slug":"create-react-app-搭建项目踩坑记录","published":1,"updated":"2021-12-01T02:45:37.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5t001q7oo9f7uj30pz","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n\n<h1 id=\"中文说明\"><a href=\"#中文说明\" class=\"headerlink\" title=\"中文说明\"></a>中文说明</h1><h2 id=\"搭建前端开发环境笔记\"><a href=\"#搭建前端开发环境笔记\" class=\"headerlink\" title=\"搭建前端开发环境笔记\"></a>搭建前端开发环境笔记</h2><p>由<code>npx create-react-app articles_published_system</code>创建的项目</p>\n<p>后来漏掉了<code>typescript</code>支持，原本可以由命令<code>npx create-react-app articles_published_system --template typescript</code>可以直接创建支持ts的应用</p>\n<p>后续要将ts添加到已有项目中，用以下命令：</p>\n<p><code>npm install --save typescript @types/node @types/react @types/react-dom @types/jest</code></p>\n<p>项目中配置<code>sass</code>:</p>\n<ol>\n<li><p>执行<code>yarn add node-sass</code>下载包（按理说执行<code>npm install node-sass --save</code>也应该有用，但是我这边报错了）。</p>\n<p> 报错如下：</p>\n<p> <img src=\"https://upload-images.jianshu.io/upload_images/13931286-44bf5ea859ce44fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/672/format/webp\" alt=\"npm安装sass报错\"></p>\n<p> 我的vscode和node版本都是最新的</p>\n<p> 建议大家用<code>yarn</code>来安装项目</p>\n<p> <strong>发现启动后sass会报错</strong></p>\n<p> 解决办法：sass指定版本为<code>^1.43.5</code>，postcss-pxtorem为<code>^5.1.1</code>，不要安装node-sass了</p>\n<p> 前端生态配置仍然复杂</p>\n</li>\n<li><p>将样式文件后缀改为<code>.scss</code>并在tsx或者js文件中引入，项目会自动编译。</p>\n</li>\n</ol>\n<p>为了实现自适应，给项目配置postcss-pxtorem</p>\n<ol>\n<li><p>执行<code>yarn add lib-flexible postcss-pxtorem</code></p>\n</li>\n<li><p>在应用入口引入<code>import &#39;lib-flexible&#39;</code></p>\n</li>\n<li><p>执行<code>npm run eject</code>可以打开<code>create-react-app</code>应用的配置文件</p>\n</li>\n<li><p>在<code>config/webpack.config.js</code>文件中配置postcss，位置及方法如下图：</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-da7732a5f0bf175d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp\" alt=\"引入postcss\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-7f538e5227508fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp\" alt=\"配置postcss\"></p>\n<p>UI库使用antdesign</p>\n<ol>\n<li><p>安装antd，<code>yarn add antd</code></p>\n</li>\n<li><p>在App.css 中导入样式<code>@import &#39;~antd/dist/antd.css&#39;</code>，然后在组件中引入相应的ui组件就可以用了。</p>\n</li>\n</ol>\n<hr>\n<p>完~</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n\n<h1 id=\"中文说明\"><a href=\"#中文说明\" class=\"headerlink\" title=\"中文说明\"></a>中文说明</h1><h2 id=\"搭建前端开发环境笔记\"><a href=\"#搭建前端开发环境笔记\" class=\"headerlink\" title=\"搭建前端开发环境笔记\"></a>搭建前端开发环境笔记</h2><p>由<code>npx create-react-app articles_published_system</code>创建的项目</p>\n<p>后来漏掉了<code>typescript</code>支持，原本可以由命令<code>npx create-react-app articles_published_system --template typescript</code>可以直接创建支持ts的应用</p>\n<p>后续要将ts添加到已有项目中，用以下命令：</p>\n<p><code>npm install --save typescript @types/node @types/react @types/react-dom @types/jest</code></p>\n<p>项目中配置<code>sass</code>:</p>\n<ol>\n<li><p>执行<code>yarn add node-sass</code>下载包（按理说执行<code>npm install node-sass --save</code>也应该有用，但是我这边报错了）。</p>\n<p> 报错如下：</p>\n<p> <img src=\"https://upload-images.jianshu.io/upload_images/13931286-44bf5ea859ce44fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/672/format/webp\" alt=\"npm安装sass报错\"></p>\n<p> 我的vscode和node版本都是最新的</p>\n<p> 建议大家用<code>yarn</code>来安装项目</p>\n<p> <strong>发现启动后sass会报错</strong></p>\n<p> 解决办法：sass指定版本为<code>^1.43.5</code>，postcss-pxtorem为<code>^5.1.1</code>，不要安装node-sass了</p>\n<p> 前端生态配置仍然复杂</p>\n</li>\n<li><p>将样式文件后缀改为<code>.scss</code>并在tsx或者js文件中引入，项目会自动编译。</p>\n</li>\n</ol>\n<p>为了实现自适应，给项目配置postcss-pxtorem</p>\n<ol>\n<li><p>执行<code>yarn add lib-flexible postcss-pxtorem</code></p>\n</li>\n<li><p>在应用入口引入<code>import &#39;lib-flexible&#39;</code></p>\n</li>\n<li><p>执行<code>npm run eject</code>可以打开<code>create-react-app</code>应用的配置文件</p>\n</li>\n<li><p>在<code>config/webpack.config.js</code>文件中配置postcss，位置及方法如下图：</p>\n</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-da7732a5f0bf175d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp\" alt=\"引入postcss\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-7f538e5227508fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp\" alt=\"配置postcss\"></p>\n<p>UI库使用antdesign</p>\n<ol>\n<li><p>安装antd，<code>yarn add antd</code></p>\n</li>\n<li><p>在App.css 中导入样式<code>@import &#39;~antd/dist/antd.css&#39;</code>，然后在组件中引入相应的ui组件就可以用了。</p>\n</li>\n</ol>\n<hr>\n<p>完~</p>\n"},{"title":"git rebase 用法","date":"2021-12-02T09:16:28.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n[参考自此文章](https://zhuanlan.zhihu.com/p/34197548)\n\n以前提交代码一直是用命令行提交的\n\n```js\n\n// 一把梭\ngit pull\ngit add .\ngit commit -m 'xxxxxx'\ngit push\n```\n\n在多人开发项目下，这样提交的话会有如下效果:\n\n![显示效果](https://upload-images.jianshu.io/upload_images/13931286-3d42d72b334fc7c7.png?imageMogr2/auto-orient/strip|imageView2/2/w/594/format/webp)\n\n![显示效果](https://upload-images.jianshu.io/upload_images/13931286-d0fb965ce204e6f4.png?imageMogr2/auto-orient/strip|imageView2/2/w/222/format/webp)\n\n当很多人都把自己的分支合到主分支的时候，这样会显得主线很乱而且还会有自动生成的提交信息\n\n**所以提倡用`git rebase`**\n\n## 使用 rebase 和 merge 的基本原则\n\n1. 下游分支更新上游分支内容的时候使用 rebase\n2. 上游分支合并下游分支内容的时候使用 merge\n3. 更新当前分支的内容时一定要使用 --rebase 参数\n\n例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 `git rebase master`\n\n等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 `git merge dev`\n\n## 实际开发中遇到操作\n\n当你和其他人在同一个分支开发时，在你提交的时候发现有人已经提交了一些东西上去了，你可以这样操作：\n\n1. `git pull --rebase`\n\n2. `git push`\n\n你也可以使用vscode上下载的git插件来操作：\n\n![vscode操作](https://upload-images.jianshu.io/upload_images/13931286-ecca9bb5bd96dc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后再push上去。\n","source":"_posts/2021-12-02-git-rebase-用法.md","raw":"---\ntitle: git rebase 用法\ndate: 2021-12-02 17:16:28\ntags: [JavaScript,面试]\ncategories: 技术类-前端\n---\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n[参考自此文章](https://zhuanlan.zhihu.com/p/34197548)\n\n以前提交代码一直是用命令行提交的\n\n```js\n\n// 一把梭\ngit pull\ngit add .\ngit commit -m 'xxxxxx'\ngit push\n```\n\n在多人开发项目下，这样提交的话会有如下效果:\n\n![显示效果](https://upload-images.jianshu.io/upload_images/13931286-3d42d72b334fc7c7.png?imageMogr2/auto-orient/strip|imageView2/2/w/594/format/webp)\n\n![显示效果](https://upload-images.jianshu.io/upload_images/13931286-d0fb965ce204e6f4.png?imageMogr2/auto-orient/strip|imageView2/2/w/222/format/webp)\n\n当很多人都把自己的分支合到主分支的时候，这样会显得主线很乱而且还会有自动生成的提交信息\n\n**所以提倡用`git rebase`**\n\n## 使用 rebase 和 merge 的基本原则\n\n1. 下游分支更新上游分支内容的时候使用 rebase\n2. 上游分支合并下游分支内容的时候使用 merge\n3. 更新当前分支的内容时一定要使用 --rebase 参数\n\n例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 `git rebase master`\n\n等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 `git merge dev`\n\n## 实际开发中遇到操作\n\n当你和其他人在同一个分支开发时，在你提交的时候发现有人已经提交了一些东西上去了，你可以这样操作：\n\n1. `git pull --rebase`\n\n2. `git push`\n\n你也可以使用vscode上下载的git插件来操作：\n\n![vscode操作](https://upload-images.jianshu.io/upload_images/13931286-ecca9bb5bd96dc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后再push上去。\n","slug":"git-rebase-用法","published":1,"updated":"2021-12-09T05:07:01.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5v001u7oo9gtjx72sd","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n<p><a href=\"https://zhuanlan.zhihu.com/p/34197548\">参考自此文章</a></p>\n<p>以前提交代码一直是用命令行提交的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><br><span class=\"hljs-comment\">// 一把梭</span><br>git pull<br>git add .<br>git commit -m <span class=\"hljs-string\">&#x27;xxxxxx&#x27;</span><br>git push<br></code></pre></td></tr></table></figure>\n\n<p>在多人开发项目下，这样提交的话会有如下效果:</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-3d42d72b334fc7c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/594/format/webp\" alt=\"显示效果\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-d0fb965ce204e6f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/222/format/webp\" alt=\"显示效果\"></p>\n<p>当很多人都把自己的分支合到主分支的时候，这样会显得主线很乱而且还会有自动生成的提交信息</p>\n<p><strong>所以提倡用<code>git rebase</code></strong></p>\n<h2 id=\"使用-rebase-和-merge-的基本原则\"><a href=\"#使用-rebase-和-merge-的基本原则\" class=\"headerlink\" title=\"使用 rebase 和 merge 的基本原则\"></a>使用 rebase 和 merge 的基本原则</h2><ol>\n<li>下游分支更新上游分支内容的时候使用 rebase</li>\n<li>上游分支合并下游分支内容的时候使用 merge</li>\n<li>更新当前分支的内容时一定要使用 –rebase 参数</li>\n</ol>\n<p>例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 <code>git rebase master</code></p>\n<p>等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 <code>git merge dev</code></p>\n<h2 id=\"实际开发中遇到操作\"><a href=\"#实际开发中遇到操作\" class=\"headerlink\" title=\"实际开发中遇到操作\"></a>实际开发中遇到操作</h2><p>当你和其他人在同一个分支开发时，在你提交的时候发现有人已经提交了一些东西上去了，你可以这样操作：</p>\n<ol>\n<li><p><code>git pull --rebase</code></p>\n</li>\n<li><p><code>git push</code></p>\n</li>\n</ol>\n<p>你也可以使用vscode上下载的git插件来操作：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-ecca9bb5bd96dc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vscode操作\"></p>\n<p>然后再push上去。</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n<p><a href=\"https://zhuanlan.zhihu.com/p/34197548\">参考自此文章</a></p>\n<p>以前提交代码一直是用命令行提交的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><br><span class=\"hljs-comment\">// 一把梭</span><br>git pull<br>git add .<br>git commit -m <span class=\"hljs-string\">&#x27;xxxxxx&#x27;</span><br>git push<br></code></pre></td></tr></table></figure>\n\n<p>在多人开发项目下，这样提交的话会有如下效果:</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-3d42d72b334fc7c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/594/format/webp\" alt=\"显示效果\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-d0fb965ce204e6f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/222/format/webp\" alt=\"显示效果\"></p>\n<p>当很多人都把自己的分支合到主分支的时候，这样会显得主线很乱而且还会有自动生成的提交信息</p>\n<p><strong>所以提倡用<code>git rebase</code></strong></p>\n<h2 id=\"使用-rebase-和-merge-的基本原则\"><a href=\"#使用-rebase-和-merge-的基本原则\" class=\"headerlink\" title=\"使用 rebase 和 merge 的基本原则\"></a>使用 rebase 和 merge 的基本原则</h2><ol>\n<li>下游分支更新上游分支内容的时候使用 rebase</li>\n<li>上游分支合并下游分支内容的时候使用 merge</li>\n<li>更新当前分支的内容时一定要使用 –rebase 参数</li>\n</ol>\n<p>例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 <code>git rebase master</code></p>\n<p>等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 <code>git merge dev</code></p>\n<h2 id=\"实际开发中遇到操作\"><a href=\"#实际开发中遇到操作\" class=\"headerlink\" title=\"实际开发中遇到操作\"></a>实际开发中遇到操作</h2><p>当你和其他人在同一个分支开发时，在你提交的时候发现有人已经提交了一些东西上去了，你可以这样操作：</p>\n<ol>\n<li><p><code>git pull --rebase</code></p>\n</li>\n<li><p><code>git push</code></p>\n</li>\n</ol>\n<p>你也可以使用vscode上下载的git插件来操作：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-ecca9bb5bd96dc14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vscode操作\"></p>\n<p>然后再push上去。</p>\n"},{"title":"JavaScript的同步与异步","date":"2021-12-14T07:10:10.000Z","_content":"\n[更详细的可以点这里](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing)\n\n## [异步JavaScript](https://developer.mozilla.org/zh-CN/docs/Glossary/Asynchronous)\n\n**异步**指两个或两个以上的对象或事件**不**同时存在或发生（或多个相关事物的发生**无需**等待其前一事物的完成）\n\n## [同步JavaScript](https://developer.mozilla.org/zh-CN/docs/Glossary/Synchronous)\n\n各方都实时（或者尽可能实时）地收取（而且必要的话也处理或者回复）信息的即时沟通方式，即为**同步**。\n\n电话即为一个日常的例子：人们都倾向于在使用电话时即时地作出回应。\n\n许多程序指令也是实时的：例如当输入一个算式时，除非编程人员有意为止，否则环境都会立即将结果反馈回来。\n\n## 事件队列\n\n像`promise`这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境。\n\n## Promises 对比 callbacks\n\npromises与旧式callbacks有一些相似之处。它们本质上是一个返回的对象，您可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。\n\n然而，Promise是专门为异步操作而设计的，与旧式回调相比具有许多优点:\n\n- 您可以使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作。这种链接方式对回调来说要难得多，会使回调以混乱的“末日金字塔”告终。 (也称为回调地狱)。\n- Promise总是严格按照它们放置在事件队列中的顺序调用。\n- 错误处理要好得多——所有的错误都由块末尾的一个.catch()块处理，而不是在“金字塔”的每一层单独处理。\n\n## 异步代码的本质\n\n让我们研究一个示例，它进一步说明了异步代码的本质，展示了当我们不完全了解代码执行顺序以及将异步代码视为同步代码时可能发生的问题\n\n```js\nconsole.log ('Starting');\nlet image;\n\nfetch('coffee.jpg').then((response) => {\n  console.log('It worked :)')\n  return response.blob();\n}).then((myBlob) => {\n  let objectURL = URL.createObjectURL(myBlob);\n  image = document.createElement('img');\n  image.src = objectURL;\n  document.body.appendChild(image);\n}).catch((error) => {\n  console.log('There has been a problem with your fetch operation: ' + error.message);\n});\n\nconsole.log ('All done!');\n```\n\n浏览器将会执行代码，看见第一个`console.log()` 输出`Starting` ，然后创建`image`变量。\n\n然后，它将移动到下一行并开始执行`fetch()`块，但是，因为`fetch()`是异步执行的，没有阻塞，所以在`promise`相关代码之后程序继续执行，从而到达最后的`console.log()`语句`All done!`并将其输出到控制台。\n\n只有当`fetch()` 块完成运行返回结果给`.then()`，我们才最后看到第二个`console.log()`消息 `It worked ;)`。所以 这些消息可能以和你预期不同的顺序出现：\n\n- Starting\n- All done!\n- It worked :)\n\n如果你感到疑惑，考虑下面这个小例子：\n\n```js\nconsole.log(\"registering click handler\");\n\nbutton.addEventListener('click', () => {\n  console.log(\"get click\");\n});\n\nconsole.log(\"all done\");\n```\n\n这在行为上非常相似——第一个和第三个`console.log()`消息将立即显示，但是第二个消息将被阻塞，直到有人单击鼠标按钮。前面的示例以相同的方式工作，只是在这种情况下，第二个消息在`promise`链上被阻塞，直到获取资源后再显示在屏幕上，而不是单击。\n\n要查看实际情况，并将第三个`console.log()`调用更改为以下命令：\n\n```js\nconsole.log ('All done! ' + image.src + 'displayed.');\n```\n\n此时控制台将会报错，而不会显示第三个 console.log 的信息：\n\n```js\nTypeError: image is undefined; can't access its \"src\" property\n```\n\n这是因为：浏览器运行第三个console.log()的时候，fetch() 语句块还没有完成，因此image还没有赋值。\n\n## 小结\n\n`JavaScript`是一种同步的、阻塞的、单线程的语言，在这种语言中，一次只能执行一个操作。\n\n但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是异步地调用函数(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。\n\n这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。\n\n### 异步还是同步执行代码，取决于我们要做什么\n\n- 同步-如果我们希望事情能够立即加载并发生。例如，当将一些用户定义的样式应用到一个页面时，您希望这些样式能够尽快被应用。\n\n- 异步-如果我们正在运行一个需要时间的操作，比如查询数据库并使用结果填充模板，那么最好将该操作从主线程中移开使用异步完成任务。\n\n","source":"_posts/2021-12-14-JavaScript的同步与异步.md","raw":"---\ntitle: JavaScript的同步与异步\ndate: 2021-12-14 15:10:10\ntags: [JavaScript,面试]\ncategories: 技术类-前端\n---\n\n[更详细的可以点这里](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing)\n\n## [异步JavaScript](https://developer.mozilla.org/zh-CN/docs/Glossary/Asynchronous)\n\n**异步**指两个或两个以上的对象或事件**不**同时存在或发生（或多个相关事物的发生**无需**等待其前一事物的完成）\n\n## [同步JavaScript](https://developer.mozilla.org/zh-CN/docs/Glossary/Synchronous)\n\n各方都实时（或者尽可能实时）地收取（而且必要的话也处理或者回复）信息的即时沟通方式，即为**同步**。\n\n电话即为一个日常的例子：人们都倾向于在使用电话时即时地作出回应。\n\n许多程序指令也是实时的：例如当输入一个算式时，除非编程人员有意为止，否则环境都会立即将结果反馈回来。\n\n## 事件队列\n\n像`promise`这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境。\n\n## Promises 对比 callbacks\n\npromises与旧式callbacks有一些相似之处。它们本质上是一个返回的对象，您可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。\n\n然而，Promise是专门为异步操作而设计的，与旧式回调相比具有许多优点:\n\n- 您可以使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作。这种链接方式对回调来说要难得多，会使回调以混乱的“末日金字塔”告终。 (也称为回调地狱)。\n- Promise总是严格按照它们放置在事件队列中的顺序调用。\n- 错误处理要好得多——所有的错误都由块末尾的一个.catch()块处理，而不是在“金字塔”的每一层单独处理。\n\n## 异步代码的本质\n\n让我们研究一个示例，它进一步说明了异步代码的本质，展示了当我们不完全了解代码执行顺序以及将异步代码视为同步代码时可能发生的问题\n\n```js\nconsole.log ('Starting');\nlet image;\n\nfetch('coffee.jpg').then((response) => {\n  console.log('It worked :)')\n  return response.blob();\n}).then((myBlob) => {\n  let objectURL = URL.createObjectURL(myBlob);\n  image = document.createElement('img');\n  image.src = objectURL;\n  document.body.appendChild(image);\n}).catch((error) => {\n  console.log('There has been a problem with your fetch operation: ' + error.message);\n});\n\nconsole.log ('All done!');\n```\n\n浏览器将会执行代码，看见第一个`console.log()` 输出`Starting` ，然后创建`image`变量。\n\n然后，它将移动到下一行并开始执行`fetch()`块，但是，因为`fetch()`是异步执行的，没有阻塞，所以在`promise`相关代码之后程序继续执行，从而到达最后的`console.log()`语句`All done!`并将其输出到控制台。\n\n只有当`fetch()` 块完成运行返回结果给`.then()`，我们才最后看到第二个`console.log()`消息 `It worked ;)`。所以 这些消息可能以和你预期不同的顺序出现：\n\n- Starting\n- All done!\n- It worked :)\n\n如果你感到疑惑，考虑下面这个小例子：\n\n```js\nconsole.log(\"registering click handler\");\n\nbutton.addEventListener('click', () => {\n  console.log(\"get click\");\n});\n\nconsole.log(\"all done\");\n```\n\n这在行为上非常相似——第一个和第三个`console.log()`消息将立即显示，但是第二个消息将被阻塞，直到有人单击鼠标按钮。前面的示例以相同的方式工作，只是在这种情况下，第二个消息在`promise`链上被阻塞，直到获取资源后再显示在屏幕上，而不是单击。\n\n要查看实际情况，并将第三个`console.log()`调用更改为以下命令：\n\n```js\nconsole.log ('All done! ' + image.src + 'displayed.');\n```\n\n此时控制台将会报错，而不会显示第三个 console.log 的信息：\n\n```js\nTypeError: image is undefined; can't access its \"src\" property\n```\n\n这是因为：浏览器运行第三个console.log()的时候，fetch() 语句块还没有完成，因此image还没有赋值。\n\n## 小结\n\n`JavaScript`是一种同步的、阻塞的、单线程的语言，在这种语言中，一次只能执行一个操作。\n\n但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是异步地调用函数(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。\n\n这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。\n\n### 异步还是同步执行代码，取决于我们要做什么\n\n- 同步-如果我们希望事情能够立即加载并发生。例如，当将一些用户定义的样式应用到一个页面时，您希望这些样式能够尽快被应用。\n\n- 异步-如果我们正在运行一个需要时间的操作，比如查询数据库并使用结果填充模板，那么最好将该操作从主线程中移开使用异步完成任务。\n\n","slug":"JavaScript的同步与异步","published":1,"updated":"2021-12-14T07:51:00.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5v001y7oo9133m6jj4","content":"<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing\">更详细的可以点这里</a></p>\n<h2 id=\"异步JavaScript\"><a href=\"#异步JavaScript\" class=\"headerlink\" title=\"异步JavaScript\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Asynchronous\">异步JavaScript</a></h2><p><strong>异步</strong>指两个或两个以上的对象或事件<strong>不</strong>同时存在或发生（或多个相关事物的发生<strong>无需</strong>等待其前一事物的完成）</p>\n<h2 id=\"同步JavaScript\"><a href=\"#同步JavaScript\" class=\"headerlink\" title=\"同步JavaScript\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Synchronous\">同步JavaScript</a></h2><p>各方都实时（或者尽可能实时）地收取（而且必要的话也处理或者回复）信息的即时沟通方式，即为<strong>同步</strong>。</p>\n<p>电话即为一个日常的例子：人们都倾向于在使用电话时即时地作出回应。</p>\n<p>许多程序指令也是实时的：例如当输入一个算式时，除非编程人员有意为止，否则环境都会立即将结果反馈回来。</p>\n<h2 id=\"事件队列\"><a href=\"#事件队列\" class=\"headerlink\" title=\"事件队列\"></a>事件队列</h2><p>像<code>promise</code>这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境。</p>\n<h2 id=\"Promises-对比-callbacks\"><a href=\"#Promises-对比-callbacks\" class=\"headerlink\" title=\"Promises 对比 callbacks\"></a>Promises 对比 callbacks</h2><p>promises与旧式callbacks有一些相似之处。它们本质上是一个返回的对象，您可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。</p>\n<p>然而，Promise是专门为异步操作而设计的，与旧式回调相比具有许多优点:</p>\n<ul>\n<li>您可以使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作。这种链接方式对回调来说要难得多，会使回调以混乱的“末日金字塔”告终。 (也称为回调地狱)。</li>\n<li>Promise总是严格按照它们放置在事件队列中的顺序调用。</li>\n<li>错误处理要好得多——所有的错误都由块末尾的一个.catch()块处理，而不是在“金字塔”的每一层单独处理。</li>\n</ul>\n<h2 id=\"异步代码的本质\"><a href=\"#异步代码的本质\" class=\"headerlink\" title=\"异步代码的本质\"></a>异步代码的本质</h2><p>让我们研究一个示例，它进一步说明了异步代码的本质，展示了当我们不完全了解代码执行顺序以及将异步代码视为同步代码时可能发生的问题</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log (<span class=\"hljs-string\">&#x27;Starting&#x27;</span>);<br><span class=\"hljs-keyword\">let</span> image;<br><br>fetch(<span class=\"hljs-string\">&#x27;coffee.jpg&#x27;</span>).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;It worked :)&#x27;</span>)<br>  <span class=\"hljs-keyword\">return</span> response.blob();<br>&#125;).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">myBlob</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">let</span> objectURL = URL.createObjectURL(myBlob);<br>  image = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&#x27;img&#x27;</span>);<br>  image.src = objectURL;<br>  <span class=\"hljs-built_in\">document</span>.body.appendChild(image);<br>&#125;).catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;There has been a problem with your fetch operation: &#x27;</span> + error.message);<br>&#125;);<br><br><span class=\"hljs-built_in\">console</span>.log (<span class=\"hljs-string\">&#x27;All done!&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>浏览器将会执行代码，看见第一个<code>console.log()</code> 输出<code>Starting</code> ，然后创建<code>image</code>变量。</p>\n<p>然后，它将移动到下一行并开始执行<code>fetch()</code>块，但是，因为<code>fetch()</code>是异步执行的，没有阻塞，所以在<code>promise</code>相关代码之后程序继续执行，从而到达最后的<code>console.log()</code>语句<code>All done!</code>并将其输出到控制台。</p>\n<p>只有当<code>fetch()</code> 块完成运行返回结果给<code>.then()</code>，我们才最后看到第二个<code>console.log()</code>消息 <code>It worked ;)</code>。所以 这些消息可能以和你预期不同的顺序出现：</p>\n<ul>\n<li>Starting</li>\n<li>All done!</li>\n<li>It worked :)</li>\n</ul>\n<p>如果你感到疑惑，考虑下面这个小例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;registering click handler&quot;</span>);<br><br>button.addEventListener(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;get click&quot;</span>);<br>&#125;);<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;all done&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>这在行为上非常相似——第一个和第三个<code>console.log()</code>消息将立即显示，但是第二个消息将被阻塞，直到有人单击鼠标按钮。前面的示例以相同的方式工作，只是在这种情况下，第二个消息在<code>promise</code>链上被阻塞，直到获取资源后再显示在屏幕上，而不是单击。</p>\n<p>要查看实际情况，并将第三个<code>console.log()</code>调用更改为以下命令：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log (<span class=\"hljs-string\">&#x27;All done! &#x27;</span> + image.src + <span class=\"hljs-string\">&#x27;displayed.&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>此时控制台将会报错，而不会显示第三个 console.log 的信息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">TypeError</span>: image is <span class=\"hljs-literal\">undefined</span>; can<span class=\"hljs-string\">&#x27;t access its &quot;src&quot; property</span><br></code></pre></td></tr></table></figure>\n\n<p>这是因为：浏览器运行第三个console.log()的时候，fetch() 语句块还没有完成，因此image还没有赋值。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p><code>JavaScript</code>是一种同步的、阻塞的、单线程的语言，在这种语言中，一次只能执行一个操作。</p>\n<p>但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是异步地调用函数(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。</p>\n<p>这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。</p>\n<h3 id=\"异步还是同步执行代码，取决于我们要做什么\"><a href=\"#异步还是同步执行代码，取决于我们要做什么\" class=\"headerlink\" title=\"异步还是同步执行代码，取决于我们要做什么\"></a>异步还是同步执行代码，取决于我们要做什么</h3><ul>\n<li><p>同步-如果我们希望事情能够立即加载并发生。例如，当将一些用户定义的样式应用到一个页面时，您希望这些样式能够尽快被应用。</p>\n</li>\n<li><p>异步-如果我们正在运行一个需要时间的操作，比如查询数据库并使用结果填充模板，那么最好将该操作从主线程中移开使用异步完成任务。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing\">更详细的可以点这里</a></p>\n<h2 id=\"异步JavaScript\"><a href=\"#异步JavaScript\" class=\"headerlink\" title=\"异步JavaScript\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Asynchronous\">异步JavaScript</a></h2><p><strong>异步</strong>指两个或两个以上的对象或事件<strong>不</strong>同时存在或发生（或多个相关事物的发生<strong>无需</strong>等待其前一事物的完成）</p>\n<h2 id=\"同步JavaScript\"><a href=\"#同步JavaScript\" class=\"headerlink\" title=\"同步JavaScript\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Synchronous\">同步JavaScript</a></h2><p>各方都实时（或者尽可能实时）地收取（而且必要的话也处理或者回复）信息的即时沟通方式，即为<strong>同步</strong>。</p>\n<p>电话即为一个日常的例子：人们都倾向于在使用电话时即时地作出回应。</p>\n<p>许多程序指令也是实时的：例如当输入一个算式时，除非编程人员有意为止，否则环境都会立即将结果反馈回来。</p>\n<h2 id=\"事件队列\"><a href=\"#事件队列\" class=\"headerlink\" title=\"事件队列\"></a>事件队列</h2><p>像<code>promise</code>这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境。</p>\n<h2 id=\"Promises-对比-callbacks\"><a href=\"#Promises-对比-callbacks\" class=\"headerlink\" title=\"Promises 对比 callbacks\"></a>Promises 对比 callbacks</h2><p>promises与旧式callbacks有一些相似之处。它们本质上是一个返回的对象，您可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。</p>\n<p>然而，Promise是专门为异步操作而设计的，与旧式回调相比具有许多优点:</p>\n<ul>\n<li>您可以使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作。这种链接方式对回调来说要难得多，会使回调以混乱的“末日金字塔”告终。 (也称为回调地狱)。</li>\n<li>Promise总是严格按照它们放置在事件队列中的顺序调用。</li>\n<li>错误处理要好得多——所有的错误都由块末尾的一个.catch()块处理，而不是在“金字塔”的每一层单独处理。</li>\n</ul>\n<h2 id=\"异步代码的本质\"><a href=\"#异步代码的本质\" class=\"headerlink\" title=\"异步代码的本质\"></a>异步代码的本质</h2><p>让我们研究一个示例，它进一步说明了异步代码的本质，展示了当我们不完全了解代码执行顺序以及将异步代码视为同步代码时可能发生的问题</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log (<span class=\"hljs-string\">&#x27;Starting&#x27;</span>);<br><span class=\"hljs-keyword\">let</span> image;<br><br>fetch(<span class=\"hljs-string\">&#x27;coffee.jpg&#x27;</span>).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;It worked :)&#x27;</span>)<br>  <span class=\"hljs-keyword\">return</span> response.blob();<br>&#125;).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">myBlob</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">let</span> objectURL = URL.createObjectURL(myBlob);<br>  image = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&#x27;img&#x27;</span>);<br>  image.src = objectURL;<br>  <span class=\"hljs-built_in\">document</span>.body.appendChild(image);<br>&#125;).catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;There has been a problem with your fetch operation: &#x27;</span> + error.message);<br>&#125;);<br><br><span class=\"hljs-built_in\">console</span>.log (<span class=\"hljs-string\">&#x27;All done!&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>浏览器将会执行代码，看见第一个<code>console.log()</code> 输出<code>Starting</code> ，然后创建<code>image</code>变量。</p>\n<p>然后，它将移动到下一行并开始执行<code>fetch()</code>块，但是，因为<code>fetch()</code>是异步执行的，没有阻塞，所以在<code>promise</code>相关代码之后程序继续执行，从而到达最后的<code>console.log()</code>语句<code>All done!</code>并将其输出到控制台。</p>\n<p>只有当<code>fetch()</code> 块完成运行返回结果给<code>.then()</code>，我们才最后看到第二个<code>console.log()</code>消息 <code>It worked ;)</code>。所以 这些消息可能以和你预期不同的顺序出现：</p>\n<ul>\n<li>Starting</li>\n<li>All done!</li>\n<li>It worked :)</li>\n</ul>\n<p>如果你感到疑惑，考虑下面这个小例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;registering click handler&quot;</span>);<br><br>button.addEventListener(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;get click&quot;</span>);<br>&#125;);<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;all done&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>这在行为上非常相似——第一个和第三个<code>console.log()</code>消息将立即显示，但是第二个消息将被阻塞，直到有人单击鼠标按钮。前面的示例以相同的方式工作，只是在这种情况下，第二个消息在<code>promise</code>链上被阻塞，直到获取资源后再显示在屏幕上，而不是单击。</p>\n<p>要查看实际情况，并将第三个<code>console.log()</code>调用更改为以下命令：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log (<span class=\"hljs-string\">&#x27;All done! &#x27;</span> + image.src + <span class=\"hljs-string\">&#x27;displayed.&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>此时控制台将会报错，而不会显示第三个 console.log 的信息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">TypeError</span>: image is <span class=\"hljs-literal\">undefined</span>; can<span class=\"hljs-string\">&#x27;t access its &quot;src&quot; property</span><br></code></pre></td></tr></table></figure>\n\n<p>这是因为：浏览器运行第三个console.log()的时候，fetch() 语句块还没有完成，因此image还没有赋值。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p><code>JavaScript</code>是一种同步的、阻塞的、单线程的语言，在这种语言中，一次只能执行一个操作。</p>\n<p>但web浏览器定义了函数和API，允许我们当某些事件发生时不是按照同步方式，而是异步地调用函数(比如，时间的推移，用户通过鼠标的交互，或者获取网络数据)。</p>\n<p>这意味着您的代码可以同时做几件事情，而不需要停止或阻塞主线程。</p>\n<h3 id=\"异步还是同步执行代码，取决于我们要做什么\"><a href=\"#异步还是同步执行代码，取决于我们要做什么\" class=\"headerlink\" title=\"异步还是同步执行代码，取决于我们要做什么\"></a>异步还是同步执行代码，取决于我们要做什么</h3><ul>\n<li><p>同步-如果我们希望事情能够立即加载并发生。例如，当将一些用户定义的样式应用到一个页面时，您希望这些样式能够尽快被应用。</p>\n</li>\n<li><p>异步-如果我们正在运行一个需要时间的操作，比如查询数据库并使用结果填充模板，那么最好将该操作从主线程中移开使用异步完成任务。</p>\n</li>\n</ul>\n"},{"title":"React随笔","date":"2021-12-18T11:08:44.000Z","_content":"\n## React 中的`this`\n\nReact 的官方文档里写的自定义的方法都需要用 bind 方法绑定一下才能使用，否则 this 会出现指向问题，那究竟是为什么呢？\n\n### 探讨一\n\n```js\nclass Person {\n    constructor(props){\n        this.state = {\n            ......\n        }\n    }\n    render(){\n        return <div onClick={demo}>你好，DexterHwang</div>\n    }\n}\n\nfunction demo(){\n    console.log(this.state)   // 会报错，注意此处的this\n}\n\nReactDom.render(<Person />,document.getElementById('app'))\n```\n\n`React` 中的 `Babel` 使用了严格模式，所以写的全局的 `this`指向的是`undefined`\n\n而且 `demo` 方法并不写在 `Person` 类中，所以这个 `this` 也不会指向 `Person` 的实例对象\n\n### 探讨二\n\n```js\nclass Person {\n    constructor(props){\n        this.state = {\n            ......\n        }\n    }\n    render(){\n        return <div onClick={demo}>你好，DexterHwang</div> // 会报错，报错信息为：`demo is not defined`。`onClick={demo}`是找不到 `demo` 方法的\n        // return <div onClick={this.demo}>你好，DexterHwang</div> // 这样写也会报错，因为并不是通过实例对象去调用demo方法。由于demo是作为onClick的回调，不是通过实例调用的，是直接调用。类中的方法默认开启了局部的严格模式，所以this值是undefined\n    }\n    // demo方法在Person的原型对象(prototype)上，也就是在Person的实例对象的原型链上(_proto_)\n    // 只有通过Person实例对象调用demo方法时，demo里面的this指向的就是Person的实例对象\n    demo(){\n        console.log(this)\n    }\n}\n\nReactDom.render(<Person />,document.getElementById('app'))\n```\n\n我们看下面的例子\n\n```js\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  study() {\n    console.log(this);\n  }\n}\nconst p1 = new Person(\"DexterHwang\", 18);\n\np1.study(); //{name:'DexterHwang',age:18}\nconst x = p1.study;\nx(); // 输出undefined\n```\n\np1 的原型链上是可以找到 study 方法的，然后把 study 方法赋值给了 x。也就相当于在栈上多了一个指针指向了 study 方法，这下 x 就彻底和 p1 没有关系了\n\n另外，再明确一点：_类中自定义的方法，都会启用局部严格模式_。也就是说 this 的值是 undefined\n\n也就是说 x 执行后 this 值就是 undefined\n\n验证：_类中自定义的方法，都会启用局部严格模式_\n\n```js\nfunction test() {\n  console.log(this);\n}\n\nfunction test2() {\n  \"use strict\";\n  console.log(this);\n}\n\ntest(); // window\ntest2(); // undefined\n```\n\n### 分析 `this.demo = this.demo.bind(this)`\n\n为什么用 bind()就可以解决 this 指向问题呢？\n\n```js\n class Person {\n    constructor(props){\n        this.state = {\n            ......\n        }\n        this.demo = this.demo.bind(this)\n    }\n    render(){\n        return <div onClick={this.demo}>你好，DexterHwang</div>\n    }\n\n    demo(){\n        console.log(this)\n    }\n}\n\nReactDom.render(<Person />,document.getElementById('app'))\n\n// 点击后会输出：Person{...}\n```\n\n分析`this.demo = this.demo.bind(this)`\n\n等号右侧的第一个 this 指向的是实例对象，这个实例对象上有 demo 方法吗？有，但是实在原型链上的。\n\nbind 方法做两件事：\n\n1. 将 this 牢牢的绑定到传入的参数上\n2. 返回一个新的函数\n\n等号右边第二个 this，也就是传入的参数，这个 this 指的就是实例对象\n\n这样的话返回了一个新的函数，而且这个函数牢牢的绑定到了实例对象上，并不需要去原型链上找了\n\n再看等号左侧，将返回的新函数赋值给了 this，这个 this 也是 Person 实例对象，用相同的方法名接收一下\n\n这样就可以使用了\n\n我们这样再去看`onClick={this.demo}`,这下再点击后执行的就是实例自身上的 demo 方法了。\n\n---\n\n## 2021-12-25 更新—— React17 对比新旧生命周期\n\n新的生命周期和旧的生命周期相比，即将废弃三个钩子：`componentWillMount`、`componentWillUpdate`、`componentWillReceiveProps`\n\n新增了两个新的钩子：`getDerivedStateFromProps`、`getSnapshotBeforeUpdate`\n\n剩下的都和之前的一样的\n\n## 2021-12-16 更新—— React 配置代理\n\n单个代理可以直接在`package.json`文件中配置`proxy`\n\n多个代理则需要新建一个`setupProxy.js`文件，配置如下：\n\n```js\nconst proxy = require(\"http-proxy-middleware\");\n\nmodule.exports = function (app) {\n  app.use(\n    proxy(\"/api1\", {\n      //遇见api1前缀的请求，就会触发这个代理配置\n      target: \"http://localhost:5000\", // 请求转发给谁，也就是服务器地址\n      changeOrigin: true, // 控制服务器收到的请求头中Host的值，这里是localhost:5000\n      pathRewrite: { \"^/api1\": \"\" }, // 重写请求路径\n    }),\n    proxy(\"/api2\", {\n      target: \"http://localhost:5001\",\n      changeOrigin: true,\n      pathRewrite: { \"^/api2\": \"\" },\n    })\n  );\n};\n```\n\n`create-react-app`脚手架会自动找到`setupProxy.js`文件，并将配置加入到 webpack 中\n\n## 2021-12-27 更新—— React 路由原理\n\n靠的是 H5 推出的 history 上的 API\n\n```js\n//路由跳转\nfunction push(path) {\n  history.push(path);\n  return false;\n}\n\n// 路由替换\nfunction replace(path) {\n  history.replace(path);\n}\n\n// 路由回退\nfunction back() {\n  history.goBack();\n}\n\n// 路由前进\nfunction forword() {\n  history.goForward();\n}\n\n// 监听路由变化\nhistory.listen((location) => {\n  console.log(\"监听路由变化\");\n});\n```\n\n## 2021-12-28 更新—— 全局事件总线\n\n用第三方库`mitt`或者`pubsub`，可以实现多层级的组件之间的通信\n\n## 2021-12-30 更新—— React的setState()\n\n异步执行\n\n1. 多个setState()会推到一个任务队列里面，将多次执行合并为一个来执行。\n\n2. setState()的几种写法\n\n```js\n//常规写法，这种写法会将多次setState()方法合并\n// counter的初始值为1\nthis.setState({\n  counter: this.state.counter+1\n})\nthis.setState({\n  counter: this.state.counter+1\n})\nthis.setState({\n  counter: this.state.counter+1\n})\n// counter的值是2\n// ----------------------------------------\n// 这种写法和上面执行结果不同，preState拿到的是最新的设置后的值（上一个setState设置的值）\nthis.setState(preState => ({\n  counter: preState.counter + 1\n}))\n\nthis.setState(preState => ({\n  counter: preState.counter + 1\n}))\n\nthis.setState(preState => ({\n  counter: preState.counter + 1\n}))\n// counter的值是4\n```\n\nsetState()方法里的第二个参数是一个回调函数，该函数能拿到设置之后的值\n\n## 2021-12-31 更新—— 无副作用\n\n在React里经常看到`无副作用`这个词，它表示它只对自身有影响对自身以外的无影响，所有的输出都是由我的输入来决定的。\n\n发一个请求，设置了localstorage，对外部进行了操作这都叫做**副作用**\n\n## React生命周期\n\n1. 组件初始化阶段 initialization, 比如constructor\n2. 组件挂载阶段 mount\n   1. componentWillMount  组件挂载到DOM前调用,只会被调用一次, 这里写setState不会引起组件重新渲染\n   2. render 返回一个react元素, react根据此函数的返回值渲染DOM. 不能在这里setState\n   3. componentDidMount 组件挂载到DOM后调用, 且只会被调用一次\n3. 组件的更新阶段 update\n   1. componentWillReceiveProps(nextProps) 触发于props引起的组件更新过程中\n   2. shouldComponentUpdate(nextProps, nextState) 比较之前和当前的props state是否有变化\n   3. componentWillUpdate(nextProps, nextState) render方法前执行\n   4. render\n   5. componentDidUpdate(preProps, preState)\n4. 组件的卸载阶段 unmount\n   1. componentWillUnmount 卸载前调用, 在这里可以清理一些定时器\n\n`componentWillMount`,`componentWillReceiveProps`,`componentWillUnmount`在React17不建议使用，即将被废弃\n","source":"_posts/2021-12-18-React随笔.md","raw":"---\ntitle: React随笔\ndate: 2021-12-18 19:08:44\ntags: [React, 面试]\ncategories: 技术类-React\n---\n\n## React 中的`this`\n\nReact 的官方文档里写的自定义的方法都需要用 bind 方法绑定一下才能使用，否则 this 会出现指向问题，那究竟是为什么呢？\n\n### 探讨一\n\n```js\nclass Person {\n    constructor(props){\n        this.state = {\n            ......\n        }\n    }\n    render(){\n        return <div onClick={demo}>你好，DexterHwang</div>\n    }\n}\n\nfunction demo(){\n    console.log(this.state)   // 会报错，注意此处的this\n}\n\nReactDom.render(<Person />,document.getElementById('app'))\n```\n\n`React` 中的 `Babel` 使用了严格模式，所以写的全局的 `this`指向的是`undefined`\n\n而且 `demo` 方法并不写在 `Person` 类中，所以这个 `this` 也不会指向 `Person` 的实例对象\n\n### 探讨二\n\n```js\nclass Person {\n    constructor(props){\n        this.state = {\n            ......\n        }\n    }\n    render(){\n        return <div onClick={demo}>你好，DexterHwang</div> // 会报错，报错信息为：`demo is not defined`。`onClick={demo}`是找不到 `demo` 方法的\n        // return <div onClick={this.demo}>你好，DexterHwang</div> // 这样写也会报错，因为并不是通过实例对象去调用demo方法。由于demo是作为onClick的回调，不是通过实例调用的，是直接调用。类中的方法默认开启了局部的严格模式，所以this值是undefined\n    }\n    // demo方法在Person的原型对象(prototype)上，也就是在Person的实例对象的原型链上(_proto_)\n    // 只有通过Person实例对象调用demo方法时，demo里面的this指向的就是Person的实例对象\n    demo(){\n        console.log(this)\n    }\n}\n\nReactDom.render(<Person />,document.getElementById('app'))\n```\n\n我们看下面的例子\n\n```js\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  study() {\n    console.log(this);\n  }\n}\nconst p1 = new Person(\"DexterHwang\", 18);\n\np1.study(); //{name:'DexterHwang',age:18}\nconst x = p1.study;\nx(); // 输出undefined\n```\n\np1 的原型链上是可以找到 study 方法的，然后把 study 方法赋值给了 x。也就相当于在栈上多了一个指针指向了 study 方法，这下 x 就彻底和 p1 没有关系了\n\n另外，再明确一点：_类中自定义的方法，都会启用局部严格模式_。也就是说 this 的值是 undefined\n\n也就是说 x 执行后 this 值就是 undefined\n\n验证：_类中自定义的方法，都会启用局部严格模式_\n\n```js\nfunction test() {\n  console.log(this);\n}\n\nfunction test2() {\n  \"use strict\";\n  console.log(this);\n}\n\ntest(); // window\ntest2(); // undefined\n```\n\n### 分析 `this.demo = this.demo.bind(this)`\n\n为什么用 bind()就可以解决 this 指向问题呢？\n\n```js\n class Person {\n    constructor(props){\n        this.state = {\n            ......\n        }\n        this.demo = this.demo.bind(this)\n    }\n    render(){\n        return <div onClick={this.demo}>你好，DexterHwang</div>\n    }\n\n    demo(){\n        console.log(this)\n    }\n}\n\nReactDom.render(<Person />,document.getElementById('app'))\n\n// 点击后会输出：Person{...}\n```\n\n分析`this.demo = this.demo.bind(this)`\n\n等号右侧的第一个 this 指向的是实例对象，这个实例对象上有 demo 方法吗？有，但是实在原型链上的。\n\nbind 方法做两件事：\n\n1. 将 this 牢牢的绑定到传入的参数上\n2. 返回一个新的函数\n\n等号右边第二个 this，也就是传入的参数，这个 this 指的就是实例对象\n\n这样的话返回了一个新的函数，而且这个函数牢牢的绑定到了实例对象上，并不需要去原型链上找了\n\n再看等号左侧，将返回的新函数赋值给了 this，这个 this 也是 Person 实例对象，用相同的方法名接收一下\n\n这样就可以使用了\n\n我们这样再去看`onClick={this.demo}`,这下再点击后执行的就是实例自身上的 demo 方法了。\n\n---\n\n## 2021-12-25 更新—— React17 对比新旧生命周期\n\n新的生命周期和旧的生命周期相比，即将废弃三个钩子：`componentWillMount`、`componentWillUpdate`、`componentWillReceiveProps`\n\n新增了两个新的钩子：`getDerivedStateFromProps`、`getSnapshotBeforeUpdate`\n\n剩下的都和之前的一样的\n\n## 2021-12-16 更新—— React 配置代理\n\n单个代理可以直接在`package.json`文件中配置`proxy`\n\n多个代理则需要新建一个`setupProxy.js`文件，配置如下：\n\n```js\nconst proxy = require(\"http-proxy-middleware\");\n\nmodule.exports = function (app) {\n  app.use(\n    proxy(\"/api1\", {\n      //遇见api1前缀的请求，就会触发这个代理配置\n      target: \"http://localhost:5000\", // 请求转发给谁，也就是服务器地址\n      changeOrigin: true, // 控制服务器收到的请求头中Host的值，这里是localhost:5000\n      pathRewrite: { \"^/api1\": \"\" }, // 重写请求路径\n    }),\n    proxy(\"/api2\", {\n      target: \"http://localhost:5001\",\n      changeOrigin: true,\n      pathRewrite: { \"^/api2\": \"\" },\n    })\n  );\n};\n```\n\n`create-react-app`脚手架会自动找到`setupProxy.js`文件，并将配置加入到 webpack 中\n\n## 2021-12-27 更新—— React 路由原理\n\n靠的是 H5 推出的 history 上的 API\n\n```js\n//路由跳转\nfunction push(path) {\n  history.push(path);\n  return false;\n}\n\n// 路由替换\nfunction replace(path) {\n  history.replace(path);\n}\n\n// 路由回退\nfunction back() {\n  history.goBack();\n}\n\n// 路由前进\nfunction forword() {\n  history.goForward();\n}\n\n// 监听路由变化\nhistory.listen((location) => {\n  console.log(\"监听路由变化\");\n});\n```\n\n## 2021-12-28 更新—— 全局事件总线\n\n用第三方库`mitt`或者`pubsub`，可以实现多层级的组件之间的通信\n\n## 2021-12-30 更新—— React的setState()\n\n异步执行\n\n1. 多个setState()会推到一个任务队列里面，将多次执行合并为一个来执行。\n\n2. setState()的几种写法\n\n```js\n//常规写法，这种写法会将多次setState()方法合并\n// counter的初始值为1\nthis.setState({\n  counter: this.state.counter+1\n})\nthis.setState({\n  counter: this.state.counter+1\n})\nthis.setState({\n  counter: this.state.counter+1\n})\n// counter的值是2\n// ----------------------------------------\n// 这种写法和上面执行结果不同，preState拿到的是最新的设置后的值（上一个setState设置的值）\nthis.setState(preState => ({\n  counter: preState.counter + 1\n}))\n\nthis.setState(preState => ({\n  counter: preState.counter + 1\n}))\n\nthis.setState(preState => ({\n  counter: preState.counter + 1\n}))\n// counter的值是4\n```\n\nsetState()方法里的第二个参数是一个回调函数，该函数能拿到设置之后的值\n\n## 2021-12-31 更新—— 无副作用\n\n在React里经常看到`无副作用`这个词，它表示它只对自身有影响对自身以外的无影响，所有的输出都是由我的输入来决定的。\n\n发一个请求，设置了localstorage，对外部进行了操作这都叫做**副作用**\n\n## React生命周期\n\n1. 组件初始化阶段 initialization, 比如constructor\n2. 组件挂载阶段 mount\n   1. componentWillMount  组件挂载到DOM前调用,只会被调用一次, 这里写setState不会引起组件重新渲染\n   2. render 返回一个react元素, react根据此函数的返回值渲染DOM. 不能在这里setState\n   3. componentDidMount 组件挂载到DOM后调用, 且只会被调用一次\n3. 组件的更新阶段 update\n   1. componentWillReceiveProps(nextProps) 触发于props引起的组件更新过程中\n   2. shouldComponentUpdate(nextProps, nextState) 比较之前和当前的props state是否有变化\n   3. componentWillUpdate(nextProps, nextState) render方法前执行\n   4. render\n   5. componentDidUpdate(preProps, preState)\n4. 组件的卸载阶段 unmount\n   1. componentWillUnmount 卸载前调用, 在这里可以清理一些定时器\n\n`componentWillMount`,`componentWillReceiveProps`,`componentWillUnmount`在React17不建议使用，即将被废弃\n","slug":"React随笔","published":1,"updated":"2022-01-14T02:34:21.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5x00227oo9b2su0btd","content":"<h2 id=\"React-中的this\"><a href=\"#React-中的this\" class=\"headerlink\" title=\"React 中的this\"></a>React 中的<code>this</code></h2><p>React 的官方文档里写的自定义的方法都需要用 bind 方法绑定一下才能使用，否则 this 会出现指向问题，那究竟是为什么呢？</p>\n<h3 id=\"探讨一\"><a href=\"#探讨一\" class=\"headerlink\" title=\"探讨一\"></a>探讨一</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.state = &#123;<br>            ......<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;demo&#125;</span>&gt;</span>你好，DexterHwang<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">demo</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.state)   <span class=\"hljs-comment\">// 会报错，注意此处的this</span><br>&#125;<br><br>ReactDom.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Person</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;app&#x27;</span>))<br></code></pre></td></tr></table></figure>\n\n<p><code>React</code> 中的 <code>Babel</code> 使用了严格模式，所以写的全局的 <code>this</code>指向的是<code>undefined</code></p>\n<p>而且 <code>demo</code> 方法并不写在 <code>Person</code> 类中，所以这个 <code>this</code> 也不会指向 <code>Person</code> 的实例对象</p>\n<h3 id=\"探讨二\"><a href=\"#探讨二\" class=\"headerlink\" title=\"探讨二\"></a>探讨二</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.state = &#123;<br>            ......<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;demo&#125;</span>&gt;</span>你好，DexterHwang<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span> <span class=\"hljs-comment\">// 会报错，报错信息为：`demo is not defined`。`onClick=&#123;demo&#125;`是找不到 `demo` 方法的</span><br>        <span class=\"hljs-comment\">// return &lt;div onClick=&#123;this.demo&#125;&gt;你好，DexterHwang&lt;/div&gt; // 这样写也会报错，因为并不是通过实例对象去调用demo方法。由于demo是作为onClick的回调，不是通过实例调用的，是直接调用。类中的方法默认开启了局部的严格模式，所以this值是undefined</span><br>    &#125;<br>    <span class=\"hljs-comment\">// demo方法在Person的原型对象(prototype)上，也就是在Person的实例对象的原型链上(_proto_)</span><br>    <span class=\"hljs-comment\">// 只有通过Person实例对象调用demo方法时，demo里面的this指向的就是Person的实例对象</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">demo</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>    &#125;<br>&#125;<br><br>ReactDom.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Person</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;app&#x27;</span>))<br></code></pre></td></tr></table></figure>\n\n<p>我们看下面的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name, age</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.name = name;<br>    <span class=\"hljs-built_in\">this</span>.age = age;<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">study</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">&quot;DexterHwang&quot;</span>, <span class=\"hljs-number\">18</span>);<br><br>p1.study(); <span class=\"hljs-comment\">//&#123;name:&#x27;DexterHwang&#x27;,age:18&#125;</span><br><span class=\"hljs-keyword\">const</span> x = p1.study;<br>x(); <span class=\"hljs-comment\">// 输出undefined</span><br></code></pre></td></tr></table></figure>\n\n<p>p1 的原型链上是可以找到 study 方法的，然后把 study 方法赋值给了 x。也就相当于在栈上多了一个指针指向了 study 方法，这下 x 就彻底和 p1 没有关系了</p>\n<p>另外，再明确一点：_类中自定义的方法，都会启用局部严格模式_。也就是说 this 的值是 undefined</p>\n<p>也就是说 x 执行后 this 值就是 undefined</p>\n<p>验证：<em>类中自定义的方法，都会启用局部严格模式</em></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test2</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br><span class=\"hljs-meta\">  &quot;use strict&quot;</span>;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>&#125;<br><br>test(); <span class=\"hljs-comment\">// window</span><br>test2(); <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"分析-this-demo-this-demo-bind-this\"><a href=\"#分析-this-demo-this-demo-bind-this\" class=\"headerlink\" title=\"分析 this.demo = this.demo.bind(this)\"></a>分析 <code>this.demo = this.demo.bind(this)</code></h3><p>为什么用 bind()就可以解决 this 指向问题呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.state = &#123;<br>            ......<br>        &#125;<br>        <span class=\"hljs-built_in\">this</span>.demo = <span class=\"hljs-built_in\">this</span>.demo.bind(<span class=\"hljs-built_in\">this</span>)<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;this.demo&#125;</span>&gt;</span>你好，DexterHwang<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">demo</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>    &#125;<br>&#125;<br><br>ReactDom.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Person</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;app&#x27;</span>))<br><br><span class=\"hljs-comment\">// 点击后会输出：Person&#123;...&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>分析<code>this.demo = this.demo.bind(this)</code></p>\n<p>等号右侧的第一个 this 指向的是实例对象，这个实例对象上有 demo 方法吗？有，但是实在原型链上的。</p>\n<p>bind 方法做两件事：</p>\n<ol>\n<li>将 this 牢牢的绑定到传入的参数上</li>\n<li>返回一个新的函数</li>\n</ol>\n<p>等号右边第二个 this，也就是传入的参数，这个 this 指的就是实例对象</p>\n<p>这样的话返回了一个新的函数，而且这个函数牢牢的绑定到了实例对象上，并不需要去原型链上找了</p>\n<p>再看等号左侧，将返回的新函数赋值给了 this，这个 this 也是 Person 实例对象，用相同的方法名接收一下</p>\n<p>这样就可以使用了</p>\n<p>我们这样再去看<code>onClick=&#123;this.demo&#125;</code>,这下再点击后执行的就是实例自身上的 demo 方法了。</p>\n<hr>\n<h2 id=\"2021-12-25-更新——-React17-对比新旧生命周期\"><a href=\"#2021-12-25-更新——-React17-对比新旧生命周期\" class=\"headerlink\" title=\"2021-12-25 更新—— React17 对比新旧生命周期\"></a>2021-12-25 更新—— React17 对比新旧生命周期</h2><p>新的生命周期和旧的生命周期相比，即将废弃三个钩子：<code>componentWillMount</code>、<code>componentWillUpdate</code>、<code>componentWillReceiveProps</code></p>\n<p>新增了两个新的钩子：<code>getDerivedStateFromProps</code>、<code>getSnapshotBeforeUpdate</code></p>\n<p>剩下的都和之前的一样的</p>\n<h2 id=\"2021-12-16-更新——-React-配置代理\"><a href=\"#2021-12-16-更新——-React-配置代理\" class=\"headerlink\" title=\"2021-12-16 更新—— React 配置代理\"></a>2021-12-16 更新—— React 配置代理</h2><p>单个代理可以直接在<code>package.json</code>文件中配置<code>proxy</code></p>\n<p>多个代理则需要新建一个<code>setupProxy.js</code>文件，配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;http-proxy-middleware&quot;</span>);<br><br><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">app</span>) </span>&#123;<br>  app.use(<br>    proxy(<span class=\"hljs-string\">&quot;/api1&quot;</span>, &#123;<br>      <span class=\"hljs-comment\">//遇见api1前缀的请求，就会触发这个代理配置</span><br>      <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&quot;http://localhost:5000&quot;</span>, <span class=\"hljs-comment\">// 请求转发给谁，也就是服务器地址</span><br>      <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">// 控制服务器收到的请求头中Host的值，这里是localhost:5000</span><br>      <span class=\"hljs-attr\">pathRewrite</span>: &#123; <span class=\"hljs-string\">&quot;^/api1&quot;</span>: <span class=\"hljs-string\">&quot;&quot;</span> &#125;, <span class=\"hljs-comment\">// 重写请求路径</span><br>    &#125;),<br>    proxy(<span class=\"hljs-string\">&quot;/api2&quot;</span>, &#123;<br>      <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&quot;http://localhost:5001&quot;</span>,<br>      <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,<br>      <span class=\"hljs-attr\">pathRewrite</span>: &#123; <span class=\"hljs-string\">&quot;^/api2&quot;</span>: <span class=\"hljs-string\">&quot;&quot;</span> &#125;,<br>    &#125;)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><code>create-react-app</code>脚手架会自动找到<code>setupProxy.js</code>文件，并将配置加入到 webpack 中</p>\n<h2 id=\"2021-12-27-更新——-React-路由原理\"><a href=\"#2021-12-27-更新——-React-路由原理\" class=\"headerlink\" title=\"2021-12-27 更新—— React 路由原理\"></a>2021-12-27 更新—— React 路由原理</h2><p>靠的是 H5 推出的 history 上的 API</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//路由跳转</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">push</span>(<span class=\"hljs-params\">path</span>) </span>&#123;<br>  history.push(path);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 路由替换</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">replace</span>(<span class=\"hljs-params\">path</span>) </span>&#123;<br>  history.replace(path);<br>&#125;<br><br><span class=\"hljs-comment\">// 路由回退</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">back</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  history.goBack();<br>&#125;<br><br><span class=\"hljs-comment\">// 路由前进</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">forword</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  history.goForward();<br>&#125;<br><br><span class=\"hljs-comment\">// 监听路由变化</span><br>history.listen(<span class=\"hljs-function\">(<span class=\"hljs-params\">location</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;监听路由变化&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2021-12-28-更新——-全局事件总线\"><a href=\"#2021-12-28-更新——-全局事件总线\" class=\"headerlink\" title=\"2021-12-28 更新—— 全局事件总线\"></a>2021-12-28 更新—— 全局事件总线</h2><p>用第三方库<code>mitt</code>或者<code>pubsub</code>，可以实现多层级的组件之间的通信</p>\n<h2 id=\"2021-12-30-更新——-React的setState\"><a href=\"#2021-12-30-更新——-React的setState\" class=\"headerlink\" title=\"2021-12-30 更新—— React的setState()\"></a>2021-12-30 更新—— React的setState()</h2><p>异步执行</p>\n<ol>\n<li><p>多个setState()会推到一个任务队列里面，将多次执行合并为一个来执行。</p>\n</li>\n<li><p>setState()的几种写法</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//常规写法，这种写法会将多次setState()方法合并</span><br><span class=\"hljs-comment\">// counter的初始值为1</span><br><span class=\"hljs-built_in\">this</span>.setState(&#123;<br>  <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-built_in\">this</span>.state.counter+<span class=\"hljs-number\">1</span><br>&#125;)<br><span class=\"hljs-built_in\">this</span>.setState(&#123;<br>  <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-built_in\">this</span>.state.counter+<span class=\"hljs-number\">1</span><br>&#125;)<br><span class=\"hljs-built_in\">this</span>.setState(&#123;<br>  <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-built_in\">this</span>.state.counter+<span class=\"hljs-number\">1</span><br>&#125;)<br><span class=\"hljs-comment\">// counter的值是2</span><br><span class=\"hljs-comment\">// ----------------------------------------</span><br><span class=\"hljs-comment\">// 这种写法和上面执行结果不同，preState拿到的是最新的设置后的值（上一个setState设置的值）</span><br><span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\"><span class=\"hljs-params\">preState</span> =&gt;</span> (&#123;<br>  <span class=\"hljs-attr\">counter</span>: preState.counter + <span class=\"hljs-number\">1</span><br>&#125;))<br><br><span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\"><span class=\"hljs-params\">preState</span> =&gt;</span> (&#123;<br>  <span class=\"hljs-attr\">counter</span>: preState.counter + <span class=\"hljs-number\">1</span><br>&#125;))<br><br><span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\"><span class=\"hljs-params\">preState</span> =&gt;</span> (&#123;<br>  <span class=\"hljs-attr\">counter</span>: preState.counter + <span class=\"hljs-number\">1</span><br>&#125;))<br><span class=\"hljs-comment\">// counter的值是4</span><br></code></pre></td></tr></table></figure>\n\n<p>setState()方法里的第二个参数是一个回调函数，该函数能拿到设置之后的值</p>\n<h2 id=\"2021-12-31-更新——-无副作用\"><a href=\"#2021-12-31-更新——-无副作用\" class=\"headerlink\" title=\"2021-12-31 更新—— 无副作用\"></a>2021-12-31 更新—— 无副作用</h2><p>在React里经常看到<code>无副作用</code>这个词，它表示它只对自身有影响对自身以外的无影响，所有的输出都是由我的输入来决定的。</p>\n<p>发一个请求，设置了localstorage，对外部进行了操作这都叫做<strong>副作用</strong></p>\n<h2 id=\"React生命周期\"><a href=\"#React生命周期\" class=\"headerlink\" title=\"React生命周期\"></a>React生命周期</h2><ol>\n<li>组件初始化阶段 initialization, 比如constructor</li>\n<li>组件挂载阶段 mount<ol>\n<li>componentWillMount  组件挂载到DOM前调用,只会被调用一次, 这里写setState不会引起组件重新渲染</li>\n<li>render 返回一个react元素, react根据此函数的返回值渲染DOM. 不能在这里setState</li>\n<li>componentDidMount 组件挂载到DOM后调用, 且只会被调用一次</li>\n</ol>\n</li>\n<li>组件的更新阶段 update<ol>\n<li>componentWillReceiveProps(nextProps) 触发于props引起的组件更新过程中</li>\n<li>shouldComponentUpdate(nextProps, nextState) 比较之前和当前的props state是否有变化</li>\n<li>componentWillUpdate(nextProps, nextState) render方法前执行</li>\n<li>render</li>\n<li>componentDidUpdate(preProps, preState)</li>\n</ol>\n</li>\n<li>组件的卸载阶段 unmount<ol>\n<li>componentWillUnmount 卸载前调用, 在这里可以清理一些定时器</li>\n</ol>\n</li>\n</ol>\n<p><code>componentWillMount</code>,<code>componentWillReceiveProps</code>,<code>componentWillUnmount</code>在React17不建议使用，即将被废弃</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"React-中的this\"><a href=\"#React-中的this\" class=\"headerlink\" title=\"React 中的this\"></a>React 中的<code>this</code></h2><p>React 的官方文档里写的自定义的方法都需要用 bind 方法绑定一下才能使用，否则 this 会出现指向问题，那究竟是为什么呢？</p>\n<h3 id=\"探讨一\"><a href=\"#探讨一\" class=\"headerlink\" title=\"探讨一\"></a>探讨一</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.state = &#123;<br>            ......<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;demo&#125;</span>&gt;</span>你好，DexterHwang<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">demo</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.state)   <span class=\"hljs-comment\">// 会报错，注意此处的this</span><br>&#125;<br><br>ReactDom.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Person</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;app&#x27;</span>))<br></code></pre></td></tr></table></figure>\n\n<p><code>React</code> 中的 <code>Babel</code> 使用了严格模式，所以写的全局的 <code>this</code>指向的是<code>undefined</code></p>\n<p>而且 <code>demo</code> 方法并不写在 <code>Person</code> 类中，所以这个 <code>this</code> 也不会指向 <code>Person</code> 的实例对象</p>\n<h3 id=\"探讨二\"><a href=\"#探讨二\" class=\"headerlink\" title=\"探讨二\"></a>探讨二</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.state = &#123;<br>            ......<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;demo&#125;</span>&gt;</span>你好，DexterHwang<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span> <span class=\"hljs-comment\">// 会报错，报错信息为：`demo is not defined`。`onClick=&#123;demo&#125;`是找不到 `demo` 方法的</span><br>        <span class=\"hljs-comment\">// return &lt;div onClick=&#123;this.demo&#125;&gt;你好，DexterHwang&lt;/div&gt; // 这样写也会报错，因为并不是通过实例对象去调用demo方法。由于demo是作为onClick的回调，不是通过实例调用的，是直接调用。类中的方法默认开启了局部的严格模式，所以this值是undefined</span><br>    &#125;<br>    <span class=\"hljs-comment\">// demo方法在Person的原型对象(prototype)上，也就是在Person的实例对象的原型链上(_proto_)</span><br>    <span class=\"hljs-comment\">// 只有通过Person实例对象调用demo方法时，demo里面的this指向的就是Person的实例对象</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">demo</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>    &#125;<br>&#125;<br><br>ReactDom.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Person</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;app&#x27;</span>))<br></code></pre></td></tr></table></figure>\n\n<p>我们看下面的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">name, age</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.name = name;<br>    <span class=\"hljs-built_in\">this</span>.age = age;<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">study</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">&quot;DexterHwang&quot;</span>, <span class=\"hljs-number\">18</span>);<br><br>p1.study(); <span class=\"hljs-comment\">//&#123;name:&#x27;DexterHwang&#x27;,age:18&#125;</span><br><span class=\"hljs-keyword\">const</span> x = p1.study;<br>x(); <span class=\"hljs-comment\">// 输出undefined</span><br></code></pre></td></tr></table></figure>\n\n<p>p1 的原型链上是可以找到 study 方法的，然后把 study 方法赋值给了 x。也就相当于在栈上多了一个指针指向了 study 方法，这下 x 就彻底和 p1 没有关系了</p>\n<p>另外，再明确一点：_类中自定义的方法，都会启用局部严格模式_。也就是说 this 的值是 undefined</p>\n<p>也就是说 x 执行后 this 值就是 undefined</p>\n<p>验证：<em>类中自定义的方法，都会启用局部严格模式</em></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test2</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br><span class=\"hljs-meta\">  &quot;use strict&quot;</span>;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>);<br>&#125;<br><br>test(); <span class=\"hljs-comment\">// window</span><br>test2(); <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"分析-this-demo-this-demo-bind-this\"><a href=\"#分析-this-demo-this-demo-bind-this\" class=\"headerlink\" title=\"分析 this.demo = this.demo.bind(this)\"></a>分析 <code>this.demo = this.demo.bind(this)</code></h3><p>为什么用 bind()就可以解决 this 指向问题呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>        <span class=\"hljs-built_in\">this</span>.state = &#123;<br>            ......<br>        &#125;<br>        <span class=\"hljs-built_in\">this</span>.demo = <span class=\"hljs-built_in\">this</span>.demo.bind(<span class=\"hljs-built_in\">this</span>)<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;this.demo&#125;</span>&gt;</span>你好，DexterHwang<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">demo</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>    &#125;<br>&#125;<br><br>ReactDom.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Person</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;app&#x27;</span>))<br><br><span class=\"hljs-comment\">// 点击后会输出：Person&#123;...&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>分析<code>this.demo = this.demo.bind(this)</code></p>\n<p>等号右侧的第一个 this 指向的是实例对象，这个实例对象上有 demo 方法吗？有，但是实在原型链上的。</p>\n<p>bind 方法做两件事：</p>\n<ol>\n<li>将 this 牢牢的绑定到传入的参数上</li>\n<li>返回一个新的函数</li>\n</ol>\n<p>等号右边第二个 this，也就是传入的参数，这个 this 指的就是实例对象</p>\n<p>这样的话返回了一个新的函数，而且这个函数牢牢的绑定到了实例对象上，并不需要去原型链上找了</p>\n<p>再看等号左侧，将返回的新函数赋值给了 this，这个 this 也是 Person 实例对象，用相同的方法名接收一下</p>\n<p>这样就可以使用了</p>\n<p>我们这样再去看<code>onClick=&#123;this.demo&#125;</code>,这下再点击后执行的就是实例自身上的 demo 方法了。</p>\n<hr>\n<h2 id=\"2021-12-25-更新——-React17-对比新旧生命周期\"><a href=\"#2021-12-25-更新——-React17-对比新旧生命周期\" class=\"headerlink\" title=\"2021-12-25 更新—— React17 对比新旧生命周期\"></a>2021-12-25 更新—— React17 对比新旧生命周期</h2><p>新的生命周期和旧的生命周期相比，即将废弃三个钩子：<code>componentWillMount</code>、<code>componentWillUpdate</code>、<code>componentWillReceiveProps</code></p>\n<p>新增了两个新的钩子：<code>getDerivedStateFromProps</code>、<code>getSnapshotBeforeUpdate</code></p>\n<p>剩下的都和之前的一样的</p>\n<h2 id=\"2021-12-16-更新——-React-配置代理\"><a href=\"#2021-12-16-更新——-React-配置代理\" class=\"headerlink\" title=\"2021-12-16 更新—— React 配置代理\"></a>2021-12-16 更新—— React 配置代理</h2><p>单个代理可以直接在<code>package.json</code>文件中配置<code>proxy</code></p>\n<p>多个代理则需要新建一个<code>setupProxy.js</code>文件，配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;http-proxy-middleware&quot;</span>);<br><br><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">app</span>) </span>&#123;<br>  app.use(<br>    proxy(<span class=\"hljs-string\">&quot;/api1&quot;</span>, &#123;<br>      <span class=\"hljs-comment\">//遇见api1前缀的请求，就会触发这个代理配置</span><br>      <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&quot;http://localhost:5000&quot;</span>, <span class=\"hljs-comment\">// 请求转发给谁，也就是服务器地址</span><br>      <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">// 控制服务器收到的请求头中Host的值，这里是localhost:5000</span><br>      <span class=\"hljs-attr\">pathRewrite</span>: &#123; <span class=\"hljs-string\">&quot;^/api1&quot;</span>: <span class=\"hljs-string\">&quot;&quot;</span> &#125;, <span class=\"hljs-comment\">// 重写请求路径</span><br>    &#125;),<br>    proxy(<span class=\"hljs-string\">&quot;/api2&quot;</span>, &#123;<br>      <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&quot;http://localhost:5001&quot;</span>,<br>      <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,<br>      <span class=\"hljs-attr\">pathRewrite</span>: &#123; <span class=\"hljs-string\">&quot;^/api2&quot;</span>: <span class=\"hljs-string\">&quot;&quot;</span> &#125;,<br>    &#125;)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><code>create-react-app</code>脚手架会自动找到<code>setupProxy.js</code>文件，并将配置加入到 webpack 中</p>\n<h2 id=\"2021-12-27-更新——-React-路由原理\"><a href=\"#2021-12-27-更新——-React-路由原理\" class=\"headerlink\" title=\"2021-12-27 更新—— React 路由原理\"></a>2021-12-27 更新—— React 路由原理</h2><p>靠的是 H5 推出的 history 上的 API</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//路由跳转</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">push</span>(<span class=\"hljs-params\">path</span>) </span>&#123;<br>  history.push(path);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 路由替换</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">replace</span>(<span class=\"hljs-params\">path</span>) </span>&#123;<br>  history.replace(path);<br>&#125;<br><br><span class=\"hljs-comment\">// 路由回退</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">back</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  history.goBack();<br>&#125;<br><br><span class=\"hljs-comment\">// 路由前进</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">forword</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  history.goForward();<br>&#125;<br><br><span class=\"hljs-comment\">// 监听路由变化</span><br>history.listen(<span class=\"hljs-function\">(<span class=\"hljs-params\">location</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;监听路由变化&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2021-12-28-更新——-全局事件总线\"><a href=\"#2021-12-28-更新——-全局事件总线\" class=\"headerlink\" title=\"2021-12-28 更新—— 全局事件总线\"></a>2021-12-28 更新—— 全局事件总线</h2><p>用第三方库<code>mitt</code>或者<code>pubsub</code>，可以实现多层级的组件之间的通信</p>\n<h2 id=\"2021-12-30-更新——-React的setState\"><a href=\"#2021-12-30-更新——-React的setState\" class=\"headerlink\" title=\"2021-12-30 更新—— React的setState()\"></a>2021-12-30 更新—— React的setState()</h2><p>异步执行</p>\n<ol>\n<li><p>多个setState()会推到一个任务队列里面，将多次执行合并为一个来执行。</p>\n</li>\n<li><p>setState()的几种写法</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//常规写法，这种写法会将多次setState()方法合并</span><br><span class=\"hljs-comment\">// counter的初始值为1</span><br><span class=\"hljs-built_in\">this</span>.setState(&#123;<br>  <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-built_in\">this</span>.state.counter+<span class=\"hljs-number\">1</span><br>&#125;)<br><span class=\"hljs-built_in\">this</span>.setState(&#123;<br>  <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-built_in\">this</span>.state.counter+<span class=\"hljs-number\">1</span><br>&#125;)<br><span class=\"hljs-built_in\">this</span>.setState(&#123;<br>  <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-built_in\">this</span>.state.counter+<span class=\"hljs-number\">1</span><br>&#125;)<br><span class=\"hljs-comment\">// counter的值是2</span><br><span class=\"hljs-comment\">// ----------------------------------------</span><br><span class=\"hljs-comment\">// 这种写法和上面执行结果不同，preState拿到的是最新的设置后的值（上一个setState设置的值）</span><br><span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\"><span class=\"hljs-params\">preState</span> =&gt;</span> (&#123;<br>  <span class=\"hljs-attr\">counter</span>: preState.counter + <span class=\"hljs-number\">1</span><br>&#125;))<br><br><span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\"><span class=\"hljs-params\">preState</span> =&gt;</span> (&#123;<br>  <span class=\"hljs-attr\">counter</span>: preState.counter + <span class=\"hljs-number\">1</span><br>&#125;))<br><br><span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\"><span class=\"hljs-params\">preState</span> =&gt;</span> (&#123;<br>  <span class=\"hljs-attr\">counter</span>: preState.counter + <span class=\"hljs-number\">1</span><br>&#125;))<br><span class=\"hljs-comment\">// counter的值是4</span><br></code></pre></td></tr></table></figure>\n\n<p>setState()方法里的第二个参数是一个回调函数，该函数能拿到设置之后的值</p>\n<h2 id=\"2021-12-31-更新——-无副作用\"><a href=\"#2021-12-31-更新——-无副作用\" class=\"headerlink\" title=\"2021-12-31 更新—— 无副作用\"></a>2021-12-31 更新—— 无副作用</h2><p>在React里经常看到<code>无副作用</code>这个词，它表示它只对自身有影响对自身以外的无影响，所有的输出都是由我的输入来决定的。</p>\n<p>发一个请求，设置了localstorage，对外部进行了操作这都叫做<strong>副作用</strong></p>\n<h2 id=\"React生命周期\"><a href=\"#React生命周期\" class=\"headerlink\" title=\"React生命周期\"></a>React生命周期</h2><ol>\n<li>组件初始化阶段 initialization, 比如constructor</li>\n<li>组件挂载阶段 mount<ol>\n<li>componentWillMount  组件挂载到DOM前调用,只会被调用一次, 这里写setState不会引起组件重新渲染</li>\n<li>render 返回一个react元素, react根据此函数的返回值渲染DOM. 不能在这里setState</li>\n<li>componentDidMount 组件挂载到DOM后调用, 且只会被调用一次</li>\n</ol>\n</li>\n<li>组件的更新阶段 update<ol>\n<li>componentWillReceiveProps(nextProps) 触发于props引起的组件更新过程中</li>\n<li>shouldComponentUpdate(nextProps, nextState) 比较之前和当前的props state是否有变化</li>\n<li>componentWillUpdate(nextProps, nextState) render方法前执行</li>\n<li>render</li>\n<li>componentDidUpdate(preProps, preState)</li>\n</ol>\n</li>\n<li>组件的卸载阶段 unmount<ol>\n<li>componentWillUnmount 卸载前调用, 在这里可以清理一些定时器</li>\n</ol>\n</li>\n</ol>\n<p><code>componentWillMount</code>,<code>componentWillReceiveProps</code>,<code>componentWillUnmount</code>在React17不建议使用，即将被废弃</p>\n"},{"title":"React搭配Mobx开发","date":"2021-12-22T08:06:55.000Z","_content":"\n今天试了一下React搭配Mobx开发，确实好用\n\n先挖个坑，有空来填\n","source":"_posts/2021-12-22-React搭配Mobx开发.md","raw":"---\ntitle: React搭配Mobx开发\ndate: 2021-12-22 16:06:55\ntags: React\ncategories: 技术类-React\n---\n\n今天试了一下React搭配Mobx开发，确实好用\n\n先挖个坑，有空来填\n","slug":"React搭配Mobx开发","published":1,"updated":"2021-12-22T08:07:59.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5x00247oo9dlx1evcc","content":"<p>今天试了一下React搭配Mobx开发，确实好用</p>\n<p>先挖个坑，有空来填</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天试了一下React搭配Mobx开发，确实好用</p>\n<p>先挖个坑，有空来填</p>\n"},{"title":"目前感兴趣以及值得学习的技术","date":"2021-12-23T06:00:54.000Z","_content":"\n1. mobx，状态管理工具\n\n2. Flutter，Flutter 是 Google 开源的应用开发框架，仅通过一套代码库，就能构建精美的、原生平台编译的多平台应用。\n链接：https://flutter.cn/\n\n3. Fiber，一个受express启发，用Go编写的web框架。Fiber是一个建立在fastttp之上的Go web框架，fastttp是Go最快的HTTP引擎。它的设计是为了在零内存分配和零性能的情况下简化快速开发。\n\n4. Taro，Taro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ / 飞书 小程序 / H5 / RN 等应用。\n","source":"_posts/2021-12-23-2021-12-23-每日TODO.md","raw":"---\ntitle: 目前感兴趣以及值得学习的技术\ndate: 2021-12-23 14:00:54\ntags: [TODO]\n---\n\n1. mobx，状态管理工具\n\n2. Flutter，Flutter 是 Google 开源的应用开发框架，仅通过一套代码库，就能构建精美的、原生平台编译的多平台应用。\n链接：https://flutter.cn/\n\n3. Fiber，一个受express启发，用Go编写的web框架。Fiber是一个建立在fastttp之上的Go web框架，fastttp是Go最快的HTTP引擎。它的设计是为了在零内存分配和零性能的情况下简化快速开发。\n\n4. Taro，Taro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ / 飞书 小程序 / H5 / RN 等应用。\n","slug":"2021-12-23-每日TODO","published":1,"updated":"2021-12-31T07:33:58.749Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno5z00287oo93r5mgvhr","content":"<ol>\n<li><p>mobx，状态管理工具</p>\n</li>\n<li><p>Flutter，Flutter 是 Google 开源的应用开发框架，仅通过一套代码库，就能构建精美的、原生平台编译的多平台应用。<br>链接：<a href=\"https://flutter.cn/\">https://flutter.cn/</a></p>\n</li>\n<li><p>Fiber，一个受express启发，用Go编写的web框架。Fiber是一个建立在fastttp之上的Go web框架，fastttp是Go最快的HTTP引擎。它的设计是为了在零内存分配和零性能的情况下简化快速开发。</p>\n</li>\n<li><p>Taro，Taro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ / 飞书 小程序 / H5 / RN 等应用。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>mobx，状态管理工具</p>\n</li>\n<li><p>Flutter，Flutter 是 Google 开源的应用开发框架，仅通过一套代码库，就能构建精美的、原生平台编译的多平台应用。<br>链接：<a href=\"https://flutter.cn/\">https://flutter.cn/</a></p>\n</li>\n<li><p>Fiber，一个受express启发，用Go编写的web框架。Fiber是一个建立在fastttp之上的Go web框架，fastttp是Go最快的HTTP引擎。它的设计是为了在零内存分配和零性能的情况下简化快速开发。</p>\n</li>\n<li><p>Taro，Taro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ / 飞书 小程序 / H5 / RN 等应用。</p>\n</li>\n</ol>\n"},{"title":"装饰器的使用","date":"2021-12-23T06:37:11.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n## 在 create-react-app 搭建的项目中使用装饰器\n\n1. 执行`yarn eject`命令，暴露出配置项\n\n2. 因为装饰器是新的提案，许多浏览器和 Node 环境并不支持，所以我们需要安装插件：`@babel/plugin-proposal-decorators`。使用`create-react-app`创建的项目自带这个插件，不过我们需要配置一下，找到`package.json`文件加入一下代码：\n\n```json\n{\n  \"babel\": {\n    \"presets\": [\"react-app\"],\n\n    \"plugins\": [[\"@babel/plugin-proposal-decorators\", { \"legacy\": true }]]\n  }\n}\n```\n\n另外 vscode 可能会提示你需要配置`tsconfig`或`jsconfig`文件，我们在项目根目录创建`jsconfig.js`，并写入：\n\n```json\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n这样就能愉快的在项目中使用装饰器了\n\n## 装饰器的使用\n\n### 使用装饰器修饰类\n\n```js\n//声明一个装饰器\nfunction fn(target) {\n  //这个函数的`target`指的就是装饰器要修饰的类\n  target.test = false;\n}\n\n@fn //使用装饰器\nclass Person {\n  //声明一个类\n}\n@fn\nclass Dog {\n  //声明另一个类\n}\n\nconsole.log(Person.test); //false\nconsole.log(Dog.test); //false\n```\n\n![输出结果](https://upload-images.jianshu.io/upload_images/13931286-758df1981c769cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到`Person`类和`Dog`类下面多出了一个`test`属性，这就体现了装饰器的优点，无需更改类的内部代码也无需去继承就可以给类添加新功能\n\n### 使用装饰器传参\n\n```js\n@fn\n@fn2(5)\nclass Person {}\n\nfunction fn(target) {\n  target.test = false;\n}\n\nfunction fn2(value) {\n  return function (target) {\n    //这个函数的`target`指的就是装饰器要修饰的类\n    target.count = value;\n  };\n}\n\nconsole.log(Person.test);\nconsole.log(Person.count);\n```\n\n声明一个装饰器`fn2`，它接收一个值，并且返回一个函数，这个函数的`target`指的就是装饰器要修饰的类\n![输出结果](https://upload-images.jianshu.io/upload_images/13931286-446a1e6ba77e0c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 使用装饰器添加实例属性\n\n```js\n@fn\n@fn2(5)\n@fn3\nclass Person {}\n\nfunction fn(target) {\n  target.test = false;\n}\n\nfunction fn2(value) {\n  return function (target) {\n    target.count = value;\n  };\n}\n\nfunction fn3(target) {\n  target.prototype.foo = \"hhh\"; // target指的就是装饰的类，在类的原型对象上添加一个属性foo\n}\n\nconst test1 = new Person(); // new一个实例出来\nconsole.log(test1.foo);\n```\n\n![输出结果](https://upload-images.jianshu.io/upload_images/13931286-d69f263c088633e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 实现一个混入 mixins 功能\n\n```js\n// 实现一个mixins功能\nexport function mixins(...list) {\n  return function (target) {\n    Object.assign(target.prototype, ...list);\n  };\n}\n\nimport { mixins } from \"./mixins\";\n\nconst Test = {\n  test() {\n    console.log(\"这是测试\");\n  },\n};\n\n@mixins(Test)\nclass Myclass {}\n\nconst newMyclass = new Myclass();\nnewMyclass.test(); //这是测试\n```\n\n### 使用装饰器修饰类的成员\n\n```js\n@fn\n@fn2(5)\n@fn3\nclass Person {\n  @readonly message = \"hello\";\n}\n\nfunction fn(target) {\n  target.test = false;\n}\n\nfunction fn2(value) {\n  return function (target) {\n    target.count = value;\n  };\n}\n\nfunction fn3(target) {\n  target.prototype.foo = \"hhh\";\n}\n\nfunction readonly(target, name, descriptor) {\n  console.log(target); //目标类的原型对象 xxx.prototype\n  console.log(name); // 被修饰的类的成员名称\n  console.log(descriptor);\n  /*被修饰的类的成员的描述对象：\n    configurable: 能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true\n    enumerable: 是否被遍历，对象属性是否可通过for-in循环，flase为不可循环，默认值为true\n    initializer: 对象属性的默认值，默认值为undefined\n    writable: 对象属性是否可修改,flase为不可修改，默认值为true\n  */\n\n  descriptor.writable = false;\n}\n\nconst test1 = new Person();\ntest1.message = \"你好\";\n```\n\n它接收三个参数，具体看以上代码注释\n\n![输出结果](https://upload-images.jianshu.io/upload_images/13931286-4f66e2ca9e5b7c34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/2021-12-23-装饰器的使用.md","raw":"---\ntitle: 装饰器的使用\ndate: 2021-12-23 14:37:11\ntags: [JavaScript, 面试]\ncategories: 技术类-前端\n---\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n## 在 create-react-app 搭建的项目中使用装饰器\n\n1. 执行`yarn eject`命令，暴露出配置项\n\n2. 因为装饰器是新的提案，许多浏览器和 Node 环境并不支持，所以我们需要安装插件：`@babel/plugin-proposal-decorators`。使用`create-react-app`创建的项目自带这个插件，不过我们需要配置一下，找到`package.json`文件加入一下代码：\n\n```json\n{\n  \"babel\": {\n    \"presets\": [\"react-app\"],\n\n    \"plugins\": [[\"@babel/plugin-proposal-decorators\", { \"legacy\": true }]]\n  }\n}\n```\n\n另外 vscode 可能会提示你需要配置`tsconfig`或`jsconfig`文件，我们在项目根目录创建`jsconfig.js`，并写入：\n\n```json\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n这样就能愉快的在项目中使用装饰器了\n\n## 装饰器的使用\n\n### 使用装饰器修饰类\n\n```js\n//声明一个装饰器\nfunction fn(target) {\n  //这个函数的`target`指的就是装饰器要修饰的类\n  target.test = false;\n}\n\n@fn //使用装饰器\nclass Person {\n  //声明一个类\n}\n@fn\nclass Dog {\n  //声明另一个类\n}\n\nconsole.log(Person.test); //false\nconsole.log(Dog.test); //false\n```\n\n![输出结果](https://upload-images.jianshu.io/upload_images/13931286-758df1981c769cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到`Person`类和`Dog`类下面多出了一个`test`属性，这就体现了装饰器的优点，无需更改类的内部代码也无需去继承就可以给类添加新功能\n\n### 使用装饰器传参\n\n```js\n@fn\n@fn2(5)\nclass Person {}\n\nfunction fn(target) {\n  target.test = false;\n}\n\nfunction fn2(value) {\n  return function (target) {\n    //这个函数的`target`指的就是装饰器要修饰的类\n    target.count = value;\n  };\n}\n\nconsole.log(Person.test);\nconsole.log(Person.count);\n```\n\n声明一个装饰器`fn2`，它接收一个值，并且返回一个函数，这个函数的`target`指的就是装饰器要修饰的类\n![输出结果](https://upload-images.jianshu.io/upload_images/13931286-446a1e6ba77e0c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 使用装饰器添加实例属性\n\n```js\n@fn\n@fn2(5)\n@fn3\nclass Person {}\n\nfunction fn(target) {\n  target.test = false;\n}\n\nfunction fn2(value) {\n  return function (target) {\n    target.count = value;\n  };\n}\n\nfunction fn3(target) {\n  target.prototype.foo = \"hhh\"; // target指的就是装饰的类，在类的原型对象上添加一个属性foo\n}\n\nconst test1 = new Person(); // new一个实例出来\nconsole.log(test1.foo);\n```\n\n![输出结果](https://upload-images.jianshu.io/upload_images/13931286-d69f263c088633e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 实现一个混入 mixins 功能\n\n```js\n// 实现一个mixins功能\nexport function mixins(...list) {\n  return function (target) {\n    Object.assign(target.prototype, ...list);\n  };\n}\n\nimport { mixins } from \"./mixins\";\n\nconst Test = {\n  test() {\n    console.log(\"这是测试\");\n  },\n};\n\n@mixins(Test)\nclass Myclass {}\n\nconst newMyclass = new Myclass();\nnewMyclass.test(); //这是测试\n```\n\n### 使用装饰器修饰类的成员\n\n```js\n@fn\n@fn2(5)\n@fn3\nclass Person {\n  @readonly message = \"hello\";\n}\n\nfunction fn(target) {\n  target.test = false;\n}\n\nfunction fn2(value) {\n  return function (target) {\n    target.count = value;\n  };\n}\n\nfunction fn3(target) {\n  target.prototype.foo = \"hhh\";\n}\n\nfunction readonly(target, name, descriptor) {\n  console.log(target); //目标类的原型对象 xxx.prototype\n  console.log(name); // 被修饰的类的成员名称\n  console.log(descriptor);\n  /*被修饰的类的成员的描述对象：\n    configurable: 能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true\n    enumerable: 是否被遍历，对象属性是否可通过for-in循环，flase为不可循环，默认值为true\n    initializer: 对象属性的默认值，默认值为undefined\n    writable: 对象属性是否可修改,flase为不可修改，默认值为true\n  */\n\n  descriptor.writable = false;\n}\n\nconst test1 = new Person();\ntest1.message = \"你好\";\n```\n\n它接收三个参数，具体看以上代码注释\n\n![输出结果](https://upload-images.jianshu.io/upload_images/13931286-4f66e2ca9e5b7c34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"装饰器的使用","published":1,"updated":"2021-12-23T09:20:21.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno60002b7oo95q8bf1x1","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h2 id=\"在-create-react-app-搭建的项目中使用装饰器\"><a href=\"#在-create-react-app-搭建的项目中使用装饰器\" class=\"headerlink\" title=\"在 create-react-app 搭建的项目中使用装饰器\"></a>在 create-react-app 搭建的项目中使用装饰器</h2><ol>\n<li><p>执行<code>yarn eject</code>命令，暴露出配置项</p>\n</li>\n<li><p>因为装饰器是新的提案，许多浏览器和 Node 环境并不支持，所以我们需要安装插件：<code>@babel/plugin-proposal-decorators</code>。使用<code>create-react-app</code>创建的项目自带这个插件，不过我们需要配置一下，找到<code>package.json</code>文件加入一下代码：</p>\n</li>\n</ol>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<br>  <span class=\"hljs-attr\">&quot;babel&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;presets&quot;</span>: [<span class=\"hljs-string\">&quot;react-app&quot;</span>],<br><br>    <span class=\"hljs-attr\">&quot;plugins&quot;</span>: [[<span class=\"hljs-string\">&quot;@babel/plugin-proposal-decorators&quot;</span>, &#123; <span class=\"hljs-attr\">&quot;legacy&quot;</span>: <span class=\"hljs-literal\">true</span> &#125;]]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>另外 vscode 可能会提示你需要配置<code>tsconfig</code>或<code>jsconfig</code>文件，我们在项目根目录创建<code>jsconfig.js</code>，并写入：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<br>  <span class=\"hljs-attr\">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;experimentalDecorators&quot;</span>: <span class=\"hljs-literal\">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样就能愉快的在项目中使用装饰器了</p>\n<h2 id=\"装饰器的使用\"><a href=\"#装饰器的使用\" class=\"headerlink\" title=\"装饰器的使用\"></a>装饰器的使用</h2><h3 id=\"使用装饰器修饰类\"><a href=\"#使用装饰器修饰类\" class=\"headerlink\" title=\"使用装饰器修饰类\"></a>使用装饰器修饰类</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//声明一个装饰器</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">target</span>) </span>&#123;<br>  <span class=\"hljs-comment\">//这个函数的`target`指的就是装饰器要修饰的类</span><br>  target.test = <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br>@fn <span class=\"hljs-comment\">//使用装饰器</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;<br>  <span class=\"hljs-comment\">//声明一个类</span><br>&#125;<br>@fn<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> </span>&#123;<br>  <span class=\"hljs-comment\">//声明另一个类</span><br>&#125;<br><br><span class=\"hljs-built_in\">console</span>.log(Person.test); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-built_in\">console</span>.log(Dog.test); <span class=\"hljs-comment\">//false</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-758df1981c769cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"输出结果\"></p>\n<p>可以看到<code>Person</code>类和<code>Dog</code>类下面多出了一个<code>test</code>属性，这就体现了装饰器的优点，无需更改类的内部代码也无需去继承就可以给类添加新功能</p>\n<h3 id=\"使用装饰器传参\"><a href=\"#使用装饰器传参\" class=\"headerlink\" title=\"使用装饰器传参\"></a>使用装饰器传参</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">@fn<br>@fn2(<span class=\"hljs-number\">5</span>)<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">target</span>) </span>&#123;<br>  target.test = <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn2</span>(<span class=\"hljs-params\">value</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target</span>) </span>&#123;<br>    <span class=\"hljs-comment\">//这个函数的`target`指的就是装饰器要修饰的类</span><br>    target.count = value;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-built_in\">console</span>.log(Person.test);<br><span class=\"hljs-built_in\">console</span>.log(Person.count);<br></code></pre></td></tr></table></figure>\n\n<p>声明一个装饰器<code>fn2</code>，它接收一个值，并且返回一个函数，这个函数的<code>target</code>指的就是装饰器要修饰的类<br><img src=\"https://upload-images.jianshu.io/upload_images/13931286-446a1e6ba77e0c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"输出结果\"></p>\n<h3 id=\"使用装饰器添加实例属性\"><a href=\"#使用装饰器添加实例属性\" class=\"headerlink\" title=\"使用装饰器添加实例属性\"></a>使用装饰器添加实例属性</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">@fn<br>@fn2(<span class=\"hljs-number\">5</span>)<br>@fn3<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">target</span>) </span>&#123;<br>  target.test = <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn2</span>(<span class=\"hljs-params\">value</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target</span>) </span>&#123;<br>    target.count = value;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn3</span>(<span class=\"hljs-params\">target</span>) </span>&#123;<br>  target.prototype.foo = <span class=\"hljs-string\">&quot;hhh&quot;</span>; <span class=\"hljs-comment\">// target指的就是装饰的类，在类的原型对象上添加一个属性foo</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> test1 = <span class=\"hljs-keyword\">new</span> Person(); <span class=\"hljs-comment\">// new一个实例出来</span><br><span class=\"hljs-built_in\">console</span>.log(test1.foo);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-d69f263c088633e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"输出结果\"></p>\n<h3 id=\"实现一个混入-mixins-功能\"><a href=\"#实现一个混入-mixins-功能\" class=\"headerlink\" title=\"实现一个混入 mixins 功能\"></a>实现一个混入 mixins 功能</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 实现一个mixins功能</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mixins</span>(<span class=\"hljs-params\">...list</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">Object</span>.assign(target.prototype, ...list);<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">import</span> &#123; mixins &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./mixins&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> Test = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;这是测试&quot;</span>);<br>  &#125;,<br>&#125;;<br><br>@mixins(Test)<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Myclass</span> </span>&#123;&#125;<br><br><span class=\"hljs-keyword\">const</span> newMyclass = <span class=\"hljs-keyword\">new</span> Myclass();<br>newMyclass.test(); <span class=\"hljs-comment\">//这是测试</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用装饰器修饰类的成员\"><a href=\"#使用装饰器修饰类的成员\" class=\"headerlink\" title=\"使用装饰器修饰类的成员\"></a>使用装饰器修饰类的成员</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">@fn<br>@fn2(<span class=\"hljs-number\">5</span>)<br>@fn3<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;<br>  @readonly message = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">target</span>) </span>&#123;<br>  target.test = <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn2</span>(<span class=\"hljs-params\">value</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target</span>) </span>&#123;<br>    target.count = value;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn3</span>(<span class=\"hljs-params\">target</span>) </span>&#123;<br>  target.prototype.foo = <span class=\"hljs-string\">&quot;hhh&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">readonly</span>(<span class=\"hljs-params\">target, name, descriptor</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(target); <span class=\"hljs-comment\">//目标类的原型对象 xxx.prototype</span><br>  <span class=\"hljs-built_in\">console</span>.log(name); <span class=\"hljs-comment\">// 被修饰的类的成员名称</span><br>  <span class=\"hljs-built_in\">console</span>.log(descriptor);<br>  <span class=\"hljs-comment\">/*被修饰的类的成员的描述对象：</span><br><span class=\"hljs-comment\">    configurable: 能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true</span><br><span class=\"hljs-comment\">    enumerable: 是否被遍历，对象属性是否可通过for-in循环，flase为不可循环，默认值为true</span><br><span class=\"hljs-comment\">    initializer: 对象属性的默认值，默认值为undefined</span><br><span class=\"hljs-comment\">    writable: 对象属性是否可修改,flase为不可修改，默认值为true</span><br><span class=\"hljs-comment\">  */</span><br><br>  descriptor.writable = <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> test1 = <span class=\"hljs-keyword\">new</span> Person();<br>test1.message = <span class=\"hljs-string\">&quot;你好&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>它接收三个参数，具体看以上代码注释</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-4f66e2ca9e5b7c34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"输出结果\"></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h2 id=\"在-create-react-app-搭建的项目中使用装饰器\"><a href=\"#在-create-react-app-搭建的项目中使用装饰器\" class=\"headerlink\" title=\"在 create-react-app 搭建的项目中使用装饰器\"></a>在 create-react-app 搭建的项目中使用装饰器</h2><ol>\n<li><p>执行<code>yarn eject</code>命令，暴露出配置项</p>\n</li>\n<li><p>因为装饰器是新的提案，许多浏览器和 Node 环境并不支持，所以我们需要安装插件：<code>@babel/plugin-proposal-decorators</code>。使用<code>create-react-app</code>创建的项目自带这个插件，不过我们需要配置一下，找到<code>package.json</code>文件加入一下代码：</p>\n</li>\n</ol>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<br>  <span class=\"hljs-attr\">&quot;babel&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;presets&quot;</span>: [<span class=\"hljs-string\">&quot;react-app&quot;</span>],<br><br>    <span class=\"hljs-attr\">&quot;plugins&quot;</span>: [[<span class=\"hljs-string\">&quot;@babel/plugin-proposal-decorators&quot;</span>, &#123; <span class=\"hljs-attr\">&quot;legacy&quot;</span>: <span class=\"hljs-literal\">true</span> &#125;]]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>另外 vscode 可能会提示你需要配置<code>tsconfig</code>或<code>jsconfig</code>文件，我们在项目根目录创建<code>jsconfig.js</code>，并写入：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<br>  <span class=\"hljs-attr\">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class=\"hljs-attr\">&quot;experimentalDecorators&quot;</span>: <span class=\"hljs-literal\">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样就能愉快的在项目中使用装饰器了</p>\n<h2 id=\"装饰器的使用\"><a href=\"#装饰器的使用\" class=\"headerlink\" title=\"装饰器的使用\"></a>装饰器的使用</h2><h3 id=\"使用装饰器修饰类\"><a href=\"#使用装饰器修饰类\" class=\"headerlink\" title=\"使用装饰器修饰类\"></a>使用装饰器修饰类</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//声明一个装饰器</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">target</span>) </span>&#123;<br>  <span class=\"hljs-comment\">//这个函数的`target`指的就是装饰器要修饰的类</span><br>  target.test = <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br>@fn <span class=\"hljs-comment\">//使用装饰器</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;<br>  <span class=\"hljs-comment\">//声明一个类</span><br>&#125;<br>@fn<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> </span>&#123;<br>  <span class=\"hljs-comment\">//声明另一个类</span><br>&#125;<br><br><span class=\"hljs-built_in\">console</span>.log(Person.test); <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-built_in\">console</span>.log(Dog.test); <span class=\"hljs-comment\">//false</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-758df1981c769cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"输出结果\"></p>\n<p>可以看到<code>Person</code>类和<code>Dog</code>类下面多出了一个<code>test</code>属性，这就体现了装饰器的优点，无需更改类的内部代码也无需去继承就可以给类添加新功能</p>\n<h3 id=\"使用装饰器传参\"><a href=\"#使用装饰器传参\" class=\"headerlink\" title=\"使用装饰器传参\"></a>使用装饰器传参</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">@fn<br>@fn2(<span class=\"hljs-number\">5</span>)<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">target</span>) </span>&#123;<br>  target.test = <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn2</span>(<span class=\"hljs-params\">value</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target</span>) </span>&#123;<br>    <span class=\"hljs-comment\">//这个函数的`target`指的就是装饰器要修饰的类</span><br>    target.count = value;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-built_in\">console</span>.log(Person.test);<br><span class=\"hljs-built_in\">console</span>.log(Person.count);<br></code></pre></td></tr></table></figure>\n\n<p>声明一个装饰器<code>fn2</code>，它接收一个值，并且返回一个函数，这个函数的<code>target</code>指的就是装饰器要修饰的类<br><img src=\"https://upload-images.jianshu.io/upload_images/13931286-446a1e6ba77e0c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"输出结果\"></p>\n<h3 id=\"使用装饰器添加实例属性\"><a href=\"#使用装饰器添加实例属性\" class=\"headerlink\" title=\"使用装饰器添加实例属性\"></a>使用装饰器添加实例属性</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">@fn<br>@fn2(<span class=\"hljs-number\">5</span>)<br>@fn3<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">target</span>) </span>&#123;<br>  target.test = <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn2</span>(<span class=\"hljs-params\">value</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target</span>) </span>&#123;<br>    target.count = value;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn3</span>(<span class=\"hljs-params\">target</span>) </span>&#123;<br>  target.prototype.foo = <span class=\"hljs-string\">&quot;hhh&quot;</span>; <span class=\"hljs-comment\">// target指的就是装饰的类，在类的原型对象上添加一个属性foo</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> test1 = <span class=\"hljs-keyword\">new</span> Person(); <span class=\"hljs-comment\">// new一个实例出来</span><br><span class=\"hljs-built_in\">console</span>.log(test1.foo);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-d69f263c088633e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"输出结果\"></p>\n<h3 id=\"实现一个混入-mixins-功能\"><a href=\"#实现一个混入-mixins-功能\" class=\"headerlink\" title=\"实现一个混入 mixins 功能\"></a>实现一个混入 mixins 功能</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 实现一个mixins功能</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mixins</span>(<span class=\"hljs-params\">...list</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">Object</span>.assign(target.prototype, ...list);<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">import</span> &#123; mixins &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./mixins&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> Test = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;这是测试&quot;</span>);<br>  &#125;,<br>&#125;;<br><br>@mixins(Test)<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Myclass</span> </span>&#123;&#125;<br><br><span class=\"hljs-keyword\">const</span> newMyclass = <span class=\"hljs-keyword\">new</span> Myclass();<br>newMyclass.test(); <span class=\"hljs-comment\">//这是测试</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用装饰器修饰类的成员\"><a href=\"#使用装饰器修饰类的成员\" class=\"headerlink\" title=\"使用装饰器修饰类的成员\"></a>使用装饰器修饰类的成员</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">@fn<br>@fn2(<span class=\"hljs-number\">5</span>)<br>@fn3<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;<br>  @readonly message = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">target</span>) </span>&#123;<br>  target.test = <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn2</span>(<span class=\"hljs-params\">value</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target</span>) </span>&#123;<br>    target.count = value;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn3</span>(<span class=\"hljs-params\">target</span>) </span>&#123;<br>  target.prototype.foo = <span class=\"hljs-string\">&quot;hhh&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">readonly</span>(<span class=\"hljs-params\">target, name, descriptor</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(target); <span class=\"hljs-comment\">//目标类的原型对象 xxx.prototype</span><br>  <span class=\"hljs-built_in\">console</span>.log(name); <span class=\"hljs-comment\">// 被修饰的类的成员名称</span><br>  <span class=\"hljs-built_in\">console</span>.log(descriptor);<br>  <span class=\"hljs-comment\">/*被修饰的类的成员的描述对象：</span><br><span class=\"hljs-comment\">    configurable: 能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true</span><br><span class=\"hljs-comment\">    enumerable: 是否被遍历，对象属性是否可通过for-in循环，flase为不可循环，默认值为true</span><br><span class=\"hljs-comment\">    initializer: 对象属性的默认值，默认值为undefined</span><br><span class=\"hljs-comment\">    writable: 对象属性是否可修改,flase为不可修改，默认值为true</span><br><span class=\"hljs-comment\">  */</span><br><br>  descriptor.writable = <span class=\"hljs-literal\">false</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> test1 = <span class=\"hljs-keyword\">new</span> Person();<br>test1.message = <span class=\"hljs-string\">&quot;你好&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>它接收三个参数，具体看以上代码注释</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13931286-4f66e2ca9e5b7c34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"输出结果\"></p>\n"},{"title":"Vue随笔","date":"2022-01-07T09:20:21.000Z","_content":"\n## 前言\n\n本文记录的是我个人认为在实际项目中不常用的，但是重要或者会在面试中遇到的。\n\n## 表单输入绑定\n\n`v-model`在内部为不同的输入元素使用不同的 property 并抛出不同的事件：\n\n- text 和 textarea 元素使用 value property 和 input 事件；\n- checkbox 和 radio 使用 checked property 和 change 事件；\n- select 字段将 value 作为 prop 并将 change 作为事件。\n\n### .lazy\n\n在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件之后进行同步：\n\n```js\n<!-- 在“change”时而非“input”时更新 -->\n<input v-model.lazy=\"msg\" />\n```\n\n### .number\n\n如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：\n\n```js\n<input v-model.number=\"age\" type=\"text\" />\n```\n\n当输入类型为 `text` 时这通常很有用。如果输入类型是 `number`，Vue 能够自动将原始字符串转换为数字，无需为 `v-model` 添加 `.number` 修饰符。如果这个值无法被 `parseFloat()` 解析，则返回原始的值。\n\n### .trim\n\n如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\n\n```js\n<input v-model.trim=\"msg\" />\n```\n\n## 全局API\n\n## h\n\n返回一个”虚拟节点“，通常缩写为**VNode**：一个普通对象，其中包含向 Vue 描述它应在页面上渲染哪种节点的信息，包括所有子节点的描述。它的目的是用于手动编写的渲染函数：\n\nrender() {\n  return h('h1', {}, 'Some title')\n}\n\n### 参数\n\n接收三个参数：`type`，`props` 和 `children`\n","source":"_posts/2022-01-07-Vue随笔.md","raw":"---\ntitle: Vue随笔\ndate: 2022-01-07 17:20:21\ntags: [Vue, 面试]\ncategories: 技术类-Vue\n---\n\n## 前言\n\n本文记录的是我个人认为在实际项目中不常用的，但是重要或者会在面试中遇到的。\n\n## 表单输入绑定\n\n`v-model`在内部为不同的输入元素使用不同的 property 并抛出不同的事件：\n\n- text 和 textarea 元素使用 value property 和 input 事件；\n- checkbox 和 radio 使用 checked property 和 change 事件；\n- select 字段将 value 作为 prop 并将 change 作为事件。\n\n### .lazy\n\n在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件之后进行同步：\n\n```js\n<!-- 在“change”时而非“input”时更新 -->\n<input v-model.lazy=\"msg\" />\n```\n\n### .number\n\n如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：\n\n```js\n<input v-model.number=\"age\" type=\"text\" />\n```\n\n当输入类型为 `text` 时这通常很有用。如果输入类型是 `number`，Vue 能够自动将原始字符串转换为数字，无需为 `v-model` 添加 `.number` 修饰符。如果这个值无法被 `parseFloat()` 解析，则返回原始的值。\n\n### .trim\n\n如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\n\n```js\n<input v-model.trim=\"msg\" />\n```\n\n## 全局API\n\n## h\n\n返回一个”虚拟节点“，通常缩写为**VNode**：一个普通对象，其中包含向 Vue 描述它应在页面上渲染哪种节点的信息，包括所有子节点的描述。它的目的是用于手动编写的渲染函数：\n\nrender() {\n  return h('h1', {}, 'Some title')\n}\n\n### 参数\n\n接收三个参数：`type`，`props` 和 `children`\n","slug":"Vue随笔","published":1,"updated":"2022-01-19T09:14:35.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno62002g7oo99u0p7k36","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文记录的是我个人认为在实际项目中不常用的，但是重要或者会在面试中遇到的。</p>\n<h2 id=\"表单输入绑定\"><a href=\"#表单输入绑定\" class=\"headerlink\" title=\"表单输入绑定\"></a>表单输入绑定</h2><p><code>v-model</code>在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>\n<ul>\n<li>text 和 textarea 元素使用 value property 和 input 事件；</li>\n<li>checkbox 和 radio 使用 checked property 和 change 事件；</li>\n<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>\n</ul>\n<h3 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\".lazy\"></a>.lazy</h3><p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步。你可以添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件之后进行同步：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;!-- 在“change”时而非“input”时更新 --&gt;<br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model.lazy</span>=<span class=\"hljs-string\">&quot;msg&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\".number\"></a>.number</h3><p>如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;input v-model.number=<span class=\"hljs-string\">&quot;age&quot;</span> type=<span class=\"hljs-string\">&quot;text&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>\n\n<p>当输入类型为 <code>text</code> 时这通常很有用。如果输入类型是 <code>number</code>，Vue 能够自动将原始字符串转换为数字，无需为 <code>v-model</code> 添加 <code>.number</code> 修饰符。如果这个值无法被 <code>parseFloat()</code> 解析，则返回原始的值。</p>\n<h3 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\".trim\"></a>.trim</h3><p>如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;input v-model.trim=<span class=\"hljs-string\">&quot;msg&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"全局API\"><a href=\"#全局API\" class=\"headerlink\" title=\"全局API\"></a>全局API</h2><h2 id=\"h\"><a href=\"#h\" class=\"headerlink\" title=\"h\"></a>h</h2><p>返回一个”虚拟节点“，通常缩写为<strong>VNode</strong>：一个普通对象，其中包含向 Vue 描述它应在页面上渲染哪种节点的信息，包括所有子节点的描述。它的目的是用于手动编写的渲染函数：</p>\n<p>render() {<br>  return h(‘h1’, {}, ‘Some title’)<br>}</p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>接收三个参数：<code>type</code>，<code>props</code> 和 <code>children</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文记录的是我个人认为在实际项目中不常用的，但是重要或者会在面试中遇到的。</p>\n<h2 id=\"表单输入绑定\"><a href=\"#表单输入绑定\" class=\"headerlink\" title=\"表单输入绑定\"></a>表单输入绑定</h2><p><code>v-model</code>在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>\n<ul>\n<li>text 和 textarea 元素使用 value property 和 input 事件；</li>\n<li>checkbox 和 radio 使用 checked property 和 change 事件；</li>\n<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>\n</ul>\n<h3 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\".lazy\"></a>.lazy</h3><p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步。你可以添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件之后进行同步：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;!-- 在“change”时而非“input”时更新 --&gt;<br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model.lazy</span>=<span class=\"hljs-string\">&quot;msg&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\".number\"></a>.number</h3><p>如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;input v-model.number=<span class=\"hljs-string\">&quot;age&quot;</span> type=<span class=\"hljs-string\">&quot;text&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>\n\n<p>当输入类型为 <code>text</code> 时这通常很有用。如果输入类型是 <code>number</code>，Vue 能够自动将原始字符串转换为数字，无需为 <code>v-model</code> 添加 <code>.number</code> 修饰符。如果这个值无法被 <code>parseFloat()</code> 解析，则返回原始的值。</p>\n<h3 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\".trim\"></a>.trim</h3><p>如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;input v-model.trim=<span class=\"hljs-string\">&quot;msg&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"全局API\"><a href=\"#全局API\" class=\"headerlink\" title=\"全局API\"></a>全局API</h2><h2 id=\"h\"><a href=\"#h\" class=\"headerlink\" title=\"h\"></a>h</h2><p>返回一个”虚拟节点“，通常缩写为<strong>VNode</strong>：一个普通对象，其中包含向 Vue 描述它应在页面上渲染哪种节点的信息，包括所有子节点的描述。它的目的是用于手动编写的渲染函数：</p>\n<p>render() {<br>  return h(‘h1’, {}, ‘Some title’)<br>}</p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>接收三个参数：<code>type</code>，<code>props</code> 和 <code>children</code></p>\n"},{"title":"浏览器相关面试知识点","date":"2022-01-11T06:04:48.000Z","_content":"\n## 一.详解浏览器事件捕获与冒泡\n\n### 1. 事件委托/事件代理\n\n捕获阶段-->目标阶段-->冒泡阶段\n\n```js\nwindow.addEventListener(\n  \"click\",\n  function (e) {\n    console.log(\"window捕获\", e.target.nodeName, e.currentTarget.nodeName);\n  },\n  true\n);\n```\n\n- 第三个参数为 true，则监听捕获事件，不传或者传 false，则监听冒泡事件\n- `e.target`指的是点击的元素，`e.currentTarget`指的是当前触发事件的元素\n\n### 2. 阻止事件的传播\n\n`e.stopPropagation()`真正的作用是阻止事件的传播，既可以阻止事件的捕获也可以阻止事件的冒泡\n\n#### 面试题\n\n现在有一个页面，这个页面上有许多元素，div、p、button 等\n每个元素都有自己的 click 事件，都不相同\n现在有一个新需求，一个用户进入这个页面的时候，会有一个状态：`banned`，我们可以在全局上拿到这个状态：`window.banned`，\n为`true`的话表示当前用户被封禁，用户点击页面的任何元素都不执行原有逻辑，而是`alert`弹窗，提示你被封禁了；\n为`false`的话表示有操作权限。\n请问：如何实现？\n**答：**\n方案一：在最外层的一个元素上绑定上一个捕获事件，即`addEventListener`里的第三个参数为`true`，如果`window.banned`为`true`则`e.stopPropagation()`。\n\n```js\n//const body = document.getElementsByTagName('body')\nwindow.addEventListener('click',function(e){\n  if(window.banner){\n    e.stopPropagation()\n    alert('你被封禁了')\n    return\n  }\n  ...\n},true)\n```\n\n方案二：`window.banner`为`true`的时候展示一个全屏的最高层级（即：`z-index:99999`）的 div 遮罩，遮住整个页面。\n\n### 3.阻止默认事件\n\n`e.preventDefault()`\n这个没啥好说的\n\n### 4.兼容性问题\n\n`addEventListener` --> firefox、Chrome、高版本 IE、safari、opera\n`attachEvent` --> IE7、IE8，除了政府网站，大部分公司不会再去针对他们做兼容了\nIE 浏览器里没有事件捕获，只有事件冒泡\n\n#### 针对兼容性做一下封装\n\n```js\nclass BomEvent {\n  constructor(element) {\n    this.element = element;\n  }\n  addEvent(type, handler) {\n    if (this.element.addEventListener) {\n      this.element.addEventListener(type, handler, false);\n    } else if (this.element.attachEvent) {\n      this.element.attachEvent(`on${type}`, function () {\n        // 这是处于ie7或8的一个环境，不支持箭头函数，所以这里做一下绑定\n        handler.call(element);\n      });\n    } else {\n      this.element[`on${type}`] = handler;\n    }\n  }\n\n  removeEvent(type, handler) {\n    if (this.element.removeEventListener) {\n      this.element.removeEventListener(type, handler, false);\n    } else if (this.element.detachEvent) {\n      this.element.detachEvent(`on${type}`, handler);\n    } else {\n      this.element[`on${type}`] = null;\n    }\n  }\n}\n\n// IE浏览器里没有事件捕获，只有事件冒泡\nfunction stopPropagation(event) {\n  if (event.stopPropagation) {\n    event.stopPropagation(); //标准w3c浏览器\n  } else {\n    event.cancelBubble = true; // IE\n  }\n}\n\nfunction preventDefault(event) {\n  if (event.preventDefault) {\n    event.preventDefault();\n  } else {\n    event.returnValue = false;\n  }\n}\n```\n\n## 二：浏览器请求相关内容 Ajax 与 fetch\n\n**原生 ajax：**\n\n```js\nconst xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"http://domain/service\"); //建立连接，并没有发送请求\n\n//监听状态\nxhr.onreadystatechange = function () {\n  // 表示请求还没有完成\n  if (xhr.readyState !== 4) {\n    return;\n  } else if (xhr.status === 200) {\n    // 请求成功\n    console.log(xhr.responseText);\n  } else {\n    //报错了\n    console.error(\n      `HTTP error,status=${xhr.status},errorText = ${xhr.statusText}`\n    );\n  }\n};\n// 超时时间\nxhr.timeout = 3000;\nxhr.ontimeout = () => {\n  console.log(\"请求超时\");\n};\n\n// 上传进度条\nxhr.upload.onprogress = (p) => {\n  const percent = Math.round((p.loaded / p.total) * 100) + \"%\";\n};\n\nxhr.send(); //发送请求\n```\n\n**fetch**:浏览器新增的 fetch，内部封装了 promise\n\n```js\nfetch(\"http://domain/service\", {\n  method: \"GET\",\n  credentials: \"same-origin\", // 同域的请求会带上cookie\n})\n  .then((response) => {\n    if (response.ok) {\n      //请求成功\n      return response.json();\n    }\n    throw new Error(\" http error\");\n  })\n  .then((json) => {\n    console.log(json);\n  })\n  .catch((error) => {\n    console.error(error);\n    // 统一的错误管理\n    // 接收fetch出现的错误\n    //  接收请求错误信息\n  });\n```\n\n`fetch`不能直接通过`catch`来获取请求错误信息，而是要通过判断`response.ok`来返回出错误信息再通过`catch`来抓到错误信息\n\n`fetch`自身不支持设置请求超时，我们自己来封装一个\n\n```js\nfunction fetchTimeout(url,init.timeout=3000){\n  return new Promise((resolve,reject)=>{\n    fetch(url,init).then(resolve).catch(reject)\n\n    setTimeOut(reject,timeout)\n  })\n}\n```\n\n### 中断一个请求\n\n```js\n//用于中断请求\nconst controller = new AbortController();\n\nfetch(\"http://domain/service\", {\n  method: \"GET\",\n  credentials: \"same-origin\", // 同域的请求会带上cookie\n  signal: controller.sianal,\n})\n  .then((response) => {\n    if (response.ok) {\n      //请求成功\n      return response.json();\n    }\n    throw new Error(\" http error\");\n  })\n  .then((json) => {\n    console.log(json);\n  })\n  .catch((error) => {\n    console.error(error);\n  });\n\ncontroller.abort(); //用于中断请求\n```\n\n### 请求头 request-header\n\n`referer`：表示来源，你是从哪一个页面过来这个页面的，标识访问路径\n`user-agent`：用来判断环境，设备标识\n\n### 响应头 response-header\n\n`access-control-allow-origin`:跨域\n用于做域名限制，跨域\n\n- access-control-allow-origin:/\\* ,不做限制\n\n- content-encoding: 是一个实体消息首部，用于对特定媒体类型的数据进行压缩。当这个首部出现的时候，它的值表示消息主体进行了何种方式的内容编码转换。这个消息首部用来告知客户端应该怎样解码才能获取在 `Content-Type` 中标示的媒体类型内容。\n\n  Content-Encoding: gzip\n  Content-Encoding: compress\n  Content-Encoding: deflate\n  Content-Encoding: identity\n  Content-Encoding: br</pre>\n\n- set-cookie:响应首部 **`Set-Cookie`** 被用来由服务器端向客户端发送 cookie。\n\n### status 状态码\n\n响应分为五类：信息响应(`100`–`199`)，成功响应(`200`–`299`)，重定向(`300`–`399`)，客户端错误(`400`–`499`)和服务器错误 (`500`–`599`)。\n\n[`200 OK`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200)\n\n请求成功。成功的含义取决于 HTTP 方法：\n\n- GET：资源已被提取并在消息正文中传输。\n\n- HEAD：实体标头位于消息正文中。\n\n- POST：描述动作结果的资源在消息体中传输。\n\n- TRACE：消息正文包含服务器收到的请求消息\n\n[`201 Created`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/201)\n\n该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。\n\n[`301 Moved Permanently`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301)\n\n重定向。\n\n被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。\n\n[`302 Found`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302)\n\n临时重定向。\n\n请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。\n\n304：协商缓存，服务器文件未修改\n\n### 面试题\n\n`vue/react`创建的单页面应用（spa），生成的`index.html`如果要做缓存应该做什么缓存？\n\n答：一般不做缓存，如果非要做就做协商缓存\n","source":"_posts/2022-01-11-浏览器相关面试知识点.md","raw":"---\ntitle: 浏览器相关面试知识点\ndate: 2022-01-11 14:04:48\ntags: [JavaScript, 面试]\ncategories: 技术类-前端\n---\n\n## 一.详解浏览器事件捕获与冒泡\n\n### 1. 事件委托/事件代理\n\n捕获阶段-->目标阶段-->冒泡阶段\n\n```js\nwindow.addEventListener(\n  \"click\",\n  function (e) {\n    console.log(\"window捕获\", e.target.nodeName, e.currentTarget.nodeName);\n  },\n  true\n);\n```\n\n- 第三个参数为 true，则监听捕获事件，不传或者传 false，则监听冒泡事件\n- `e.target`指的是点击的元素，`e.currentTarget`指的是当前触发事件的元素\n\n### 2. 阻止事件的传播\n\n`e.stopPropagation()`真正的作用是阻止事件的传播，既可以阻止事件的捕获也可以阻止事件的冒泡\n\n#### 面试题\n\n现在有一个页面，这个页面上有许多元素，div、p、button 等\n每个元素都有自己的 click 事件，都不相同\n现在有一个新需求，一个用户进入这个页面的时候，会有一个状态：`banned`，我们可以在全局上拿到这个状态：`window.banned`，\n为`true`的话表示当前用户被封禁，用户点击页面的任何元素都不执行原有逻辑，而是`alert`弹窗，提示你被封禁了；\n为`false`的话表示有操作权限。\n请问：如何实现？\n**答：**\n方案一：在最外层的一个元素上绑定上一个捕获事件，即`addEventListener`里的第三个参数为`true`，如果`window.banned`为`true`则`e.stopPropagation()`。\n\n```js\n//const body = document.getElementsByTagName('body')\nwindow.addEventListener('click',function(e){\n  if(window.banner){\n    e.stopPropagation()\n    alert('你被封禁了')\n    return\n  }\n  ...\n},true)\n```\n\n方案二：`window.banner`为`true`的时候展示一个全屏的最高层级（即：`z-index:99999`）的 div 遮罩，遮住整个页面。\n\n### 3.阻止默认事件\n\n`e.preventDefault()`\n这个没啥好说的\n\n### 4.兼容性问题\n\n`addEventListener` --> firefox、Chrome、高版本 IE、safari、opera\n`attachEvent` --> IE7、IE8，除了政府网站，大部分公司不会再去针对他们做兼容了\nIE 浏览器里没有事件捕获，只有事件冒泡\n\n#### 针对兼容性做一下封装\n\n```js\nclass BomEvent {\n  constructor(element) {\n    this.element = element;\n  }\n  addEvent(type, handler) {\n    if (this.element.addEventListener) {\n      this.element.addEventListener(type, handler, false);\n    } else if (this.element.attachEvent) {\n      this.element.attachEvent(`on${type}`, function () {\n        // 这是处于ie7或8的一个环境，不支持箭头函数，所以这里做一下绑定\n        handler.call(element);\n      });\n    } else {\n      this.element[`on${type}`] = handler;\n    }\n  }\n\n  removeEvent(type, handler) {\n    if (this.element.removeEventListener) {\n      this.element.removeEventListener(type, handler, false);\n    } else if (this.element.detachEvent) {\n      this.element.detachEvent(`on${type}`, handler);\n    } else {\n      this.element[`on${type}`] = null;\n    }\n  }\n}\n\n// IE浏览器里没有事件捕获，只有事件冒泡\nfunction stopPropagation(event) {\n  if (event.stopPropagation) {\n    event.stopPropagation(); //标准w3c浏览器\n  } else {\n    event.cancelBubble = true; // IE\n  }\n}\n\nfunction preventDefault(event) {\n  if (event.preventDefault) {\n    event.preventDefault();\n  } else {\n    event.returnValue = false;\n  }\n}\n```\n\n## 二：浏览器请求相关内容 Ajax 与 fetch\n\n**原生 ajax：**\n\n```js\nconst xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"http://domain/service\"); //建立连接，并没有发送请求\n\n//监听状态\nxhr.onreadystatechange = function () {\n  // 表示请求还没有完成\n  if (xhr.readyState !== 4) {\n    return;\n  } else if (xhr.status === 200) {\n    // 请求成功\n    console.log(xhr.responseText);\n  } else {\n    //报错了\n    console.error(\n      `HTTP error,status=${xhr.status},errorText = ${xhr.statusText}`\n    );\n  }\n};\n// 超时时间\nxhr.timeout = 3000;\nxhr.ontimeout = () => {\n  console.log(\"请求超时\");\n};\n\n// 上传进度条\nxhr.upload.onprogress = (p) => {\n  const percent = Math.round((p.loaded / p.total) * 100) + \"%\";\n};\n\nxhr.send(); //发送请求\n```\n\n**fetch**:浏览器新增的 fetch，内部封装了 promise\n\n```js\nfetch(\"http://domain/service\", {\n  method: \"GET\",\n  credentials: \"same-origin\", // 同域的请求会带上cookie\n})\n  .then((response) => {\n    if (response.ok) {\n      //请求成功\n      return response.json();\n    }\n    throw new Error(\" http error\");\n  })\n  .then((json) => {\n    console.log(json);\n  })\n  .catch((error) => {\n    console.error(error);\n    // 统一的错误管理\n    // 接收fetch出现的错误\n    //  接收请求错误信息\n  });\n```\n\n`fetch`不能直接通过`catch`来获取请求错误信息，而是要通过判断`response.ok`来返回出错误信息再通过`catch`来抓到错误信息\n\n`fetch`自身不支持设置请求超时，我们自己来封装一个\n\n```js\nfunction fetchTimeout(url,init.timeout=3000){\n  return new Promise((resolve,reject)=>{\n    fetch(url,init).then(resolve).catch(reject)\n\n    setTimeOut(reject,timeout)\n  })\n}\n```\n\n### 中断一个请求\n\n```js\n//用于中断请求\nconst controller = new AbortController();\n\nfetch(\"http://domain/service\", {\n  method: \"GET\",\n  credentials: \"same-origin\", // 同域的请求会带上cookie\n  signal: controller.sianal,\n})\n  .then((response) => {\n    if (response.ok) {\n      //请求成功\n      return response.json();\n    }\n    throw new Error(\" http error\");\n  })\n  .then((json) => {\n    console.log(json);\n  })\n  .catch((error) => {\n    console.error(error);\n  });\n\ncontroller.abort(); //用于中断请求\n```\n\n### 请求头 request-header\n\n`referer`：表示来源，你是从哪一个页面过来这个页面的，标识访问路径\n`user-agent`：用来判断环境，设备标识\n\n### 响应头 response-header\n\n`access-control-allow-origin`:跨域\n用于做域名限制，跨域\n\n- access-control-allow-origin:/\\* ,不做限制\n\n- content-encoding: 是一个实体消息首部，用于对特定媒体类型的数据进行压缩。当这个首部出现的时候，它的值表示消息主体进行了何种方式的内容编码转换。这个消息首部用来告知客户端应该怎样解码才能获取在 `Content-Type` 中标示的媒体类型内容。\n\n  Content-Encoding: gzip\n  Content-Encoding: compress\n  Content-Encoding: deflate\n  Content-Encoding: identity\n  Content-Encoding: br</pre>\n\n- set-cookie:响应首部 **`Set-Cookie`** 被用来由服务器端向客户端发送 cookie。\n\n### status 状态码\n\n响应分为五类：信息响应(`100`–`199`)，成功响应(`200`–`299`)，重定向(`300`–`399`)，客户端错误(`400`–`499`)和服务器错误 (`500`–`599`)。\n\n[`200 OK`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200)\n\n请求成功。成功的含义取决于 HTTP 方法：\n\n- GET：资源已被提取并在消息正文中传输。\n\n- HEAD：实体标头位于消息正文中。\n\n- POST：描述动作结果的资源在消息体中传输。\n\n- TRACE：消息正文包含服务器收到的请求消息\n\n[`201 Created`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/201)\n\n该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。\n\n[`301 Moved Permanently`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301)\n\n重定向。\n\n被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。\n\n[`302 Found`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302)\n\n临时重定向。\n\n请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。\n\n304：协商缓存，服务器文件未修改\n\n### 面试题\n\n`vue/react`创建的单页面应用（spa），生成的`index.html`如果要做缓存应该做什么缓存？\n\n答：一般不做缓存，如果非要做就做协商缓存\n","slug":"浏览器相关面试知识点","published":1,"updated":"2022-01-11T06:10:20.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno63002j7oo9e2hgch7a","content":"<h2 id=\"一-详解浏览器事件捕获与冒泡\"><a href=\"#一-详解浏览器事件捕获与冒泡\" class=\"headerlink\" title=\"一.详解浏览器事件捕获与冒泡\"></a>一.详解浏览器事件捕获与冒泡</h2><h3 id=\"1-事件委托-事件代理\"><a href=\"#1-事件委托-事件代理\" class=\"headerlink\" title=\"1. 事件委托/事件代理\"></a>1. 事件委托/事件代理</h3><p>捕获阶段–&gt;目标阶段–&gt;冒泡阶段</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">window</span>.addEventListener(<br>  <span class=\"hljs-string\">&quot;click&quot;</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;window捕获&quot;</span>, e.target.nodeName, e.currentTarget.nodeName);<br>  &#125;,<br>  <span class=\"hljs-literal\">true</span><br>);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>第三个参数为 true，则监听捕获事件，不传或者传 false，则监听冒泡事件</li>\n<li><code>e.target</code>指的是点击的元素，<code>e.currentTarget</code>指的是当前触发事件的元素</li>\n</ul>\n<h3 id=\"2-阻止事件的传播\"><a href=\"#2-阻止事件的传播\" class=\"headerlink\" title=\"2. 阻止事件的传播\"></a>2. 阻止事件的传播</h3><p><code>e.stopPropagation()</code>真正的作用是阻止事件的传播，既可以阻止事件的捕获也可以阻止事件的冒泡</p>\n<h4 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h4><p>现在有一个页面，这个页面上有许多元素，div、p、button 等<br>每个元素都有自己的 click 事件，都不相同<br>现在有一个新需求，一个用户进入这个页面的时候，会有一个状态：<code>banned</code>，我们可以在全局上拿到这个状态：<code>window.banned</code>，<br>为<code>true</code>的话表示当前用户被封禁，用户点击页面的任何元素都不执行原有逻辑，而是<code>alert</code>弹窗，提示你被封禁了；<br>为<code>false</code>的话表示有操作权限。<br>请问：如何实现？<br><strong>答：</strong><br>方案一：在最外层的一个元素上绑定上一个捕获事件，即<code>addEventListener</code>里的第三个参数为<code>true</code>，如果<code>window.banned</code>为<code>true</code>则<code>e.stopPropagation()</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//const body = document.getElementsByTagName(&#x27;body&#x27;)</span><br><span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&#x27;click&#x27;</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>)</span>&#123;<br>  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">window</span>.banner)&#123;<br>    e.stopPropagation()<br>    alert(<span class=\"hljs-string\">&#x27;你被封禁了&#x27;</span>)<br>    <span class=\"hljs-keyword\">return</span><br>  &#125;<br>  ...<br>&#125;,<span class=\"hljs-literal\">true</span>)<br></code></pre></td></tr></table></figure>\n\n<p>方案二：<code>window.banner</code>为<code>true</code>的时候展示一个全屏的最高层级（即：<code>z-index:99999</code>）的 div 遮罩，遮住整个页面。</p>\n<h3 id=\"3-阻止默认事件\"><a href=\"#3-阻止默认事件\" class=\"headerlink\" title=\"3.阻止默认事件\"></a>3.阻止默认事件</h3><p><code>e.preventDefault()</code><br>这个没啥好说的</p>\n<h3 id=\"4-兼容性问题\"><a href=\"#4-兼容性问题\" class=\"headerlink\" title=\"4.兼容性问题\"></a>4.兼容性问题</h3><p><code>addEventListener</code> –&gt; firefox、Chrome、高版本 IE、safari、opera<br><code>attachEvent</code> –&gt; IE7、IE8，除了政府网站，大部分公司不会再去针对他们做兼容了<br>IE 浏览器里没有事件捕获，只有事件冒泡</p>\n<h4 id=\"针对兼容性做一下封装\"><a href=\"#针对兼容性做一下封装\" class=\"headerlink\" title=\"针对兼容性做一下封装\"></a>针对兼容性做一下封装</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BomEvent</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">element</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.element = element;<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">addEvent</span>(<span class=\"hljs-params\">type, handler</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.element.addEventListener) &#123;<br>      <span class=\"hljs-built_in\">this</span>.element.addEventListener(type, handler, <span class=\"hljs-literal\">false</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.element.attachEvent) &#123;<br>      <span class=\"hljs-built_in\">this</span>.element.attachEvent(<span class=\"hljs-string\">`on<span class=\"hljs-subst\">$&#123;type&#125;</span>`</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>        <span class=\"hljs-comment\">// 这是处于ie7或8的一个环境，不支持箭头函数，所以这里做一下绑定</span><br>        handler.call(element);<br>      &#125;);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-built_in\">this</span>.element[<span class=\"hljs-string\">`on<span class=\"hljs-subst\">$&#123;type&#125;</span>`</span>] = handler;<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">removeEvent</span>(<span class=\"hljs-params\">type, handler</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.element.removeEventListener) &#123;<br>      <span class=\"hljs-built_in\">this</span>.element.removeEventListener(type, handler, <span class=\"hljs-literal\">false</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.element.detachEvent) &#123;<br>      <span class=\"hljs-built_in\">this</span>.element.detachEvent(<span class=\"hljs-string\">`on<span class=\"hljs-subst\">$&#123;type&#125;</span>`</span>, handler);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-built_in\">this</span>.element[<span class=\"hljs-string\">`on<span class=\"hljs-subst\">$&#123;type&#125;</span>`</span>] = <span class=\"hljs-literal\">null</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// IE浏览器里没有事件捕获，只有事件冒泡</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">stopPropagation</span>(<span class=\"hljs-params\">event</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (event.stopPropagation) &#123;<br>    event.stopPropagation(); <span class=\"hljs-comment\">//标准w3c浏览器</span><br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    event.cancelBubble = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// IE</span><br>  &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">preventDefault</span>(<span class=\"hljs-params\">event</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (event.preventDefault) &#123;<br>    event.preventDefault();<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    event.returnValue = <span class=\"hljs-literal\">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二：浏览器请求相关内容-Ajax-与-fetch\"><a href=\"#二：浏览器请求相关内容-Ajax-与-fetch\" class=\"headerlink\" title=\"二：浏览器请求相关内容 Ajax 与 fetch\"></a>二：浏览器请求相关内容 Ajax 与 fetch</h2><p><strong>原生 ajax：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> xhr = <span class=\"hljs-keyword\">new</span> XMLHttpRequest();<br>xhr.open(<span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-string\">&quot;http://domain/service&quot;</span>); <span class=\"hljs-comment\">//建立连接，并没有发送请求</span><br><br><span class=\"hljs-comment\">//监听状态</span><br>xhr.onreadystatechange = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-comment\">// 表示请求还没有完成</span><br>  <span class=\"hljs-keyword\">if</span> (xhr.readyState !== <span class=\"hljs-number\">4</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (xhr.status === <span class=\"hljs-number\">200</span>) &#123;<br>    <span class=\"hljs-comment\">// 请求成功</span><br>    <span class=\"hljs-built_in\">console</span>.log(xhr.responseText);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">//报错了</span><br>    <span class=\"hljs-built_in\">console</span>.error(<br>      <span class=\"hljs-string\">`HTTP error,status=<span class=\"hljs-subst\">$&#123;xhr.status&#125;</span>,errorText = <span class=\"hljs-subst\">$&#123;xhr.statusText&#125;</span>`</span><br>    );<br>  &#125;<br>&#125;;<br><span class=\"hljs-comment\">// 超时时间</span><br>xhr.timeout = <span class=\"hljs-number\">3000</span>;<br>xhr.ontimeout = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;请求超时&quot;</span>);<br>&#125;;<br><br><span class=\"hljs-comment\">// 上传进度条</span><br>xhr.upload.onprogress = <span class=\"hljs-function\">(<span class=\"hljs-params\">p</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> percent = <span class=\"hljs-built_in\">Math</span>.round((p.loaded / p.total) * <span class=\"hljs-number\">100</span>) + <span class=\"hljs-string\">&quot;%&quot;</span>;<br>&#125;;<br><br>xhr.send(); <span class=\"hljs-comment\">//发送请求</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>fetch</strong>:浏览器新增的 fetch，内部封装了 promise</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">fetch(<span class=\"hljs-string\">&quot;http://domain/service&quot;</span>, &#123;<br>  <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&quot;GET&quot;</span>,<br>  <span class=\"hljs-attr\">credentials</span>: <span class=\"hljs-string\">&quot;same-origin&quot;</span>, <span class=\"hljs-comment\">// 同域的请求会带上cookie</span><br>&#125;)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (response.ok) &#123;<br>      <span class=\"hljs-comment\">//请求成功</span><br>      <span class=\"hljs-keyword\">return</span> response.json();<br>    &#125;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot; http error&quot;</span>);<br>  &#125;)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">json</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(json);<br>  &#125;)<br>  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.error(error);<br>    <span class=\"hljs-comment\">// 统一的错误管理</span><br>    <span class=\"hljs-comment\">// 接收fetch出现的错误</span><br>    <span class=\"hljs-comment\">//  接收请求错误信息</span><br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<p><code>fetch</code>不能直接通过<code>catch</code>来获取请求错误信息，而是要通过判断<code>response.ok</code>来返回出错误信息再通过<code>catch</code>来抓到错误信息</p>\n<p><code>fetch</code>自身不支持设置请求超时，我们自己来封装一个</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetchTimeout</span>(<span class=\"hljs-params\">url,init.timeout=<span class=\"hljs-number\">3000</span></span>)</span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve,reject</span>)=&gt;</span>&#123;<br>    fetch(url,init).then(resolve).catch(reject)<br><br>    setTimeOut(reject,timeout)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"中断一个请求\"><a href=\"#中断一个请求\" class=\"headerlink\" title=\"中断一个请求\"></a>中断一个请求</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//用于中断请求</span><br><span class=\"hljs-keyword\">const</span> controller = <span class=\"hljs-keyword\">new</span> AbortController();<br><br>fetch(<span class=\"hljs-string\">&quot;http://domain/service&quot;</span>, &#123;<br>  <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&quot;GET&quot;</span>,<br>  <span class=\"hljs-attr\">credentials</span>: <span class=\"hljs-string\">&quot;same-origin&quot;</span>, <span class=\"hljs-comment\">// 同域的请求会带上cookie</span><br>  <span class=\"hljs-attr\">signal</span>: controller.sianal,<br>&#125;)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (response.ok) &#123;<br>      <span class=\"hljs-comment\">//请求成功</span><br>      <span class=\"hljs-keyword\">return</span> response.json();<br>    &#125;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot; http error&quot;</span>);<br>  &#125;)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">json</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(json);<br>  &#125;)<br>  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.error(error);<br>  &#125;);<br><br>controller.abort(); <span class=\"hljs-comment\">//用于中断请求</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"请求头-request-header\"><a href=\"#请求头-request-header\" class=\"headerlink\" title=\"请求头 request-header\"></a>请求头 request-header</h3><p><code>referer</code>：表示来源，你是从哪一个页面过来这个页面的，标识访问路径<br><code>user-agent</code>：用来判断环境，设备标识</p>\n<h3 id=\"响应头-response-header\"><a href=\"#响应头-response-header\" class=\"headerlink\" title=\"响应头 response-header\"></a>响应头 response-header</h3><p><code>access-control-allow-origin</code>:跨域<br>用于做域名限制，跨域</p>\n<ul>\n<li><p>access-control-allow-origin:/* ,不做限制</p>\n</li>\n<li><p>content-encoding: 是一个实体消息首部，用于对特定媒体类型的数据进行压缩。当这个首部出现的时候，它的值表示消息主体进行了何种方式的内容编码转换。这个消息首部用来告知客户端应该怎样解码才能获取在 <code>Content-Type</code> 中标示的媒体类型内容。</p>\n<p>Content-Encoding: gzip<br>Content-Encoding: compress<br>Content-Encoding: deflate<br>Content-Encoding: identity<br>Content-Encoding: br</pre></p>\n</li>\n<li><p>set-cookie:响应首部 <strong><code>Set-Cookie</code></strong> 被用来由服务器端向客户端发送 cookie。</p>\n</li>\n</ul>\n<h3 id=\"status-状态码\"><a href=\"#status-状态码\" class=\"headerlink\" title=\"status 状态码\"></a>status 状态码</h3><p>响应分为五类：信息响应(<code>100</code>–<code>199</code>)，成功响应(<code>200</code>–<code>299</code>)，重定向(<code>300</code>–<code>399</code>)，客户端错误(<code>400</code>–<code>499</code>)和服务器错误 (<code>500</code>–<code>599</code>)。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200\"><code>200 OK</code></a></p>\n<p>请求成功。成功的含义取决于 HTTP 方法：</p>\n<ul>\n<li><p>GET：资源已被提取并在消息正文中传输。</p>\n</li>\n<li><p>HEAD：实体标头位于消息正文中。</p>\n</li>\n<li><p>POST：描述动作结果的资源在消息体中传输。</p>\n</li>\n<li><p>TRACE：消息正文包含服务器收到的请求消息</p>\n</li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/201\"><code>201 Created</code></a></p>\n<p>该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301\"><code>301 Moved Permanently</code></a></p>\n<p>重定向。</p>\n<p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302\"><code>302 Found</code></a></p>\n<p>临时重定向。</p>\n<p>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。</p>\n<p>304：协商缓存，服务器文件未修改</p>\n<h3 id=\"面试题-1\"><a href=\"#面试题-1\" class=\"headerlink\" title=\"面试题\"></a>面试题</h3><p><code>vue/react</code>创建的单页面应用（spa），生成的<code>index.html</code>如果要做缓存应该做什么缓存？</p>\n<p>答：一般不做缓存，如果非要做就做协商缓存</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一-详解浏览器事件捕获与冒泡\"><a href=\"#一-详解浏览器事件捕获与冒泡\" class=\"headerlink\" title=\"一.详解浏览器事件捕获与冒泡\"></a>一.详解浏览器事件捕获与冒泡</h2><h3 id=\"1-事件委托-事件代理\"><a href=\"#1-事件委托-事件代理\" class=\"headerlink\" title=\"1. 事件委托/事件代理\"></a>1. 事件委托/事件代理</h3><p>捕获阶段–&gt;目标阶段–&gt;冒泡阶段</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">window</span>.addEventListener(<br>  <span class=\"hljs-string\">&quot;click&quot;</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;window捕获&quot;</span>, e.target.nodeName, e.currentTarget.nodeName);<br>  &#125;,<br>  <span class=\"hljs-literal\">true</span><br>);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>第三个参数为 true，则监听捕获事件，不传或者传 false，则监听冒泡事件</li>\n<li><code>e.target</code>指的是点击的元素，<code>e.currentTarget</code>指的是当前触发事件的元素</li>\n</ul>\n<h3 id=\"2-阻止事件的传播\"><a href=\"#2-阻止事件的传播\" class=\"headerlink\" title=\"2. 阻止事件的传播\"></a>2. 阻止事件的传播</h3><p><code>e.stopPropagation()</code>真正的作用是阻止事件的传播，既可以阻止事件的捕获也可以阻止事件的冒泡</p>\n<h4 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h4><p>现在有一个页面，这个页面上有许多元素，div、p、button 等<br>每个元素都有自己的 click 事件，都不相同<br>现在有一个新需求，一个用户进入这个页面的时候，会有一个状态：<code>banned</code>，我们可以在全局上拿到这个状态：<code>window.banned</code>，<br>为<code>true</code>的话表示当前用户被封禁，用户点击页面的任何元素都不执行原有逻辑，而是<code>alert</code>弹窗，提示你被封禁了；<br>为<code>false</code>的话表示有操作权限。<br>请问：如何实现？<br><strong>答：</strong><br>方案一：在最外层的一个元素上绑定上一个捕获事件，即<code>addEventListener</code>里的第三个参数为<code>true</code>，如果<code>window.banned</code>为<code>true</code>则<code>e.stopPropagation()</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//const body = document.getElementsByTagName(&#x27;body&#x27;)</span><br><span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&#x27;click&#x27;</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>)</span>&#123;<br>  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">window</span>.banner)&#123;<br>    e.stopPropagation()<br>    alert(<span class=\"hljs-string\">&#x27;你被封禁了&#x27;</span>)<br>    <span class=\"hljs-keyword\">return</span><br>  &#125;<br>  ...<br>&#125;,<span class=\"hljs-literal\">true</span>)<br></code></pre></td></tr></table></figure>\n\n<p>方案二：<code>window.banner</code>为<code>true</code>的时候展示一个全屏的最高层级（即：<code>z-index:99999</code>）的 div 遮罩，遮住整个页面。</p>\n<h3 id=\"3-阻止默认事件\"><a href=\"#3-阻止默认事件\" class=\"headerlink\" title=\"3.阻止默认事件\"></a>3.阻止默认事件</h3><p><code>e.preventDefault()</code><br>这个没啥好说的</p>\n<h3 id=\"4-兼容性问题\"><a href=\"#4-兼容性问题\" class=\"headerlink\" title=\"4.兼容性问题\"></a>4.兼容性问题</h3><p><code>addEventListener</code> –&gt; firefox、Chrome、高版本 IE、safari、opera<br><code>attachEvent</code> –&gt; IE7、IE8，除了政府网站，大部分公司不会再去针对他们做兼容了<br>IE 浏览器里没有事件捕获，只有事件冒泡</p>\n<h4 id=\"针对兼容性做一下封装\"><a href=\"#针对兼容性做一下封装\" class=\"headerlink\" title=\"针对兼容性做一下封装\"></a>针对兼容性做一下封装</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BomEvent</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">element</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.element = element;<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">addEvent</span>(<span class=\"hljs-params\">type, handler</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.element.addEventListener) &#123;<br>      <span class=\"hljs-built_in\">this</span>.element.addEventListener(type, handler, <span class=\"hljs-literal\">false</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.element.attachEvent) &#123;<br>      <span class=\"hljs-built_in\">this</span>.element.attachEvent(<span class=\"hljs-string\">`on<span class=\"hljs-subst\">$&#123;type&#125;</span>`</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>        <span class=\"hljs-comment\">// 这是处于ie7或8的一个环境，不支持箭头函数，所以这里做一下绑定</span><br>        handler.call(element);<br>      &#125;);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-built_in\">this</span>.element[<span class=\"hljs-string\">`on<span class=\"hljs-subst\">$&#123;type&#125;</span>`</span>] = handler;<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">removeEvent</span>(<span class=\"hljs-params\">type, handler</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.element.removeEventListener) &#123;<br>      <span class=\"hljs-built_in\">this</span>.element.removeEventListener(type, handler, <span class=\"hljs-literal\">false</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.element.detachEvent) &#123;<br>      <span class=\"hljs-built_in\">this</span>.element.detachEvent(<span class=\"hljs-string\">`on<span class=\"hljs-subst\">$&#123;type&#125;</span>`</span>, handler);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-built_in\">this</span>.element[<span class=\"hljs-string\">`on<span class=\"hljs-subst\">$&#123;type&#125;</span>`</span>] = <span class=\"hljs-literal\">null</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// IE浏览器里没有事件捕获，只有事件冒泡</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">stopPropagation</span>(<span class=\"hljs-params\">event</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (event.stopPropagation) &#123;<br>    event.stopPropagation(); <span class=\"hljs-comment\">//标准w3c浏览器</span><br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    event.cancelBubble = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// IE</span><br>  &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">preventDefault</span>(<span class=\"hljs-params\">event</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (event.preventDefault) &#123;<br>    event.preventDefault();<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    event.returnValue = <span class=\"hljs-literal\">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二：浏览器请求相关内容-Ajax-与-fetch\"><a href=\"#二：浏览器请求相关内容-Ajax-与-fetch\" class=\"headerlink\" title=\"二：浏览器请求相关内容 Ajax 与 fetch\"></a>二：浏览器请求相关内容 Ajax 与 fetch</h2><p><strong>原生 ajax：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> xhr = <span class=\"hljs-keyword\">new</span> XMLHttpRequest();<br>xhr.open(<span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-string\">&quot;http://domain/service&quot;</span>); <span class=\"hljs-comment\">//建立连接，并没有发送请求</span><br><br><span class=\"hljs-comment\">//监听状态</span><br>xhr.onreadystatechange = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-comment\">// 表示请求还没有完成</span><br>  <span class=\"hljs-keyword\">if</span> (xhr.readyState !== <span class=\"hljs-number\">4</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (xhr.status === <span class=\"hljs-number\">200</span>) &#123;<br>    <span class=\"hljs-comment\">// 请求成功</span><br>    <span class=\"hljs-built_in\">console</span>.log(xhr.responseText);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">//报错了</span><br>    <span class=\"hljs-built_in\">console</span>.error(<br>      <span class=\"hljs-string\">`HTTP error,status=<span class=\"hljs-subst\">$&#123;xhr.status&#125;</span>,errorText = <span class=\"hljs-subst\">$&#123;xhr.statusText&#125;</span>`</span><br>    );<br>  &#125;<br>&#125;;<br><span class=\"hljs-comment\">// 超时时间</span><br>xhr.timeout = <span class=\"hljs-number\">3000</span>;<br>xhr.ontimeout = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;请求超时&quot;</span>);<br>&#125;;<br><br><span class=\"hljs-comment\">// 上传进度条</span><br>xhr.upload.onprogress = <span class=\"hljs-function\">(<span class=\"hljs-params\">p</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> percent = <span class=\"hljs-built_in\">Math</span>.round((p.loaded / p.total) * <span class=\"hljs-number\">100</span>) + <span class=\"hljs-string\">&quot;%&quot;</span>;<br>&#125;;<br><br>xhr.send(); <span class=\"hljs-comment\">//发送请求</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>fetch</strong>:浏览器新增的 fetch，内部封装了 promise</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">fetch(<span class=\"hljs-string\">&quot;http://domain/service&quot;</span>, &#123;<br>  <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&quot;GET&quot;</span>,<br>  <span class=\"hljs-attr\">credentials</span>: <span class=\"hljs-string\">&quot;same-origin&quot;</span>, <span class=\"hljs-comment\">// 同域的请求会带上cookie</span><br>&#125;)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (response.ok) &#123;<br>      <span class=\"hljs-comment\">//请求成功</span><br>      <span class=\"hljs-keyword\">return</span> response.json();<br>    &#125;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot; http error&quot;</span>);<br>  &#125;)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">json</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(json);<br>  &#125;)<br>  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.error(error);<br>    <span class=\"hljs-comment\">// 统一的错误管理</span><br>    <span class=\"hljs-comment\">// 接收fetch出现的错误</span><br>    <span class=\"hljs-comment\">//  接收请求错误信息</span><br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<p><code>fetch</code>不能直接通过<code>catch</code>来获取请求错误信息，而是要通过判断<code>response.ok</code>来返回出错误信息再通过<code>catch</code>来抓到错误信息</p>\n<p><code>fetch</code>自身不支持设置请求超时，我们自己来封装一个</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetchTimeout</span>(<span class=\"hljs-params\">url,init.timeout=<span class=\"hljs-number\">3000</span></span>)</span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve,reject</span>)=&gt;</span>&#123;<br>    fetch(url,init).then(resolve).catch(reject)<br><br>    setTimeOut(reject,timeout)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"中断一个请求\"><a href=\"#中断一个请求\" class=\"headerlink\" title=\"中断一个请求\"></a>中断一个请求</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//用于中断请求</span><br><span class=\"hljs-keyword\">const</span> controller = <span class=\"hljs-keyword\">new</span> AbortController();<br><br>fetch(<span class=\"hljs-string\">&quot;http://domain/service&quot;</span>, &#123;<br>  <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&quot;GET&quot;</span>,<br>  <span class=\"hljs-attr\">credentials</span>: <span class=\"hljs-string\">&quot;same-origin&quot;</span>, <span class=\"hljs-comment\">// 同域的请求会带上cookie</span><br>  <span class=\"hljs-attr\">signal</span>: controller.sianal,<br>&#125;)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (response.ok) &#123;<br>      <span class=\"hljs-comment\">//请求成功</span><br>      <span class=\"hljs-keyword\">return</span> response.json();<br>    &#125;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot; http error&quot;</span>);<br>  &#125;)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">json</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(json);<br>  &#125;)<br>  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.error(error);<br>  &#125;);<br><br>controller.abort(); <span class=\"hljs-comment\">//用于中断请求</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"请求头-request-header\"><a href=\"#请求头-request-header\" class=\"headerlink\" title=\"请求头 request-header\"></a>请求头 request-header</h3><p><code>referer</code>：表示来源，你是从哪一个页面过来这个页面的，标识访问路径<br><code>user-agent</code>：用来判断环境，设备标识</p>\n<h3 id=\"响应头-response-header\"><a href=\"#响应头-response-header\" class=\"headerlink\" title=\"响应头 response-header\"></a>响应头 response-header</h3><p><code>access-control-allow-origin</code>:跨域<br>用于做域名限制，跨域</p>\n<ul>\n<li><p>access-control-allow-origin:/* ,不做限制</p>\n</li>\n<li><p>content-encoding: 是一个实体消息首部，用于对特定媒体类型的数据进行压缩。当这个首部出现的时候，它的值表示消息主体进行了何种方式的内容编码转换。这个消息首部用来告知客户端应该怎样解码才能获取在 <code>Content-Type</code> 中标示的媒体类型内容。</p>\n<p>Content-Encoding: gzip<br>Content-Encoding: compress<br>Content-Encoding: deflate<br>Content-Encoding: identity<br>Content-Encoding: br</pre></p>\n</li>\n<li><p>set-cookie:响应首部 <strong><code>Set-Cookie</code></strong> 被用来由服务器端向客户端发送 cookie。</p>\n</li>\n</ul>\n<h3 id=\"status-状态码\"><a href=\"#status-状态码\" class=\"headerlink\" title=\"status 状态码\"></a>status 状态码</h3><p>响应分为五类：信息响应(<code>100</code>–<code>199</code>)，成功响应(<code>200</code>–<code>299</code>)，重定向(<code>300</code>–<code>399</code>)，客户端错误(<code>400</code>–<code>499</code>)和服务器错误 (<code>500</code>–<code>599</code>)。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200\"><code>200 OK</code></a></p>\n<p>请求成功。成功的含义取决于 HTTP 方法：</p>\n<ul>\n<li><p>GET：资源已被提取并在消息正文中传输。</p>\n</li>\n<li><p>HEAD：实体标头位于消息正文中。</p>\n</li>\n<li><p>POST：描述动作结果的资源在消息体中传输。</p>\n</li>\n<li><p>TRACE：消息正文包含服务器收到的请求消息</p>\n</li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/201\"><code>201 Created</code></a></p>\n<p>该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301\"><code>301 Moved Permanently</code></a></p>\n<p>重定向。</p>\n<p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302\"><code>302 Found</code></a></p>\n<p>临时重定向。</p>\n<p>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。</p>\n<p>304：协商缓存，服务器文件未修改</p>\n<h3 id=\"面试题-1\"><a href=\"#面试题-1\" class=\"headerlink\" title=\"面试题\"></a>面试题</h3><p><code>vue/react</code>创建的单页面应用（spa），生成的<code>index.html</code>如果要做缓存应该做什么缓存？</p>\n<p>答：一般不做缓存，如果非要做就做协商缓存</p>\n"},{"title":"ES6随笔","date":"2022-01-14T02:34:45.000Z","_content":"\n[参考资料：阮一峰ES6标准入门教程第三版](https://www.bookstack.cn/read/es6-3rd/sidebar.md)\n\n> 本文用于记录我觉得ES6中重要的原理和使用技巧以及可能在面试中会问到的\n\n## class的继承\n\nClass 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\n\n```js\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n  toString() {\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\n  }\n}\n```\n\n子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。\n\n*ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。\n","source":"_posts/2022-01-14-ES6随笔.md","raw":"---\ntitle: ES6随笔\ndate: 2022-01-14 10:34:45\ntags:\n---\n\n[参考资料：阮一峰ES6标准入门教程第三版](https://www.bookstack.cn/read/es6-3rd/sidebar.md)\n\n> 本文用于记录我觉得ES6中重要的原理和使用技巧以及可能在面试中会问到的\n\n## class的继承\n\nClass 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\n\n```js\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n  toString() {\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\n  }\n}\n```\n\n子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。\n\n*ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。\n","slug":"ES6随笔","published":1,"updated":"2022-01-14T06:20:04.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno65002o7oo94zmff2a3","content":"<p><a href=\"https://www.bookstack.cn/read/es6-3rd/sidebar.md\">参考资料：阮一峰ES6标准入门教程第三版</a></p>\n<blockquote>\n<p>本文用于记录我觉得ES6中重要的原理和使用技巧以及可能在面试中会问到的</p>\n</blockquote>\n<h2 id=\"class的继承\"><a href=\"#class的继承\" class=\"headerlink\" title=\"class的继承\"></a>class的继承</h2><p>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ColorPoint</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Point</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">x, y, color</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">super</span>(x, y); <span class=\"hljs-comment\">// 调用父类的constructor(x, y)</span><br>    <span class=\"hljs-built_in\">this</span>.color = color;<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">toString</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.color + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-built_in\">super</span>.toString(); <span class=\"hljs-comment\">// 调用父类的toString()</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p>\n<p>*ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.bookstack.cn/read/es6-3rd/sidebar.md\">参考资料：阮一峰ES6标准入门教程第三版</a></p>\n<blockquote>\n<p>本文用于记录我觉得ES6中重要的原理和使用技巧以及可能在面试中会问到的</p>\n</blockquote>\n<h2 id=\"class的继承\"><a href=\"#class的继承\" class=\"headerlink\" title=\"class的继承\"></a>class的继承</h2><p>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ColorPoint</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Point</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">x, y, color</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">super</span>(x, y); <span class=\"hljs-comment\">// 调用父类的constructor(x, y)</span><br>    <span class=\"hljs-built_in\">this</span>.color = color;<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">toString</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.color + <span class=\"hljs-string\">&#x27; &#x27;</span> + <span class=\"hljs-built_in\">super</span>.toString(); <span class=\"hljs-comment\">// 调用父类的toString()</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p>\n<p>*ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>\n"},{"title":"vue-router随笔","date":"2022-01-19T09:13:37.000Z","_content":"\n## 编程式导航\n\n### 导航到不同的位置\n\n除了使用 `<router-link>` 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。\n\n在 Vue 实例中，你可以通过 `$router` 访问路由实例。因此你可以调用 `this.$router.push`。\n\n该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：\n\n```js\n// 字符串路径\nrouter.push('/users/eduardo')\n\n// 带有路径的对象\nrouter.push({ path: '/users/eduardo' })\n\n// 命名的路由，并加上参数，让路由建立 url\nrouter.push({ name: 'user', params: { username: 'eduardo' } })\n\n// 带查询参数，结果是 /register?plan=private\nrouter.push({ path: '/register', query: { plan: 'private' } })\n\n// 带 hash，结果是 /about#team\nrouter.push({ path: '/about', hash: '#team' })\n```\n\n如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path ：\n\n```js\nconst username = 'eduardo'\n// 我们可以手动建立 url，但我们必须自己处理编码\nrouter.push(`/user/${username}`) // -> /user/eduardo\n// 同样\nrouter.push({ path: `/user/${username}` }) // -> /user/eduardo\n// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益\nrouter.push({ name: 'user', params: { username } }) // -> /user/eduardo\n// `params` 不能与 `path` 一起使用\nrouter.push({ path: '/user', params: { username } }) // -> /user\n```\n\n### 替换当前位置`router.replace()`\n\n它的作用类似于 router.push，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。\n\n也可以直接在传递给 `router.push` 的 `routeLocation` 中增加一个属性 `replace: true` ：\n\n```js\nrouter.push({ path: '/home', replace: true })\n// 相当于\nrouter.replace({ path: '/home' })\n```\n\n## 命名视图\n\n有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 `sidebar (侧导航)` 和 `main (主内容)` 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。**如果 router-view 没有设置名字，那么默认为 default**\n\n```js\n\n<router-view class=\"view left-sidebar\" name=\"LeftSidebar\"></router-view>\n\n<router-view class=\"view main-content\"></router-view>\n\n<router-view class=\"view right-sidebar\" name=\"RightSidebar\"></router-view>\n\n```\n\n```js\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [\n    {\n      path: '/',\n      components: {\n        default: Home,\n        // LeftSidebar: LeftSidebar 的缩写\n        LeftSidebar,\n        // 它们与 `<router-view>` 上的 `name` 属性匹配\n        RightSidebar,\n      },\n    },\n  ],\n})\n```\n","source":"_posts/2022-01-19-vue-router随笔.md","raw":"---\ntitle: vue-router随笔\ndate: 2022-01-19 17:13:37\ntags: [Vue, 面试]\ncategories: 技术类-Vue\n---\n\n## 编程式导航\n\n### 导航到不同的位置\n\n除了使用 `<router-link>` 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。\n\n在 Vue 实例中，你可以通过 `$router` 访问路由实例。因此你可以调用 `this.$router.push`。\n\n该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：\n\n```js\n// 字符串路径\nrouter.push('/users/eduardo')\n\n// 带有路径的对象\nrouter.push({ path: '/users/eduardo' })\n\n// 命名的路由，并加上参数，让路由建立 url\nrouter.push({ name: 'user', params: { username: 'eduardo' } })\n\n// 带查询参数，结果是 /register?plan=private\nrouter.push({ path: '/register', query: { plan: 'private' } })\n\n// 带 hash，结果是 /about#team\nrouter.push({ path: '/about', hash: '#team' })\n```\n\n如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path ：\n\n```js\nconst username = 'eduardo'\n// 我们可以手动建立 url，但我们必须自己处理编码\nrouter.push(`/user/${username}`) // -> /user/eduardo\n// 同样\nrouter.push({ path: `/user/${username}` }) // -> /user/eduardo\n// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益\nrouter.push({ name: 'user', params: { username } }) // -> /user/eduardo\n// `params` 不能与 `path` 一起使用\nrouter.push({ path: '/user', params: { username } }) // -> /user\n```\n\n### 替换当前位置`router.replace()`\n\n它的作用类似于 router.push，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。\n\n也可以直接在传递给 `router.push` 的 `routeLocation` 中增加一个属性 `replace: true` ：\n\n```js\nrouter.push({ path: '/home', replace: true })\n// 相当于\nrouter.replace({ path: '/home' })\n```\n\n## 命名视图\n\n有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 `sidebar (侧导航)` 和 `main (主内容)` 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。**如果 router-view 没有设置名字，那么默认为 default**\n\n```js\n\n<router-view class=\"view left-sidebar\" name=\"LeftSidebar\"></router-view>\n\n<router-view class=\"view main-content\"></router-view>\n\n<router-view class=\"view right-sidebar\" name=\"RightSidebar\"></router-view>\n\n```\n\n```js\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [\n    {\n      path: '/',\n      components: {\n        default: Home,\n        // LeftSidebar: LeftSidebar 的缩写\n        LeftSidebar,\n        // 它们与 `<router-view>` 上的 `name` 属性匹配\n        RightSidebar,\n      },\n    },\n  ],\n})\n```\n","slug":"vue-router随笔","published":1,"updated":"2022-01-19T09:27:37.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno66002r7oo98va659s7","content":"<h2 id=\"编程式导航\"><a href=\"#编程式导航\" class=\"headerlink\" title=\"编程式导航\"></a>编程式导航</h2><h3 id=\"导航到不同的位置\"><a href=\"#导航到不同的位置\" class=\"headerlink\" title=\"导航到不同的位置\"></a>导航到不同的位置</h3><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p>\n<p>在 Vue 实例中，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</p>\n<p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 字符串路径</span><br>router.push(<span class=\"hljs-string\">&#x27;/users/eduardo&#x27;</span>)<br><br><span class=\"hljs-comment\">// 带有路径的对象</span><br>router.push(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/users/eduardo&#x27;</span> &#125;)<br><br><span class=\"hljs-comment\">// 命名的路由，并加上参数，让路由建立 url</span><br>router.push(&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;user&#x27;</span>, <span class=\"hljs-attr\">params</span>: &#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">&#x27;eduardo&#x27;</span> &#125; &#125;)<br><br><span class=\"hljs-comment\">// 带查询参数，结果是 /register?plan=private</span><br>router.push(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/register&#x27;</span>, <span class=\"hljs-attr\">query</span>: &#123; <span class=\"hljs-attr\">plan</span>: <span class=\"hljs-string\">&#x27;private&#x27;</span> &#125; &#125;)<br><br><span class=\"hljs-comment\">// 带 hash，结果是 /about#team</span><br>router.push(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/about&#x27;</span>, <span class=\"hljs-attr\">hash</span>: <span class=\"hljs-string\">&#x27;#team&#x27;</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n<p>如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> username = <span class=\"hljs-string\">&#x27;eduardo&#x27;</span><br><span class=\"hljs-comment\">// 我们可以手动建立 url，但我们必须自己处理编码</span><br>router.push(<span class=\"hljs-string\">`/user/<span class=\"hljs-subst\">$&#123;username&#125;</span>`</span>) <span class=\"hljs-comment\">// -&gt; /user/eduardo</span><br><span class=\"hljs-comment\">// 同样</span><br>router.push(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">`/user/<span class=\"hljs-subst\">$&#123;username&#125;</span>`</span> &#125;) <span class=\"hljs-comment\">// -&gt; /user/eduardo</span><br><span class=\"hljs-comment\">// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益</span><br>router.push(&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;user&#x27;</span>, <span class=\"hljs-attr\">params</span>: &#123; username &#125; &#125;) <span class=\"hljs-comment\">// -&gt; /user/eduardo</span><br><span class=\"hljs-comment\">// `params` 不能与 `path` 一起使用</span><br>router.push(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/user&#x27;</span>, <span class=\"hljs-attr\">params</span>: &#123; username &#125; &#125;) <span class=\"hljs-comment\">// -&gt; /user</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"替换当前位置router-replace\"><a href=\"#替换当前位置router-replace\" class=\"headerlink\" title=\"替换当前位置router.replace()\"></a>替换当前位置<code>router.replace()</code></h3><p>它的作用类似于 router.push，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。</p>\n<p>也可以直接在传递给 <code>router.push</code> 的 <code>routeLocation</code> 中增加一个属性 <code>replace: true</code> ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">router.push(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/home&#x27;</span>, <span class=\"hljs-attr\">replace</span>: <span class=\"hljs-literal\">true</span> &#125;)<br><span class=\"hljs-comment\">// 相当于</span><br>router.replace(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/home&#x27;</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"命名视图\"><a href=\"#命名视图\" class=\"headerlink\" title=\"命名视图\"></a>命名视图</h2><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar (侧导航)</code> 和 <code>main (主内容)</code> 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。<strong>如果 router-view 没有设置名字，那么默认为 default</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><br>&lt;router-view <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">&quot;view left-sidebar&quot;</span> name=<span class=\"hljs-string\">&quot;LeftSidebar&quot;</span>&gt;&lt;/router-view&gt;<br><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-view</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;view main-content&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-view</span>&gt;</span></span><br><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-view</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;view right-sidebar&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;RightSidebar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-view</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> router = createRouter(&#123;<br>  <span class=\"hljs-attr\">history</span>: createWebHashHistory(),<br>  <span class=\"hljs-attr\">routes</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/&#x27;</span>,<br>      <span class=\"hljs-attr\">components</span>: &#123;<br>        <span class=\"hljs-attr\">default</span>: Home,<br>        <span class=\"hljs-comment\">// LeftSidebar: LeftSidebar 的缩写</span><br>        LeftSidebar,<br>        <span class=\"hljs-comment\">// 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配</span><br>        RightSidebar,<br>      &#125;,<br>    &#125;,<br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"编程式导航\"><a href=\"#编程式导航\" class=\"headerlink\" title=\"编程式导航\"></a>编程式导航</h2><h3 id=\"导航到不同的位置\"><a href=\"#导航到不同的位置\" class=\"headerlink\" title=\"导航到不同的位置\"></a>导航到不同的位置</h3><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p>\n<p>在 Vue 实例中，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</p>\n<p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 字符串路径</span><br>router.push(<span class=\"hljs-string\">&#x27;/users/eduardo&#x27;</span>)<br><br><span class=\"hljs-comment\">// 带有路径的对象</span><br>router.push(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/users/eduardo&#x27;</span> &#125;)<br><br><span class=\"hljs-comment\">// 命名的路由，并加上参数，让路由建立 url</span><br>router.push(&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;user&#x27;</span>, <span class=\"hljs-attr\">params</span>: &#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">&#x27;eduardo&#x27;</span> &#125; &#125;)<br><br><span class=\"hljs-comment\">// 带查询参数，结果是 /register?plan=private</span><br>router.push(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/register&#x27;</span>, <span class=\"hljs-attr\">query</span>: &#123; <span class=\"hljs-attr\">plan</span>: <span class=\"hljs-string\">&#x27;private&#x27;</span> &#125; &#125;)<br><br><span class=\"hljs-comment\">// 带 hash，结果是 /about#team</span><br>router.push(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/about&#x27;</span>, <span class=\"hljs-attr\">hash</span>: <span class=\"hljs-string\">&#x27;#team&#x27;</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n<p>如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> username = <span class=\"hljs-string\">&#x27;eduardo&#x27;</span><br><span class=\"hljs-comment\">// 我们可以手动建立 url，但我们必须自己处理编码</span><br>router.push(<span class=\"hljs-string\">`/user/<span class=\"hljs-subst\">$&#123;username&#125;</span>`</span>) <span class=\"hljs-comment\">// -&gt; /user/eduardo</span><br><span class=\"hljs-comment\">// 同样</span><br>router.push(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">`/user/<span class=\"hljs-subst\">$&#123;username&#125;</span>`</span> &#125;) <span class=\"hljs-comment\">// -&gt; /user/eduardo</span><br><span class=\"hljs-comment\">// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益</span><br>router.push(&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;user&#x27;</span>, <span class=\"hljs-attr\">params</span>: &#123; username &#125; &#125;) <span class=\"hljs-comment\">// -&gt; /user/eduardo</span><br><span class=\"hljs-comment\">// `params` 不能与 `path` 一起使用</span><br>router.push(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/user&#x27;</span>, <span class=\"hljs-attr\">params</span>: &#123; username &#125; &#125;) <span class=\"hljs-comment\">// -&gt; /user</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"替换当前位置router-replace\"><a href=\"#替换当前位置router-replace\" class=\"headerlink\" title=\"替换当前位置router.replace()\"></a>替换当前位置<code>router.replace()</code></h3><p>它的作用类似于 router.push，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。</p>\n<p>也可以直接在传递给 <code>router.push</code> 的 <code>routeLocation</code> 中增加一个属性 <code>replace: true</code> ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">router.push(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/home&#x27;</span>, <span class=\"hljs-attr\">replace</span>: <span class=\"hljs-literal\">true</span> &#125;)<br><span class=\"hljs-comment\">// 相当于</span><br>router.replace(&#123; <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/home&#x27;</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"命名视图\"><a href=\"#命名视图\" class=\"headerlink\" title=\"命名视图\"></a>命名视图</h2><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar (侧导航)</code> 和 <code>main (主内容)</code> 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。<strong>如果 router-view 没有设置名字，那么默认为 default</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><br>&lt;router-view <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">&quot;view left-sidebar&quot;</span> name=<span class=\"hljs-string\">&quot;LeftSidebar&quot;</span>&gt;&lt;/router-view&gt;<br><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-view</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;view main-content&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-view</span>&gt;</span></span><br><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-view</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;view right-sidebar&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;RightSidebar&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-view</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> router = createRouter(&#123;<br>  <span class=\"hljs-attr\">history</span>: createWebHashHistory(),<br>  <span class=\"hljs-attr\">routes</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/&#x27;</span>,<br>      <span class=\"hljs-attr\">components</span>: &#123;<br>        <span class=\"hljs-attr\">default</span>: Home,<br>        <span class=\"hljs-comment\">// LeftSidebar: LeftSidebar 的缩写</span><br>        LeftSidebar,<br>        <span class=\"hljs-comment\">// 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配</span><br>        RightSidebar,<br>      &#125;,<br>    &#125;,<br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure>\n"},{"title":"数据结构与算法","date":"2022-01-27T02:48:53.000Z","_content":"\n## 1.线性表\n\n### 定义\n\n> 线性表是具有相同数据类型的 n(n≥0)个数据元素的有限序列。其中 n 为表长，当 n=0 时该线性表是一个空表。\n\n若用 L 命名线性表，则其一般表示如下：\n\n    L=(a1,a2,...ai,ai+1,...,an)\n\n其中，a1 是唯一的“第一个”数据元素，又称为表头元素；an 是唯一的“最后一个”数据元素，又称为表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。\n\n### 特点\n\n线性表常见的特点如下：\n\n- 表中元素的个数是有限的；\n\n- 表中元素具有逻辑上的顺序性，在序列中各元素排列有先后次序；\n\n- 表中元素都是数据元素，每一个表元素都是单个元素；\n\n- 表中元素的数据类型都相同，这意味着每一个表元素占有相同数量的存储空间；\n\n- 表中元素具有抽象性，就是说，仅讨论表元素之间的逻辑关系，不考虑表元素究竟表示什么内容\n\n### 分类\n\n{% asset_img 线性表的分类.jpg 线性表的分类 %}\n\n### 线性表的基本操作\n\n    ```js\n    InitList(L); //初始化表。构造一个空的线性表；\n    Legnth(L); //求表长度。返回线性表L的长度，即L中数据元素的个数；\n    LocateElem(L, e); //按值查找操作。在表L中查找具有给定关键字值的元素；\n    GetElem(L, i); //按位查找操作。获取表L中第i个位置的元素的值；\n    ListInsert(L, i, e); //插入操作。在表L中第i个位置上插入制定元素；\n    ListDelete(L, i, e); //删除操作。删除表L中第i个位置上的元素；\n    PrintList(L); //输出操作。按前后顺序输出线性表L的所有元素的值；\n    Empty(L); //判空操作\n    ```\n\n## 1.1 线性表的顺序表示(顺序表)\n\n> 线性表的顺序存储又称之为**顺序表**。\n\n它是用一组连续地址的存储单元，依次存储线性表的数据元素，从而使得逻辑上相邻的两个元素在物理上也相邻。\n\n### 特点\n\n- 顺序表中元素的逻辑顺序与物理顺序相同\n","source":"_posts/2022-01-27-数据结构与算法.md","raw":"---\ntitle: 数据结构与算法\ndate: 2022-01-27 10:48:53\ntags: [算法, leetcode]\ncategories: 算法类\n---\n\n## 1.线性表\n\n### 定义\n\n> 线性表是具有相同数据类型的 n(n≥0)个数据元素的有限序列。其中 n 为表长，当 n=0 时该线性表是一个空表。\n\n若用 L 命名线性表，则其一般表示如下：\n\n    L=(a1,a2,...ai,ai+1,...,an)\n\n其中，a1 是唯一的“第一个”数据元素，又称为表头元素；an 是唯一的“最后一个”数据元素，又称为表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。\n\n### 特点\n\n线性表常见的特点如下：\n\n- 表中元素的个数是有限的；\n\n- 表中元素具有逻辑上的顺序性，在序列中各元素排列有先后次序；\n\n- 表中元素都是数据元素，每一个表元素都是单个元素；\n\n- 表中元素的数据类型都相同，这意味着每一个表元素占有相同数量的存储空间；\n\n- 表中元素具有抽象性，就是说，仅讨论表元素之间的逻辑关系，不考虑表元素究竟表示什么内容\n\n### 分类\n\n{% asset_img 线性表的分类.jpg 线性表的分类 %}\n\n### 线性表的基本操作\n\n    ```js\n    InitList(L); //初始化表。构造一个空的线性表；\n    Legnth(L); //求表长度。返回线性表L的长度，即L中数据元素的个数；\n    LocateElem(L, e); //按值查找操作。在表L中查找具有给定关键字值的元素；\n    GetElem(L, i); //按位查找操作。获取表L中第i个位置的元素的值；\n    ListInsert(L, i, e); //插入操作。在表L中第i个位置上插入制定元素；\n    ListDelete(L, i, e); //删除操作。删除表L中第i个位置上的元素；\n    PrintList(L); //输出操作。按前后顺序输出线性表L的所有元素的值；\n    Empty(L); //判空操作\n    ```\n\n## 1.1 线性表的顺序表示(顺序表)\n\n> 线性表的顺序存储又称之为**顺序表**。\n\n它是用一组连续地址的存储单元，依次存储线性表的数据元素，从而使得逻辑上相邻的两个元素在物理上也相邻。\n\n### 特点\n\n- 顺序表中元素的逻辑顺序与物理顺序相同\n","slug":"数据结构与算法","published":1,"updated":"2022-01-27T06:04:41.281Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckywkno6g004c7oo9gihn7b2l","content":"<h2 id=\"1-线性表\"><a href=\"#1-线性表\" class=\"headerlink\" title=\"1.线性表\"></a>1.线性表</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><blockquote>\n<p>线性表是具有相同数据类型的 n(n≥0)个数据元素的有限序列。其中 n 为表长，当 n=0 时该线性表是一个空表。</p>\n</blockquote>\n<p>若用 L 命名线性表，则其一般表示如下：</p>\n<pre><code>L=(a1,a2,...ai,ai+1,...,an)\n</code></pre>\n<p>其中，a1 是唯一的“第一个”数据元素，又称为表头元素；an 是唯一的“最后一个”数据元素，又称为表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>线性表常见的特点如下：</p>\n<ul>\n<li><p>表中元素的个数是有限的；</p>\n</li>\n<li><p>表中元素具有逻辑上的顺序性，在序列中各元素排列有先后次序；</p>\n</li>\n<li><p>表中元素都是数据元素，每一个表元素都是单个元素；</p>\n</li>\n<li><p>表中元素的数据类型都相同，这意味着每一个表元素占有相同数量的存储空间；</p>\n</li>\n<li><p>表中元素具有抽象性，就是说，仅讨论表元素之间的逻辑关系，不考虑表元素究竟表示什么内容</p>\n</li>\n</ul>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><img src=\"/20220127/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB.jpg\" class=\"\" title=\"线性表的分类\">\n\n<h3 id=\"线性表的基本操作\"><a href=\"#线性表的基本操作\" class=\"headerlink\" title=\"线性表的基本操作\"></a>线性表的基本操作</h3><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">InitList(L); <span class=\"hljs-comment\">//初始化表。构造一个空的线性表；</span><br>Legnth(L); <span class=\"hljs-comment\">//求表长度。返回线性表L的长度，即L中数据元素的个数；</span><br>LocateElem(L, e); <span class=\"hljs-comment\">//按值查找操作。在表L中查找具有给定关键字值的元素；</span><br>GetElem(L, i); <span class=\"hljs-comment\">//按位查找操作。获取表L中第i个位置的元素的值；</span><br>ListInsert(L, i, e); <span class=\"hljs-comment\">//插入操作。在表L中第i个位置上插入制定元素；</span><br>ListDelete(L, i, e); <span class=\"hljs-comment\">//删除操作。删除表L中第i个位置上的元素；</span><br>PrintList(L); <span class=\"hljs-comment\">//输出操作。按前后顺序输出线性表L的所有元素的值；</span><br>Empty(L); <span class=\"hljs-comment\">//判空操作</span><br></code></pre></td></tr></table></figure>\n</code></pre>\n<h2 id=\"1-1-线性表的顺序表示-顺序表\"><a href=\"#1-1-线性表的顺序表示-顺序表\" class=\"headerlink\" title=\"1.1 线性表的顺序表示(顺序表)\"></a>1.1 线性表的顺序表示(顺序表)</h2><blockquote>\n<p>线性表的顺序存储又称之为<strong>顺序表</strong>。</p>\n</blockquote>\n<p>它是用一组连续地址的存储单元，依次存储线性表的数据元素，从而使得逻辑上相邻的两个元素在物理上也相邻。</p>\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>顺序表中元素的逻辑顺序与物理顺序相同</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-线性表\"><a href=\"#1-线性表\" class=\"headerlink\" title=\"1.线性表\"></a>1.线性表</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><blockquote>\n<p>线性表是具有相同数据类型的 n(n≥0)个数据元素的有限序列。其中 n 为表长，当 n=0 时该线性表是一个空表。</p>\n</blockquote>\n<p>若用 L 命名线性表，则其一般表示如下：</p>\n<pre><code>L=(a1,a2,...ai,ai+1,...,an)\n</code></pre>\n<p>其中，a1 是唯一的“第一个”数据元素，又称为表头元素；an 是唯一的“最后一个”数据元素，又称为表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>线性表常见的特点如下：</p>\n<ul>\n<li><p>表中元素的个数是有限的；</p>\n</li>\n<li><p>表中元素具有逻辑上的顺序性，在序列中各元素排列有先后次序；</p>\n</li>\n<li><p>表中元素都是数据元素，每一个表元素都是单个元素；</p>\n</li>\n<li><p>表中元素的数据类型都相同，这意味着每一个表元素占有相同数量的存储空间；</p>\n</li>\n<li><p>表中元素具有抽象性，就是说，仅讨论表元素之间的逻辑关系，不考虑表元素究竟表示什么内容</p>\n</li>\n</ul>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><img src=\"/20220127/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB.jpg\" class=\"\" title=\"线性表的分类\">\n\n<h3 id=\"线性表的基本操作\"><a href=\"#线性表的基本操作\" class=\"headerlink\" title=\"线性表的基本操作\"></a>线性表的基本操作</h3><pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">InitList(L); <span class=\"hljs-comment\">//初始化表。构造一个空的线性表；</span><br>Legnth(L); <span class=\"hljs-comment\">//求表长度。返回线性表L的长度，即L中数据元素的个数；</span><br>LocateElem(L, e); <span class=\"hljs-comment\">//按值查找操作。在表L中查找具有给定关键字值的元素；</span><br>GetElem(L, i); <span class=\"hljs-comment\">//按位查找操作。获取表L中第i个位置的元素的值；</span><br>ListInsert(L, i, e); <span class=\"hljs-comment\">//插入操作。在表L中第i个位置上插入制定元素；</span><br>ListDelete(L, i, e); <span class=\"hljs-comment\">//删除操作。删除表L中第i个位置上的元素；</span><br>PrintList(L); <span class=\"hljs-comment\">//输出操作。按前后顺序输出线性表L的所有元素的值；</span><br>Empty(L); <span class=\"hljs-comment\">//判空操作</span><br></code></pre></td></tr></table></figure>\n</code></pre>\n<h2 id=\"1-1-线性表的顺序表示-顺序表\"><a href=\"#1-1-线性表的顺序表示-顺序表\" class=\"headerlink\" title=\"1.1 线性表的顺序表示(顺序表)\"></a>1.1 线性表的顺序表示(顺序表)</h2><blockquote>\n<p>线性表的顺序存储又称之为<strong>顺序表</strong>。</p>\n</blockquote>\n<p>它是用一组连续地址的存储单元，依次存储线性表的数据元素，从而使得逻辑上相邻的两个元素在物理上也相邻。</p>\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>顺序表中元素的逻辑顺序与物理顺序相同</li>\n</ul>\n"},{"title":"本博客说明书","date":"2021-09-07T03:19:02.000Z","comments":1,"sticky":100,"_content":"{% blockquote %}\n幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔\n{% endblockquote %}\n\n19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。\n所以我又重新搭了一个。\n后续会把写过的文档陆续上传到这边\n本博客主要记录学习过程，技术文档以及日常。\n\n以下是功能测试：\n嵌入B站视频\n{% raw %}\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n<iframe src=\"//player.bilibili.com/player.html?aid=846655043&bvid=BV1e54y1n7XK&cid=371989206&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\"allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; Left: 0; top: 0;\"> </iframe></div>\n{% endraw %}\n\n\n代码块\n```js\nconsole.log('zouHuaLu')\nhexo g\nhexo g -w\nhexo server\nhexo clean\nhexo deploy\n```\n以后有时间弄一下评论功能\n\n---\n2021-09-23 本博客新增评论功能，支持评论啦！","source":"_posts/about-me.md","raw":"---\ntitle: 本博客说明书\ndate: 2021-09-07 11:19:02\ntags: 博客说明\ncategories: 博客说明\ncomments: true\nsticky: 100\n---\n{% blockquote %}\n幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔\n{% endblockquote %}\n\n19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。\n所以我又重新搭了一个。\n后续会把写过的文档陆续上传到这边\n本博客主要记录学习过程，技术文档以及日常。\n\n以下是功能测试：\n嵌入B站视频\n{% raw %}\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n<iframe src=\"//player.bilibili.com/player.html?aid=846655043&bvid=BV1e54y1n7XK&cid=371989206&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\"allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; Left: 0; top: 0;\"> </iframe></div>\n{% endraw %}\n\n\n代码块\n```js\nconsole.log('zouHuaLu')\nhexo g\nhexo g -w\nhexo server\nhexo clean\nhexo deploy\n```\n以后有时间弄一下评论功能\n\n---\n2021-09-23 本博客新增评论功能，支持评论啦！","slug":"about-me","published":1,"updated":"2021-09-26T02:21:21.380Z","layout":"post","photos":[],"link":"","_id":"ckywkno6h004d7oo922llbcsp","content":"<blockquote><p>幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔</p>\n</blockquote>\n\n<p>19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。<br>所以我又重新搭了一个。<br>后续会把写过的文档陆续上传到这边<br>本博客主要记录学习过程，技术文档以及日常。</p>\n<p>以下是功能测试：<br>嵌入B站视频</p>\n\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n<iframe src=\"//player.bilibili.com/player.html?aid=846655043&bvid=BV1e54y1n7XK&cid=371989206&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\"allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; Left: 0; top: 0;\"> </iframe></div>\n\n\n\n<p>代码块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>hexo g<br>hexo g -w<br>hexo server<br>hexo clean<br>hexo deploy<br></code></pre></td></tr></table></figure>\n<p>以后有时间弄一下评论功能</p>\n<hr>\n<p>2021-09-23 本博客新增评论功能，支持评论啦！</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote><p>幸福不是一件容易的事：她很难求之于自身，但要想在别处得到则不可能。——尚福尔</p>\n</blockquote>\n\n<p>19年搭过一个博客，可惜不好用，上传的图片经常不显示，于是就放弃使用了，后来把地址搞丢了找不回来了。<br>所以我又重新搭了一个。<br>后续会把写过的文档陆续上传到这边<br>本博客主要记录学习过程，技术文档以及日常。</p>\n<p>以下是功能测试：<br>嵌入B站视频</p>\n\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n<iframe src=\"//player.bilibili.com/player.html?aid=846655043&bvid=BV1e54y1n7XK&cid=371989206&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\"allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; Left: 0; top: 0;\"> </iframe></div>\n\n\n\n<p>代码块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;zouHuaLu&#x27;</span>)<br>hexo g<br>hexo g -w<br>hexo server<br>hexo clean<br>hexo deploy<br></code></pre></td></tr></table></figure>\n<p>以后有时间弄一下评论功能</p>\n<hr>\n<p>2021-09-23 本博客新增评论功能，支持评论啦！</p>\n"}],"PostAsset":[{"_id":"source/_posts/2022-01-27-数据结构与算法/线性表的分类.jpg","post":"ckywkno6g004c7oo9gihn7b2l","slug":"线性表的分类.jpg","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ckywkno4p00017oo9hr9k8taw","category_id":"ckywkno4v00047oo984l3cl7n","_id":"ckywkno58000f7oo904jv8ams"},{"post_id":"ckywkno4s00037oo9abho6k3y","category_id":"ckywkno4v00047oo984l3cl7n","_id":"ckywkno5b000k7oo90pso17qz"},{"post_id":"ckywkno4x00067oo9a4973xps","category_id":"ckywkno57000e7oo90rb0gm0z","_id":"ckywkno5g000t7oo9fdzdg0gs"},{"post_id":"ckywkno5c000n7oo9gbca4y5m","category_id":"ckywkno5b000l7oo9asyy2dpo","_id":"ckywkno5h000w7oo9elcp2ng8"},{"post_id":"ckywkno4z00077oo9ecqr3akw","category_id":"ckywkno5b000l7oo9asyy2dpo","_id":"ckywkno5i00107oo92hd45ux8"},{"post_id":"ckywkno5000087oo9g07l47k3","category_id":"ckywkno5f000q7oo9d91i6gl2","_id":"ckywkno5k00157oo9a56161yo"},{"post_id":"ckywkno5g000v7oo90czsc7bl","category_id":"ckywkno57000e7oo90rb0gm0z","_id":"ckywkno5l001a7oo911cpggnl"},{"post_id":"ckywkno55000c7oo92bw51y8h","category_id":"ckywkno5b000l7oo9asyy2dpo","_id":"ckywkno5m001d7oo91qar3vrp"},{"post_id":"ckywkno5k00167oo9a0ka4xyu","category_id":"ckywkno5b000l7oo9asyy2dpo","_id":"ckywkno5n001h7oo9bn5yc819"},{"post_id":"ckywkno57000d7oo99f5x0hsh","category_id":"ckywkno5f000q7oo9d91i6gl2","_id":"ckywkno5p001l7oo9hu3r8fgz"},{"post_id":"ckywkno5l00197oo950j6deow","category_id":"ckywkno5b000l7oo9asyy2dpo","_id":"ckywkno5s001o7oo99w0yfek1"},{"post_id":"ckywkno5m001c7oo98td05663","category_id":"ckywkno5b000l7oo9asyy2dpo","_id":"ckywkno5u001r7oo95nbk3338"},{"post_id":"ckywkno59000i7oo9chpd277w","category_id":"ckywkno5b000l7oo9asyy2dpo","_id":"ckywkno5v001v7oo917xw3jsn"},{"post_id":"ckywkno5n001g7oo948fjhel3","category_id":"ckywkno5b000l7oo9asyy2dpo","_id":"ckywkno5w001z7oo9axtzhrsi"},{"post_id":"ckywkno5a000j7oo90m6thr49","category_id":"ckywkno5b000l7oo9asyy2dpo","_id":"ckywkno5x00237oo94x5hg7n9"},{"post_id":"ckywkno5q001n7oo9av9bc76h","category_id":"ckywkno57000e7oo90rb0gm0z","_id":"ckywkno5y00257oo9d0ej11so"},{"post_id":"ckywkno5d000p7oo956m1euwl","category_id":"ckywkno5f000q7oo9d91i6gl2","_id":"ckywkno6000297oo928dy27pw"},{"post_id":"ckywkno5v001u7oo9gtjx72sd","category_id":"ckywkno5b000l7oo9asyy2dpo","_id":"ckywkno61002c7oo9c8qwb2p8"},{"post_id":"ckywkno5v001y7oo9133m6jj4","category_id":"ckywkno5b000l7oo9asyy2dpo","_id":"ckywkno62002h7oo9gy967ef5"},{"post_id":"ckywkno5f000s7oo92ddcdynl","category_id":"ckywkno5v001x7oo9anuj9s04","_id":"ckywkno63002k7oo9h32ueewb"},{"post_id":"ckywkno5h000z7oo94ndvgwtc","category_id":"ckywkno5y00267oo9dgze0acm","_id":"ckywkno65002p7oo95hy0hru0"},{"post_id":"ckywkno60002b7oo95q8bf1x1","category_id":"ckywkno5b000l7oo9asyy2dpo","_id":"ckywkno66002s7oo973880wik"},{"post_id":"ckywkno62002g7oo99u0p7k36","category_id":"ckywkno5f000q7oo9d91i6gl2","_id":"ckywkno67002w7oo91kow7a91"},{"post_id":"ckywkno5i00127oo95herfmr0","category_id":"ckywkno5v001x7oo9anuj9s04","_id":"ckywkno67002y7oo92h255bbg"},{"post_id":"ckywkno63002j7oo9e2hgch7a","category_id":"ckywkno5b000l7oo9asyy2dpo","_id":"ckywkno6800327oo9c0xagf50"},{"post_id":"ckywkno5o001k7oo9hbej736m","category_id":"ckywkno63002l7oo96ncr0j52","_id":"ckywkno6800347oo98lmshiob"},{"post_id":"ckywkno66002r7oo98va659s7","category_id":"ckywkno5f000q7oo9d91i6gl2","_id":"ckywkno6800377oo90c4w7qq0"},{"post_id":"ckywkno5t001q7oo9f7uj30pz","category_id":"ckywkno66002t7oo9fhuu9xtu","_id":"ckywkno6900397oo92xl83sko"},{"post_id":"ckywkno5x00227oo9b2su0btd","category_id":"ckywkno66002t7oo9fhuu9xtu","_id":"ckywkno69003a7oo99kfhh395"},{"post_id":"ckywkno5x00247oo9dlx1evcc","category_id":"ckywkno66002t7oo9fhuu9xtu","_id":"ckywkno69003d7oo966he5olo"},{"post_id":"ckywkno6g004c7oo9gihn7b2l","category_id":"ckywkno5y00267oo9dgze0acm","_id":"ckywkno6i004i7oo90n7838rw"},{"post_id":"ckywkno6h004d7oo922llbcsp","category_id":"ckywkno6i004f7oo96jao81lw","_id":"ckywkno6j004k7oo9a46p5dvl"}],"PostTag":[{"post_id":"ckywkno4p00017oo9hr9k8taw","tag_id":"ckywkno4w00057oo98vv73daq","_id":"ckywkno55000b7oo9fo05d2xk"},{"post_id":"ckywkno4s00037oo9abho6k3y","tag_id":"ckywkno4w00057oo98vv73daq","_id":"ckywkno58000h7oo959vgeavx"},{"post_id":"ckywkno4x00067oo9a4973xps","tag_id":"ckywkno58000g7oo989oteeex","_id":"ckywkno5d000o7oo960fw39lo"},{"post_id":"ckywkno4z00077oo9ecqr3akw","tag_id":"ckywkno5b000m7oo94b3m9grw","_id":"ckywkno5g000u7oo9c63b85b0"},{"post_id":"ckywkno5000087oo9g07l47k3","tag_id":"ckywkno5f000r7oo905zocfht","_id":"ckywkno5i00117oo9ctw90hhr"},{"post_id":"ckywkno5g000v7oo90czsc7bl","tag_id":"ckywkno58000g7oo989oteeex","_id":"ckywkno5j00137oo9d0okcctq"},{"post_id":"ckywkno55000c7oo92bw51y8h","tag_id":"ckywkno5h000y7oo94qkb04jv","_id":"ckywkno5l00187oo941ps7v6n"},{"post_id":"ckywkno57000d7oo99f5x0hsh","tag_id":"ckywkno5f000r7oo905zocfht","_id":"ckywkno5n001f7oo9779qa7ln"},{"post_id":"ckywkno5m001c7oo98td05663","tag_id":"ckywkno5h000y7oo94qkb04jv","_id":"ckywkno5o001j7oo987yk3tls"},{"post_id":"ckywkno5q001n7oo9av9bc76h","tag_id":"ckywkno58000g7oo989oteeex","_id":"ckywkno5u001t7oo94joh0wfj"},{"post_id":"ckywkno59000i7oo9chpd277w","tag_id":"ckywkno5h000y7oo94qkb04jv","_id":"ckywkno5v001w7oo902spd2la"},{"post_id":"ckywkno59000i7oo9chpd277w","tag_id":"ckywkno5p001m7oo9bei2g2t3","_id":"ckywkno5w00217oo9ekhq95z9"},{"post_id":"ckywkno5a000j7oo90m6thr49","tag_id":"ckywkno5h000y7oo94qkb04jv","_id":"ckywkno60002a7oo99bonhr2b"},{"post_id":"ckywkno5a000j7oo90m6thr49","tag_id":"ckywkno5w00207oo9d57vdi65","_id":"ckywkno61002e7oo98xcufnrt"},{"post_id":"ckywkno60002b7oo95q8bf1x1","tag_id":"ckywkno5h000y7oo94qkb04jv","_id":"ckywkno62002i7oo93vl9fsvc"},{"post_id":"ckywkno60002b7oo95q8bf1x1","tag_id":"ckywkno5w00207oo9d57vdi65","_id":"ckywkno64002n7oo99k4jhkrh"},{"post_id":"ckywkno5c000n7oo9gbca4y5m","tag_id":"ckywkno5h000y7oo94qkb04jv","_id":"ckywkno65002q7oo9f98dan53"},{"post_id":"ckywkno5c000n7oo9gbca4y5m","tag_id":"ckywkno5w00207oo9d57vdi65","_id":"ckywkno67002v7oo949y73x5l"},{"post_id":"ckywkno63002j7oo9e2hgch7a","tag_id":"ckywkno5h000y7oo94qkb04jv","_id":"ckywkno67002x7oo9dr4sdsa3"},{"post_id":"ckywkno63002j7oo9e2hgch7a","tag_id":"ckywkno5w00207oo9d57vdi65","_id":"ckywkno67002z7oo95aii5719"},{"post_id":"ckywkno5d000p7oo956m1euwl","tag_id":"ckywkno5f000r7oo905zocfht","_id":"ckywkno6800337oo99qmgdl8o"},{"post_id":"ckywkno5f000s7oo92ddcdynl","tag_id":"ckywkno66002u7oo9ax7i2zad","_id":"ckywkno6800357oo94ctgbr5c"},{"post_id":"ckywkno5h000z7oo94ndvgwtc","tag_id":"ckywkno6700317oo92d9l9ebo","_id":"ckywkno69003c7oo9b5n49g82"},{"post_id":"ckywkno5h000z7oo94ndvgwtc","tag_id":"ckywkno6800387oo94v13ewrf","_id":"ckywkno69003e7oo99ekpcwkx"},{"post_id":"ckywkno5i00127oo95herfmr0","tag_id":"ckywkno66002u7oo9ax7i2zad","_id":"ckywkno69003g7oo9ajy2cyfr"},{"post_id":"ckywkno5k00167oo9a0ka4xyu","tag_id":"ckywkno5h000y7oo94qkb04jv","_id":"ckywkno6a003i7oo95a768ggt"},{"post_id":"ckywkno5k00167oo9a0ka4xyu","tag_id":"ckywkno5w00207oo9d57vdi65","_id":"ckywkno6a003j7oo92yhz4vb5"},{"post_id":"ckywkno5l00197oo950j6deow","tag_id":"ckywkno5h000y7oo94qkb04jv","_id":"ckywkno6a003l7oo926q9avf6"},{"post_id":"ckywkno5l00197oo950j6deow","tag_id":"ckywkno5w00207oo9d57vdi65","_id":"ckywkno6a003m7oo90p2rcmpx"},{"post_id":"ckywkno5n001g7oo948fjhel3","tag_id":"ckywkno5h000y7oo94qkb04jv","_id":"ckywkno6b003o7oo960en0nqg"},{"post_id":"ckywkno5n001g7oo948fjhel3","tag_id":"ckywkno5w00207oo9d57vdi65","_id":"ckywkno6b003p7oo9goxz9x3c"},{"post_id":"ckywkno5o001k7oo9hbej736m","tag_id":"ckywkno6a003n7oo97ogz4ful","_id":"ckywkno6b003r7oo9cmfddqme"},{"post_id":"ckywkno5t001q7oo9f7uj30pz","tag_id":"ckywkno6b003q7oo9b8fg0lyd","_id":"ckywkno6b003t7oo9cxgm5kn3"},{"post_id":"ckywkno5v001u7oo9gtjx72sd","tag_id":"ckywkno5h000y7oo94qkb04jv","_id":"ckywkno6c003v7oo93o3y3vjn"},{"post_id":"ckywkno5v001u7oo9gtjx72sd","tag_id":"ckywkno5w00207oo9d57vdi65","_id":"ckywkno6c003w7oo988cm2g7w"},{"post_id":"ckywkno5v001y7oo9133m6jj4","tag_id":"ckywkno5h000y7oo94qkb04jv","_id":"ckywkno6c003y7oo9bq1a9dl2"},{"post_id":"ckywkno5v001y7oo9133m6jj4","tag_id":"ckywkno5w00207oo9d57vdi65","_id":"ckywkno6c003z7oo95d0nf1l5"},{"post_id":"ckywkno5x00227oo9b2su0btd","tag_id":"ckywkno6b003q7oo9b8fg0lyd","_id":"ckywkno6c00417oo945yn0bu8"},{"post_id":"ckywkno5x00227oo9b2su0btd","tag_id":"ckywkno5w00207oo9d57vdi65","_id":"ckywkno6d00427oo96b3lewpi"},{"post_id":"ckywkno5x00247oo9dlx1evcc","tag_id":"ckywkno6b003q7oo9b8fg0lyd","_id":"ckywkno6d00447oo94w89857a"},{"post_id":"ckywkno5z00287oo93r5mgvhr","tag_id":"ckywkno6d00437oo968vb1vvt","_id":"ckywkno6d00467oo9bw0mdhi2"},{"post_id":"ckywkno62002g7oo99u0p7k36","tag_id":"ckywkno6d00457oo93ji567mc","_id":"ckywkno6d00487oo93cuu4be0"},{"post_id":"ckywkno62002g7oo99u0p7k36","tag_id":"ckywkno5w00207oo9d57vdi65","_id":"ckywkno6d00497oo9045v0uq8"},{"post_id":"ckywkno66002r7oo98va659s7","tag_id":"ckywkno6d00457oo93ji567mc","_id":"ckywkno6e004a7oo956xw9tf0"},{"post_id":"ckywkno66002r7oo98va659s7","tag_id":"ckywkno5w00207oo9d57vdi65","_id":"ckywkno6e004b7oo9bkb1hls9"},{"post_id":"ckywkno6g004c7oo9gihn7b2l","tag_id":"ckywkno6700317oo92d9l9ebo","_id":"ckywkno6i004e7oo91l2e7gf6"},{"post_id":"ckywkno6g004c7oo9gihn7b2l","tag_id":"ckywkno6800387oo94v13ewrf","_id":"ckywkno6i004h7oo9bwxcf3nf"},{"post_id":"ckywkno6h004d7oo922llbcsp","tag_id":"ckywkno6i004g7oo9gpap2bi2","_id":"ckywkno6j004j7oo99ek22aih"}],"Tag":[{"name":"TypeScript","_id":"ckywkno4w00057oo98vv73daq"},{"name":"日常","_id":"ckywkno58000g7oo989oteeex"},{"name":"课程","_id":"ckywkno5b000m7oo94b3m9grw"},{"name":"Vue3","_id":"ckywkno5f000r7oo905zocfht"},{"name":"JavaScript","_id":"ckywkno5h000y7oo94qkb04jv"},{"name":"ES6","_id":"ckywkno5p001m7oo9bei2g2t3"},{"name":"面试","_id":"ckywkno5w00207oo9d57vdi65"},{"name":"计算机基础","_id":"ckywkno66002u7oo9ax7i2zad"},{"name":"算法","_id":"ckywkno6700317oo92d9l9ebo"},{"name":"leetcode","_id":"ckywkno6800387oo94v13ewrf"},{"name":"Node.js","_id":"ckywkno6a003n7oo97ogz4ful"},{"name":"React","_id":"ckywkno6b003q7oo9b8fg0lyd"},{"name":"TODO","_id":"ckywkno6d00437oo968vb1vvt"},{"name":"Vue","_id":"ckywkno6d00457oo93ji567mc"},{"name":"博客说明","_id":"ckywkno6i004g7oo9gpap2bi2"}]}}